Odd name, but I'll allow it 😄.
Why the change here? Does the secondary color not read on top of primary?
@a14n Can you confirm that there was no reason for adding the `required` here in the first place?
see documentation above.
we could do `final Object exception = this.exception` as the top of this function to remove all the `as`es.
rather than just reducing the number of tests, let's replace them with tests that check similar codepaths, e.g. adding `exception: NullError()` to these, or pass in some other object with a known toString, or something.
I believe this example does not exist in the [gallery repo](https://github.com/flutter/gallery), so there is nothing to update over there.
What does this macro do?
Nice!
Elsewhere I defined a template with:  ``` {@template flutter.widgets.editableText.complexCharacters} ```  So now every place that uses this macro will import the text defined in the template.
I think that's probably not true If the editable text is only meant for english alphabets and/or numbers (verification code, for example), and there's a formatter that guarantees that?
Should this paragraph have the same   /// ## Handling emojis and other complex characters header as well?
True.  I'll change it to something like "when working with user input text that may contain complex characters"
This expect is failing:  ``` package:test_api                                             expect package:flutter_test/src/widget_tester.dart 429:3            expect test/painting/image_provider_and_image_cache_test.dart 80:5  main.<fn>  Expected: <0>   Actual: <1> ```  I doesn't make sense to me why migrating this to NNBD would cause that... /cc @dnfield any idea?
Why are we changing the completer from `Completer<StateError>` to `Completer<void>`?I don't see how that would cause this problem but it seems strange to me.
I think I got it, this test case was supposed to test this error case here:  https://github.com/flutter/flutter/blob/c8466d0430195755615a987171920582823ed79a/packages/flutter/lib/src/painting/image_provider.dart#L676-L682  However, as the comment there says, with null-safety enabled, that error cannot happen anymore. Therefore deleting this test case.
Deleting as explained here: https://github.com/flutter/flutter/pull/67360#discussion_r499936328
nit: why not use `!` and leave the null check as is?
Not for this PR, but all of this is making me think we should just be making the `imageCache` late non-nullable somehow.
either works :)
you can remove all fastlane related code in the codebase as well. There are some in .cirrus.yaml. You can skip fastlane related setup in the dockerfile as well. Also the various fastlane related files in flutter_gallery/android|ios/fastlane.
Please help take another look. `Gemfile.lock` was updated after I ran `bundle` after removing `fastlane` codes from `Gemfile`.
This PR looks good to me.  As a nit, can you also update the timestamp on the Dockerfile https://github.com/flutter/flutter/blob/master/dev/ci/docker_linux/Dockerfile#L13, to bust the cache and trigger a rebuild of the Dockerfile. I want to make sure that all the linux tests pass without fastlane installed.
Updated.
nit: "view and debug"?
Should we pass `--source-maps` when `sourceMapsEnabled` for explicitness?
--source-maps is not a flag, just --no-source-maps
Done
here and below: use `Object?` instead of `dynamic` if possible.
It seems like either this should be not be nullable, or the code below in line 4817 should be checking whether it is null rather than asserting that it's not null.  Given that we've had this check expecting it not to be null (it previously would have thrown if null was returned by this function), I'm inclined to believe that this should not be nullable. Did it break any tests or analysis making it non-nullable?
In `cupertino/route_test.dart` there are several tests using `buildNavigator` that return null for `Navigator.onPopPage`, which is currently a non-nullable `PopPageCallback`. In these tests they do not return a bool, so I thought I'd make it nullable to support the tests.  Should I make `Navigator.onPopPage` nullable instead? I think that will work.
The analyzer dings me for it. It only passes if I match the signature of the super class.
I think that makes sense, but I'd feel better if @chunhtai or @goderbauer agree :)
Ahhh ok. We may want to separately consider having that be `Object?` instead of `dynamic`, since dynamic introduces terror into the type analysis.
(Again, I'm not clear on whether there's some good reason to not do that based on other code though)
We should **not** make the return type of PopPageCallback nullable here. Instead we need to fix the tests to not return null. In the tests, null was probably chosen because the tests don't invoke the callback? Presumably, you could just return true or false from it since it doesn't seem to matter?
I would change the tests to something like:  ```dart       buildNavigator(         pages: myPages,         onPopPage: (Route<dynamic> route, dynamic result) {           assert(false); // the test shouldn't call this.           return true;         },         transitionDelegate: detector,       ) ```
SGTM! Thanks!
nit: capitalize "the".  (I probably had this wrong in the snippet I gave you... sorry)
```suggestion           assert(false); // The test shouldn't call this. ```
```suggestion           assert(false); // The test shouldn't call this. ```
```suggestion           assert(false); // The test shouldn't call this. ```
```suggestion           assert(false); // The test shouldn't call this. ```
This was the reason for the google3 failure: In #67078 this method was marked `async`, which changes the timing slightly for tests. There's no need for it to be async, though. The main goal of this commit is to revert that.
```suggestion This functionality was deprecated and removed after 1.23.0 ```
nit: I would have expected the question mark to come at the end of the last line rather than the beginning of this one, but if this style is consistent with other uses it should be fine.
I thought we were trying to avoid adding new globals to the context and instead providing ctor initialization. Is that not possible for some reason in this case, or are we not trying to do that anymore?
`?.` is one operator though, splitting them up seems odd - or do you mean leaving both on a previous line?
The initialization of the flutter commands still needs some work, but eventually yet.
err "eventually yes"
Can we just introduce this into the ctors of the necessary commands in this patch rather than introducing more work to refactor?
Hm. Dartfmt does indeed move the `?` part to the next line as well. Maybe I'm just starting to think in terms of null-safety world, with `?` as one operator and `.` as another, but this is fine.
I considered that but it is not feasible until https://github.com/flutter/flutter/pull/67275 and others have been completed and initialization of the tool is moved out of the flutter command
Ok. LGTM
This is not necessary because the error_handling_io.dart implementation of FileSystem will catch permission errors
Renamed from other file since it only contained Android. Added test cases to prove that embedding version identification works
Mostly unchanged, but standardized formatting, usage of cast operator, and removed extra group.  Also expanded the descriptions on a few of the test cases
I believe our official recommendation is to use rubygems, e.g. https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/macos/cocoapods.dart#L44
fyi, i think the homebrew formula for cocoapods just delegates to rubygems anyway
+1 I have never installed it with homebrew. https://flutter.dev/docs/get-started/install/macos#deploy-to-ios-devices
TIL, why did I install it with brew - perhaps that was old documentation?
Done, and added link to iOS getting started docs
Seems silly to inject os utils just to format the OS name
See comment below on Flutter validator
See https://github.com/flutter/flutter/issues/67352 for the issue where we fix + remove this.  Do not need to worry about the binaries being up to date, because gen_snapshot is a native binary and does not need a matching Dart SDK
Needs to be deleted if it exists so that the downloader does not append to a file that already exists
This forces the file to be created so that the tests pass
NB: This is going to open and close the file on every chunk, which might be significant since the cache is downloading large files.
would you suggest opening a RandomAccessFile instead and using those write methods? I'd need to add a few more wrappers in error_handling_io, but if that makes this more reliable it seems worth it?
I think it's not worth it right now, but that would be a good plan if we notice that there's a problem with the change in this PR.
ack
I think this comment should be updated to only mention `label`, since that is the non-deprecated parameter.
Let me double check that on Monday
Yeah, let's only mention the `label` here.
Ok Thanks @goderbauer 
Thanks, @goderbauer 
This change is required to make the integration test added pass
How does one unfamiliar with State Restoration go about learning about how to use it? I'm thinking that naturally, developers look for code samples to play around with how to use this. I personally used the test code in this PR to familiarize myself with how to use state restoration with the Navigator/CupertinoTabView.  There is a code sample at [Navigator.restorablePush](https://master-api.flutter.dev/flutter/widgets/Navigator/restorablePush.html) and [Navigatoor.restorablePushNamed](https://master-api.flutter.dev/flutter/widgets/Navigator/restorablePushNamed.html), so maybe we could link there?
Good idea. I added three more links to the "see also" section in the macro.
@HansMuller this double-level of nullness looks suspicious, is it what we want?
cc @HansMuller is it ok for this to return null?
Yes. If it returns null, the caller is responsible for looking up a default.
Yes, this is correct. If specified (if non-null), properties like textStyle can resolve to `TextStyle?`.  If the MSP is null,  then the style does not override the default textStyle. If the MSP is non-null, it can resolve to null for the subset of MaterialStates that it does not override. 
wow, good catch
we assert it's not null just below
ditto
also sliderTheme
sliderTheme is asserted not null below
ditto for the two here
and these three
also these three
asserted non-null below
asserted non-null below
these are all asserted non-null
same for these
and these
non-null
asserted non-null
all these are asserted non-null
lots of these are asserted non-null
same
same
same
same
here too
same
same
same
cc @HansMuller we might be able to get rid of this line too, it looks like RenderToggleable always sets reverseCurve when it sets curve. But that's a story for another PR.
Those 2 parameters can not be required because `getPreferredSize` overrides `SliderComponentShape.getPreferredSize(bool isEnabled, bool isDiscrete)` that does not define those optional parameters.
Same explanation because of override
Oh wow, interesting.
Tests in google are breaking because this was marked required.  @a14n do you remember why this needs to be required now?  /cc @Hixie @HansMuller 
Nothing obvious comes to my mind. We can remove the required keyword.
Removing in https://github.com/flutter/flutter/pull/67427.
nit: delete 'so'
Not sure if "drop on the floor" is a commonly understood idiom. How about "ignored"?
updated docs with more information while i was at it
Would be good to clean this up before stable release. How widespread is the usage of this setter?
@Piinks is working on a deprecation policy.
went with "discarded"
I'll make sure to send you the proposal, it will include what usage data I've been able to collect and some guidelines for cleaning up old code. <=1 week out from publishing :)
Why this?
Why this?
nit: trailing comma and `)` on next line.
?
Not `Object?`?
weird, I had some problems getting vs code to show analysis warnings locally - maybe this isn't necessary?
AFAIK, it shouldn't be necessary since you raised the SDK constraints in the pubspec?
The return type of the method on result is defined as:  ```  /// Serializes this message to a JSON map.   Map<String, dynamic> toJson(); ```
FWIW, I would lean towards moving from `dynamic` to `Object?` everywhere rather than the other way around, but that's something we can worry about in another PR.
At least that last issue is closed., so these probably need rechecking.
Updated
Do these options work in release mode on other platforms? Since they won't currently on desktop, maybe we should see if this is non-empty and if the build mode is release, output a warning that the options will be ignored and to file an issue describing their use case.
Wouldn't it be clearer to start this as zero, increment flags at the start of `addFlag` instead of the end, and not have to subtract in `finish`?
This won't actually work currently, but I guess it's harmless to pass anyway, and then it'll be in place already when implemented on the engine side.
Skimming, I almost missed that this was an early return instead of just another flag. Maybe wrap all the rest in `if (debuggingOptions.debuggingEnabled) {...}` instead of early return so it's clearer?  (As a concrete issue, I think there's a good chance that if I were ever to add anything to the flags here as currently written, I would accidentally add it to the end of the function not realizing that it wouldn't always get there.)
Do we have an issue filled? I could add that in a comment
done
The tooling will already ignore the unsupported values when constructing the debugging options object:  https://github.com/flutter/flutter/blob/90bc7c64dd3c02922e4bad49f6001fe32b86ae54/packages/flutter_tools/lib/src/commands/run.dart#L374  That seems like a reasonable place to insert some logging to warn users if they are passing flags that have no effect.
Filled https://github.com/flutter/flutter/issues/67315
Updated to only have a single return
Actually, now that I look closer it might be that this is internal enough that it does work. I was thinking of the embedding using software mode at the embedder.h level, which may not be the same thing. Let's just leave this as-is.
This test takes a while to execute, are you sure you want to run it 15 times?  I think it probably takes at least 1-2 minutes.
Yes, I checked the build dashboard and here's what I observed and expected (as documented in the PR/commit description) > Currently, a startup test runs for about 1 minute. After the change, the test should run for about 5 minutes or less because some setup steps don't need to be repeated 5 times.
This has since been done
I tried :) 
nit: ```suggestion   testWithoutContext('WindowsDevices lists a devices if the workflow is supported', () async { ```
And we can safely assume these never get mutated, leaking state between tests?
There are some contrived circumstances where you can mutate the environment field, but only if that is set to a non-const value (it defaults to an empty const map, which is unmodifiable) 
There's usually a blank line around these, but I guess it really doesn't matter here.
Not `Object?`?
(same question below)
It's probably not critical and maybe the compiler should just figure this out anyway, but for my curiosity - would it be better to just have a single copy of `rrect` that's asserted not null here at the top? like   ```dart final RRect rrect = this.rrect!; ```  or something to that effect?
Changed.
I don't know. I think doing it the other way would in this case actually make the code more complicated because you would have two separate ifs.
Yeah. And honestly if the compiler doesn't optimize this the way we'd want I'd be pretty disappointed.
This should be moved a line above.
(it does real async work and expects to complete before any other async operations it's enclosed by).
Ah, yes! It was suppose to go there! Fixed.
We need to keep these asserts for now since people may be running in a mode where null-safety is not enabled.
This could be `late` instead of `?` since you will always assign it before first accessing it.
late
late
`?` and `nullOk: false` is odd. You probably just want a `!` after the resolve call.
late
Can these and below also be `late`?
We're not yet removing these asserts, since it is still possible to run Flutter in non-NNBD mode. We'll do a pass later and remove all of these at once (there's a lint that we'll turn on).
just make it non-nullable and add the ! at the end after `()`.
same
same
You can make this `late` instead of nullable.
This can be `late`.
This can be `late`.
Can be `late`.
Can be `late`.
Can be `late`.
Can be `late`.
Can be `late`.
Can be `late`.
```suggestion     setState(() { brightness = Brightness.dark; }); ```
Why is the `cast` needed? Seems like you should be able to do: ```suggestion     final Offset? notIncluded = includes.firstWhere((Offset offset) => !item.contains(offset), orElse: () => null); ``` But I guess `firstWhere` is templated on the type of `includes` and probably doesn't allow null from the `orElse`.  Interesting.
> But I guess firstWhere is templated on the type of includes and probably doesn't allow null from the orElse. Interesting.  Yes, this is unfortunately the reason for the cast...
We weren't actually using this package before, it was just transitive. Unfortunately adding new direct dependencies may slow down out eventually null safety migration, so I'd only like to do so if we know that it will be migrated/maintained.  @natebosch is this something that is planned for `package:html` eventually?  Alternatively you could parse it out with a regex (Yeah I know...)
baseref is really an optional feature right? I would leave this out and we can update release notes instead.  As is this message does not give enough context for a user to know what/how to fix it
For these, it would to give a longer message with some examples of good baseHrefs.   ``` Error: The base href in "web/index.html" must end with a "/", but found Found: `{outerhtml}` . For example, to serve from the root use:    <base href="/">  To serve from a subdomain (?) named "foo" use:    <base href="/foo">   ```  Plus some word smithing
Yes, this will be migrated soon. I'm not sure the long term future for the package, but at least in the short term we will be maintaining it.
Okay SGTM,  in that case @mdebbar remove the `# transitive ...` dependency tag from the pubspec.yaml and move it over with the rest of the direct dependencies
👍 
Makes sense. Where do I update release notes?
changelog on the wiki is a good place to start. We'll need to collect all of the index.html changes up offline and possibly ask users just to regenerate
nice!
Thanks for the review and suggestions 😃
Update the comment "Hover and down pointer events..."
Ditto.
Ditto.
Ditto.
Ditto.
Ditto.
Ditto.
Ditto.
Like here, we need a comment saying that for device without hover event, add event and down event will always have the same position and therefore won't add hover event
Done
Can you make this non-nullable and just add a `!` on the `selectedLabelStyle.fontSize`? That would eliminate some `!` checks below.  And the checks below get hard to read, because some usages of `selectedFontSize` have them, and some don't need them.
Done
fyi @HansMuller not sure if this was the intended design but this does match what we had before. Maybe we should make selectedLabelStyle and unselectedLabelStyle nullable in some future PR?
cc @HansMuller similar here
looks like this should be required
But there are place where no animationController is passed. And sometimes a nullable value is passed as well.
This looks like an obvious error for which I assume we had no test coverage. This widget is supposed to be "conventional", non-null style parameters override defaults valued computed by the widget.  CC @johnsonmh 
Same reply as above.
This change (making `close()` `async`) caused the test failures in google3 because it's changing the timing in tests slightly. I am going to make this non-async again to restore the old behavior.
Thanks for the catch, this PR should fix the bug and make desired nullability more clear: https://github.com/flutter/flutter/pull/67342
This test is deleted because the type system now grantees that `null` can never be passed in as a value.
```suggestion     Widget _text({String text = 'Text', required Color color, required Color background}) { ```
```suggestion         _icon(color: Colors.white, background: Colors.red[800]!, icon: Icons.more_horiz),         _icon(color: Colors.white, background: Colors.green[800]!, icon: Icons.description),         _icon(color: Colors.white, background: Colors.blue[800]!, icon: Icons.image),         _icon(color: Colors.white, background: Colors.purple[800]!, icon: Icons.beach_access), ```
```suggestion         _icon(color: Colors.white, background: Colors.red[200]!, icon: Icons.more_horiz),         _icon(color: Colors.white, background: Colors.green[400]!, icon: Icons.description),         _icon(color: Colors.white, background: Colors.blue[600]!, icon: Icons.image),         _icon(color: Colors.white, background: Colors.purple[800]!, icon: Icons.beach_access), ```
Instead of using the mock use `FakePlatform(operatingSystem: 'windows')`
// This should not throw.  Alternatively if you want to be more explicit you could use:  `expect(() => handleSymlinkException(e, platform: platform, os: os), returnsNormally)`
Done.
Ah, perfect. I tried to find an example of a similar test to see what the best construction was, but didn't find the right search terms.
This one is hard to read... good luck 😦 
formatting is kind of weird here, could you align the FakeCommand args?
Done.
normally we mention where this would get used in the doc.
Ditto
Ditto
Ditto
Ditto
Ditto
+1, see also https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#leave-breadcrumbs-in-the-comments:  > Typedefs should mention at least one place where the signature is used.
It looks like this is only used internally.  Maybe it should be made private?
I was just about to say that. Looks like this should actually be private.
Not quite sure what context to provide on this one...  @HansMuller: can you advise?   
@HansMuller ?
```suggestion /// Signature for a function that builds a [VelocityTracker]. /// /// Used by [DragGestureRecognizer.velocityTrackerBuilder]. ```
@dreveman or @liyuqian can you provide a better description for this one?
nit: here and everywhere else: Can you replace "see:" with "Used by" to match style?
Used by [BottomSheet.onDragStart].
Used by [BottomSheet.onDragEnd].
Should mention `[debugOnPaintImage]`.
Should I go ahead and make it private here or is that better in a different PR?
```suggestion /// A callback used by [PointerEventResampler.sample] and [PointerEventResampler.stop] to process a resampled `event`, ```
Just do it here :) 
Thanks!
Thanks!
Good deal.
Privatized.
Add a debugCheckHasDirectionality.
These `!` on the iconTheme property are unfortunate. We know that `IconTheme.of` only returns theme data where that is true, I wish we could express that in code better.   Maybe add an `assert(iconTheme.isConcrete)` above this line to make it clear to the reader?
This could be late, I think?
You're right, thanks.
assert added
added
We are planning on making `initialDate` an optional parameter to allow the picker to express nothing is currently selected. This is something we can relax after this work is complete without breaking existing apps, right? 
Do we still need this assert (and the one below it)? These will never be null, right?
These asserts are no longer needed.
Assert no longer required.
> This is something we can relax after this work is complete without breaking existing apps, right?  In the case of parameters it is not breaking to change from required non-nullable to accept nullable.  
Removed the sync call because for processes async is better, and it was only used once
made private and moved to the end of the file
Made these public and documented on AndroidDevice. Just constants, should update the tests we have to use them instead of using specific strings
will clean up with g3fix
Can't happen now that we check if adb is null
No longer needed now that we can easily create classes for testing
Gave documenting these a shot, its a start!
These tests are all the same but updated to go through the real API
If you accidentally `print([])` you would crash the parsing here
```suggestion /// See [AndroidDevice] for more explanation of why this is needed. ```
thank you
thank you again
does that mean this PR is blocked?
No, g3 fix allows me to create a CL that has all the needed changes and tell frob about it. Then when this rolls into g3 that CL gets patched into automatically
why the switch to processManager here?
SGTM
I can't remember so I changed it back
I think this was a real bug: I was getting test failures because `directory/gradle/wrapper` didn't exist when this method was called right after the directory was created: https://github.com/flutter/flutter/blob/b9274c7c607bdb287d3b0483c5a3a8dcf5b35fcb/packages/flutter_tools/lib/src/cache.dart#L1040-L1043
Note sure if this is the right annotation?
If the `rootOverride` is passed in but not `fileSystem`, use the override file system, otherwise drop back to `MemoryFileSystem`
This is the default from `Artifacts.test()`.
`@visibleForTesting` if it should only be used in test files. `@visibleForOverriding` I'm not really sure what that means that is different from `@protected`
If you make this method `async` you don't need a `return null`
Might be worth sharing this or making it a visibleForTesting artifact in cache.dart
Is there somewhere else to put it?  I don't really want even more test fake code littering the real code.
👍 
nice!
You could create a fakes.dart in the test utils folder, or at least something in the ios test folder.
Yeah I think I want `@protected`.
Should have answered my own question, I was tired of looking at it.
I put it in the existing `fakes.dart` file.
This one wasn't `MockFile` related but it was easy.
I'll take it
Since these will run every time, I think the additional logs should be left out, it will make startup somewhat noisy
Why do we need to newly allow null here?
Why is `inputString` allowed to be null here?
What's guaranteeing here that `animation` is not null?
Should have a `debugCheckHasMediaQuery` call.
Similar question everywhere below.
nit: this could just be:  ```suggestion return context.findAncestorRenderObjectOfType<_RenderInkFeatures>(); ```
The call chain comes from `typedef FormFieldValidator<T> = String? Function(T? value);` where value is nullable.
Same cause : The call chain comes from `typedef FormFieldValidator<T> = String? Function(T? value);` where value is nullable.
Nothing, but it works as before :p More seriously there's an assert non-null in build() at L387 but I really don't know how it works. Trying to make animation required cause a lot of warning. Perhaps @HansMuller could take a look?
added
Done
It looks like SnackBar is always used as argument of `showSnackBar`. That's where a animation is added and why animation is not null.
I see, thanks.
Nit: remove the extra `//`
Done
a launcher
Done
Can you explain this startup process and the error cases a bit more?
Sure. I'm happy to add this information in comments as well if you'd like.  This first case here is meant to catch errors that occur during DDS startup (e.g., failure to bind to a port, failure to connect to the VM service, attaching to a VM service with existing clients, etc).  The second try block below with the new `Future.any(...)` code handles cases where the VM service connection goes down before flutter_tools connects to DDS. The DDS `done` future completes when DDS shuts down, including after an error, so if this future completes before `connectToVmService` we know that something went wrong that caused DDS to shutdown early. 
:(   What errors are thrown?
Ugh, forgot I changed this before landing last week. We originally threw a `StateError` [here](https://github.com/dart-lang/sdk/blob/master/pkg/dds/lib/src/dds_impl.dart#L32) but past me thought that wasn't a good idea and changed it.
Documented too please :) 
Done.
```suggestion       _ddsInstance.done.whenComplete(_completer.complete); ```
```suggestion         } on Exception catch (e) { ```
This formatting could use a little TLC
Can you add some more context to this exception? this case does indicate an error in dds right?
The tool integration tests could be written to cover this partially - i.e. create an app template that crashes immediately and connect to it. This should work with the flutter tester, right?
Done.
It simply indicates that DDS has shutdown, not necessarily whether or not it encountered an error. However, if we've shutdown DDS before the VM service connection is established it means something has gone wrong, likely the VM service disappearing. It's described in the comment block above the try block.
use https://github.com/flutter/flutter/blob/43c1b34cf5cb4517483a8e9e95277be6692c6f55/packages/flutter_tools/lib/src/base/common.dart#L40 instead
Done.
Nice! Is it possible to use the test driver with this code? I believe it will throw an exception if the startup fails, but you could still catch that and inspect the logs
This should make sure its not an unhandled exception, perhaps checking for stack frames? Not quite sure what the best way is. The message itself is fairly generic
Took a couple changes, but got that working. Didn't see it the first time around.
Yeah, I was thinking it could be an issue. Added a regexp check to make sure there's no stack frames.
```suggestion     } on Exception { ```
Nice!
Thinking a bit more (and looking at the timeout) this could be flaky if it goes down too fast. Maybe an await for a few seconds?
Added a 50ms delay. Not sure if things happening too fast or too slow caused the timeout, but if it turns out the test is just inherently flaky we might want to abandon it.
maybe link to initState here?
maybe rephrase this to: GlobalKey are usually long-lived objects owned for example by a [State] object. They should not be re-created on every build.
If you follow this advise, you will still have the same problem for Stateless widgets that do get re-instantiated when they rebuild. You need to make sure the key is owned by soemthing longer lived, e.g. a state object.
`[GestureDetector]`
This sentence is kinda strange. Maybe something like: Creating a new GlobalKey on every build will throw away the state of the subtree associated with the old key and create a new fresh subtree for the new key.
I think this should be a static of `ErrorHandlingFileSystem`. `withAllowedFailure` is a bit too generic by itself. Also, how about `noExitOnFailure` or `exceptionOnFailure` since it's not so much that failures are allowed as it is that they're just presented in a different way.
Also, this should account for nesting the calls, and have a test that that is handled correctly.
Consider wrapping the logic from here to the `throwToolExit` in a helper method.
The behavior of config is changing a bit, too, so it would be good to have a test of that as well.
Ahh good point about the nesting, I didn't think of that :) 
Done
Done
@zanderso WDUT?
The Logger already does the emoji support check, so you can just use it directly here.
TIL
nit: return not needed.
nit: two space indent on continued line.
Could this still be useful?
I was only using this as a sentinel in a test, but not throwing an exception accomplishes the same goal
Done
Done
Try using a target platform variant here.  Then the test body is just a switch statement, and it runs one test per platform, so if it fails, it's clear which platform failed.  ```suggestion   }, variant: TargetPlatformVariant.all()); ``` 
Oh TIL, this is nice!
Done
I'm still feeling this is a workaround, see also https://github.com/flutter/flutter/pull/60558#discussion_r496235528  This is a public method because it's needed in `WidgetTester`. 
why is this needed in WidgetTester? If needed then maybe this is find but ideally the name would just be "sample()" instead of triggerResample.
> why is this needed in WidgetTester? If needed then maybe this is find but ideally the name would just be "sample()" instead of triggerResample.  Because `triggerResample` is called in `_flushPointerEventQueue`, which is before the input injection in `WidgetTester`. `triggerResample` is in `_flushPointerEventQueue` because otherwise `sample` is not properly called: when `_pendingPointerEvents` is empty, we still need to call `_resampler.sample` for updated resampled event (see https://github.com/flutter/flutter/pull/60558#discussion_r496235528) @dreveman 
As for the name, I'm feeling `binding.sample` is confusing because binding is not the subject of `sample`...
Thank to @liyuqian 's [comment](https://github.com/flutter/flutter/pull/60558/files/b7802f69f91e1b5466d6b5b58e98193160964ca5#r499014047) I realize this `triggerResample` is kind of duplicate with `_handleSampleTimeChanged`. `triggerResample` is removed in the new commit. 
What if resamplingEnabled is false here? Should we stop the resampler instead then?
This can happen when resample was on but is turned off, and the logic should be to just discard the remaining events queued in the resampler? @dreveman 
Updated. PTAL.
Not in love with the extension method, but I don't want to re-type everything as ErrorHandling file.  Maybe just a static helper method?
Does this extension apply to every class that extends or implements `File`, or does it apply *only* to exactly `File`? Either way, it is probably worth a comment here.
If the extension method applies to any implementation of `File`, then we need test coverage of how it applies to them.
If `File` is an `ErrorHandlingFile`, then you could get either a `ToolExit` or an `Exception` here depending on whether you're under a `noExitOnFailure`.
This would subvert a `noExitOnFailure`.
Thats true - this should probably become a static method on error handling file system - then that can be taken into account.
The goal with this catch is to only intercept error code 2, which we don't catch with error handling io because it normally seems to indicate a tool error.  Any other exception types should pass through as is, though I will add support for the existing error ignoring logic
Update to static method on ErrorHandlingFileSystem
Moved to ErrorHandlingFileSystem
Updated to support noExitOnFailure
Wouldn't this be different on different OS's?
How about: ```dart static bool deleteIfExists(FileSystemEntity entity, ...) { ... } ```  Then it can handle directories and links as well.
How about replacing https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/src/common.dart#L34 and using that not just for directories but also for files?
For files it is the same, windows 2 is ERROR_FILE_NOT_FOUND, and 2 on linux/macOS  2 is ENOENT is No such file or directory. I can check if deleting a directory that does not exist uses the same error code on windows 
Will check if these have the same error code on windows
kk. This would be good to have as a comment in the code here.
That probably needs to be fixed too, but it is more for file lock issues on windows than read-only problems
same error code for directories
Made the comment more specific
So, the difference would be a different error code? The same code structure could handle the situation apart from that, though, right? Maybe not for this PR, but it would be nice to have a single way for the tool to try to delete something.
I think we would prefer if the tests shut down cleanly, and this was added as more of a stopgap 
Ah, yeah. Good point.
Most of these methods do not need to be async - this made it much easier to fix the disabled test
These changes just make the async APIs sync like the underlying code
The only change for the log command
This test was disabled, now it works again yay
FWIW, I would strongly prefer we never use `FutureOr`. It leads to all kinds of issues later.
not quite sure i understand where this ends up mattering
Removed, its not necessary
This is reasonable but we can't reference private variables in public docs. i.e. IDEs and our API doc website won't link this snippet to anything and just looking at the variable name doesn't really inform our users of anything. We can either make this public or change how we describe it.  1. I took a look at this color, and it seems like we use 0x33000000 in a couple of places, so it would be nice to add it to https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/cupertino/colors.dart, but we should also be systematic and not make up new semantic names for these names and I couldn't find an Apple spec'ed name for this color in the apple sketch file 🤷‍♂️  ![Screen Shot 2020-09-28 at 11 39 59 AM](https://user-images.githubusercontent.com/156888/94472285-5f85a300-017f-11eb-92b0-a5da7052e5fb.png)  2. Keeping it private makes this easier since we don't have to promise to keep some semantic color correct and publicly up to date forever. Here we can just say: `When unspecified, the barrier color defaults to a light opacity black scrim based on iOS's dialog screens.` 
`tapping` instead of `clicking`. We already say `tapping` elsewhere in this file. Be consistent here.
Slightly out of scope but since we're here, let's also make the showCupertinoDialog parameters consistent with these new ones as well
Leave the last newline
Thought I would do a different PR for that since it doesn't involve the popup and I would have to write tests for that too. Would you rather I do that in this PR?
Nope. A different PR sounds good :)
I'm not sure I understood this test. Based on the description, I would have assumed that we were going to assert that without specifying a `barrierColor`, the outcome is a Color(0x33000000) color. 
typo
It's not so much that it's the same color. Rather than here specifically, you're pumping a light themed widget tree (which is the default).
You're right, I had to leave it out.
Who is you? Prefer a bit of passive voice instead maybe?
when would someone want/need to create a clone?
Why is comparing clones useful?
Rephrased.
Expanded with example.
concrete example of a Client is an Image widget? Or an image cache?
why does this clone if it doesn't dispose? won't this create extra image clones
Any method or class receiving this object.
The render object disposes of it. This can't dispose because it's stateless - it needs to be kept alive by whatever created RawImage.
This is pretty confusing - so the State class has its copy, which it will clone/dispose as needed. Then the RawImage is just a pass through, and finally the RO accepts the clone and does a dispose.  Maybe a safer arrangement would be for the RO to clone in the setter, so that the behavior is internal to it?
The comment above here is confusing and/or outdated since no listener is added in the code below?
I'm trying to keep the contract as you should never have to clone something you received. If we have some places that clone immediately I think it's more confusing.  However, I agree that `RawImage` is a sore spot, and I think it'd be preferable to just make it private since it's easy to misuse.
grammer: ... is called only called if ...
This should document that listeners are in charge of disposing the image they receive.
same here
nit: rename _listeners to _activeListeners to avoid confusion in the code of what's included here?
Update this method's docs to make it clear that this is about active listeners and passive ones don't count?
I don't understand... we seem to be disposing it a few lines above. Aren't we disposing somebody else's handle if we don't retain?
Who disposes this?
I have also been confused by the fact that cloning and disposing are done by separate entities.
Yeah, if it needs to act like an implementation detail of the Image class it should be private. But we do have other `RawFoo` classes exposed in the framework so that people could build on top of that, though I think there is also a rendering helper method too?  I dunno.
This doesn't need to be disposed?
This is oddly named since it does not dispose the image from the info given to it. Maybe rename to replaceImage?
?
haha whups :)  Thought I needed this at one point but I do not.
Done
Oh. I think I do need something like this. I'll fix it and add the relevant test.  The problem right now is that if the TickerMode goes off, we could inadvertently dispose of the image stream when we stop listening to it. We'll have to add a passive listener and remove it.
This causes the render object to dispose the image.
The render object.
Only if it's not null above. Added a comment to clarify.
Oh, this comment is just wrong. Removing it. I thought at one point it would work this way but it did not in fact work. I just forgot to remove the comment.
Added a doc.
Done
Added to template.
Template should cover both. I'll also update ImageStreamListener.onImage.
Fixed
I've refactored `RawImage` into a public `StatefulWidget` and made the current impl private. The public impl now does not need to be special cased.
Refactored RawImage to not be a special case. There's a private impl that's a special case now though.
Why dispose when `value == _image`? Wouldn't this potentially dispose the object we are holding onto in `_image`?
Maybe add a comment here explaining why we need to set this to null.
This dance is necessary because otherwise the removal of the oldListener may dispose the image?
Why are passive listeners not informed here? The doc for them includes:  > but does want to know the latest frame used in case new clients ask for the cached image.  Wouldn't the cache then have an outdated image?
Similarly to what's happening in rendering/image.dart, there could be an optimization here if value is a clone of _image, no?
Make arg a named param so we know here what's set to true?
The code here would be a little clearer with a named arg set to null to indicate that the image is getting replaced by nothing?
For my own understanding, why this assert?
A doc comment somewhere explaining why stopping to listen may require a passive listener would be helpful.
Ah, you are right. I'll add a test for this and fix it.
Correct.
It will get the updated image once an active listener registers, as will the active listener.  The cache itself doesn't actually need the image reference, it just needs the completer to give out.
I had to revert that refactor because it doesn't work to have the image hold a stateful object like that.
Done
Done
Done
Ahh I added this while testing things to make sure the image wasn't disposed here. I'll replace it with a better assert.
Actually just removing it, there's other tests covering this now.
Done
Adding this.
Updated the comment.
It's really sketchy that we're disposing something inside an object. That doesn't seem right (intuitive) at all.
commented out code
addPostFrameCallback doesn't request a new frame. Are you guaranteed that this code is called only during a frame?
i think this class should have a dispose, since it owns something that can be disposed. That would be more intuitive than having to clean out its contents.
why not have the widget pass through, and its caller (the call to the RawImage constructor) have to call `clone()`?
The widget might create multiple RenderObjects (via multiple elements). It has no defined lifetime, and so it's not clear when the widget's clone would ever get disposed.
No, but we want to keep it alive until the next scheduled frame to give other clients time to subscribe.   The downside is that if you precache an image and then never ever schedule a frame again, you'll hold the memory. But I'm not clear on how that would happen - you shouldn't be precaching images if you're not going to schedule frames to draw them.
The only reason I didn't do that is because we have some objects that eventually are just given the image out of an ImageInfo.  I think it's confusing either way, I'm just not sure which way is less confusing :)
avoid => in setState since it doesn't return anything
Done
k
Should you dispose the _imageInfo directly here instead of the image?
and here?
nit: we no longer have passive listeners.
Change this to what the actual code in rendering/image.dart is? I.e. don't dispose if `value == _imageInfo`!
nit: add some context why to look there.
I wonder if it is worthwhile to add asserts that a disposed imageinfo isn't used anymore (e.g. assert in the image and clone getter?)
nit: "should avoid" sounds pretty weak. Are there situations where we dispose this even though somebody anted it alive?
is command not found the only situation we'd see an `ArgumentError` here?
should we enable `verboseExceptions` here too?
Technically we could get it by passing `null` too. If we did not have the ProcessManager wrapper, this would actually be a ProcessException
done
wonder if that will make any tests fail...
pretty sure every time you ask that question, the answer is yes
```suggestion   Future<HttpClientResponse> get done async => _MockHttpResponse(); ```
```suggestion         final RenderBox renderObject = element.renderObject! as RenderBox; ```
Perhaps throwing something is better here?
`== true` could be removed.
```suggestion     final RenderRepaintBoundary boundary = boundaryKey.currentContext!.findRenderObject()! as RenderRepaintBoundary; ```
```suggestion       renderObject = renderObject.parent! as RenderObject; ```
break?
nit: ```suggestion     unnecessary_null_comparison: false # https://github.com/dart-lang/language/issues/1018, turned off until https://github.com/flutter/flutter/issues/61042 ```
Out of curiosity, why the word "clear"? I don't think it adds anything, or maybe I don't understand what you mean. LOL...it's unclear.
Nice fix.  Seems like this was a bug found by NNBD.
This 12.0 should probably be a constant somewhere.
So you can't get the current task count if not currently in a test, but do we want to throw?  Couldn't you just return zero if `!inTest`?
Much better...
Doesn't casting it to `Object` (as opposed to `Object?`) imply the `!`?
Why is this no longer `Future<void>`? It doesn't appear to return anything.
Can't you just do this for all of these, and avoid adding another function?  ```dart  onMetricsChanged?.call(); ```
Same here: ```dart  onLocaleChanged?.call(); ```
All of these extra functions to test for nullness seem unnecessary to me.
Yes!
Yes, it does. But @a14n is working on a lint that will require you to specifically think about null and add the `!` to say that you thought about nullability and this cannot be null here. 
Changed this back to void. I originally made this dynamic because the analyzer was complaining. Turns out, that was a bug in the analyzer: https://github.com/dart-lang/linter/issues/2185
Removed them per your suggestion. 
That's actually pretty clever. I forgot about `call()`. Changed all of them.
I think that accessing this outside of a test is meaningless and almost certainly means you have some kind of a bug. Therefore, it should throw.
I am just changing this to an API we already have :P   I think clearing the test value is _clearer_ than setting it to null. You are not really setting the physicalSize to null. You are removing/clearing a previously specified test value to make the actual value specified by the embedder "come through" again.
OK, makes sense.
Oh, I see. For some reason, I was reading it as an assignment, not a function call, which is what confused me.
OK. When that lint is turned on, I'm sure we'll have a bunch of places to fix.
Yeah, a14n has already been fixing up our code base in prep for that.
that second bug is closed
should we check if renderObject is non-null? Or is it more or less guaranteed to be?
ditto
similar here; what if someone ends up calling this before layout/paint have run? you can change the phase in a test.
yikes, do we document / check that this is only used with RenderBoxes?
docs should mention T
nit: switch (` (space before `(`)
fyi @gspencergoog 
Yes, I saw this when I did my review, and it simplifies other code here, but doesn't change behavior, so a net win.
i wonder how many people ever use this and whether we should just remove it. I don't think I've used it once since implementing it.
(just an idle thought unrelated to this PR obviously)
Removed.
Added an assert.
I added an assert. Currently, it is guaranteed that the renderObject will always be a RenderBox because the element finder above only returns Elements of `Text` or `Editable` widgets, which will always have RenderBox elements.
What's the rationale as to where this falls in the list of fields?
"says" -> "say"
I put it above the callbacks but below existing params since they're all of different types. It's a private class so the order isn't super important
done
Did we already have this localization for something else? Does it make sense that the semantic text match the label in this case? 
Yes this localization was already used for the hour/minute labels underneath the textfields on this screen. But those labels are excluded from semantics to improve the screen reader experience. So we also use them for the text field's hint texts when screen readers are enabled
nit: I would keep the closing `)`s on the same line
Instead of using FSutils here I would just do:  ``` file.parent.createSync(recursive: true); ```  The FSUtils will throw a fatal exception if the operation fails, which we don't want for the config/settings.
Please add some more context on how this is used. For example, talk about how if the config is written in home it is appended to the name, and if xdg then not.
This seems wrong? Why no `if (!platform.isLinux) { ... }`
Should this file name have stayed the same?
same here?
```suggestion ```
Longer comment here: config is created in the specified xdg directory if it does not already exist in the home dir?
You are right. I do however think `$XDG_CONFIG_HOME` should be the default on macOS as well, so it would be `if (!platform.isLinux && !platform.isMacOS)`.
I changed `Config.test` to prepend the `.flutter_` prefix, so this can stay the same.
good docs, but follow https://dart.dev/guides/language/effective-dart/documentation#do-start-doc-comments-with-a-single-sentence-summary and split off the additional details in a new paragraph.
can you revert style changes from this PR that are unrelated to the change?
while you are here (and if you're going to reformat it...), change this to `platform.isWindows` ? ... : ...
you don't need an `else` block if you have an early return
think positive
pull out `XDG_CONFIG_HOME` into a constant and document it with a link to the specification
can we actually use `case null` now?
Yes, changed.
@dkwingsmt Can you take a look at this? In general `resolve` will return a nullable type, I worry that this `!` isn't safe and should maybe look something more like:  ```dart return resolve(<MaterialState>{})?.createSession(device) ?? _defaultMouseCursor.createSession(device); ```
Yes. In most (all) cases, if MaterialState's resolve method returns null, that indicates that the widget should defer to the next most general default.
Use a `FakePlatform(operatingSystem: 'linux')` instead of a mock
what is this testing?
Consider using the FakeProcessManager and listing out the commands explicitly, like:  https://github.com/flutter/flutter/blob/943b41bd61de434fd18777675b89ade479ccefd9/packages/flutter_tools/test/general.shard/macos/macos_device_test.dart#L61
2 space indent for second line
Yes! this is much easier. Do you have any concern that is more brittle, since any changes to other flags of the command would break it?
This was to test that I could return the command as a list. Not needed with the change to using FakeCommand
Nit: make the completer private and add a getter that returns its `Future`
We want the tests to fail if the commands/flags change
Right now, the only way to use this is by modifying the source code. It would be nice if we could support this via a cli flag or env variable. Thoughts?
This would also need to be specified in the application's index.html right? We could consider parsing it out of that file.  Alternatively a cli flag would be the most approachable option, see the existing `--web-` values that are passed through `DebuggingOptions` 
you could also configure it through the pubspec.yaml, but that feels redundant with the index.html
Correct. This needs be added to `index.html` like this: ```html <base href="/base/path/"> ``` I think we should also change the html template to include the `<base>` tag commented out with an explanation: ```html <!--   Uncomment the following line if you are serving your web app in a path other   than the root.    Fore more details:   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base --> <!-- <base href="/foo/"> --> ```  I like the idea of parsing it automatically from the html file. But when do we parse it?  If we do it at server startup, the user could change their index.html file while the server is running. They have to kill and start their server again (not ideal).  Should we parse it every time we receive a request? I think this might work but will lead to slower responses.  Maybe do it at build time and re-parse on hot restart? This is different from today's behavior where changes in `index.html` don't require a hot restart.
I think leaving this commented out in the template is a great idea to start with.  parsing the base url out only at server startup is a reasonable compromise? I can't imagine that changing the value is going to be a common edit case, but if it is we can revisit this in the future.  Otherwise, a hot restart would be the best place to do so - that is somewhat consistent with the rest of the development cycle.
Do you mind if I do the template changes and the html parsing in a separate PR? I want to keep the PRs small and easy to review.
SGTM
Just pointing out this TODO in case you forgot it, otherwise I assume it's for another PR.
I'll open an issue. The onSurface color causes a tiny difference, black instead of "black87", which causes some golden image tests to fail. Will need to do a separate update to change the color.
This test is getting more and more complicated. Seems like it is just a band-aid over the fact that we really don't have a concept of what is a surface and what isn't. That said, this is a good fix for now. Thx. 
Nice test. 
Agreed, we are kind of patching things up. Material-Android has gotten to a stable place with dark theme logic, so hopefully once we've patched the same holes that they have, we will be able to leave it alone. Removing opacities is another part of their check. 
Thanks! 👍 
indentation here looks funky?
Fixed, thanks.
I may be wrong (hard to tell in GitHub), but it looks to me like lines 285-288 are indented 1 col too far, while 289-290 look ok?
should we leave a breadcrumb comment at the location in the tool where we define the min version to also update this magic constant?
I'm not sure this is the best place to put it. Since it's a test to check that interdependencies in plugins work correctly rather than checking the project->plugin connection. Should this just be in plugin_tests.dart?  Also how do we know plugins A/B/C/D says iOS 8? Tangentially, do we need to update https://github.com/flutter/flutter/blob/6b049372927f21f3d0de6d08d67545ae130c4a35/packages/flutter_tools/templates/plugin/ios-swift.tmpl/projectName.podspec.tmpl#L18 as well?
You're right.  Good eye (again).
Good idea.
> Should this just be in plugin_tests.dart?  I moved it there, see if you like it better.  > Also how do we know plugins A/B/C/D says iOS 8?  I changed the test to make the plugin version low (7.0) so it would trigger the warning on the devicelab machines running Xcode 11.  > Tangentially, do we need to update https://github.com/flutter/flutter/blob/6b049372927f21f3d0de6d08d67545ae130c4a35/packages/flutter_tools/templates/plugin/ios-swift.tmpl/projectName.podspec.tmpl#L18 as well?  If we updated to `s.platform = :ios, '9.0'` then newly created plugins would not be usable (complication error) in any projects created before https://github.com/flutter/flutter/issues/60035, and we have no migration (yet) to increase this value in already existing apps.
I debated whether to drop these two paragraphs altogether, thinking that they might be more confusing than just removing them, but I decided to keep them.  Let me know if you think they should go.
Personally I think it helps clarify what the problem is without involving the terrifying terms. 
This caused one of the tests to fail (line 5725 in `editable_text_test.dart`), when I updated the logic in `EditableText`: https://github.com/flutter/flutter/blob/5b7869c1464c22673d98342d6c09213db3e53d0a/packages/flutter/test/widgets/editable_text_test.dart#L5725 
Also @justinmc it appears the docs here talk in length about how we are counting characters in Unicode scalar values. I believe that's no longer true?
Nit: It could be confusing whether the resulting '12345' is a truncation of '123456' or whether it is the previous value.  Maybe use something like 'abcdef' instead of '123456' to make that clear?
Ah good catch.  Yeah below it incorrectly says it *doesn't* count grapheme clusters correctly.
I'll update that in a separate PR right now.
That separate PR is here for the record: https://github.com/flutter/flutter/pull/66582
too many options here...
Nice catch. However, while we don't see the same problem with `firstDate` here, that is only because it `_initialMonthIndex` defaults to 0. I would still like to see both cases handled here so that it is obvious both are handled. Perhaps something like:  ```dart     if (!initialDate.isBefore(widget.firstDate) &&          !initialDate.isAfter(widget.lastDate)) {       _initialMonthIndex = utils.monthDelta(widget.firstDate, initialDate);     } ``` 
It is not a good practice to have tests dependent on things like the current date, as the results could vary between runs. A better practice here would be to just set the `currentDate` to a known constant and check against that. That way you wouldn't need to compute the month names as you would be testing against the one that you set.
Nice catch. Thanks. 
Oh this is much better! Thank you.
I was not aware that `DateRangePicker` allows `currentDate` to be set, haha. Thank you for the best practice advice!
Could you add a comment to each of these so we remember why they are disabled? something like  package_names: non conforming packages in sdk sort_pub_dependencies: prevents separating pinned transitive dependencies
Good idea.  Done!
If context.widget is a ScaffoldMessenger, ScaffoldMessenger.of(context) will fail, right? In other words, it seems like only the findAncestorWidget... part of the expression is needed.
This is all true however it might add a little clarity to include an complete ScaffoldMessenger.of(context).showSnackBar() expression.
is assign => is to assign  We should provide a better rationale for this approach than expediency. The cost of ScaffoldMessenger.of(context) is constant (not proportional to context's depth). The example that follows does cover the case where the key is useful. 
when you may want to show => when you show
In this case you do have access to the context, because State.context. If the incrementCounter method and its state were in a separate class, this "no context" scenario would be clearer.
This would be a good place to mention debugCheckHasScaffoldMessenger(context))
This would be a good place to see-also debugCheckHasScaffoldMessenger(context))
It looks like it returns null
What about asserting that the scaffold was actually removed?  https://github.com/flutter/flutter/pull/65416/files#diff-ad7e5ee7be5375e4242652ddc6448da7R238
indent
When would the _snackBarTimer be null here (or in hideCurrentSnackBar)?
This seems to sell ScaffoldState short. What about drawers?
It would be OK to add that the method will be deprecated in the near future.
What happens if we're rebuilt under a different ScaffoldMessenger? Don't we need to unregister with the old one?
Do all of the examples need to demo this property? Since it's only temporary, we should say as much here.
This is just temporary? Should it be deprecated?
const here and elsewhere in this example.   
extra space
This is the same explanation we give currently for using a key for the Scaffold: https://github.com/flutter/flutter/blob/2adb91895c5ef6aad5c27c72734962a2f1513a8d/packages/flutter/lib/src/material/scaffold.dart#L1460  What other rationale should I include?
Wouldn't that happen if the timer has already run out?
It did not mention drawers before? I can certainly add it.
Added handling.
Oh no, we definitely don't want anyone using this, that is why it is deprecated. Does the deprecation communicate that, or should we add more?
Added.
The example that follows provides a rationale that makes sense. Please file an issue/TODO about the other expedient comment.
Filed: https://github.com/flutter/flutter/issues/66690
Can't the `of` call return null if there's no messenger in the tree?
Should this include a call to `debugCheckHasScaffoldMessenger` to assert with a nice message when it fails to find one it expected to find?  Also, a common pattern with these `of` calls is to include a `nullOk` optional `bool` that allows it to not assert and just return null.  I realize we do also have this pattern in some places of just returning null, but I guess I'm asking which is more appropriate for the use case: defaulting to throwing if it isn't found, or defaulting to not throwing and making the developer check for it? I think I'd lean toward the former, because it'll make them think about their choice.
It can, but in this case it there is a MaterialApp above in the sample code, so it has a ScaffoldMessenger by default.
At one point I had it the way you describe, but it was massively breaking at the time. It's been re-worked a fair bit since then, so I think I should be able to add this back now. Thank you! 
I've applied your suggestions, PTAL. :) 
```suggestion     assert(nullOk || debugCheckHasScaffoldMessenger(context)); ```
Shouldn't the compiler assume that `route` is non-nullable after the `is` comparing it to a non-nullable type?
Can't this be non-nullable and default to false?
Could this be on one line? ```dart widget.tabBar.onTap?.call(newIndex); ```
```suggestion     const <Color>[Color(0x00000000), Color(0xFFFF00FF), Color(0xFFFF00FF), Color(0x00000000)],     const <double>[0.25, 0.25, 0.75, 0.75], ```
promotion to non-null does not work for fields/getters. See dart-lang/language#1187 for possible improvement.
Darn.  OK.
Done
Definitively. It's a matter of style. Done.
Done
This is the only change other than the import.  The rest is whitespace.
this is to try and surface issues if we download the file incorrectly
Should this ignore exceptions?
The exception message will get printed below by the `printTrace()`. You remember what this is for now, but what about in a few  weeks... =)
Good point :) 
I think if we fail to delete this, we'd also likely fail to copy files over it
This pattern strikes me as odd. Why is renderObject nullable in the super-class, but not in (many of its) subclasses?
Why remove this? Don't we have to keep these asserts for apps that run in mixed mode for now?
`RenderObjectElement.renderObject` is never null once mounted.
This is the only place where `renderView` thrown with the change : ```diff --- a/packages/flutter/lib/src/rendering/binding.dart +++ b/packages/flutter/lib/src/rendering/binding.dart @@ -163,7 +163,7 @@ mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, Gesture    late PipelineOwner _pipelineOwner;      /// The render tree that's attached to the output surface. -  RenderView get renderView => _pipelineOwner.rootNode as RenderView; +  RenderView get renderView => _pipelineOwner.rootNode! as RenderView;    /// Sets the given [RenderView] object (which must not be null), and its tree, to    /// be the new render tree to display. The previous tree, if any, is detached.    set renderView(RenderView value) { ```
Looks like this widget is missing a `debugCheckHasMediaQuery` for a better error message.
Same here.
debug check for mediaquery?
The comment above needs updating.
Done
Done
Done
Done
this is for benchmark mode only for, those tests will validate where it stabilizes things
Updated to add test case for org-dartlang-app URI and to expect file URIs
Can we push the `supportsServiceProtocol` check into `debugToggleBrightness` and return a bool if it's handled, it it's a requirement?  Otherwise every caller has to know to check it.
Some of the methods have meaningful return values, so that would help but it would not necessarily be 100% consistent.
More defensive programming would be good in the tool code, we have so many spots where the caller needs to understand the guts and requirements of a method to call it, or things need to be called in a certain order to work...
I disagree in general, defensive programming is bad because it makes it harder to track down the cause of crashes. And using crash reporting is just the natural life cycle of a large project that is impossible to completely test.  Though I do agree we should adopt a safer pattern here, and making the invoked function responsible seems like a good adjustment
Oh, and as I say that - of course the FlutterDevice class that defines these methods cannot check that 🤦 
ahh nvm I was being silly
Does web need the debug check?
Same.
Same.
Woo!
Shame we lost the negative case logic.  Can you add it back to https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/general.shard/resident_runner_test.dart#L1653?
yeah - I need to take another pass on this and see where we lost test coverage (I think some of these are covered, but definitely not all of them).
The web does not need the debug check, because there is no real "profile" mode with a debug connection but release perf.
does process_runner dependency have to be updated as well?
hmm that seems likely, this isn't listed in the `update_packages.dart` script
cc @gspencergoog 
I haven't made any more updates to `process_runner` since porting it to nullsafety, so there's nothing to bump it to.
If it needs to be bumped to match the process package, then I can push a new version, but I think it's compatible. Its pubspec has `process: ^4.0.0-nullsafety.1` as a constraint, so it shouldn't block.
I sent a pr here https://github.com/google/process_runner/pull/12
Actually, Jake needed to update the SDK constraint, so he made a PR and I published a new version.
Updated
this package itself seems to have sdk constraint that needs to be adjusted: https://github.com/flutter/flutter/blob/master/packages/flutter_goldens/pubspec.yaml#L5
I could do that as a part of this PR as well, should I?
I see also this one which is totally invalid... https://github.com/flutter/flutter/blob/master/packages/flutter_goldens_client/pubspec.yaml#L5. I think these might just be ignored since they aren't pub packages.
as well as flutter_goldens_client https://github.com/flutter/flutter/blob/master/packages/flutter_goldens_client/pubspec.yaml#L5
> I could do that as a part of this PR as well, should I?  Yeah, I think so
I will go ahead and just update them.
This will ignore every single folder that matches this pattern. Instead, you should only ignore the exact folders, like `/android/app/debug`.   Also please leave a comment describing what this is for
How about "Android Studio will place build artifacts here" or something similar?
Good idea. i changed.
These are not formal API docs, so I included a reference to LibTxt, I can remove if people feel it is best not to link to specific engine implementation that is slated to be swapped out.
I trust you to update this comment once libtxt is swapped out :)
If you feel like an overachiever though, you could consider moving _kDefaultFontSize to a shared constants file in painting/constants.dart.  We have a few files like that elsewhere but none in painting yet.
You could use `getBuildInfo().dartExperiments` (or better, yet use an existing build info), which should already have this parsing logic baked in
Ah - cool! I added `--sound-null-safety` too
I believe you also want to add the deprecation notice to this param here.
Let's not mention google here.
Why this?
This should go after the doc comment.
```suggestion /// Deprecated. Use [Stack.clipBehavior] instead. ```
Done.
Done.
Done.
Done.
I was trying to revert the change in https://github.com/flutter/flutter/pull/61366. I can certainly remove this line but this line could test that overflow won't cause any compile error yet. Would you like me to remove this line?
this deprecation should also go below the doc comment.
nit: formatting.
Done.
Done.
Shouldn't this `protected` be on `NoDefaultCupertinoThemeData`?
Totally. Fixed.
Is there a reason to put this as a actual value instead of a getter?  Consider the behavior: - Form created using `autovalidateMode` to `AutovalidateMode.always` in constructor     - Access `autovalidate` will be `false`, while `autovalidateMode` will be `AutovalidateMode.always` - Form created setting `autovalidate` to `true` in constructor     - Access `autovalidate` will be `true`, while `autovalidateMode` will be `AutovalidateMode.always`  Putting this as a getter referencing `autovalidateMode` means there's only a single property storing state, so it can't be inconsistent. ```suggestion   bool get autovalidate => autovalidateMode != AutovalidateMode.never; ```
Hi @skyeskie Sorry, this PR is not ready for review yet (I probably should set it as draft).  Creating form with `autovalidateMode` to `always` `autovalidate` should not be used so it should be false. We are deprecating `autovalidate` so we are not going to use it anywhere internally. We are adding it back just because of the breaking changes!  We have an assertion that prevent devs to use both at the same time.  https://github.com/flutter/flutter/blob/f19597728f28686bfcec4a33751956aa25622fb1/packages/flutter/lib/src/widgets/form.dart#L90-L94  if you still using `autovalidate`, I suggest you to switch to `autovalidateMode` because deprecated properties will be removed anytime in the future!
Marked as WIP per comment. ;) 
The assertion works on the constructor. It doesn't prevent using `autovalidateMode` in the constructor and the `autovalidate` getter.  There are scenarios where the getter could be located in another package ([`FormBuilderCustomField`](https://github.com/danvick/flutter_form_builder/blob/v3.14.0-alpha.2/lib/src/form_builder_custom_field.dart))  Granted, I don't use that, and the `flutter_form_builder` package might even update before this change lands. It just avoids some potential issues by having a single source of truth/state.  -----  Do I need to do anything to discard the review?
You don't need to do anything.
"provide" => "provides"
"behaviour" => "behavior"  We try to consistently use American spellings.
Does this need to be saved on the class instance, or could it just be a parameter since it's only used in the constructor?
I think to be comprehensive you should test when autovalidate is false, and also do the same two tests for Form.  You could make `builder` take a parameter for `autovalidate` and build it a second time set to false.
I'm adding it back into the class instance because looks like it is being used as by developers, please see https://github.com/flutter/flutter/pull/61648/files#r490653719.
Yes, this test title also needs a improvement!
Oh got it!
This is just a reorganization of the params to match the parent devFS class, which revealed that 'pathToReload' was missing a `required`
Note to self: fall through is for `DevFSStringContent`/`DevFSByteContent`
We also discussed using this same code for the iOS simulator (can be in a future PR).
g3 doesn't like this new `@required`, it's passing one into the context.
Same, g3 doesn't like this new `@required`.
Now that I look at it, shouldnt this also be `childAfter(earliestUsefulChild)`?
@Kavantix Yes, I think so 
oops nice catch
nit: maybe `behind` instead of `below` ```suggestion /// barrier that darkens everything behind the dialog. If `null` the default color ```
nit, it's not your mistake, but would be good to fix this anyway :)  ```suggestion /// the dialog will only be constrained by the screen size. `useSafeArea` cannot be `null`. ```
Yes I wanted to do behind, but above/below is used everywhere when describing such behavior, even on the ModalBarrier page. Maybe they were describing where the page is on the widget tree?
Let's just keep "below" then. I did a quick search around the codebase and below and behind are both used in different contexts, so it should be pretty clear what either means to our users
remove the extra `/// `
This doc comment needs more details describing what this alignment is and also that it is only used when [transform] is not null.
You could use tester.getSize and `tester.getTopLeft` here to make the test slightly more readable.
How about:  ```suggestion  /// The alignment of the origin, relative to the size of the container, if [transform] is specified.  ///  /// When [transform] is null, the value of this property is ignored.  ///  /// See also:  ///  ///  * [Transform.align], which is set by this property. ```
Is this intended to remove?
Yes, that one is still failing consistently.
Sometimes a failure to delete is benign, so I'm not sure this should go here.
The docs for `abort()` say that this will cause `HttpClientRequest.done` to be completed with an error, which I would have expected to be propagated to the containing zone, skipping over the catch block below since it is an asynchronous error.  Even if that isn't what should happen, we can be on the safe side and put an `await request.done` after this line, which should definitely force the error into the catch block below.
I made the change.  I tried to understand what the concern is and had a hard time figuring it out.  Is your concern that there was some asynchronous operations in abort that could be short circuited the TimeoutException?
Without awaiting the request's `done` `Future`, the `TimeoutException` would be rethrown and caught below as expected, but in addition, `abort()` will complete the `done` `Future` with an error (probably in a later microtask). When a `Future` is completed with an error, and it doesn't have an error handling callback attached with e.g. `Future.catchError` or isn't `await`ed, then the error skips over synchronous `try {} catch {}` blocks, and is passed to the unhandled exception callback of the containing `Zone`. We don't want that to happen here because that callback will report the exception to crash logging.  If you aren't seeing the `abort()` result in an error like that, then that behavior doesn't match the API docs...
nit: no newline after '=', two space indent on continued line. ```suggestion           final HttpClientResponse response = await request.close().timeout(             const Duration(milliseconds: 500),           ); ```
> is passed to the unhandled exception callback of the containing Zone  Ah, ok.  That's the piece I was missing, thanks.  I was thinking the the abort exception would silently be ignored since there was no one to catch it.
done
We probably want to take a look at the stdout and stderr from the BufferLogger to make sure their contents is as expected.
We can use completers to avoid the polling loop. This also uses a completer for the result of close(), so that the same Future can be returned for `httpRequest.done`.  ```dart     final Completer<void> abortCompleter = Completer<void>();     final Completer<HttpClientResponse> responseCompleter = Completer<HttpClientResponse>();     when(httpRequest.close()).thenAnswer((Invocation invocation) async {       if (!didAbort) {         await abortCompleter.future;         unawaited(Future<void>(() async {           responseCompleter.completeError(HttpException('aborted'));         });         return responseCompleter.future;       }       didRetry = true;       return httpClientResponse;     });     when(httpRequest.abort()).thenAnswer((_) {       didAbort = true;       abortCompleter.complete();     });     when(httpRequest.done).thenReturn(responseCompleter.future); ```
Done
Done.
This doesn't need to by `async`, and I don't think you want to `await` the `Future` before returning it---the code under test should be doing that.
`assert(false)` -> `fail('This branch should not happen')`
Done.
Done.
This should be:  ``` return scheme + '://' + filePath.substring(fileSystemRoot.length); ```
do you have some examples of file schemes + paths used? this code is sort of fragile because it is assuming a particular string structure, I should really figure out how the Uri class should be used
discussed offline
You can use TestAsyncUtild.giard for the method being called here and it will throw if you fail to await
Thanks @dnfield!
uber nit: this can be combined with the above line as  ```dart   }) => TestAsyncUtils.guard<String>(() async { ``` 
The change in this file switches the order of fallbacks, which confused `git`.  Now it first tries log scanning, and only if that fails, falls back to mDNS discovery.
I renamed `fallback-success` and `fallback-failure` to `log-success` and `log-failure`.  Do we care about usage data continuity?  If so, I can change the names back.
This was previously waiting and buffering for `duration` before sending the first message.  The observatory URL was discovered faster than 200 ms in my tests, so let's not wait to process it.
Not really, change away
this might deserve a const, with a doc describing where you found it.
nit: maybe describe what parts are hard-coded for testing
The events were only added to understand the severity of the issues around this that we were seeing. Please feel free to modify the events into whatever is useful for this new way of doing things, including adding new ones if needed.
This will fail if ios-deploy is missing right? should we catch the error or let it crash here and solve the problem elsewhere? i.e. startup checks
Can this not happen anymore?
Can a test only visibility annotation go here?
Is there any way to make this test and the test for 'success' more resilient to changes in output from lldb? Maybe ignore whitespace or unexpected lines between here and 'success'?
Oh, okay. The very next line after the lldb run line doesn't have to be 'success'. We'll wait until it is. Consider updating the comment above.
Does ios-deploy have anything interesting on its stderr when it exits with an error?
This change is swapping the order fallbacks.  Before it was trying mDNS and then log scanning, but now it's trying log scanning first.  The reordering confused the diff, this `ArgumentError` was just moved.
It's https://github.com/flutter/flutter/pull/66092/commits/e91e25e01ffa596f7e60c861b435a9c672a9a29e#diff-e0fb4f81676c3d33cb1796b5f126a4fdR94 now.
👍 
Good call.
Some stuff: https://github.com/ios-control/ios-deploy/blob/master/src/ios-deploy/ios-deploy.m#L1741 Though nothing that's probably actionable to the developer.  It's being `printTrace`d a few lines above this. https://github.com/flutter/flutter/pull/66092/files/e91e25e01ffa596f7e60c861b435a9c672a9a29e#diff-8d108d6a887a4f5b74f7c7d77003e795R326  They seem to put actionable errors to `stdout` (see `_monitorIOSDeployFailure` parsing below, which existed before this PR).
`run` is coming from [ios-deploy](https://github.com/ios-control/ios-deploy/blob/master/src/ios-deploy/ios-deploy.m#L51), and `success` is coming from lldb.  I will make this a regex to handle whitespace differences. 
It does have to be "success" (`lldbRunCalled ` logic where it's being set to false if the next line isn't "success"), unless I have a bug in here.  Maybe I should change this to fail if the next line isn't "success" so it doesn't hang forever on something unexpected instead of special-casing "error: process launch failed" (and example of a non-success next line).
I think we already have those checks in place with the stamp/artifact download logic, since `ios-deploy` is an artifact we ship ourselves `idevicesyslog`.  Unlike the Xcode tooling where we do lots of install checks.
Ah, okay. I misread the code. My suggestion for a cleanup would be to structure this explicitly as a state machine, with an enum setting out explicitly what the states are, and a big comment explaining what/when the transitions are.  That might also make testing this code easier. I think I see below that the error paths in here could use some coverage.
Test failure modes on unexpected stdout.
Added `_monitorIOSDeployFailure` to the stderr processing in case they move how that's output.  Will add a test.
Done.
Done.
Done.
Added more comments and tests.
Added an enum, hopefully it's clearer now.
Done.
these diffs are always so hard for me to read...  So this is saying we always want to run the test for any PR, and on post-submit only on affected diffs...right?  This doesn't seem like the right logic. Should it be `&& $CIRRUS_PR == ''`, which would be only run pre-submit with a diff on the affected files?
I see, yeah I think it has to be && but I thought $CIRRUS_PR == '' meant postsubmit.
lol, yeah you're right. so `&& $CIRRUS_PR != ''`
This is why I put question marks at the end of all my statements, I never get this right the first try.
yeah, errors in those conditionals are usually difficult to spot. Updated.
this event is dispatched by the flutter binding
this needs to be initialized to a non-null value.
It's a little bit odd to see a call to `html` outside of web_ui (but I like how direct this is).   How about making the first frame rendered some sort of PlatformMessage that gets intercepted by the `web_ui` engine window [here](https://github.com/flutter/engine/blob/master/lib/web_ui/lib/src/engine/window.dart#L562), and broadcast as an html.window event from there?  _(I'm not 100% sure of what needs to be done (or not done) in the native side to noop to an unknown platform message, though)_
Disclaimer: I don't know enough about the binding, if @goderbauer is cool with the PR, he's the boss
We could conditionally call the platform channel on the web, otherwise we would need to add a nop impl on every platform I think. 
I've found the [Result.notImplemented](https://github.com/flutter/engine/blob/33015c6c7a7d215fba4f3caa9d2888de9658034a/shell/platform/android/io/flutter/plugin/common/MethodChannel.java#L189) thing as a default, but I'm not sure how that's handled by the framework later (if it errors out, or just silently noops)
Opened https://github.com/flutter/engine/pull/21284
I pinged the chat for them to take a look!, going to mention this PR as well, thanks!!
There's probably some people with the old `addEventListener('load'...)`, how do we normally communicate this type of changes to users? A tweet/blog post/something else?
This looks like a [system_channel](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/services/system_channels.dart), but I guess it's fine here since it's used only once at this time.
Use `@TestOn('browser')` or `skip` instead of bailing out of the test at runtime?
hmmm, its not really a breaking change. Probably the changelog?
_(Resolving this, thanks for considering this comment, Jonah!)_
added with a skip
yeah, I think since this is sort of private it would be good to keep the scope limited
How does this behave with hot restart? Does it get called again?
btw, you are not checking for the method name in the engine.
I don't think it is important unless we expand the number of actions here. i.e. building in service worker auto-update dialog or something.
it does get called again, but now (thanks to @yjbanov ) in run mode we definitely do not create a real service worker so it would only reload an empty script.
FWIW the title for this test is confusing to me.  "registered plugin"?  "registered handler?"
heh, this is one reason why in my ideal test framework there's no test names. :-)  I think it refers to what happens when a method call comes in but no plugin has registered a handler for that channel.
(the name is identical to the previous test, all I did was make a copy of the test with a minor tweak)
Feel free to change that one too, it's equally confusing.
Was this here just for sanity before? Or why did we need to check for `self.skipWaiting` being a thing?
yeah, not needed - also infinite loop 
(The comment above still mentions that we're adding a hash for main.dart.js, but it seems we don't do that anymore, I think it should be updated just to not confuse future us :P)
Ah, I was understanding "remove main.dart.js bypass" wrong. This lets the service worker cache the main.dart.js again, by not overriding its name with a hash.  (I was about to ask: if we want the serviceworker to bypass main.dart.js, shouldn't we also remove it from the RESOURCES map? :P)
Fixed!
Yes, exactly - now that I realize I was COMPLETE WRONG about the default behavior of sw, everything makes more sense!  But we also bypass the worker for http requests that won't go to the cache, since I guess there is overhead for forwarding the requests
According to the documentation  > The coordinates returned in the details are viewport coordinates relative to the parent.  Is that correct?
No it's not, thanks for catching that!  I was just copying what I did for the other onInteractionUpdate, which is also wrong apparently.  I will change the code in both places so that the documentation is correct. I think that's best because the user can still convert to scene coordinates themselves using the same toScene method.
Done.  I also updated a test to make sure this is covered.
`onInteractionStart` should also use the viewport coordinate system according to the documentation? (`onInteractionStart` is called after updating the transform. Is that expected?)   also nit: I think we can do `widget.onInteractionUpdate?.call(ScaleUpdateDetails(...))` instead? 
Oh yeah that too.  I've now made sure that all of the onInteraction* calls are using the coordinates of the event (not transformed to the scene) and that they are called after the controller has been updated.  That way the user can transform them to scene coordinates if they want by using the controller, but otherwise have the viewport coordinates.  That seems like the best approach to me.   I also wrote another test confirming that you can do this.
If the developer tries to access the transform in the `onInteractionStart`, are they supposed to see the updated transform, or the pre-scroll transform? Couldn't find that in the doc.
Someone actually opened an issue for this (https://github.com/flutter/flutter/issues/63606). This PR should close that issue too now.
Good point, I updated the docs.  For start, the transformation shouldn't have changed, but for update/end, it should have changed.
This is the fix to the presubmit, It is not cleared to me which component it will focus by default when you have a TYPE_WINDOW_STATE_CHANGED. From my observation:  - If this is the first time this screen is present, it will find the element that has the same label as the message that is sent with TYPE_WINDOW_STATE_CHANGED, and focus the NEXT element of that element. This is why it change from body to title  -  If screen has be shown before, it will remember which element was focused the last time the screen was shown, and will refocus the element after the message is announced.
nit: indentation
This seems a little strange. What guarantees that `textTheme` is not null?  /cc @HansMuller What's the pattern for dealing with null theme values? Do the widgets usually have a default value in case the theme is also null?
Same question about the theme here.
We should assert here that Directionality is not null with `debugCheckHasDirectionality` in an assert. That will give people a nicer error message then a failed `!` check.
Same here.
I don't understand how value is guaranteed to be non-null here.
Same here and below where controller is used.
Same directionality assert.
Same directionality assert.
TextTheme, which is not a "theme" by our current standards but is too old to change, only has non-null text styles by default. Most (all?) widgets assume that TextTheme properties are non-null
the `!` is on the themeData property though. Is `themeData.textTheme` guaranteed to be non-null?
here the code assumes `resolve` may return null, but on line 256 it assumes it will return non-null
Yes, ThemeData.raw(), which is used by the ThemeData factory, requires textTheme to be non-null. 
Looks like Material's ThemeData is specified that way, but the CupertinoThemeData used here doesn't do that, though.
Looks like maybe this getter here should be non-nullable since createDefaults never returns null? https://github.com/flutter/flutter/blob/fb08acf10c63c6eaeb6f32931a965f18cbf28eb9/packages/flutter/lib/src/cupertino/theme.dart#L254-L256
FTR: of the 73 ThemeData.raw() parameters, buttonColor, applyElevationOverlayColor, and cupertinoOverrideTheme are _not_ required to be non-null.  https://github.com/flutter/flutter/issues/66060
Sorry, it's easy to be misled by a small window into a large file. The `themeData` we're referring to here is a CupertinoThemeData, not ThemeData, and all of its properties can be null because [cupertinoOverrideTheme](https://api.flutter.dev/flutter/material/ThemeData/cupertinoOverrideTheme.html). 
``` const Color _kHighlighterBorder = CupertinoDynamicColor.withBrightness(   color: Color(0x33000000),   darkColor: Color(0x33FFFFFF), ); ```  Completely specifies _kHighlighterBorder's color properties so I think line 256 can correctly assume that resolve's return value is non-null.
Done
Done
I change the code to make controller non-nullable.
Changed.
Here it is non-null because it is used in a non-null context (`BoxDecoration(color: resolvedBackgroundColor)` L308). L256 required a null check because it is used in a non-null context (`BorderSide(width: 0.0, color: resolvedBorderColor)`)
Done
Done
That's what I was referring in https://discord.com/channels/608014603317936148/684483384839503894/755100965811519627: > it looks like all properties (primaryColor, primaryContrastingColor, textTheme...) could be non-nullable BUT CupertinoThemeData.noDefault() makes that impossible  Basically material currently relays on the nullability of those properties to work (see https://github.com/flutter/flutter/blob/d26268bb9e6d713a73d6148da7fa75936d442741/packages/flutter/lib/src/material/theme_data.dart#L1764-L1774) by using [_NoDefaultCupertinoThemeData](https://github.com/flutter/flutter/blob/d26268bb9e6d713a73d6148da7fa75936d442741/packages/flutter/lib/src/cupertino/theme.dart) that seems to be the only place where the properties can be null.  I thought it could be possible to refactor the code to make those properties non-nullable but I haven't manage to make it work :-(  So is there something I have to do in this PR regarding this comment thread?
nit: space after `=>`
From a user's perspective it's odd that the theme properties are nullable, but we just assume in a lot of places in the cupertino code that they are not. I understand why this is (the overriding stuff in the MaterialTheme). I tried to untangle this a little bit in this commit: https://github.com/flutter/flutter/pull/66155/commits/8984c527a6ca0cc13d0e5be2989635c108101ddc  I believe it is a non-breaking change. Curious to hear what other think about an approach like that.
Cleaned-up that suggestion and posted it as a PR here: https://github.com/flutter/flutter/pull/66274
Thanks for help!
done
This should be [Router.routeInformationProvider]
fixed :)
super nit: double space
Since the regression tests link to this issue, this comment and the one in `range_slider.dart`arent' strictly necessary
Fixed. Move the RangeSlider test case to another file.
Removed.
Is the minWidth already accounted for in the TextButton.styleFrom()?
Yes, the default minimum size for TextButton is Size(64, 36)
@blasten does this change look okay to you?  On iOS we don't want the logs to scan forever when no observatory URL is found since it needs to detect the URL wasn't found and fail.
I assume this could be for all sorts of reasons right? For instance someone tries `flutter attach` but never launched the flutter app/module etc. Make the language softer? e.g. If you previously dismissed a local network permission dialog, you can revise it here. 
This method is called for `flutter run` and `flutter drive` only, not `attach`.  But you're right, this may not be the reason the observatory isn't found.  The "Try" was to make it softer since we do that in a few places.  Like right above this we have "Try launching Xcode and selecting "Product > Run" to fix the problem:" for example.  Open to wordsmithing suggestions.
@xster You were right, this confused everyone... https://github.com/flutter/flutter/issues/66408 and others.  Going to revert this...
Typo duplicate "set"
minor formatting: we generally try to keep our line widths to 80 characters. See examples above (the lines without the \n at the end) for breaking up a string into concatenated multi-line string
Understood.
Technically, it doesn't set an environment variable. It just reads from this config directly in https://github.com/flutter/flutter/blob/6978832293eefa7cd3c2cc064d4698f8320f80f5/packages/flutter_tools/lib/src/android/android_studio.dart#L159. I think you can just remove the `String envKey` argument too since we don't need it anymore. 
I did try removing that, but it caused some tests to fail. Specifically this test: https://github.com/flutter/flutter/blob/7f3c9b6bdab5a38cfa9eb4ba5aa5d7c5378282f3/packages/flutter_tools/test/general.shard/android/android_workflow_test.dart#L334
I read your comment below. I'll change that test so it reflects the new error messages.
I don't think `flutter config --android-sdk` helps finding the Android SDK, at least based on how the tool is written now.  Just suggesting `flutter config --android-sdk` is probably enough.   https://github.com/flutter/flutter/blob/d3515f5fb6342e76cb8b99b9874605179a0d0592/packages/flutter_tools/lib/src/android/android_sdk.dart#L71
you can add a negative test here to say it doesn't find any mentions of 'Unable to locate Android SDK' here since we did provide a valid MockAndroidSdk to the AndroidValidator. 
Added below. Can you let me know if it looks good?
Thanks for pointing that out. I've updated it by removing line 78. Please let me know if it looks good!
nit: trailing comma after caption.color
AlignmentDirectional.centerStart 
can remove this line since it defaults to 0
Done
Done
Done
We should be able to look up the color from `Theme.of(context).colorScheme`. Presumably it's the `onSurface` color with some opacity per the spec?
Will this work in dark mode? Maybe use `...colorScheme.onSurface`
Similar comments here: lets show developers how to configure this in a way that works with dark mode, by using the color scheme.
Theme.of(context).textTheme.capption,  I checked and using the caption will work for dark mode as well 
I removed the color parameter. 
Done
The indentation is off here, need an extra space
I'm assuming that this looks OK in dark/light mode, using the default theme (or ColorScheme.light(), and ColorScheme.dark()).
If we're going to use const consistently in an example, then you'll need it here too. Best to check this code with analyze.
done
It does look good 
done
Let's default this to `Clip.hardEdge` now to avoid breaking changes. We can change the default and go through the lengthy breaking change process later.
ditto.
ditto.
ditto
ditto
ditto
ditto
ditto
ditto
remember to change documentation too when the default is changed to `Clip.hardEdge`.
ditto
ditto
ditto
nit: space after `if` and before `(`.
Done :D
`&&` has higher precedence than `||`  I have no idea what the logical flow was intended to be here, but it looks wrong.
That does look wrong. Wanna send a PR to fix it?
See https://github.com/flutter/flutter/issues/67343
Agree it's wrong. Thanks for finding it!
So sorry for this guys 😞 I somehow missed it
I think the context should just be required here to be non-null.
according to the assert location `context` could be null with null `resolvable`. I will run the tests to check if context can be non-null.
Updated a test to make context non nullable.
Why is this better?
To prevent null to be used. The `CupertinoDynamicColor.resolve` user now know that the context is mandatory to call this function. Calling it with null resolvable looks quite uncommon and using a non-null value required the context to be non-null.
I see, the second `CupertinoDynamicColor.resolve()` argument can no longer be null. But the first (Color) parameter can, so this test survives. 
Exactly :)
Looking at this again, isn't it guaranteed that this will always return a non-null value? primaryColor should always be non-null in the default theme?  Same for many of the getters below that reference the default.
Same explanation as https://github.com/flutter/flutter/pull/66024#discussion_r490767475
Maybe instead of "arbitrarily sized test image" -> "arbitrarily sized image for testing", since it is just a regular image.  I dunno if async is necessarily important here, since that is implied by the return type.  
Done.
(Cleaned up a little of the rest of the doc too, and saved a file I had fixed but forogtten to save :\)
... for the rest of the test suite (maybe?)
Done.
Why can the use of this FakeImage not be replaced with the new test image stuff?
Same here and below.
... and here.
should this link to [setUpAll] / [setUp] as an appropriate place to call this?
These are not added to the cache?
Ah, I see, it happens within the method. Maybe for symmetry, pull the caching code out and place it here?
I was slightly confused by this telling me to avoid it and the fact that it defaults to true. Maybe add a sentence describing why you usually want caching?
Why do we need the caching at all? Does re-creating the image really cost that much in terms of testing performance?
Refactored all of these, thanks for catching.
Added links.
My thought is that we're going from what is a very fast operation (constructing a fake implementation) to what is now a measurably slower and more memory intensive operation, particularly if the image tested is large.  Most of our test cases use a 10x10 image, completely arbitrarily. Some of them use as big as 200x300. If our CI machines are running slowly, caching that 200x300 could save us something on the order of seconds.  Updated the docs here to explain that.
Refactored this a bit to clean it up.
nit: probably also `assert(cache != null);`
nit: space after `,`
Actually, just use `cacheKey` here instead of recomputing it?
Whups, done.
Done
uber nit ```suggestion class MockDartDevelopmentService extends Mock implements DartDevelopmentService {}  ```
If children is empty (seen in the example app posted in the bug and in the test case, this throws an exception)
The second sentence sounds like an implementation detail that doesn't really belong in a doc? If this is a problem we could wire up a parameters passed in here to Scrollable.ensureVisible, though.
I thought of wiring up the parameter but, as you say, there's currently no problem that necessitates the use of that parameter. Just that the behavior is not clear from documentation. I also did not want to just say: "until the start of `finder` is visible` and leave it at that because this method does not own that functionality. Therefore, I wanted to provide a link to how the behavior is determined so someone else, if needed, can make a request to plumb that parameter.
```suggestion         // flutter root and pub must be lazily-loaded to avoid initialization ```
This new version is pretty dense. Why do you need to destructure `...` the output of `.map()` here, I would assume that the `.map()` is returning a `List<Future<bool>>` already?
I had to do this because `FutureOr<bool>` is not a `Future<bool>`, so I can't pass it to Future.wait. I should just change to type signature to skip the FutureOr, then I can simplify this
Done
Ahh, that makes sense. Is `Future<bool>` a sub-type of `FutureOr<bool>`?
Xcode change this whitespace, let it.
Match https://github.com/flutter/flutter/blob/2e67bf2e32391af4fe38cb292c99e77d14b53584/dev/benchmarks/platform_views_layout/ios/Runner.xcodeproj/project.pbxproj#L319
Match https://github.com/flutter/flutter/blob/2e67bf2e32391af4fe38cb292c99e77d14b53584/dev/benchmarks/platform_views_layout_hybrid_composition/ios/Runner.xcodeproj/project.pbxproj#L319
`skipWaiting` doesn't seem to be supported in Safari: https://caniuse.com/?search=skipWaiting
there is no mechanism to force update (automatically or via user interaction) without skip waiting.  Should we disable service workers on safari?
This does work on safari desktop it seems, but it is not sufficient on iOS
I'm guessing it's less of a concern on mobile since on mobile you typically don't have multiple tabs of the same app active at the same time?
🤷‍♂️ 
just remove `../project-name ` entirely, here and below
also remove trailing space
ok! , i will do it 
This will be automatically called by the controller's notifier.
This is tricky, good call testing this case.
I think it should stay as "Change", as I understand it.  I think it meant like: "is selection the only change"
I'm not sure why the selection wasn't checked here in the first place.  This seems to make more sense.
Could you create an actual issue for this and link to it here?  I just want to make sure this has the chance to get looked at, in case it is a problem.  It doesn't make sense to me that the engine should notify twice for the numeric keyboard.
This PR really reminds me of this issue, which also deals with the asynchronous communication between the engine and framework: https://github.com/flutter/flutter/issues/61282  My solution there wasn't anything like this PR, but I think using this flag `_updateEditingValueInProgress` could maybe help us handle problems like that.
The track at #65811 
Done.
Do we still need this, with the changes made in line 1650 through 1656 (i.e., the additional case handling when `_value == value` )?
@LongCatIsLooong  Yes, you are correct. But the name of this function is ambiguous, or change the name instead.
It appears the method is only used here. You can get rid of it and use the expression instead (and maybe leave a comment that says if the change is selection only)
Good idea. Done.
Thanks!
Can you flip a boolean value here to mark that the onChanged callback was called, then add an expectation after the `enterText` call to verify that the callback was called?
Good point, thank you, now updated.
Why were these imported in the first place? Is it needed for the references in the doc comments? If so, why aren't the new button classes needed to be imported?
I don't know why the were imported before. The analyzer reported that the were not needed and the docs  tests succeeded, so I'm assuming that similar imports are needed anymore.
Is this a change in defaults, or was the previous comment incorrect?
The previous comment was incorrect.
Nice test
TY!
Please add a comment at the top of this test: ```dart /// Regression test for https://github.com/flutter/flutter/issues/65657 ```
It looked like firstRenderObject shouldn't be needed here because there's only one.
Might be slightly simpler (here and below) without saving a ref to the renderobject. Also the "equals" isn't needed. ```dart final Finder rail = find.byType(NavigationRail); expect(tester.getSize(rail).width, 72) ```
fyi
there's a line above this, like, "The identifier to use when enabling state restoration for the navigator." or whatever, missing. (The first line of docs should be a noun phrase.)
why "nav"? Why not "n" or "navigator" or "\0x01" or "$Navigator" or something?
docs
throughout -> during  throughout implies it happening continually, during refers to a particular case of it happening
"...transitioning off screen, which triggers a notification on this field" or some such. (Right now, you say "as an example" but don't actually then say why what you describe is an example of the previous sentence)
"in their names"
typo in "navigator"
should this mention the default id that WidgetsApp uses?
indentation
put some punctuation between the prefix and the id (or use something other than letters), to avoid the risk of someone being offended if they use the id "rick" or something.
declare this before first use
"endtempalte" is a typo  might be good to have some sample code here
the restorable* methods should be mentioned in their corresponding non-restorable version
we should do that in this PR
Yes. Any of those are valid as long as they are unique within the surrounding  restoration scope. Here, the navigator is the only thing in this scope. Children (the individual routes) have their own scope.
Interestingly, the analyzer didn't warn about the missing docs here. Filed https://github.com/dart-lang/linter/issues/2238.
WidgetsApp doesn't use a default id.  It internally specifies an ID for the Navigator it creates. However, that's an implementation detail that's not exposed to the public.
lol, but good point. Added a "+".
Does user have chance to use the RootRestorationScope? isn't this only used by the navigator widget or router widget?
should this be nullable String?
here and other places
Couldn't the restorablePush just return the restorable future? if we asked user to provide their own restorationid to the route, I think we can probably restore this future with the logic similar to the _hookOntoRouteFuture?
why do we use restorationScopeId here?
At the time the PR was created, this file had not been migrated to NNBD, so this was correct. I am going to rebase this to the latest master, though, and then it will have to be nullable, yes.
Rephrased.
In other unmigrated files it cannot be marked as nullable just yet.
After state restoration, how would the entity that pushed the route get access to the restorableRouteFuture again that was returned when the route was initially pushed? 
Whenever the restorationScopeID changes, we need to rebuild the RestorationScope.
Is this because there is no way to restore the future chain unless all the call back are static functions? Restore the route future is possible I think? but then caller will have to reattach their future chain again.
Ah I was confused by the the name animated, and keep thinking it should be a double.
So why "nav" specifically?
If it's the same API as pushReplacementNamed, does it need to be different?
is this supposed to return String?
for example, don't we need to be doing something with the return value?
this should probably be before the sample
never mind i didn't see the `@macro flutter.widgets.navigator.restorablePushNamed.returnValue`.
this seems to discard the return value
this also ignores the return value
Does the restoration framework sends update if the platform is web?
You only have to do something with the return value if you want to get access to the return value of the route or the route object itself. If you don't care about any of this, the usage is exactly the same. See also the `flutter.widgets.navigator.restorablePushNamed.returnValue` docs.
Instead of a `String` I could make this one return an opaque RouteId object, if that sounds better...
I also added some clearer language around this to the doc.
which is fine, see new and improved doc on return value.
which is fine, see new and improved doc on return value.
The web embedder currently does not turn on restoration.
Could we move this to under the first example? The first example is a generic set of use-cases for `ListTile`, and this particular API doc addresses a unique use-case.
Just some wording recommendations:  ```suggestion /// To use a [ListTile] within a [Row], it needs to be wrapped in an /// [Expanded] widget. [ListTile] requires fixed width constraints,  /// whereas a [Row] does not constrain its children. ```
I would maybe add another widget or two into the `Row` before/after the `ListTile` to make the example more realistic. Having only a single `ListTile` in a `Row` does not really make sense :) 
@a14n, could this be `String this.data` so that you can't pass nulls to the default constructor (i.e. `Text(null)` should be an error) ?
Sure! Thanks for the review :) A lint could make sense to catch similar issue.
Done. I also changed `Text.rich` textSpan parameter.
Filed dart-lang/linter#2237
nit: remove commented code
Done!
let's pin mockito to 4.1.1 since we're planning on removing it entirely anyway (right? cc @jonahwilliams) (I'm assuming it's the cause of all these new dependencies.)
let's not encourage that second path if we don't need it... requiring that this approach only be used by entirely separable code seems like a good place to start.
mockito still exists in one test, the one that uses private APIs. Once it is removed from there it will be gone from `package:flutter`, but still used elsewhere in the SDK
you don't actually use args, it seems
"extends Object" is redundant
should it end with `_test.json`?
Are we not planning on removing it from everywhere?
The one test is the one I'm removing in this PR, I think.
We definitely don't have time to do that for the flutter_tool. I'm not sure about the other packages though.
But is it OK to pin it to 4.1.1 for `flutter_tool`?
Good point.  Removed.
Yeah, I know, but there were some weird analysis problems with non-nullable code that it was fixing.  It appears to not be needed now though, so maybe it was a bug in the analyzer that got fixed.
Good idea.  Done.
We're not going to migrate to NNBD in the tool for quite a while, so it should be safe for now
Right. Removed. (I would if there was a nullsafety version.)
nit: double space
Fixed.
question: what is `oldwidget`?
it is the original widget before the update
do we need to do similar things for obscure and disabled?
Should this be `if (!attacted) return` ? I remember I ran into situation when user update widget when the input connection is attached to another textfield and cause a crash
I don't want to jump the gun and implement something that nobody asked for ("if it aint broke dont fix it") lol. That said, after this PR، it becomes super easy to add obscure, disabled, etc when they are needed.
That's a good point. I just followed what the other methods are doing.  I think this should remain as is, and the code in `EditableText.didUpdateWidget` should check before calling `updateConfig`. I'll fix it.
This is a stateful widget, which means the `state` instance remains alive even if you build `EditableText` multiple times. So when you do: ```dart Widget build(BuildContext context) {   return EditableText(     readOnly: true,     ...   ); } ``` ^ this `EditableText` instance becomes the new value for `widget`, and the `EditableText` instance from the previous build is available in `oldWidget`.
Is `minScale` the max scale allowed?  if `_boundaryRect.size` is `(10, 10)` and the viewport's size is `(100, 200)`, then `minScale` is going to be 20 right? Anything above 20 is going to make the child exceed the size of the viewport in both dimensions?
This minScale is the minimum scale allowed, but maybe my comment in the code above this is confusing.  The boundary is defined as being positioned on the child, and it scales with the child.  In your example of a 10,10 boundary, let's say that the child is also of size 10,10.  So here's your example with an orange child and a yellow viewport:  | scale | 1.0 | 10.0 | 20.0 | | -- | -- | -- | -- | |           | <img width="151" alt="Screen Shot 2020-09-10 at 9 37 20 AM" src="https://user-images.githubusercontent.com/389558/92764802-9d926280-f349-11ea-8ca2-85fde7e1627d.png"> | <img width="173" alt="Screen Shot 2020-09-10 at 9 37 02 AM" src="https://user-images.githubusercontent.com/389558/92766646-41304280-f34b-11ea-879e-682a18e82b9d.png"> | <img width="196" alt="Screen Shot 2020-09-10 at 9 37 40 AM" src="https://user-images.githubusercontent.com/389558/92765015-cfa3c480-f349-11ea-9fae-363d0987785e.png"> |  The purpose of this minScale is to prevent the viewport from exposing anything beyond the boundary. In other words, in this example it's trying to cover up all the yellow using the orange child.  It is not trying to prevent the child from growing beyond the size of the viewport, that's fine.
Ah I see. Thanks for the explanation! In that case would it be possible to move the logic in the if clause to before clamping? Then the function would be roughly ```dart     final double currentScale = _transformationController.value.getMaxScaleOnAxis();     final double totalScale = math.max(currentScale * scale, math.max(_viewport.width / _boundaryRect.width, _viewport.height / _boundaryRect.height));       final double clampedTotalScale = totalScale.clamp(widget.minScale, widget.maxScale);     final double clampedScale = clampedTotalScale / currentScale;     return matrix.clone()..scale(clampedScale); ```
Yes that looks much better, thanks!
This needs to be a full exit
This also needs to be a full exit
If I don't shorten this message, then `:upgrade_succeeded` cannot be located from the `GOTO` on L137 when running the hostonly windoows machines.
I removed these messages because redirecting pwsh stdout to stderr applies the exception formatting that cannot be removed
Not sure what you mean. What is the exception formatting, and why is it not desirable? Because it looks like a failure?
For example: https://i.stack.imgur.com/Lg7aA.png
Wait, what? Why's that?
Isn't this conceptually the same lock that the windows script acquires in "acquire_lock"? Does that logic need to be updated as well?
Did you double check that this redirects the right thing to the right thing in real life? Line 57/59 does some funny business with the descriptors (see comment in line 58). I almost would have expected a redirect to "3" since that supposedly should be stderr now. Unless of course the file descriptor magic doesn't apply inside the subroutine... 
Now that I think about this again, the way you have it is correct, I believe. Line 59 redirects stderr "2" of this subroutine to "3", which is stderr in the call context of the subroutine, but not within the subroutine. 
It does ... but that was more difficult, due to how much longer the check is/gotos 
good question!  I've seen some information that GOTO label can behave weird if the label is outside of some certain size block, but from what I read that only applies if unix line endings are used. however, without fail the hostonly windows machines could not locate the `upgrade_succeeded` label with the longer message.
Does this mean that we can't use e.g. spacebar as an input?
yes - though this matches the restrictions that the resident runner has. This could be changed to strip off a trailing newline line if length > 1 instead? I'm not sure that would buy us that much
Maybe worth adding this as a comment, though I'm not sure this would be the best spot?  The spacebar is pretty big on keyboards, so it might be convenient to use for something someday.
I think there is a typo in this sentence. :)
Style nits: The indentations on all of these SliverConstraints is off. 
This was not a nit at all, thanks for pointing it out :)
No need for this extra newline here.
I think the analyzer will complain about not following Flutter's code style unless you do it this way:  ```dart widget.onInteractionStart(   ScaleStartDetails(focalPoint: focalPointSceneScaled), ); ```
What do you think about `horizontalScale` and `verticalScale`?  Maybe the best thing to do is to leave them null as you have already done.  When doing pinch-to-scale, horizontalScale and verticalScale are independent of scale and seem to be related to the angle of the two contact points on the screen.  This is probably irrelevant when scaling with the mouse wheel.  Or, we could set them to scale, or set them to 1.0.
Change this to `0.0` just to make it clear that it's a double.
I think scaleChange might be what we want here.  In _onScaleUpdate, it calls onInteractionUpdate with the direct `details.scale` value, which doesn't consider the current scale of the child.
So for every mouse wheel event, we call all 3 callbacks: Start, Update, and End.  I guess that makes sense.  I don't think it's possible to group calls to _receivedPointerSignal.
```suggestion     testWidgets('Scale with mouse returns onInteraction properties', (WidgetTester tester) async { ```
```suggestion       expect(afterScaling, equals(currentScale));       expect(currentVelocity, equals(noMovement)); ```
Could you also expect that currentScale is not null and not 1.0?  I worry that this feature could break but the test would still pass if currentScale were 1.0 or null.
Maybe add a `calledStart` boolean and set it to true in here, then expect it to be true later?  Just to get onInteractionStart some test coverage, even though it doesn't do much.
Extra newline.
I'm not sure about this one because it seems that in the normal pinch zooming it seems to display the currentScale instead of the scaleChange, could you do a crosscheck on this just to make sure. Also the ScaleChange value seems to be fixed at approximately 1.3 for zoom in and 0.89 for zoom out  per tick of scroll( as in when you can feel it scroll once). so I'm not sure which would be the better choice. I'm giving my opinion on the decision but do update me on which one you think should be used  for better consistency and/or change!
I think it's better to leave it at 1 because I agree it being irrelevant when scaling with mousewheel.
I also have a follow up question regarding the flutter_build check, it seems there are times when it was fine and times it is not, is this a normal thing?
I think you'll have to add those parameters here too then, otherwise they're null:  ```dart   horizontalScale: 1.0,   verticalScale: 1.0, ```
Regarding the 1.3/0.89 thing, is your InteractiveViewer wrapped in a GestureDetector somewhere?  There is a known issue about that which I still need to fix: https://github.com/flutter/flutter/issues/58636  Regarding the current scale vs. scaleChange, it does seem to be passing the change in scale based on my experiment:  ```dart InteractiveViewer   onInteractionUpdate: (ScaleChangeDetails details) {     print('onInteractionUpdate ${details.scale}');   },   ... ) ```  Logs: ``` (Zooming in:) flutter: onInteractionUpdate 1.0051666615057695 flutter: onInteractionUpdate 1.0103338151812797 ... flutter: onInteractionUpdate 2.4213762341047356 (Stopping and zooming out:) flutter: onInteractionUpdate 0.9978297973338419 flutter: onInteractionUpdate 0.995660468727219 ... ```  ~~Lastly, about the flutter_build check.  Yes, our test infrastructure is quite flakey unfortunately.  If the error message doesn't seem related to your PR, then it's probably an infrastructure problem and just needs to be re-run.~~ Sorry, I misread this at first.  Specifically the flutter-build check is referring to the current status of Flutter's master build, which does usually go red a few times per day.  It happens whenever someone merges a PR that breaks a test.  The only thing to do is to wait for it to go green.
the 1.3/0.89 I think is becaused a scroll tick is always constant value, so probably why the scaleChange value is constant. But since your tests are proven scaleChange, then I will be using that for the details.scale!
unfortunately adding a new named parameter here breaks some internal customers. Can we reland this with either an optional named parameter, or just a new named constructor for it?
Why wouldn't you just specify the `targetRenderObject` as the `object` parameter?
@dnfield Hi,   If we only pass in the inner target RO, the outer `viewport` cannot be obtained by `RenderAbstractViewport.of(object)` at line 648 below, and we cannot get the offset to reveal the target for the outer viewport.
Why can't we just traverse up the viewports and get the offset for all of them?
@dnfield  Yes, we traverse up `viewport` by the superior calling, https://github.com/flutter/flutter/blob/78fdd52a0fcf9a75686079ad72b46c938bec4c87/packages/flutter/lib/src/widgets/scrollable.dart#L320-L328  Here just a correction to the area to be displayed.
Ohhhh I see now, we're using this parameter to memoize which object we were initially trying to center and let the viewports know that's the one - we don't expect callers to actually pass this in as a duplicate of object. Is that correct?
@dnfield  You are absolutely correct. Actually, if the caller does this, it has the same effect as setting it to null, which means the target area is itself.
I think we no longer have `iphonexs` in the devicelab. We probably should just use `mac/ios`.
Let's also add a `flaky: true` here just to be cautious.
Done
This is the part that should fix the post-commit failure from https://github.com/flutter/flutter/pull/64674. Run `pod install` (assuming the fingerprint says it's needed) when there's a Podfile even if there aren't Flutter plugins. @xster What do you think about this?  Looks like the `project.isModule` caveat was added back in #21276.
nit. Maybe a comment to explain why we have to `pod install` even if it doesn't have plugins?
Good idea, done.
I wish that original line could be DeMorgan rewritten 😂  That isModule part is definitely weird. I can see the argument for just generally not running pod install when there's only a user Podfile without plugin. Since at that point, it doesn't have much to do with Flutter's build pipeline. When a user changes his own Podfile, the user should run pod install themselves. Our customers did complain back in beta days about pod install always running for no changes and being slow.   I can't think of why isModule + has Podfile means pod instead has to run. Removing isModule from this consideration altogether seems reasonable. "'Cause if you like it, then you shoulda put a test on it" 
I reverted this, and instead added a Flutter plugin to the integration test so the tool runs `pod install` for us and I don't need to call it manually.
```suggestion   /// How each line of text in the Text widget should be aligned horizontally. ```
ummm this is reasonable. Thanks for catching this
Add more context to this comment. e.g. `Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on` in this and the next file.
Leave the final line break here and in the next file.
Thanks for review! Could you please check again?
Do we need to do this in `_handleImageChunk` as well?
Yes - we should add the same after line 1198.
Yes we do.
@dnfield I can't understand why the test case throw this on second call. 
nit: new line at EOF
I'm not clear on what you mean.
Ah I see the test now. Perhaps you could instrument this method to print the load count locally and figure out who's calling it?
Thanks for this. I found out that the Image widget was calling it.
nit: Can you pick a more descriptive name here?   Alternatively, can we just merge this class with TestImageStreamCompleter in here?
Yes, I think it is possible to merge.
@dnfield I think it is better now.
This widget can be `const` I think?
```suggestion /// When the user scrolls past [refreshTriggerPullDistance], ```
nit: Probably better to briefly describe what the sample code does instead of reiterating the docs.   Maybe something like  "this sample shows the default ios pull to refresh indicator for 1 second and adds a new item to the top of the list view"?
That makes sense. There is not enough explanation for the example. I will apply a new comment for the example code.
I agree. :)
Thank you!!
I'd just inline your function in here to make it easier to read. 
Since it's a cupertino example, I'd just use CupertinoApp and CupertinoPageScaffold here. (I also suspect this doesn't build if you just import cupertino.dart above)
align these indents.
> (I also suspect this doesn't build if you just import cupertino.dart above)  I referred to this example. https://api.flutter.dev/flutter/cupertino/CupertinoContextMenu-class.html
The doc on `TextPainter` says "The newline, if any, is included in the range". However this doesn't seem to be the case... or I missunderstand this statement.  I couldn't find any tests for `TextPainter.getLineBoundary` to see if this is expected.
Oh, interesting. So the web tests failed here with:  ``` 07:30 +485 ~12 -1: /b/s/w/ir/k/flutter/packages/flutter/test/rendering/paragraph_test.dart: getLineBoundary control test [E]                                                                              Expected: 'I polished up that handle so carefullee'     Actual: 'I polished up that handle so carefullee\n'               ''      Which: is different. Both strings start the same, but the actual value also has the following trailing characters: \n ```  Which sounds like implementation for the web platform is more aligned with the doc... ?  Running this test locally on macOS works fine.  I'm probably going to need help determining which behavior is the correct one and whether I should be looking at the TextPainter implementation to fix this inconsistency.
Extra newline here.
required => require
Or maybe this? "Accessing this value does not cause the layout to be updated."
Any of these docs comments that were copied from text_painter.dart should use a macro instead.  Here's an example of how to do that:  https://github.com/flutter/flutter/blob/0bb1e573fce0a32c28d1bd3caf26e53405604f48/packages/flutter/lib/src/painting/text_painter.dart#L335-L337  https://github.com/flutter/flutter/blob/0bb1e573fce0a32c28d1bd3caf26e53405604f48/packages/flutter/lib/src/rendering/paragraph.dart#L269
I would agree with you, something seems not right there.  Let's see if @GaryQian knows what the behavior should be.  There are some tests in the web part of the engine for this, and they include the newline: https://github.com/flutter/engine/blob/09a5bf7acf44dbb22d68830f5a51ebe822d5e659/lib/web_ui/test/paragraph_test.dart#L926
If you have a workaround for preferredLineHeight, I would prefer that we hold off on exposing this as official API. The current implementation of this value is sketchy at best and is something I want to eventually rework.  Some problems with this value is that it assumes an alphabetic space as the character to get metrics from. This causes some issues with ideographic text such as Chinese or even Arabic in some fonts. The current implementation also does not account for the differences in first line vs second+ line height, so could produce values that are not useful beyond the first line.  For now, I suggest continuing to use your workaround instead of adding this API that may have to be broken in the future.
tight -> strut  Can you change this in the original docs in TextPainter as well? This doc is no longer accurate.
Going off of the macro comment by Justin, change this in the original doc, and then macro it here.
The primary reason this is not exposed is API bloat, since once we add it, it cannot be removed. We should try our best to explore reasonable alternatives before resorting to adding additional API.  In this case, getLineBoundary exposes a few of the text position APIs based on metrics, which we want to eventually move away from to contain more bitdepth.  I think you may be able to workaround this by calling getBoxesForSelection, once with a collapsed selection to get the rect that bounds the current position, and again with a wide selection that encompasses a few lines. Then, you can take the right most and left most boundaries of the boxes that share the same y offset as the first call. Then pass those boundaries to getPositionForOffset.  That should get you something that may work for your purposes. If the resulting code is really complicated, confusing, or unreliable, we can proceed with exposing this.
This should be ok to expose, as the CaretMetrics construct is native to TextPainter.  The name "fullHeight" seems a bit ambiguous in hindsight especially since there is no API for not-full height here. We may want to consider renaming it to something like "rawHeight" here, indicating it is unprocessed and a direct result of the caret computation. The alternative is to just keep the naming as "full" for consistency.  I am leaning towards keeping it as "full" as diverging API is not good. @justinmc any opinions?
Let me know if you are able to get a workaround working!
This may indeed be a bug, I think the newline makes sense here, especially since the docs indicate that it was meant to be included. It isn't your responsibility to fix that though, so you may want to just mark it with a comment and a `TODO: blahblah` to indicate that the result here may be due to a bug. Then, you can duplicate the test and make one of them skip web while having the other skip android+ios. We should file a bug on this.
Makes sense, thanks! I can keep my workaround for now and remove this method from here.
Updated and added a macro in TextPainter. I haven't included the last line referencing `[layout]` of TextPainter as it seemed specific to the painter class itself (even though RenderParagraph has a similar requirement).  Let me know if you'd like that line to be included in the template, I'll update.  Also changed `[position]` to use backticks, as it seems more inline with the style guide around method parameters.
Thanks for the examples!
Removed this method per @GaryQian 's recommendation.
Per @Hixie suggestion I updated this test to be more strict in comparing expected value.
Yep it does seem to work pretty well. Thanks for the suggestion! Since each RenderParagraph in Zefyr represents a single paragraph of text (meaning text between two newlines) here is what I ended up with:  https://github.com/memspace/zefyr/blob/78a5ac11542d39a45cc11cb904416dec0c443da7/packages/zefyr/lib/src/rendering/editable_text_line.dart#L294-L309  ```dart   @override   TextRange getLineBoundary(TextPosition position) {     // getOffsetForCaret returns top-left corner of the caret. To find all     // selection boxes on the same line we shift caret offset by 0.5 of     // preferredLineHeight so that it's in the middle of the line and filter out     // boxes which do not include this offset on the Y axis.     final caret = getOffsetForCaret(position);     final lineDy = caret.translate(0.0, 0.5 * preferredLineHeight(position)).dy;     final boxes = getBoxesForSelection(         TextSelection(baseOffset: 0, extentOffset: node.length - 1));     final lineBoxes = boxes         .where((element) => element.top < lineDy && element.bottom > lineDy)         .toList(growable: false);     final start = getPositionForOffset(Offset(lineBoxes.first.left, lineDy));     final end = getPositionForOffset(Offset(lineBoxes.last.right, lineDy));     return TextRange(start: start.offset, end: end.offset);   } ```  I'm checking at the vertical middle of the line because I've noticed that emojis, for instance, have larger selection boxes (and they also mess with the line height they are at): ![image](https://user-images.githubusercontent.com/441756/92557187-7db34f80-f220-11ea-89ee-5cc55227e273.png)  Overall it's actually pretty concise and I'm happy with this approach. So I removed `getLineBoundary` from this PR.  It now only exposes `getFullHeightForCaret`. 
Oh yeah, one more thing before submitting, caretPrototype here does not do anything useful as in getFullHeightForCaret, it only contributes width, which is then ignored. You should just remove the parameter and pass a zero rect instead in the method body.
Updated.
Is there anything else that refers to "full height" in the codebase?  Not that I could think of or find with a quick search.  If it's really just this method, maybe we should nip it in the bud and switch to "rawHeight" while we have the chance?  If I'm wrong then it definitely makes sense to be consistent and use "fullHeight".
This check is new and was not in https://github.com/flutter/flutter/pull/64988.  If the user rearranged their build scripts manually, error and tell them how to fix it. <img width="483" alt="Screen Shot 2020-09-02 at 5 16 38 PM" src="https://user-images.githubusercontent.com/682784/92049734-15580000-ed40-11ea-9300-1e1440836a82.png"> 
This test is new.
This is new and tests https://github.com/flutter/flutter/pull/65124
Well I get this error but the build script "Thin Binary" is after "Copy Bundle Resources" <img width="213" alt="Bildschirmfoto 2020-09-09 um 11 29 50" src="https://user-images.githubusercontent.com/6883178/92581291-c7874e80-f28f-11ea-885b-66ce9cf3bfb1.png"> 
@bennibau can you file a new issue and @ mention me?  I want to see what's going on in your case.  Please include the output of `flutter doctor -v` and the full exported Xcode run report. View > Navigator > Reports > Export...  <img width="350" alt="Screen Shot 2020-09-10 at 1 41 57 PM" src="https://user-images.githubusercontent.com/682784/92802492-66cd4400-f36b-11ea-8715-89cd92dc6df3.png">  Also, a screenshot with those build phases expanded. 
I'm also hitting this error with this build script:   ![Screen Shot 2020-10-04 at 4 42 50 PM](https://user-images.githubusercontent.com/44235716/95027760-a5030e00-0660-11eb-83a1-06a29c32887c.png)  flutter doctor -v:   [✓] Flutter (Channel master, 1.23.0-8.0.pre.131, on Mac OS X 10.15.6 19G2021 x86_64, locale en-US)     • Flutter version 1.23.0-8.0.pre.131 at /Users/samparks/dev/sdks/flutter     • Framework revision 8485580bb9 (3 hours ago), 2020-10-04 14:47:02 -0400     • Engine revision a8d7d97bef     • Dart version 2.11.0 (build 2.11.0-185.0.dev)  [✓] Android toolchain - develop for Android devices (Android SDK version 30.0.2)     • Android SDK at /Users/samparks/Library/Android/sdk     • Platform android-30, build-tools 30.0.2     • Java binary at: /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java     • Java version OpenJDK Runtime Environment (build 1.8.0_242-release-1644-b3-6222593)     • All Android licenses accepted.  [✓] Xcode - develop for iOS and macOS (Xcode 12.0.1)     • Xcode at /Applications/Xcode.app/Contents/Developer     • Xcode 12.0.1, Build version 12A7300     • CocoaPods version 1.9.3  [✓] Chrome - develop for the web     • Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome  [✓] Android Studio (version 4.0)     • Android Studio at /Applications/Android Studio.app/Contents     • Flutter plugin version 48.1.2     • Dart plugin version 193.7361     • Java version OpenJDK Runtime Environment (build 1.8.0_242-release-1644-b3-6222593)  [✓] VS Code (version 1.49.3)     • VS Code at /Applications/Visual Studio Code.app/Contents     • Flutter extension version 3.15.0    [✓] Connected device (3 available)                 • iPhone (mobile)  • 00008030-000608880E9B802E • ios            • iOS 13.7     • Web Server (web) • web-server                • web-javascript • Flutter Tools     • Chrome (web)     • chrome                    • web-javascript • Google Chrome 85.0.4183.121  • No issues found!  
This test has no name.
WE DON'T HAVE FUN HERE.
I seriously considered leaving the original or having it say "funny and fully" or something but...
Ah yes, test names. One of the other features I'd just remove entirely if I were to create a new test framework. :-)  Fixed
Does the web go through the text input client instead of raw keyboard event?
This also attempt to sync the remove editing value in the embedding side, I think we should still need to do that if it is a selection change? cc @gspencergoog .
should we also verify the handle does not show up?
Yes. All keyboard interactions with the text field are handled by the browser and we only receive the result of the change. e.g. If the user clicks "shift+right arrow", we receive an event from the browser telling us that selection has changed, so we read the new selection state from the input field and we send it to Flutter through the text input client.
how do we verify it? can we add a screenshot test here?
Something like this should be sufficient https://github.com/flutter/flutter/blob/d3fd62c8433ab9bf4e6b7312096cea1ab98b543f/packages/flutter/test/material/text_field_test.dart#L1032
The thing is, `EditableText` doesn't show the handles on its own. Instead, it takes a `showSelectionHandles` property. This test is only making sure that `EditableText` reports the change correctly. The rest is on `SelectableText` and `material/TextField` to take the selection change and pass the correct value for `showSelectionHandles` (which they already do, and they have tests for that).
Maybe I'll add a test that includes the entire interaction between `EditableText` and `material/TextField`?
I think you can just use textfield/selectabletext to test directly, after all, we care about they do not show the handle but not how editabletext ineract with textfield to make that happen. 
Thanks for the suggestions! I wrote a test for `selectable_text` and `material/text_field` to make sure they don't show handles under these circumstances.  @chunhtai do you think I should remove the `editable_text` test that I had initially?
What is a "remove editing value"? Shouldn't it send a `TextEditingValue` with an empty `text` in that case? And that would fail the `_isSelectionOnlyChange` check.
@chunhtai can you explain what you mean again?  I'm not sure I understand exactly what you're referring to.
sorry it is a typo, i meant the remote editing value. The formatAndSetValue also called _updateRemoteEditingValueIfNeeded https://github.com/flutter/flutter/blob/9e315985d0788ee04df48559896be46225ecf2f5/packages/flutter/lib/src/widgets/editable_text.dart#L1804  This will attempt to sync the current editing value to the embedding. I was wondering if selection only change needs to be sync to the embedding as well.
I think we can keep it
Yes, it does, because otherwise the next editing operation won't operate on the same selection in both places.
After receiving a new value from embedding, if it's a selection-only change, we won't be formatting the text. Which means that `_value` and `_receivedRemoteTextEditingValue` are certainly the same. Is there something I'm missing?
If I understand correctly, the only reason we may want to update remote editing value is when the text formatting causes changes in the editing value, so we send it to the embedding to avoid getting out-of-sync.
I took a look at the code in engine https://github.com/flutter/engine/blob/f7c7b41f0a0c72163d749321d070880fcac6402d/shell/platform/android/io/flutter/plugin/editing/TextInputPlugin.java#L577 It looks like we care about the selection value. I was under the impression that the engine should sync its own editing value before sending the updateEditingValue to the framework, but i couldn't find the code that does that. So It seems like we do need to call _updateRemoteEditingValueIfNeeded somewhere even if it is a selection only change? 
The `TextEditingValue` includes the current selection.  So a "selection only" change does cause a change to `_value` or `_receivedRemoteTextEditingValue`, which then needs to be synced.
Maybe we're all in agreement here that it needs to be synced? I somehow feel like we're all saying the same thing...
ah I see, the updateEditingState is sent with the value inside the embedding, so it is already the same. yes, we don't need to sync it in this case.
Ok, let me try to clarify a bit. I think we are using the word "sync" which has many meanings in this context.  On the framework side, we keep two variables: - `_value`: The current editing value on the framework side. - `_receivedRemoteTextEditingValue`: This is what the framework thinks is the current editing value on the engine side.  Whenever the editing value changes in the engine, it sends an `updateEditingValue` message to the framework. The framework then sets `_receivedRemoteTextEditingValue` to the new value received from the engine (this is one meaning of "sync"). Then the framework tries to format the text of the new editing value received from the engine. If the formatting causes changes to the editing value (i.e. `_value` != `_receivedRemoteTextEditingValue`) then the framework sends the new (formatted) `_value` to the engine via `_updateRemoteEditingValueIfNeeded` (another meaning of "sync").  In the case of this PR, a selection-only change means there'll be no formatting changes, hence `_value` and `_receivedRemoteTextEditingValue` are guaranteed to be the same. So there's no need to call `_updateRemoteEditingValueIfNeeded` to "sync" the editing value back to the engine.
Thanks for the clarification. Makes sense now. LGTM.
Keep the information that it is safe to call this during build?
seems like we could rename this to posix exception, et cetera
on Linux/macOS
` || platform.isMacOS`?
oops, messed up my merge
nit. is there either POSIX documentation for these, or macos specific docs?
done
This is the actual change.  The rest of the PR updates the benchmark Xcode projects.
This was what caused the devicelab errors on #64988 post-submit.  `xcode_backend.sh` without any args was building, thinning, and embedding.  However, at this point the generated Info.plist that we will need to edit for https://github.com/flutter/flutter/pull/64988 doesn't exist, so it was failing.
Wow!
ultra nit / optional: "Consider source controlling your project before regenerating to inspect the difference."
if you parse the result and compare a dart map, the test will be resilient to changes in formatting.
Done.
can we document this some way to avoid future me "optimizing" this code back to the previous state?
nit: does this fit on one line?
done! hopefully the test will help too
Optional cleanup: Pull the debug banner toggle out into a helper function.
Does this change the help text for release mode?
Yes, the screenshot help was missing despite the fact that it should be supported. I added a test case for this.
fixed
done
`toggleDebugBanner` should maybe be `setDebugBanner` and accept a bool arg to turn it back on, too.
Sorry, I'm confused. It's supported in profile but not in release, right? Is `supportsServiceProtocol` what we were using to distinguish those cases?
its supported in profile and release, because it involves talking to a device daemon (ios-deploy/adb) and not the service protocol.
actually idevicescreenshot, not ios-deploy
where you saying that `canRun` is not reliable on Windows?
canRun just checks if the result of https://github.com/google/process.dart/blob/cce751da2076b8345d2f17b9db5cc6fc04f60e69/lib/src/interface/common.dart#L51 is null. I'm not actually sure what it will do in this case.
This variable should no longer be necessary. Remove to simplify code.
Combine `kNonDraggingListHeight` and `kDraggingListHeight` to simplify code.
Shall we add a message to the error? 
Shall we add a message to the error here as well? Also a comment on why we add this method. (Sorry the serviceClient also doesn't have it, but I thought it might be useful in the future to the readers of this code)
There are a few things we need to do here. (1) This only works for desktop web (mobile web has another method which is very similar to this) (2) If `flt-semantics-placeholder` which lives on the engine changes, this will break. It would be very hard to understand for the engine-developers. It is best to add a documentation and also a link to that code.  Btw, a question we can also click on this button by calling the following right? ``` webDriver.execute(           'document.querySelector(\'flt-semantics-placeholder\').click();',           <String>[]); ``` 
Question: Looks like we are also switching the way we are accessing the driver object (fromExistingSession vs constructor)? Is there a specific reason for it (anything failing with a11y or screendriver)?  
The async version of fromExistingSession returns a WebDriver instance which will **NOT** have the same capabilities (in fact, it would be empty) as the original one where the capabilities plays an important role for screendriver.
Discussed offline. Will follow existing pattern and do not add message to UnimplementedError.
See the comment below.
Updated accordingly. Well create an issue for Mobile Web (in fact, it works on Android-Chrome).
Great, thanks for adding this test!
Even though selectionColor and cursorColor will not be deprecated (yet), their API docs should explain what the deprecation warning will, and the docs should warn about the upcoming deprecation.
Nit: Is there any way this could be a constant?  Just thinking that it's not intuitive where this value comes from by looking at the test (I see it hard coded in material/text_field.dart).  Don't worry about this if it's not a quick and obvious improvement, I know it's not really this PR's responsibility!
I think this has to be the same as `Color(ColorScheme.light().primary.value)`. Only pointing that out because I wish we wouldn't use ThemeData.fallback(), since it needlessly obscures ThemeData.light().
Why has this test and the next one been hollowed out?
Good point. Done.
I just switched everything to color constants for the default values so this is no longer an issue.
Before we had two tests for defaults: one with opt-in turned off and one for opt-in turn on. With this PR there is only one default (the opt-in) case, so this replaced both with just the opt-in case.
do this in the initializer and it can be final
nit: add a brief doc comment and link to the correct documentation?
there are some helpers like `stringArg`, `stringsArg`, et cetera that avoid the casting
consider not catching all file system exceptions: some of these might be programming errors in the tool.
consider an short name alias for typing - gen-l10n ?
Note also: maybe we should use a hyphenated name for the long form as well.
I've converted any `FileSystemException`s I threw in the tool into `L10nException`s and then removed the code catching file system exceptions
I think the problem here is that in this locale the font sizes appear to be larger than ISO Latin fonts, which is causing some layout issues. Instead of changing this constant, a better fix would be to have this spacing SizedBox be the Flexible child instead of the help text. That way if there isn't enough room due to font size issues, the slack will be taken from this spacing widget instead of the help text. I am thinking something like:  ```dart const SizedBox(height: 16), child: help, const Flexible(child: SizedBox(height: 38)), ``` 
@darrenaustin can you review my PR again please 
We want to remove the `Flexible` from the help widget with this change. In essence we are making the `SizedBox` flexible and not the help widget. We always want the help widget to be as big as it needs to be, but the `SizedBox` is just used for spacing, so it can be smaller.  If we make them both `Flexible`, then any missing height will be taken from both of them equally instead of just from the spacing `SizedBox`, leaving the help text potentially cut off again.
PR updated. Thank you @darrenaustin 
`return child.getDistanceToActualBaseline(baseline);` ?
Can you modify the test to just call the getDistanceToBaseline on renderobject of LayoutBuilder and see if it returns the right value when it has child? 
I was afraid that changing how baseline is calculated may have adverse effects. That's why I only called `getDiatanceToActualBasline` to pass the baseline to child.  Should I override how the baseline is computed by returning it?
I decided to only pass the baseline to child because of this [issue I faced](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772)
If I guessed right, I won't be able to call getDistanceToBaseline in the test after getting the LayoutBuilder RenderBox since it's only allowed to call when performing layout. 
I have edited the test to check that getDistanceToActualBaseline is actually caching the baseline for computation as we have done for other widgets like Chip and ListTile.
I did test it out, and returning the child's actual baseline do have an effect on how the child is laid out on y coordinate when a Baseline is present. Wouldn't that make it a breaking change?
let me take a step back, May I know what is the use case of this change? It seems weird that we call getDiatanceToActualBasline of the child if we don't want to use the result. That will be a weird side affect.
If you check out [the comment](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772) which describes the blockage for the PR. Hexie suggested providing Ink widget a private RenderObject. So instead of providing a private RenderObject, I suggested that what if we implement the baseline logic for LayoutBuilder instead of rewriting the most of the code for the Ink widget. The [comments on the PR](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772) descibes the usecase and why I ended up doing this.
Ah So this is for a failing test. I think we should return the child, otherwise according to the test it will no longer baseline the list title correctly.
But I do agree with you that there is no point if we are not returning the child's baseline since then Baseline won't be able to properly define the y coordinate for a child. I'm just concern that doing so may be a breaking change.
I think this is more programmatically correct, so i think it is ok if this is a breaking change.
So, is the PR good to go without a breaking change design doc or we should handle it with a flag property? I can write a design doc for it, if needed.
We only consider it a breaking change when it break contributed tests https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes  So you should make the change first to see if it does break tests
I have already made the changes to return the child's baseline, and it's not breaking any test. 
This is not a good test for this change, can we try to build a real child and verify its position does take the child.getDistanceToActualBaseline into account?
I have updated the test. Let me know if it's not good. I'll try to improve.
Moved these failures to where they are detected, instead of the end of the test.
This works, but is there a more idiomatic way to return a string from a bash function?
Unrelated to this change, but I noticed the quotes were missing.
This is a new xcode_backend entrypoint.  At the least, we can tell add-to-app customers to call this in a new build script phase.
Check out the screenshot in the description.  We can probably remove the second "Flutter".  Maybe also "connect"? > Allow Flutter tools on your computer to debug your application. This prompt will not appear on release builds.
This section is new.
Don't really care what it says since that seems like a moving target, just that it exists.
This was moved from `general.shard`, it's not a hermetic test.
These were disabled in https://github.com/flutter/flutter/issues/35707, but as an integration test they should get a precache, so I fixed them up and reenabled.
This one is new, the behavior changed #57688 but the `installWithoutRelease ` test was being skipped so it didn't fail.
I might be misreading this a bit, isn't this ultimately the same plist as https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/targets/ios.dart#L341 ?
https://stackoverflow.com/questions/17336915/return-value-in-a-bash-function probably
I think I would rather not add this for add-to-app.  Those customers should be sophisticated enough to read an error log and know which plist(s) to update.  This is likely to get things wrong for some customer and we'll get requests to change it or a specific CI system or wahtever.
oh lol, TIL. So there's an actual built-in tool to turn plists to things like json so it can be more easily consumed by things like dart?
oh cool, is this a whole new feature (that confused matt forever) bundled here? :D
Also add a common name (as seen in the xcode gui) for this? People might not know what the CONFIGURATION setting maps to.
Also add a gui description if possible (I assume people can go into the build settings tab, add a new row, expand the configurations and type in something in xcode).
How come this works here and not for add-to-app? Because our template build phase puts xcode_backend.sh later than where cocoapods can help us put it?
Display an error message otherwise?
On the second connect. I'd maybe leave it. Otherwise people might think I'm just flutter running and then maybe taking a screenshot or something. I'm not technically "debugging", why doesn't it work?  On the second Flutter, don't have a strong opinion. To be specific, we're not really debugging their (objective-c) application. This is strictly dart/observatory/flutter stuff.
What about .frameworks? Will those cases never work unless users type in something manually in their real checked-in info.plist?
This has been in there for .. a while now.  Basically, we try to use the $CONFIGURATION because that's probably what the user wants if they're running from Xcode (in particular, we don't want instruments tests from debug mode Dart, and we set up instruments to run in a "PROFILE" configuration by default).  But we do let a user override it if necessary.
It's not the same file, that's the project's `ios/Runner/Info.plist` (build setting `INFOPLIST_FILE`), and that's checked into source code, and where [the docs](https://flutter.dev/docs/deployment/ios#updating-the-apps-name) tell users to update some fields before they submit to the app store.    This PR is editing the Xcode-generated Info.plist that gets embedded into the `Runner.app`. After Xcode compiles everything and it embeds resources (storyboards, images, etc), it creates a `Runner.app/Info.plist`, which is a combination what's in the user's Info.plist in Xcode, plus a bunch of other Xcode-generated keys and metadata <img width="1032" alt="Screen Shot 2020-09-01 at 12 05 55 AM" src="https://user-images.githubusercontent.com/682784/91813044-eb3efa80-ebe6-11ea-93da-b3033cf9622b.png">  By editing this final generated Info.plist, we don't need to update the user's checked in Info.plist, update the template, or have a complicated migration where we set different Info.plists depending on configuration, which would cause flavor-users a bunch of pain.  We know the user needs this service in debug and profile when copied to the device, and it also means it won't slip into the release version that gets submitted to the App Store.
> Those customers should be sophisticated enough to read an error log and know which plist(s) to update.  How would they see an error message from the VM if they can't attach?  **Edit: oh right, they would see it in Xcode.** It definitely requires some Xcode-foo to know you can edit the Info.plist per configuration.  You need to know how to expand the build setting, which people seem confused by.   <img width="862" alt="Screen Shot 2020-09-01 at 12 16 17 AM" src="https://user-images.githubusercontent.com/682784/91814041-66ed7700-ebe8-11ea-93c1-912feed22d9e.png"> Or they can do something like `Info-${CONFIGURATION}.plist` We'll have to update the docs, for sure.  >  Will those cases never work unless users type in something manually in their real checked-in info.plist?  Right, they would need to edit their plist.  At least in the CocoaPods case they can add the build phase I suggested in https://github.com/flutter/flutter/issues/63893#issuecomment-684126922 
Actually, looking again, https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/targets/ios.dart#L341 is a different third `Info.plist`. It's the one that gets embedded in the `App.framework`.
Yeah this logic and error messaging was just moved into a common function so I could use it in two places.
This was all just moved.
> Because our template build phase puts xcode_backend.sh later than where cocoapods can help us put it?  Bingo.  I put some more details in https://github.com/flutter/flutter/issues/63893#issuecomment-684126922.
If the developer sets their own NSLocalNetworkUsageDescription because their app is doing their own local networking we don't override it.
that's ok. I just meant if that's the case, we should print something in the console to indicate that you'll get a popup in debug and we can't set the message in it but it's for flutter tools to connect.
Yup, it's being used for other plist parsing, see https://github.com/flutter/flutter/blob/80619f100ffefec82528be1b92a76ad22807e459/packages/flutter_tools/lib/src/ios/plist_parser.dart#L53  Except the json part doesn't totally work... https://github.com/flutter/flutter/issues/62160
oh lol, sad
Does it matter which Plist these permissions are added to, or could it be done to the flutter framework plist itself?
Can we call this dartObservatoryBonjourServiceFound?  or take in `_dartobservatory._tcp` as a parameter?  From the callsite it just looks like we are throwing if any bonjour service is found.
Is this throwing an error if a user legitimately has their own mdns service for their release build?  We want to make sure to support that.
This is an integration test, it doesn't have any mDNS service set.  The `xcode_build` script handles that case, it detects if the `NSBounjourServices` key is set, and adds it to the list.
It needs to be on the app bundle, so `Runner.app/Info.plist`.  A framework can't set app-level permission requests or entitlements.  Otherwise this problem would be a whole lot simpler.
understood. 
we should go have Matt write this down in https://flutter.dev/docs/deployment/flavors :D
CONFIGURATION is an env var provided by Xcode. It's available in the build settings if you dig into them. There's no special GUI name.  By default anXcode project has Debug and Release. We added profile to our default template when this was added.
Oh hey, this was another bug we needed to fix
I can't find the original issue, but we did not correctly run pub when building for macos
https://github.com/flutter/flutter/issues/46236
Nice.
Is 'digest parsing' something we no longer need to test, or is this handled elsewhere?
Hoping to start optimizing that analyzer 😉 
We don't need it anymore because we are no longer retrieving digests. :) Before this change, we had to look up all of the digests and then figure out which one we needed in order to get the right image. With the new endpoint, we can just ask for the exact image we need. 
Doesn't have to be in this PR, but should this be moved to the integration shard?
I wasn't sure. It is definitely touching the real filesystem, but it is also more of an analysis check - I could see wanting it to remain fast.
would it be possible to allow the entire `//test/integration.shard/` dir?
we could - this sort of enforces using the existing test_utils, which could be helpful if we do want to change the file system in the future
oh yeah, makes sense
Does it run in parallel with other general shard tests?
yes ... hopefully those aren't also writing to the filesytem...hmm
we should probably just move this?
i vote move them just to be safe and rule out the potential flaking.
done!
How about a test in forbidden_imports_test.dart that checks that this file isn't imported outside of the integration.shard subdir?
let's leave iPadOS out or add a caveat since we never invested much in tablet specific UI (which has not many but some noticeable differences)
Why not making `tallky[key]` as `double` to get more precision?
I'm keeping the same datatypes as before to avoid breakage.  With how big these numbers are 1/3 of a number is inconsequential.
I could also use a content hash, but technically it needs to be the content hash of the _entire_ bundle in order to be correct. Use a large random number is a pretty close approximation, because it will only change when at least one aspect of the build has changed (causing this logic to rerun)
I think `nextInt` [accepts up to 1 << 32](https://api.dart.dev/stable/2.9.1/dart-math/Random/nextInt.html), so you could go as high as: `4294967296`. (Not sure it'd make a big difference)
since it is embedded as a string we could go bigger, 4294967296 sounds like a nice number though!
There are a few more of these actually: https://github.com/flutter/flutter/pull/65693/files If its not too much trouble could you apply them in this PR?
Sure, I'll add them! Thanks for looking at this PR
Nit: Consider turning this into a macro if you haven't already. I think it's repeated 4 times, if I'm not missing a slight change.
avoid creating new list with sublist(0)
avoid creating more than a single list or any extra iterables
avoid creating extra list
avoid creating extra iterables
The name is a bit confusing, maybe siblingLength?
is this necessary?
A more specific type is generally better, in this case it is a private API so there should be no concerns.
done
`_attempt` could return `null` on success, and the exception object on an error. Then here you can rethrow the most recent error. Then at the callsite, you can catch `IOException`, or something more narrow, since it doesn't look like the text `'Failed to download...'` is used there. The caller also presumably already knows what the url is.
done?
Ehhhh. Okay, sorry. Maybe that wasn't the best suggestion. If there's some way to avoid catching `Exception` here that would be good, though, since it's only the `IOExceptions` that probably indicate a network issue on the end-user's side.
Where did the `throwTooleExit` go?
Maybe these should all rethrow, `fetchUrl` can do a `try {} catch on IOException {}` with a `continue` in the `catch` if there are still attempts left? `doesRemoteFileExist` would also need a `try {} catch {}`, too, then I guess.
The problem with this approach is it'll fail if there's _two_ `ReorderableListView`s with items that have the same local keys. I think the solution is that `_GlobalObjectValueKey` should have two values, one is the key we're proxying to, and the other is the _ReorderableListContentState to which they belong. We can probably rename it to `_ReorderableListChildGlobalKey` or something, with arguments `final Key subkey` and `final _ReorderableListContentState state` or something like that, to make it clearer what is going on.
@Hixie  That's a great idea! Thanks for your comment. I will apply it immediately.
you don't need to make this generic, since you don't use the T in the implementation
Thank you! I updated the code.
@Hixie Add `_ReorderableListContentState` as a value of the key can not solve the situation where multiple items use the same local key, they have the same `_ReorderableListContentState`, which will lead to Multiple widgets used the same GlobalKey, such as: ```   @override   Widget build(BuildContext context) {     return ReorderableListView(       children: <Widget>[ InnerTest(key: ValueKey(0)), InnerTest(key: ValueKey(0)) ],       onReorder: (_, __) {},     );   } ``` The reason why there is no problem here is its wrong implementation of `int get hashCode => identityHashCode(subKey);`  Probably we could add the index into the values together to solve this problem.  I think we should add this to the unit test case. 
```     If [operator ==] is overridden to use the object state instead,     the hash code must also be changed to represent that state. ``` In other words, Hash codes must be the same for objects that are equal to each other according to [operator ==]
Comments whit `//` .
I don't know much about the hash in the key. Would you explain with an example?
Also see ``` /**    * The equality operator.    *    * The default behavior for all [Object]s is to return true if and    * only if `this` and [other] are the same object.    *    * Override this method to specify a different equality relation on    * a class. The overriding method must still be an equivalence relation.    * That is, it must be:    *    *  * Total: It must return a boolean for all arguments. It should never throw    *    or return `null`.    *    *  * Reflexive: For all objects `o`, `o == o` must be true.    *    *  * Symmetric: For all objects `o1` and `o2`, `o1 == o2` and `o2 == o1` must    *    either both be true, or both be false.    *    *  * Transitive: For all objects `o1`, `o2`, and `o3`, if `o1 == o2` and    *    `o2 == o3` are true, then `o1 == o3` must be true.    *    * The method should also be consistent over time,    * so whether two objects are equal should only change    * if at least one of the objects was modified.    *    * If a subclass overrides the equality operator it should override    * the [hashCode] method as well to maintain consistency.    */   external bool operator ==(Object other);    /**    * The hash code for this object.    *    * A hash code is a single integer which represents the state of the object    * that affects [operator ==] comparisons.    *    * All objects have hash codes.    * The default hash code represents only the identity of the object,    * the same way as the default [operator ==] implementation only considers objects    * equal if they are identical (see [identityHashCode]).    *    * If [operator ==] is overridden to use the object state instead,    * the hash code must also be changed to represent that state.    *    * Hash codes must be the same for objects that are equal to each other    * according to [operator ==].    * The hash code of an object should only change if the object changes    * in a way that affects equality.    * There are no further requirements for the hash codes.    * They need not be consistent between executions of the same program    * and there are no distribution guarantees.    *    * Objects that are not equal are allowed to have the same hash code,    * it is even technically allowed that all instances have the same hash code,    * but if clashes happen too often, it may reduce the efficiency of hash-based    * data structures like [HashSet] or [HashMap].    *    * If a subclass overrides [hashCode], it should override the    * [operator ==] operator as well to maintain consistency.    */   external int get hashCode; ```
How about this way?  ```Dart @override int get hashCode => hashValues(subKey.hashCode, identityHashCode(state)); ```
Thank you very much 👍 
The new hash seems to work fine :)
```dart @override int get hashCode => hashValues(subKey, state, index); ```
Do we need an index? ValueKey already has a value for the index.
See https://github.com/flutter/flutter/pull/64855#discussion_r484312001
@xu-baolin Two children can never have the same key, so the current behavior is correct
See: https://api.flutter.dev/flutter/foundation/Key-class.html  "Keys must be unique amongst the Elements with the same parent."
I see, thank you. 
@PixelToast However, this change not an equivalent modification, and change the behavior of fault tolerance. Can we consider producing globalkey only through state and index，so that we don't have to force developers to provide the widget with a key.
@xu-baolin No problem!  This PR is for fixing a specific bug and not extending functionality though, you are welcome to open a new issue to discuss any changes to functionality that would be nice to have.
@xu-baolin @haeseoklee  This repo uses the triple slash for documentation comments, see the style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use-for-public-quality-private-documentation
@xu-baolin @PixelToast  It looks better to modify it with ```//```. Thank you for your guidance. 
Is this the same test as previous one?
Yes. One is for''vertical mode" and the other is for "horizontal mode"
I see, but then you will need to set scrollDirection to vertical in this test, right?
That's right. I'll apply it right away. 👍 
check a few more non-specified things like FLUTTER_FRAMEWORK_DIR is also pointing to reasonable places etc?
can you also add an "advanced" usage that synergizes with xcode more? Something like --flavor. 
`--flavor` does not change any of the generated config, it just controls which scheme we tell xcodebuild to use.
true dat. How about --local-engine?
we'll validate that it doesn't exist and fail :) 
as in you're going to assert users don't flutter build ios --config-only with --local-engine? Should we? If this is a flutter build ios --config-only command rather a flutter build ipa command, the intent is broader now no? We can't tell what the user wants to do and flutter build ios --config-only --local-engine can be a valid intent (e.g. this new path is now probably going to become the easiest way to flutter build ios --config-only --local-engine, then launch xcode and put a breakpoint on the engine code).
no, the tool will fail to locate the local engine because it does not exist.
ah got it. I misunderstood.
done-ish
```suggestion   /// This method sends the given event to [dispatchEvent] based on ```
Instead of saying "down event" and "signal event" this could link to the events directly, right? e.g. [PointerDownEvent] and [PointerSignalEvent].
Same for the others.
... Event events...  maybe just say "for [PointerHoverEvent]s, [PointerAddedEvent]s, or [PointerRemovedEvent]s.
"resetGesture" is a strange name. 
Why is this reset necessary when the instance just got created?
commented out code
how does this assert that the down event is cancelled?
commented out code
Since this is only needed for the LiveTestWidgetsFlutterBinding could it just live there as a private?
Presumably, we would want to keep this override to ensure that only `TestBindingEventSource.test` reach this method?
I changed it to `resetGestureBinding`.
I've added the following comment, is it clearer? ```dart     // The test target, _TestPostRouteCancel, shows on the home route how many     // [PointerCancelEvent] it has received. Initially it will show "Home 0".     // After the route is popped, it should show "Home 1", meaning it received     // one [PointerCancelEvent]. ```
It's something I've thought for a long time, and I don't think this design is either sufficient or necessary to achieve what it seems to. Redefining `TestWidgetsFlutterBinding.dispatchEvent` provides a way to diverge the behavior of `dispatchEvent` based on event source, although the new behavior is only implemented by its subclass `LiveTestWidgetsFlutterBinding`. How it behaves based on the source is shown as follows: ``` // TestWidgetsFlutterBinding binding; binding.dispatchEvent(event, result)  // AssertionError binding.dispatchEvent(event, result, source: TestBindingEventSource.test)  // Test behavior (binding as GestureBinding).dispatchEvent(event, result)  // Original behavior ``` But this is why the assertion is unnecessary: If some class calls `dispatchEvent` without adding `source`, the class must be unaware of `TestWidgetsFlutterBinding`, which means it will always call the method as `GestureBinding.dispatchEvent`. This assertion protects no one.  And why shouldn't any class aware of `TestWidgetsFlutterBinding` be allowed call the device version? The `LiveTestWidgetsFlutterBinding.dispatchEvent` even defines its own way of handling device-sourced events. The only `dispatchEvent` that does not accept device-sourced events is `TestWidgetsFlutterBinding`'s, which itself does not even redefine test-sourced events. If we really want to diverge by the source, we better do it in `LiveTestWidgetsFlutterBinding` (which does not need it either, since it _allows_ device-sourced events).  What's worse, it forces a test in `gesture_binding_resample_event_on_widget_test.dart`  to [shadow the argument](https://github.com/flutter/flutter/pull/64846/files#diff-57f04f566394a5e6943f53570d727bddL29).  Since the assertion is not needed, and the divergence is already implemented by `handlePointerEvent`, _and_ it brings trouble, I can really think of no reason to keep this assertion.
I think the intentions of the test would be a little clearer if the app would more clearly say what the "0" means. You could for example have an additional text widget that says "PointerCancelEvents: 0". The test would then be self-explanatory and you wouldn't even need the comment above.
Looks like this property (and the logic for setting/retrieving it) can be moved into the `LiveTestWidgetsFlutterBinding` class since it is only needed there?
Sadly not. `WidgetTester` calls the `handlePointerEvent` with source but `WidgetTester.binding` is of type `TestWidgetFlutterBinding`, despite its concrete type being `LiveTestWidgetsFlutterBinding`.
@zanderso What do you think of this hard deprecation?  I doubt this is commonly used.  I didn't want to silently drop it.  I could make it more complicated and print this warning, but then try to pass the deprecated `timeout` down into `deviceDiscoveryTimeout`.
This has the side effect of repopulating the `devices` cache, with the `timeout` duration.  We decided to do this in https://github.com/flutter/flutter/pull/51678#discussion_r387157291 to avoid google3 breakages.
Plumbing it to `deviceDiscovertyTimeout` sounds like the right way to deprecate this. It can then be entirely removed after the stable branch cut.
Is this the same logic as in the engine?
Yes. With the refactor to using a function for fuchsia_ctl, it was easier to diff the two files and see that this was missing.
Ordering shouldn't matter here
We actually want the analytics now that each re-entrant build corresponds to a single flutter invocation
I tried to collapse most of the logic for creating the xcodebuild command using if/for elements - it should be easier to read for the most part...
Logic is the same, just un-nested the else on old L398
below
below
`BuildContext context`
"In this example, the context used is the one from the `Builder`, which is a child of the `FrogColor` widget, so this works:"
In this example, the context used is the one from the `MyOtherPage` widget, which is an ancestor of the `FrogColor` widget, so this does not work:
for clarity let's put a header like "## The \`.of\` method convention" or "Implementing \`.of\` methods" above the paragraph that starts "The convention...", and then a similar header above your new text e.g. "## Calling `\.of\` methods" or some such.
Added the type annotation but I think we need to explicitly name the inner context differently so that the developers who we target with this documentation will have an easier time seeing how this is a different context
done
done
done
"bellow" here should be "below"
oh i also meant to remove "DON'T" (and "DO" above). The writing style for the API docs try to avoid telling people what to do, they just give information and let the reader decide what to do with it.
 🤦‍♂️ oh, that's right
removed
removed the comments entirely as we now have similar text before each snippet
It looks like we only need one of L43 and L44?  And there's also a copy of `watchPerformance` in `macrobenchmarks`.  2s is not a very short time (vs ~10s sampling time), maybe we should also increase the timeout settings in `macrobenchmarks`. 
This sounds potentially flaky. Is there any way to improve coordination with the engine to avoid magic delays like this?
Good catch. I forgot to delete L44 during refactor.
Yes, it's flaky in terms of benchmark numbers (still have a chance to be bimodal and measuring the wrong thing), but not in terms of success/failure. It will be a net gain compared to our old version as the old ones have a higher chance of measuring the wrong thing.  We shall definitely have a more proper fix to solve this reliably. Created https://github.com/flutter/flutter/issues/64808 to track that.  
If the intention here is to wait for another 2 seconds, then I think you will need a fresh instance of `Future`.
Good catch. Fixed.
so `exit $LASTEXITCODE` is setting `%ERRORLEVEL%`?
Yes, by default when you run powershell with -Command, all non-zero exit codes are translated into `1`.  This LASTEXITCODE trick allows me to set the exit code to the value from the command, which I set to 2 specifically for the case where the version is incorrect.
Could you add a comment, just because I know I won't remember that? Otherwise, LGTM.
Added more details and combined the two comments
I _think_ this only exits you out of the subroutine and then actually not sure what it executes next (would it retry the subroutine again? That wouldn't make much sense since this error is unreoverable.). I would have expected this to set `exit_code` and then jump to `: final_exit`?
Might be worthwhile to leave a comment here why this is two (e.g. link it to the batch file)
/B is subroutine only - you can test this locally by removing the condition for the pwsh version detection, but it will immediately exit.
done
I wonder why we do the 'final_exit' dance below then... But if you tried this and it works: LGTM
Nit: line 33-37 can be simplified as `imageIndex = (imageIndex + 1) % 6`.
I wonder if more memory info (e.g., peak memory, average, percentile, etc.) from `DevToolsMemoryTest` (see, e.g., [this example][1]) or Timeline (see, e.g., [profiling_summarizer][2] and https://github.com/flutter/engine/pull/18516) would be helpful here? The DevTools works for Android and the Timeline works for iOS.  [1]: https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/complex_layout_scroll_perf__devtools_memory.dart  [2]: https://github.com/flutter/flutter/blob/master/packages/flutter_driver/lib/src/driver/profiling_summarizer.dart#L79
Done
commented out code?
unless you need the `null`, this can be `observatoryUri.complete()`
Done
Done
I am a bit worrying about removing this assert. If you take a look at line 529, the getMinChildIndexForScrollOffset should return child index whose scroll offset is <= scrollOffset  It feels like a user error to me.
after taking a look at the code again it seems fine to remove it. Let me think about it further if there is any corner case
This does not feel right, the paintExtent should be accurate represnt what is available on the screen. I think the issue may be sliver grid is calculating paint extent incorrectly. It finds the delta of leadingScrollOffset and trailingScrollOffset. There is no problem with trailingScrollOffset, but it assume the leadingScrollOffset is always the scroll offset of firstchild. but that may not be true because it can be place arbitrary on screen.  Do you have the repro for the hittest issue?
I think this is ok
I think this is ok actually. The test I added includes the `hitTest` repro.  In the test case, there are 2 containers in the grid, one on top of the other, each with a height of 100. So the `paintExtent` is 200 when they are laid out, that seems right.  Checking `geometry.hitTest` here does not consider _where_ they are actually painted, even though it is being compared to the mainAxisPosition of the gesture here. In the test case the `leadingScrollOffset` is 300, the `paintExtent`/`hitTest` would have to be 500 to pass `hitTest` as it is, and that wouldn't be correct.  `SliverGeometry.hitTest` cannot exceed the `paintExtent`, and defaults to be the `paintExtent`, so it is 200 as well. This does not correlate with the actual position of the children, but is the correct representation of what has been painted.  It works when we know the children are placed at the top of the grid, but this is not allowing arbitrary placement. So the `hitTest` and `paintExtent` are correct, the question is, "have I hit within the area of the `SliverGrid` where it _may_ have painted a child?" - since we don't know yet where the grid children are positioned. I think the `maxPaintExtent` is a good representation of the area where a child may be painted. Once it passes this check, the children are `hitTest`, and this is where it reconciles the positioning of the children. WDYT?
I thought of a better way to explain - the size of something does not necessary indicate its position. 
I think the current way of calculating the paint extent is not correct. according to the doc ``` The amount of currently visible visual space that was taken by the sliver to render the subset of the sliver that covers all or part of the [SliverConstraints.remainingPaintExtent] in the current viewport. ``` I attached a picture to demonstrate my thought. ![Untitled drawing (2)](https://user-images.githubusercontent.com/47866232/92029976-3823ed80-ed1b-11ea-81c9-e7d48c93a6b2.jpg)    
Interesting! I did not know the space should be included in the paintExtent. Let me try this and see how it comes out. :)
@chunhtai I think you are right, this should be the better way to fix the hitTest result. 🙂 
is the abs necessary? is it possible for the scroll offset to be come negative? even if it does we should still use the negative value to calculate the paint extent right?
A negative scrollOffset happens when you over scroll at the top. When I was checking this yesterday there was a case where a negative scroll offset resulted in an incorrect paintExtent. Like in our example, instead of 500, when the scrollOffset was -10, it incorrectly calculated a paintExtent of 490. Checking now, it isn't reproducing, so maybe we do not need it.
I took at calculatePaintOffset, if the scrollOffset is a negative number it should still correctly calculate the delta between from and to. I think we should remove the the abs if we cannot be reproduce it.
sgtm!
```suggestion       from: math.min(constraints.scrollOffset, leadingScrollOffset), ```
How aboue `error_handling_io.dart` for the file name?
What's the relationship between these `ignore`s and `https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/general.shard/forbidden_imports_test.dart` ?
Oh I see, this file was added as an exception but that changed when I renamed it
If you mirror the way the `ErrorHandlingFileSystem` is set up:  https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/globals.dart#L66  then tests that inject their own `ProcessManager` should also get wrapped in the `ErrorHandlingProcessManager`.
That seems like the opposite of what I want - if a test specifies a regular process manager it should get a regular process manager. This would match the behavior of the non-context tests
If we have tests with a mock process manager where the mock process manager throws a `ProcessException` with one of the errors now caught by the `ErrorHandlingProcessManager`, those tests are now testing something that can't actually happen.
that's true for context injected tests, but I don't think that we should require all of the context free tests to use the error handling filesystem/process manager.  testing cases that can't happen is definitely not idea - we should be able to handle this in code review by pointing out when something is redundant with the error_handling_io lib.  I'm more worried about tests which build up a large amount of injected interfaces being hard to understand for new contributors. Why does this process exception become a tool exit here, but not here? Or what instance am I actually using.
They do not look the same, I will either not mention the video or make them look similar.
This is the new check that these plugin frameworks haven't been `lipo`d to the iOS ARCHS.
This wasn't actually building for the simulator (it's missing `--simulator`) even with the `-d` flag. `flutter build ios` with a watch companion doesn't actually work.  Anyway the next thing this does is run on the simulator, which does work.
This adds a framework to the watch extension.  Previous this failed because `xcode_backend` `lipo`d all `.framework`s, even the ones in the watch extension with a different expected architecture.
Bitcode should be off for Runner.
Adding (any) plugin is what kicks the tool into running `pod install`, which we need to embed the watch framework.
This is the actual fix. Instead of `find`ing and thinning all `*.framework`s in `Runner.app`, it now only does so in the `Runner.app/Frameworks` directory.
Add a comment for what this is? It came from a pod?
never mind, the answer's here. Still good to comment in the other file. 
Why should bitcode be off? Bitcode is a requirement when you have a watch extension.
Because this is an integration test that will never be submitted to the App Store and I didn't want to track down [issues related to the pods building before the correct bitcode-embedded version of Flutter gets copied around](https://github.com/flutter/flutter/issues/39356#issuecomment-618138976).  I'll set it back to `YES` and see if this particular integration test triggers that case.
might be worth making this `final` as a further check that the callback only runs once
ObjectKey.value should probably be nullable
we should probably use oldElement throughout here (or not at all, but i see the benefit of avoiding the `!`s)
why do we need a `!` here?
oh because [] can return null, i see.
this should be non-nullable
we should make this one non-nullable and make its getter generate a pretty FlutterError for the case where it's null, saying something like "This widget has been unmounted, so the State no longer has a context (and should be considered defunct). Consider canceling any active work during "dispose" or using the "mounted" getter to determine if the State is still active."
we might get better diagnostics if we make _widget `late` rather than nullable
should be non-nullable
child should be non-nullable and required
child should be required, non-nullable
this can be late and the method can be non-nullable; this can throw in release builds, it's debug-only
`aspect` has to be nullable, no? I'm surprised this didn't either require "required" or "?".
can we make this non-null for consistency with AbstractNode?
all builders should return non-nullable Widgets
also context on builders should always be non-nullable
this should be non-nullable
state and _state should be non-nullable
please do me a favour and remove the "Notice that" here... :-)
we need to remove this cast (and not replace it with a copy). how we do that...
the real solution is a dart feature to cast the list cheaply. But in the meantime, let's make a private Element subclass that we create a single instance of and use that as our placeholder, and just before we return let's verify that the list doesn't contain any of them.
It would conflict with `AutomaticKeepAliveClientMixin.build` :  ```dart   @mustCallSuper   @override   Widget? build(BuildContext context) {     if (wantKeepAlive && _keepAliveHandle == null)       _ensureKeepAlive();     return null;   } ```
this field is compared to null at some place, so it can't be late.
Some null may be here accros all children.
Some null may be here accros all children.
Some null may be here accros all children.
I was also surprised with that some times ago. IIRC this is allowed because the method is abstract? But that looks actually quite strange. /cc @leafpetersen 
Yes, see the 9th bullet in this section: https://github.com/dart-lang/language/blob/master/accepted/future-releases/nnbd/feature-specification.md#errors-and-warnings , landed [here](https://github.com/dart-lang/language/pull/733).
we need to change `AutomaticKeepAliveClientMixin.build`, something like this should do (untested):  ```diff diff --git a/packages/flutter/lib/src/widgets/automatic_keep_alive.dart b/packages/flutter/lib/src/widgets/automatic_keep_alive.dart index b2ae057b3f..9b6e11d5f9 100644 --- a/packages/flutter/lib/src/widgets/automatic_keep_alive.dart +++ b/packages/flutter/lib/src/widgets/automatic_keep_alive.dart @@ -330,8 +330,7 @@ class KeepAliveHandle extends ChangeNotifier {  /// with [State] subclasses.  ///  /// Subclasses must implement [wantKeepAlive], and their [build] methods must -/// call `super.build` (the return value will always return null, and should be -/// ignored). +/// call `super.build` (though the return value should be ignored).  ///  /// Then, whenever [wantKeepAlive]'s value changes (or might change), the  /// subclass should call [updateKeepAlive]. @@ -397,6 +396,17 @@ mixin AutomaticKeepAliveClientMixin<T extends StatefulWidget> on State<T> {    Widget build(BuildContext context) {      if (wantKeepAlive && _keepAliveHandle == null)        _ensureKeepAlive(); -    return null; +    return const _NullWidget(); +  } +} + +class _NullWidget extends StatelessWidget { +  const _NullWidget(); +  @override +  Widget build(BuildContext context) { +    throw FlutterError( +      'Widgets that mix AutomaticKeepAliveClientMixin into their State must ' +      'call super.build() but must ignore the return value of the superclass.' +    );    }     }   ```
ah, i see, yeah. We should probably refactor that a bit but let's do that in a separate PR.
not sure what this means. ProxyWidget should never have a null child.
Weird, what's the reasoning?
this should be non-nullable and places where we create `IndexedSlot<Element>` should be `IndexedSlot<Element?>`.
we have to avoid this cast
you can use the same trick mentioned earlier with a `class _NullElement extends Element` with a static instance.
this ! should become unnecessary when you update to tip of tree
this one too
this should be non-nullable
for all builders, BuildContext should not be nullable
in all files we should avoid double-blank lines
The routes parameter should have a non-nullable argument type here (unlike the property)
same with navigationObservers
these two should have non-nullable types in the parameter list as well as being required
do we really use null as a key in this map?
should probably be non-nullable
as discussed elsewhere, we should return _NullWidget() or something here
parameter here should be non-nullable
add a `decoration != null` here to avoid the null deref below
can this just be late?
late would avoid this `!`
this should probably be non-nullable
this too
and this
shouldn't this be non-nullable? i guess this is the source of the `?`s I commented on above...
if we can get rid of the nullability above this one would go too
can we make this non-nullable? (_position would still need to be nullable, and updatePosition would need to be updated to refer to _position instead in some places)
how much trouble do we get in if all these are non-nullable?
these should probably be non-nullable too
i think we should try making these getters non-nullable (and maybe even the fields, though they'd have to be late). it might require removing some asserts.
this should be non-nullable unless there's a really good reason it has to be nullable...
use _pixels here not pixels, in case pixels is overriden; but, in theory, this should simplify back to the old code
in this case it might be possible to use List.generate.
Done
Done
Done
Done
Done.  Doing this change the test _Destination hero scrolls out of view mid-flight_ in `packages/flutter/test/widgets/heroes_test.dart` was failing. I fixed it with  https://github.com/flutter/flutter/pull/64672/commits/0cfceff260ce8ca98e0e4861c4ee28fbd4a43999#diff-b33b1120961b2c010e3388ede5bdf04aR493-R495. Not really sure if the fix is correct, could you take a look please?
There was `DefaultTextStyle.fallback` that was explicitly using null child. Please review https://github.com/flutter/flutter/pull/64672/commits/3750f394117651f6cb2593bbb5eb66112f3da708#diff-879a73856784f585a1665c1ace514899 and let me know if this looks good to you.
Done
Done
Done
Done. I've done some refactoring to avoid testing if depth is null. Changes have been done in https://github.com/flutter/flutter/pull/64672/commits/c0e5d54a217727487197e04802ada46c3cb882ab.
Done
Done
Done
Done
Done
Done
AFAICT `pixels` is still nullable in master. I don't understand your comment.
Done
In `SilverMultiBoxAdaptorElement` there's the following case that can return null:  ``` int? get childCount => widget.delegate.estimatedChildCount; ```  What should we do in this case?
Done
Done
`Local.countryCode` (used as key of the map) is nullable
Done
Done
no because child is nullable
Done
Done
but current cannot be late
Get ride of `?` means make data required in the constructor. Some tests create Draggable without data. Should we required data to create Draggable?
Done
Trying to make it non-nullable I face test failures:  ``` When the exception was thrown, this was the stack: #2      new _CastError._create (dart:core-patch/errors_patch.dart:110:27) #3      ScrollPosition.minScrollExtent (package:flutter/src/widgets/scroll_position.dart:139:49) #4      ScrollMetrics.copyWith (package:flutter/src/widgets/scroll_metrics.dart:51:48) #5      ScrollPosition.recommendDeferredLoading (package:flutter/src/widgets/scroll_position.dart:861:7) #6      Scrollable.recommendDeferredLoadingForContext (package:flutter/src/widgets/scrollable.dart:296:28) #7      ScrollAwareImageProvider.resolveStreamForKey (package:flutter/src/widgets/scroll_aware_image_provider.dart:98:20) ```
There are some specific handling when pixels is null. (Search `pixels == null`)
I replaces `pixels` with `_pixels` but I cannot go back to old code because `_pixels` is nullable.
Those are all about the initial value. At a minimum let's make `pixels` non-nullable and add a `hasPixels` getter that returns whether `_pixels` is non-null. The `pixels` getter itself is almost always assumed to return non-null.
yeah if we must make _pixels nullable then fair enough.
looks like it's the same thing about delayed setup of the initial value, though this one seems harder to deal with so let's just let it be nullable for now i guess.
cc @goderbauer any idea if any of our (non-test) customers (e.g. google3 or fuchsia) use Draggable without data?
I think that can be `widget.delegate.estimatedChildCount!` because childCount is only used when we're past the point where we're unable to render a child and estimatedChildCount is guaranteed to be non-null at that point.
ViewportOffset.pixels is non-nullable on master as far as I can tell.
yeah looks good
yeah that seems reasonable.
Seems reasonable!
humm... It looks like my cherry-pick of the widget migration made ViewportOffset.pixels nullable... I will take a look :-/
Just changing the return type to non-nullable and using `widget.delegate.estimatedChildCount!` causes several test failures.
Shouldn't dimensions be non-nullable? (it asserts that it is non-null below).
This seems pretty useless if the file is null (line and column mean nothing without a file).  I know there's a check for null in the `toString`, but I think this should be non-nullable.
Can you add a message to the `Error`?  Maybe this should be an `UnimplementedError` instead?
This doesn't really tell the user what to do about it.  Could you give more context? Like "...because no child widget was given" or something?
I think this can be `late`, and then the getter below can return a non-nullable value.
Done
`hasPixels` getter added.
Done
Done
hmm, let me look into this. I'll grab your branch and investigate once I'm done with perf and relanding #63146.
Like `pixels` there are place where null can happen. I introduced an `hasViewportDimension` but like `hasPixels` I'm not sure those names are good API compared to just check for nullability. As a user I would say that I should wrap every `.viewportDimension` into a block garded by `hasViewportDimension`.
See da6feed457
Another issue with non-nullable field is that `ScrollMetrics.copyWith` method doesn't work anymore if one of `has*` is false.
I was using the same pattern for `minScrollExtent` and `maxScrollExtent` and faced this copyWith issue.
Trying to make them non-nullable I faced several issue (in test) and even with an `bool get has*` method there's still the `ScrollMetrics.copyWith` issue that can not be solved.
I found a workaround for `ScrollMetrics.copyWith`. Let me know if the `has*` pattern looks good to you.
See ed04e18fdc
This method is inherited from `InlineSpan`. In `WidgetSpan` `dimensions` is required but in `TextSpan` `dimensions` can be nullable. So it's not possible to make the parameter required only in this branch.
Done
Changed to UnimplementedError
```   /// A const-constructable default text style that provides fallback values.   ///   /// Returned from [of] when the given [BuildContext] doesn't have an enclosing default text style.   ///   /// This constructor creates a [DefaultTextStyle] with an invalid [child], which   /// means the constructed value cannot be incorporated into the tree.   const DefaultTextStyle.fallback({ Key? key }) ```  I don't know what to add. Do you have a suggestion?
It cannot be late because it can be set to null: ```   @override   void didUpdateWidget(Shortcuts oldWidget) {     super.didUpdateWidget(oldWidget);     if (widget.manager != oldWidget.manager) {       if (widget.manager != null) {         _internalManager?.dispose();         _internalManager = null;       } else {         _internalManager ??= ShortcutManager();       }     }     manager!.shortcuts = widget.shortcuts;   } ```
How about this: ``` A DefaultTextStyle constructed with DefaultTextStyle.fallback cannot be incorporated into the widget tree, it is meant only to provide a fallback value returned by DefaultTextStyle.of() when no enclosing default text style is present in a BuildContext. ```
OK, makes sense.
It's way better than my poor english would have suggested :) thanks!
OK, I see. Can we mark the `manager` getter as non-nullable and return `widget.manager ?? _internalManager!` from it?  The `manager` getter shouldn't ever return null when accessed, since one or the other of `_internalManager` and `widget.manager` should always be non-null.
Can we keep hasPixels to ScrollPosition rather than putting it on VIewportOffset itself?
Done
`pixels` is currently used in `VIewportOffset.debugFillDescription` and we should guard its usage to avoid LazyInitializationError. That why I added `VIewportOffset.hasPixels`. Alternativelly we could move this `description.add('offset: ${pixels.toStringAsFixed(1)}');` to every child having the concret implementation of `double get pixels`.  ```diff diff --git a/packages/flutter/lib/src/rendering/viewport_offset.dart b/packages/flutter/lib/src/rendering/viewport_offset.dart index 3e986f8640..435cbfb182 100644 --- a/packages/flutter/lib/src/rendering/viewport_offset.dart +++ b/packages/flutter/lib/src/rendering/viewport_offset.dart @@ -94,9 +94,6 @@ abstract class ViewportOffset extends ChangeNotifier {    /// the value changes due to [correctBy]).    double get pixels;   -  /// Whether [pixels] property is available. -  bool get hasPixels; -    /// Called when the viewport's extents are established.    ///    /// The argument is the dimension of the [RenderViewport] in the main axis @@ -247,11 +244,7 @@ abstract class ViewportOffset extends ChangeNotifier {    /// If you override this, make sure to start your method with a call to    /// `super.debugFillDescription(description)`.    @mustCallSuper -  void debugFillDescription(List<String> description) { -    if (hasPixels) { -      description.add('offset: ${pixels.toStringAsFixed(1)}'); -    } -  } +  void debugFillDescription(List<String> description) { }  }    class _FixedViewportOffset extends ViewportOffset { @@ -263,9 +256,6 @@ class _FixedViewportOffset extends ViewportOffset {    @override    double get pixels => _pixels;   -  @override -  bool get hasPixels => true; -    @override    bool applyViewportDimension(double viewportDimension) => true;   @@ -294,4 +284,10 @@ class _FixedViewportOffset extends ViewportOffset {      @override    bool get allowImplicitScrolling => false; + +  @override +  void debugFillDescription(List<String> description) { +    super.debugFillDescription(description); +    description.add('offset: ${pixels.toStringAsFixed(1)}'); +  }  } diff --git a/packages/flutter/lib/src/widgets/scroll_position.dart b/packages/flutter/lib/src/widgets/scroll_position.dart index 2537333b73..25864e3cea 100644 --- a/packages/flutter/lib/src/widgets/scroll_position.dart +++ b/packages/flutter/lib/src/widgets/scroll_position.dart @@ -901,6 +901,8 @@ abstract class ScrollPosition extends ViewportOffset with ScrollMetrics {      if (debugLabel != null)        description.add(debugLabel!);      super.debugFillDescription(description); +    if (hasPixels) +      description.add('offset: ${pixels.toStringAsFixed(1)}');      description.add('range: ${_minScrollExtent?.toStringAsFixed(1)}..${_maxScrollExtent?.toStringAsFixed(1)}');      description.add('viewport: ${_viewportDimension?.toStringAsFixed(1)}');    } diff --git a/packages/flutter/test/rendering/slivers_block_test.dart b/packages/flutter/test/rendering/slivers_block_test.dart index cdb61b8add..05bb823a61 100644 --- a/packages/flutter/test/rendering/slivers_block_test.dart +++ b/packages/flutter/test/rendering/slivers_block_test.dart @@ -79,9 +79,6 @@ class ViewportOffsetSpy extends ViewportOffset {    @override    double get pixels => _pixels;   -  @override -  bool get hasPixels => true; -    bool corrected = false;      @override ```  WDYT?
Ok, use this commit, it should solve our problems: https://github.com/flutter/flutter/commit/00f5d1ce9897b2d353fb69df5cfccc62ebeb78db (disclaimer: i'm still running all the tests so there's the possibility something other than the tests that failed before will now fail, but in theory the new code is just a slightly more efficient version of the old code so we should be good...)
I cherry-picked your commit. Thanks!
any idea what the cause of this one is? Is this something we'll run into again when we update the tests, or is the null check happening in widgets code?
~~ok let's leave all those as nullable then~~
that looks good except i would just call it "hasScrollExtents" rather than having both, since they should always be set together
viewportDimension should get set at the same time as the scroll extents iirc, can we use the same getter for all three?
or hasDimensions since viewportDimensions could maybe also be part of it
Interesting trade-off. I think you were probably right the first time, ViewportOffset.hasPixels makes sense since I guess we're saying in the fillDescription that it is legitimate that it can sometimes be null.
never mind, i have a fix for this one in another PR
https://github.com/flutter/flutter/pull/65135 - makes the error message better, and changes the specific test here to not worry about the exact error message in the first place, since that's not what it's about.
```suggestion     for (FocusNode node in ancestors) {       if (node is FocusScopeNode)         return node;     }     return null; ```
@a14n well in any case aspect here should be nullable
this can be non-nullable, since the assert before ensures that a directionality is available
```suggestion     final double iconOpacity = iconTheme.opacity ?? 1.0; ```
looks like this one should be non-nullable, maybe just default to false?
this can be non-nullable, it's only ever called with `this` as the argument value
this should be non-nullable; you can remove the body of the `dispose` method.
(for all of these) "Whether _the_ [foo] property is available"
seems like this should be non-nullable?
ancestor should be non-null
ancestor should be non-null
Done
As there are 2 methods (`applyViewportDimension` and `applyContentDimensions`) it seems legit to have 2 get `has*`.   IMHO if we'd like to have a single `hasDimensions` we should try to have a single  `applyDimensions` instead of the 2 `apply*` above. But regarding test failures I faced (trying to have a single `haveDimensions`) it seems to have cases where scrollExtents and viewportDimension are not all null or all non-null.  BTW should we use `hasContentDimensions` instead of `hasScrollExtents` to have the same naming as `apply*`?
Done
Done
Done
Done
Done
Done
Done
Done
This change leads to several failure in tests (that I'm not sure how to fix).
k, i'll look into it
Sure, hasContentDimensions and hasViewportDimensions works for me.
I changed `hasScrollExtents` to `hasContentDimensions`
Quick scan in google3 seems to indicate that Draggable is never used without data. Not sure about fuchsia...
Does this have to be late? It's assigned in both branches. Should not be needed.
Right! And moreover it could be made final.  It would be great to have an hint to detect unnecessary `late` like this one.
Actually `final` is not yet accepted by CFE (unlike analyzer)  I just remove `late`.
The request to hint/lint unncessary late is tracked at dart-lang/linter#2205
This `extends Object` change is failing many google3 tests where generic types are omitted. Example code: https://gist.github.com/goderbauer/244c5f19f69bb36d4a136d176ad189c4
This is causing failures in google3 where people extend ViewportOffset. 
Self-nit: remove this flag / TODO
@godofredoc do you know if fuchsia_ctl needs the flags to be ordered this way? It makes it hard to read to have the command mixed in with the flags.
Yes, -d is an option for the core command and the ones after "ssh" applies only to the ssh command.
Here and below: Very minor nit, source files should [end with a linefeed](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline). That said, that's probably more pedantic than anything -- I'm 99% certain that the entire Dart toolchain consistently handles this just fine without it. But not a bad idea anyway.
Added missing null checks
Added missing null checks, just in case ...
unskipped test that failed without addition of "just in case" null checks above.
Added test case for missed null android sdk case for diagnostics
There is already code in the FlutterProject class to parse all of this information, why are you repeating the process yourself?
didn't know . I m using it now in the new commit 
Please don't reformat the files
i will revert
I don't think this is the way to do it. If you want to insert it into the html, it should be as markup. Otherwise a JSON asset file seems like a reasonable way to go
in one comment ditman suggested to inject it in a script tag .so i tried to do that.
if that's not okay , i will revert to the previous way . 
if you inject it into a script tag you will need to use a javascript API to read it. Whereas you can use package:http JSON parse to read the version info in a json asset
Could you avoid duplicating this logic twice?
This isn't really ever testing that the contents are correct. Perhaps a unit test of your helper method to confirm it contains the correct details?
here and elsewhere: newline at EOF
is this getting added to the output dependencies? Also, you need a test that this rule is doing the right thing
yes. it is getting added to the output dependancies.
Rather than in utils, why not make this a method on `FlutterProject` itself?
here at elsewhere, add a newline at EOF
You can remove the `foo.txt` setup/assertion from this test, since it isn't what is being tested
add a newline between this test case and the previous one
can you put this space back?
Create the flutter manifest once, then pass it into the flutter project. You also should use a `MemoryFileSystem.test` instead of the globals.fs, like:   ``` final MemoryFileSystem fileSystem = MemoryFileSystem.test(); final FlutterManifest manifest = FlutterManfiest.createFromString(''' ... content goes here '''); final FlutterProject flutterProject = FlutterProject(fileSystem.current, manifest, logger: BufferLogger.test());   ```
Thanks for adding that test, this is fine now
please add this space back
spaces after `,`
prefer 2 space indent
please revert this change
space above and give this a doc comment describing what it does
newline at EOF
```suggestion          expect(environment.outputDir.childFile('version.json'),exists); ```
```suggestion              testUsingContext('Version.json info is correct',(){ ```
formatting please
`...containing the [appName], [version], and [buildNumber]`
```suggestion        testUsingContext('Version.json info is correct', (){ ```
```suggestion         final FlutterManifest manifest = FlutterManifest.createFromString('''     name: test     version: 1.0.0+3     ''', logger: BufferLogger.test()); ```
```suggestion ```
```suggestion     expect(environment.outputDir.childFile('version.json'), exists); ```
This should explain what the example does.
formatting here is odd: please use a trailing comma for argument lists and indent by two spaces.
nit: sentences should end with `.`
Instead of building a new animation/tween: These could be stored in instance variables that get re-used.
@goderbauer Sorry for late reply. I added a simple explanation of the example code. Hope this one would be better.
@goderbauer I fixed the formatting issues. Thank you for letting me know it.
@goderbauer I added `.` while I adding an explanation of the example.
@goderbauer I tried to modify the example as you said. I hope this one would be better.
nit: can you add line breaks to the sentence to keep the number of characeters under 80 per line.
nit: add a trailing comma to the end of this line
nit: add a trailing comma to the end of this line
@goderbauer Thank you for letting me know it. I fixed it.
@goderbauer I added a trailing comma. Thank you for letting me know it.
@goderbauer I added a trailing comma. Thank you.
If the .. will be less.., so switch them.
Fixed.
I remove the gap between the inactive track and active track, also see #64534 
nit: that
It may change the previous behaviour if `parentData` is null. I guest it can not be null?
Duplicated line
if you're painting then you must have parentData, yeah.
Why is this still specified as an annotation? 
because this file is still opted-out (in widgets)
IIRC the reason these were added is that dart2js could not optimize the function otherwise. If that is still the case I would expect  it to show up on the web size benchmarks
This function makes me sad
Ah, that makes sense! Thanks.
we haven't migrated widgets/ yet. This is just making sure we make the right call when we get to it.
yeah...
Based on the history, @dnfield added the original `if (kReleaseMode) return` logic, then @ferhatb added the `assert()` around the body. This removes the if condition and leaves the assert so that the method can be non-nullable. I think it was ferhat's change that improved size, and this keeps that logic. Let's keep an eye on the numbers though, certainly...
Ahh, yeah - I think I was remembering it backwards
The problem with making this an assert is that profile mode will no longer show as much helpful information. But I guess we don't have any tests covering that and no one is complaining about it so oh well.
My general opinion on this is release and profile should be as close to identical as possible except for the minimum required to actually enable collecting metrics.
Why make this a JS expression? It will effectively compile to `if (true)` and `if (false)`. If put the if outside the string interpolation we could just not emit the `else` branches.
nit: I'd probably write this as:  ```javascript if (!response) {   throw error; } return response; ```  So that the "normal" flow is outside the branch.
Would be good to spend a sentence for each option on explaining the use-case. For example: "online-only is useful if you don't want any local caching but still support adding/installing the app on the home screen as a PWA."
Can't this just be in the SizeAnalyzer class?
ya, I might be missing something but at a glance, it seems like everything you need is already in analyzeAotSnapshot. 
Done!
ultra nit: since we're doing construction injection now and this file is new, should all these be private?
the second `)` should at a new line
replace with: Slider track paints correctly when the shape is rectangular
trailing comma here
NICE. This is all much more obvious.
Can this just be: ``` bool get canListDevices => _androidSdk?.adbPath != null; ```
ditto
Are there any other uses of `which`?
We use this in coverage to look for lcov, and to look for Java if the android studio Java is missing
Completely unused
Ignore exceptions thrown when trying to delete the file.
Will permissions errors on this operation be handled by the ErrorHandlingFileSystem?
Ignoring exceptions here too is probably a good idea.
```dart if (d.listSync().isNotEmpty) {   break; } try {   d.deleteSync(); } catch FileSystemException {   ... } ```
How about counting down instead of up? ```dart int retries = 2; while (retries > 0) { ... retries -= 1; } ```
Then maybe you get something a bit easier: ```dart while (true) { ...   } on ProcessException {     retries -= 1;     if (retries == 0) {       rethrow;     }     ... } ```
The decrement should go before the `if (retries == 0)` I think.
woops!
Updated the error handling filesystem to wrap Directory.createSync
Up to you, but I'm wondering if it makes sense to pull this out under `base/`
I think at this point it is too tied to the cache API. I think it might make sense to consider combining this with the `Net` class in the future, at which point it will be more coherent and `base/` will make more sense IMO
Can the comment also include the reason why this delay is added?
Done.
This is the fix, it turns out the isolate runnable event was coming from the compute isolate, and removing it caused the test to hang. Instead we can use the point where we start registering package:flutter service extensions as an indication that the hot restart is complete
I think intent of this code was to wait for IsolateRunnable corresponding to the main isolate. Are we not seeing main isolate IsolateRunnable event, only see one for the compute isolate?
Yes, this starts listening too late to pick up the main isolate runnable. I think this is OK to switch to the extension event, because it more accurately measures when we could reasonably perform another hot reload ( though If I see a large change in the benchmarks I can investigate)
This is rather unfortunate. I think we do want to ensure we subscribe to the vm service events before we restart isolate. At a minimum let's add a comment/todo explaining why we are listening for ServiceExtensionAdded instead of IsolateRunnable.
Done
`.single` instead of `removeLast()` to capture that there's only been one call?
I don't think thats how verify works, the verification result is created once.
I guess we could clear the state between each test run
I believe single is a property and not a method.
darn my attempts to edit via github UI
As you've already added the SkSL version for gallery, I wonder if it's easy to add the SkSL version for cubic_bezier_perf in this PR so we can have 1 less TODO. It will our tech debt :D
Done. Tested against my Xiaomi MIX2 and seems normal. 
The font size change here (and the one below) looks good to me. It matches what I saw in Xcode too. I'm not sure how the rest of them (height and letterSpacing) are derived. Could you document where these values came from (similar to https://github.com/flutter/flutter/issues/21302)? This will help other maintainers when they revise these values.
Sure! I've added code comments.
You are saying the values are from the said plugin, but you had to make some adjustments?
Yup, that's right. Some rounding off and visual comparison is needed after deriving values from the plugin. What I got from the plugin: * Title ```dart fontSize: 17, letterSpacing: -0.544, // Rounded up to -0.5 height: 1.2941176470588236, // Rounded up to 1.3 ``` * Content ```dart fontSize: 13, letterSpacing: -0.10400000000000001, height: 1.2307692307692308, ``` The title `TextStyle` is okay, but content `TextStyle` needed adjustments. When rounded `letterSpacing` and `height` of content to -0.1 and 1.2, the result looks like below. | Before | Native Dialog | Before adjustments | After adjustments | |---|---|---|---| | <img src="https://user-images.githubusercontent.com/33684401/93506339-1780a800-f957-11ea-9f45-f2226c7ab23a.png"> | <img src="https://user-images.githubusercontent.com/33684401/91070565-d952da00-e671-11ea-9364-8048a859382e.png"> | <img src="https://user-images.githubusercontent.com/33684401/93506241-f7e97f80-f956-11ea-969e-eb3a753f8cef.png"> |<img src="https://user-images.githubusercontent.com/33684401/91070605-e8d22300-e671-11ea-92d8-ca56685ab3ca.png"> |  So by comparing visually, I updated the content `letterSpacing` and `height` to -0.2 and 1.35.
does this fail when you don't include the change to sliver_grid.dart?
@Hixie Yes, it will throw exception in master branch:  ``` Running "flutter pub get" in flutter...                             1.8s ══╡ EXCEPTION CAUGHT BY RENDERING LIBRARY ╞═════════════════════════════════════════════════════════ The following assertion was thrown during performLayout(): 'package:flutter/src/rendering/sliver_grid.dart': Failed assertion: line 163 pos 15: 'childMainAxisExtent != null && childMainAxisExtent >= 0': is not true.  Either the assertion indicates an error in the framework itself, or we should provide substantially more information in this error message to help you determine and fix the underlying cause. In either case, please report this assertion by filing a bug on GitHub:   https://github.com/flutter/flutter/issues/new?template=BUG.md  When the exception was thrown, this was the stack: #2      new SliverGridRegularTileLayout (package:flutter/src/rendering/sliver_grid.dart:163:15) #3      SliverGridDelegateWithFixedCrossAxisCount.getLayout (package:flutter/src/rendering/sliver_grid.dart:335:12) #4      RenderSliverGrid.performLayout (package:flutter/src/rendering/sliver_grid.dart:529:51) #5      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #6      RenderViewportBase.layoutChildSequence (package:flutter/src/rendering/viewport.dart:486:13) #7      RenderViewport._attemptLayout (package:flutter/src/rendering/viewport.dart:1491:12) #8      RenderViewport.performLayout (package:flutter/src/rendering/viewport.dart:1400:20) #9      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #10     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #11     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #12     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #13     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #14     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #15     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #16     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #17     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #18     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #19     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #20     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #21     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #22     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #23     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #24     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #25     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #26     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #27     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #28     RenderConstrainedBox.performLayout (package:flutter/src/rendering/proxy_box.dart:270:13) #29     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #30     RenderPositionedBox.performLayout (package:flutter/src/rendering/shifted_box.dart:396:13) #31     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #32     RenderView.performLayout (package:flutter/src/rendering/view.dart:169:13) #33     RenderObject._layoutWithoutResize (package:flutter/src/rendering/object.dart:1645:7) #34     PipelineOwner.flushLayout (package:flutter/src/rendering/object.dart:896:18) #35     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1091:23) #36     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5) #37     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15) #38     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9) #39     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9) #42     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #43     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27) #44     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22) #47     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #48     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27) #49     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20) #50     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29) <asynchronous suspension> #51     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart) #52     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19) <asynchronous suspension> #55     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14) #56     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24) #57     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54) #62     withClock (package:clock/src/default.dart:48:10) #63     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22) #68     FakeAsync.run (package:fake_async/fake_async.dart:178:7) #69     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15) #70     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24) #71     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19) <asynchronous suspension> #72     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart) #77     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13) #78     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15) #83     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5) #84     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17) <asynchronous suspension> #85     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart) #90     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9) #91     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15) #92     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7) #99     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11) #100    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11) #101    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16) #106    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5) #107    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7) #125    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12) #126    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31) #130    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11) #164    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21) #172    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23) #173    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46) #183    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41) #192    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33) #193    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14) (elided 117 frames from class _AssertionError, dart:async, and package:stack_trace)  The following RenderObject was being processed when the exception was fired: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT:   creator: SliverGrid ← Viewport ← IgnorePointer-[GlobalKey#b5d38] ← Semantics ← _PointerListener ←     Listener ← _GestureSemantics ←     RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ← _PointerListener ← Listener     ← _ScrollableScope ← _ScrollSemantics-[GlobalKey#1b0e4] ← ⋯   parentData: paintOffset=Offset(0.0, 0.0) (can use size)   constraints: SliverConstraints(AxisDirection.down, GrowthDirection.forward, ScrollDirection.idle,     scrollOffset: 0.0, remainingPaintExtent: 4.0, crossAxisExtent: 4.0, crossAxisDirection:     AxisDirection.right, viewportMainAxisExtent: 4.0, remainingCacheExtent: 254.0, cacheOrigin: 0.0)   geometry: null   no children current live This RenderObject has no descendants. ════════════════════════════════════════════════════════════════════════════════════════════════════ ══╡ EXCEPTION CAUGHT BY RENDERING LIBRARY ╞═════════════════════════════════════════════════════════ The following NoSuchMethodError was thrown during performLayout(): The method 'debugAssertIsValid' was called on null. Receiver: null Tried calling: debugAssertIsValid()  When the exception was thrown, this was the stack: #0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5) #1      RenderViewportBase.layoutChildSequence (package:flutter/src/rendering/viewport.dart:502:34) #2      RenderViewport._attemptLayout (package:flutter/src/rendering/viewport.dart:1491:12) #3      RenderViewport.performLayout (package:flutter/src/rendering/viewport.dart:1400:20) #4      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #5      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #6      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #7      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #8      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #9      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #10     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #11     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #12     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #13     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #14     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #15     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #16     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #17     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #18     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #19     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #20     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #21     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13) #22     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #23     RenderConstrainedBox.performLayout (package:flutter/src/rendering/proxy_box.dart:270:13) #24     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #25     RenderPositionedBox.performLayout (package:flutter/src/rendering/shifted_box.dart:396:13) #26     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7) #27     RenderView.performLayout (package:flutter/src/rendering/view.dart:169:13) #28     RenderObject._layoutWithoutResize (package:flutter/src/rendering/object.dart:1645:7) #29     PipelineOwner.flushLayout (package:flutter/src/rendering/object.dart:896:18) #30     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1091:23) #31     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5) #32     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15) #33     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9) #34     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9) #37     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #38     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27) #39     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22) #42     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #43     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27) #44     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20) #45     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29) <asynchronous suspension> #46     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart) #47     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19) <asynchronous suspension> #50     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14) #51     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24) #52     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54) #57     withClock (package:clock/src/default.dart:48:10) #58     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22) #63     FakeAsync.run (package:fake_async/fake_async.dart:178:7) #64     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15) #65     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24) #66     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19) <asynchronous suspension> #67     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart) #72     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13) #73     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15) #78     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5) #79     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17) <asynchronous suspension> #80     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart) #85     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9) #86     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15) #87     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7) #94     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11) #95     LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11) #96     RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16) #101    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5) #102    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7) #120    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12) #121    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31) #125    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11) #159    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21) #167    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23) #168    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46) #178    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41) #187    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33) #188    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14) (elided 115 frames from dart:async and package:stack_trace)  The following RenderObject was being processed when the exception was fired: RenderViewport#ac634 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE:   needs compositing   creator: Viewport ← IgnorePointer-[GlobalKey#b5d38] ← Semantics ← _PointerListener ← Listener ←     _GestureSemantics ← RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ←     _PointerListener ← Listener ← _ScrollableScope ← _ScrollSemantics-[GlobalKey#1b0e4] ←     RepaintBoundary ← ⋯   parentData: <none> (can use size)   constraints: BoxConstraints(w=4.0, h=4.0)   size: Size(4.0, 4.0)   axisDirection: down   crossAxisDirection: right   offset: ScrollPositionWithSingleContext#2038a(offset: 0.0, range: null..null, viewport: 4.0,     ScrollableState, AlwaysScrollableScrollPhysics -> ClampingScrollPhysics ->     RangeMaintainingScrollPhysics, IdleScrollActivity#1bdef, ScrollDirection.idle)   anchor: 0.0 This RenderObject had the following child:     center child: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT ════════════════════════════════════════════════════════════════════════════════════════════════════ ══╡ EXCEPTION CAUGHT BY RENDERING LIBRARY ╞═════════════════════════════════════════════════════════ The following NoSuchMethodError was thrown during paint(): The getter 'visible' was called on null. Receiver: null Tried calling: visible  When the exception was thrown, this was the stack: #0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5) #1      RenderViewportBase._paintContents (package:flutter/src/rendering/viewport.dart:620:26) #2      RenderViewportBase.paint (package:flutter/src/rendering/viewport.dart:614:7) #3      RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #4      PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11) #5      PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5) #6      PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7) #7      PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7) #8      RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #9      RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #10     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #11     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #12     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #13     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #14     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #15     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #16     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #17     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #18     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #19     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #20     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #21     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #22     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #23     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #24     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #25     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #26     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #27     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #28     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11) #29     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5) #30     PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7) #31     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7) #32     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #33     RenderCustomPaint.paint (package:flutter/src/rendering/custom_paint.dart:578:11) #34     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #35     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #36     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #37     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #38     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11) #39     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5) #40     PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7) #41     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7) #42     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15) #43     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #44     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #45     RenderShiftedBox.paint (package:flutter/src/rendering/shifted_box.dart:72:15) #46     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #47     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13) #48     RenderView.paint (package:flutter/src/rendering/view.dart:215:15) #49     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7) #50     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11) #51     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5) #52     PipelineOwner.flushPaint (package:flutter/src/rendering/object.dart:989:29) #53     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1095:27) #54     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5) #55     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15) #56     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9) #57     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9) #60     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #61     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27) #62     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22) #65     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #66     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27) #67     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20) #68     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29) <asynchronous suspension> #69     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart) #70     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19) <asynchronous suspension> #73     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14) #74     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24) #75     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54) #80     withClock (package:clock/src/default.dart:48:10) #81     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22) #86     FakeAsync.run (package:fake_async/fake_async.dart:178:7) #87     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15) #88     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24) #89     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19) <asynchronous suspension> #90     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart) #95     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13) #96     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15) #101    Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5) #102    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17) <asynchronous suspension> #103    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart) #108    Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9) #109    Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15) #110    Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7) #117    Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11) #118    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11) #119    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16) #124    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5) #125    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7) #143    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12) #144    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31) #148    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11) #182    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21) #190    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23) #191    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46) #201    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41) #210    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33) #211    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14) (elided 115 frames from dart:async and package:stack_trace)  The following RenderObject was being processed when the exception was fired: RenderViewport#ac634:   needs compositing   creator: Viewport ← IgnorePointer-[GlobalKey#b5d38] ← Semantics ← _PointerListener ← Listener ←     _GestureSemantics ← RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ←     _PointerListener ← Listener ← _ScrollableScope ← _ScrollSemantics-[GlobalKey#1b0e4] ←     RepaintBoundary ← ⋯   parentData: <none> (can use size)   constraints: BoxConstraints(w=4.0, h=4.0)   layer: OffsetLayer#114a6 DETACHED   size: Size(4.0, 4.0)   axisDirection: down   crossAxisDirection: right   offset: ScrollPositionWithSingleContext#2038a(offset: 0.0, range: null..null, viewport: 4.0,     ScrollableState, AlwaysScrollableScrollPhysics -> ClampingScrollPhysics ->     RangeMaintainingScrollPhysics, IdleScrollActivity#1bdef, ScrollDirection.idle)   anchor: 0.0 This RenderObject had the following child:     center child: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT ════════════════════════════════════════════════════════════════════════════════════════════════════ ══╡ EXCEPTION CAUGHT BY SCHEDULER LIBRARY ╞═════════════════════════════════════════════════════════ The following NoSuchMethodError was thrown during a scheduler callback: The getter 'visible' was called on null. Receiver: null Tried calling: visible  When the exception was thrown, this was the stack: #0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5) #1      RenderViewportBase.visitChildrenForSemantics.<anonymous closure> (package:flutter/src/rendering/viewport.dart:216:57) #2      WhereIterator.moveNext (dart:_internal/iterable.dart:442:13) #3      Iterable.forEach (dart:core/iterable.dart:283:23) #4      RenderViewportBase.visitChildrenForSemantics (package:flutter/src/rendering/viewport.dart:217:10) #5      RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #6      RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #7      RenderIgnorePointer.visitChildrenForSemantics (package:flutter/src/rendering/proxy_box.dart:3121:14) #8      RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #9      RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #10     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #11     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #12     RenderSemanticsAnnotations.visitChildrenForSemantics (package:flutter/src/rendering/proxy_box.dart:4450:11) #13     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #14     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #15     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #16     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #17     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #18     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #19     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #20     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #21     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #22     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #23     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #24     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #25     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #26     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #27     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #28     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #29     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #30     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #31     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #32     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #33     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #34     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #35     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #36     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #37     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #38     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #39     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #40     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #41     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #42     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #43     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #44     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #45     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #46     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #47     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #48     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #49     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #50     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61) #51     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14) #52     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5) #53     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5) #54     RenderObject._updateSemantics (package:flutter/src/rendering/object.dart:2637:41) #55     PipelineOwner.flushSemantics (package:flutter/src/rendering/object.dart:1092:16) #56     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1100:31) #57     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5) #58     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15) #59     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9) #60     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9) #63     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #64     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27) #65     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22) #68     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41) #69     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27) #70     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20) #71     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29) <asynchronous suspension> #72     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart) #73     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19) <asynchronous suspension> #76     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14) #77     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24) #78     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54) #83     withClock (package:clock/src/default.dart:48:10) #84     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22) #89     FakeAsync.run (package:fake_async/fake_async.dart:178:7) #90     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15) #91     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24) #92     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19) <asynchronous suspension> #93     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart) #98     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13) #99     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15) #104    Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5) #105    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17) <asynchronous suspension> #106    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart) #111    Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9) #112    Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15) #113    Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7) #120    Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11) #121    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11) #122    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16) #127    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5) #128    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7) #146    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12) #147    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31) #151    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11) #185    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21) #193    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23) #194    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46) #204    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41) #213    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33) #214    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14) (elided 115 frames from dart:async and package:stack_trace) ════════════════════════════════════════════════════════════════════════════════════════════════════ ══╡ EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ╞════════════════════════════════════════════════════ The following TestFailure object was thrown running a test:   Expected: null   Actual: 'Multiple exceptions (4) were detected during the running of the current test, and at least one was unexpected.'  When the exception was thrown, this was the stack: #4      main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:345:7) <asynchronous suspension> #5      main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart) #6      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29) <asynchronous suspension> #7      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart) #8      TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19) <asynchronous suspension> #11     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14) #12     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24) #13     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54) #18     withClock (package:clock/src/default.dart:48:10) #19     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22) #24     FakeAsync.run (package:fake_async/fake_async.dart:178:7) #25     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15) #26     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24) #27     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19) <asynchronous suspension> #28     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart) #33     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13) #34     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15) #39     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5) #40     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17) <asynchronous suspension> #41     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart) #46     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9) #47     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15) #48     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7) #55     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11) #56     LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11) #57     RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16) #62     RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5) #63     RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7) #81     _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12) #82     new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31) #86     CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11) #120    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21) #128    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23) #129    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46) #139    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41) #148    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33) #149    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14) (elided 111 frames from dart:async and package:stack_trace)  This was caught by the test expectation on the following line:   file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart line 345 The test description was:   SliverGrid negative usableCrossAxisExtent ════════════════════════════════════════════════════════════════════════════════════════════════════ Test failed. See exception logs above. The test description was: SliverGrid negative usableCrossAxisExtent  ✖ SliverGrid negative usableCrossAxisExtent Exited (1) ```
`kTertiaryButton`? Should probably be primary, no?
Can you add some more information here about when this will fire? e.g. after the down even of the second tap? May also be helpful to put this in relation to onTapDown (presumably, that one will fire for the first tap down - does it also fire for the second down?)
Good catch - fixed.
Done.
Why is this `binding.pump` instead of `tester.bump` as line 97 and 104?
Nit: I guess `binding.samplingOffset` here should be `const Duration(microseconds: -5500)`? I might be clearer to create a constant and use it in line 93, 100, 106, and 114.
Nit: `now` seems to be a little confusing. `currentTestFrameTime` might be a little more clear?
This is a nit. I changed it to `tester.pump`
Done
Using `binding.samplingOffset` is in David's version. I changed it to `kSamplingOffset`, but I don't get why this is better. 
I think it's a little better because 1. if the binding somehow gets the `samplingOffset` wrong, the `kSamplingOffset` version of `expect` would catch that while the `binding.sampleOffset` version of `expect` won't. 2. David's original version uses `GestureBinding.instance.samplingOffset` which would match the `GestureBinding.instance.samplingOffset = kSamplingOffset` in a simple text search. In the new version, `binding` isn't immediately obvious to be the same as `GestureBinding.instance` (but I believe they're the same).
```suggestion   String get flutterChooseOne => 'Please choose one (To quit, press "q/Q"):'; ```
Instead of exiting, use `throwToolExit('')`
I would also add 'Q'
Can you add a test case for q/Q?
leave the message blank. exitCode 0 is the default so it isn't necessary either.
Are you sure? `throwToolExit('')` exitCode will be `null`
we don't need to tell the user why we exited if they asked to exit
``` expect(e.exitCode, 0); expect(e.message, contains('exit from choose')); ```  with clear test message may help
```suggestion }  ```
```suggestion   testWidgets('Dismissible.behavior should correctly control hit testing', (WidgetTester tester) async { ``` or something more readable.
Do you recommend I rename it to behavior instead of hitTestBehavior @dkwingsmt ? Also, what do you mean by test the default argument? I do test for HitTestBehavior.opaque. Thanks 😄 !
I didn't notice you were using `hitTestBehavior`. I do recommend renaming it to `behavior`, since it seems to be the convention of most widgets (all widgets but platform views).  We want to make sure that when the `behavior` argument is not provided, `Dismissible` is acting the same way as `opaque`, since someone might change the default argument by mistake without getting caught by your current tests.
The old test was a little more strict (`called(1)`)?
Took another pass
```suggestion       matchesGoldenFile('container.clipBehaviour.with.shadow.png'), ``` The library name does not need to be included. It is handled manually. :)
perhaps add a comment regarding "50 * 1024" number?
Done
```suggestion   /// By default, the background color is transparent unless selected. Selected rows have ```
```suggestion   /// The background color for the data rows. ```
I think you could use a macro here to include much more detail about decorations
Is it actually translucent, as in you can see behind the data table? Otherwise, use a different term
```suggestion   /// The effective background color can be made to depend on the [MaterialState] state, i.e. if the ```
I think this means it's over the inkwell but below the text, is that correct? Could tweak to clarify
same here, I think there might be a useful macro
```suggestion   /// The background color of the heading row. ```
```suggestion   /// The effective color can be made to depend on the [MaterialState] state, i.e. if the ```
Is it possible to press a heading row?
nit: stay consistent for all properties, either 'This value defaults to' or ' By default, ...'
```suggestion   /// The padding between the header text and the sort icon. ```
Could this be showBottomBorder instead?
This doesn't feel super useful, was it an ask?
nit: may be more readable in 3 lines
Will this icon still be visible by default in dark mode?
remind me why we add these?
ensure the order in `data_table.dart` matches the order for DataTable theme properties
macrofy all of these and use the macros in the `data_table.dart` to avoid  disadvantages of documenting twice
nit: same order as parameters
nit: same order as parameters
maybe you should add the missing missing DiagnosticsProperties
To avoid nullable problems internally afaik
Yeah Im curious about the need for being able to customize this one
```suggestion   /// By default, a divider is not shown at the bottom to allow for a border ```
Do these need to be public?   Though if you make them private, you'll have to update the above documentation to instead have the actual values instead of referencing these.
`dataTableTheme` should never be null since it gets initialized in the `ThemeData` constructor. You can remove the `?` here and everywhere else.  ```suggestion       ?? themeData.dataTableTheme.horizontalMargin ```
Nit: Use your full GH username for the todo
```suggestion class DataTableThemeData with Diagnosticable { ```
Looks like this line is repeated 3 times
This line is repeated from above
```suggestion               letterSpacing: 0.0, // Will overflow if letter spacing is larger than 0.0. ```
Why are all the `first`s necessary? What changed to cause these to be needed?
Why is this needed?
Extra new line not needed
I looked at BoxDecoration and the Ink widget, neither of them has any templates, and they are not more specific about documentation the decoration parameter, so I'll leave this out.
That is correct
I could not find a useful macro or template for TextStyle. I think by going to TextStyle directly they can find useful enough information.
Yes if its sortable. I can add that.
I will remove this one parameter, I thought initially I would need it for internal usages but probably not needed.
Good catch
It is due to the change to how the padding is added to the sort icon. Now that I remove that option, I can revert this change actually.
To keep the test the same I could either update the variables that we `expect` or set the style to be the same as before.  Seems like it's confusing to just add the textStyle so I'll go ahead and update the values instead.
I think that is out of the scope of this pr
Done!
Yes, let me add a screenshot to the description
Looks good! Only issue is I think the macros include the "Defaults by" but the DataTableThemeDate properties should be null by default
True I will change the templates a bit to exclude this. I think for `headingRowColor` and `dataRowColor` I can exclude this part. For headingRowColor it is null and not used by default anyways and for dataRowColor the default should be updated in https://github.com/flutter/flutter/issues/64314 to be the primary color.
It would help to explain that the default values for each property are defined by DataTable itself.
`two [DataTableThemeData] objects` or `two [DataTableThemeData]s`.
two space indent here and below
Using composite values like BoxDecoration can be problematic in components and themes however, in this case, since the default is `no decoration` it should work out nicely. Is it possible that apps will want to change a table's border, depending on its focused (other?) state. If this was a `MaterialStateProperty<BoxDecoration>` it would be a little clumsier to specify simple value, but more flexible: ```dart decoration: MaterialStateProperty<BoxDecoration>.all(myDecoration) ```
Glad to see this TODO here. When it's done, the API doc for rowColor etc should explain exactly what color scheme colors are being used.
NICE
Why isn't this part of the theme?
Done!
Done!
I think in this case we will not need to have different box decorations depending on the state. The focus or selected state will only be handled by the different rows and the whole DataTable never really has any (`MaterialState`) state.
Good point, I added dividerThickness to the theme now.
Done!
Documentation should be a complete sentence that starts with a capital letter and ends with a period. This line also doesn't really tell me much about what this parameter is or how to use it.  I'm also a bit suspicious about having a `Map<String, FinderConfig>` here - it may be better to have this as type.
Similar nit. What does it mean to register a Flutter Driver Finder? Why would I want to do that? This should probably include some example code.  Also, make sure that it is a complete sentence that ends with a period.
This doesn't add anything - why would I want to create this? Are the parameters required? What happens if I pass null?  It seems like the parameters should have asserts that they're not null. 
Is it from that or from the factory passed somewhere?
nit: Indentation  Please use a complete sentence that starts with a capital letter.
Same comment about using a map here.
It seems strange that we're passing in a factory here.  I think what we'd want instead is to have these finders be provided by a default factory, and let new implementations re-implement them if desired (or just use the default one before adding its own).
remove extra newline
I think rather than having this be a typedef for a function that takes a map, it might be better to just have a class that can be implemented or extended, for which we provide a default implementation.  That way it will be a bit clearer about who to pass this to and what precisely it needs to implement.  We could move all the existing implementation into its own class that serves as a default, and still let callers pass in their own implementations that add or remove functionality.  WDYT?
I have added example
Sample code should be real, runnable code.
This doc still needs to start as a proper English sentence with a capitalized first word that ends with a period. E.g. "The `finders` parameter are used to add custom finders beyond the ones found in (whatever we end up naming the class)".  The sample below is a good start, but it doesn't really show me how to use the `finders` parameter.
nit: extra spaces between `with` and `Deserialize`.
```suggestion         } else { ```
```suggestion class FlutterDriverExtension with DeserializeFinderFactory { ```
Also, up to you, but you could just drop the `else` entirely here since you're returning in your if.
We should probably write a test that actually implements new logic here and makes sure it works.  Also, please add a new line at EOF.
```suggestion class TestDeserialize with DeserializeFinderFactory{  }  ```
I mixed it with Mock by referring to other codes
Will such an example understand how to use
```suggestion /// A factory for deserializing [Finder]s. ```
```suggestion /// The `finders` parameter are used to add custom finders, as in the following example. ```
Looking at the sample code, this appears to be unused. The actual deserialization code is in `DeserializeFinderFactory` right?
I think we should move this logic to our default `DeserializeFinderFactory`, and make it `@mustCallSuper`.
This whole class appears to be unnecessary. After reading the example above, I thikn it can be simplified down to just have the user extend `SerializableFinder` and provide the right `DeserializeFinderFactory` that creates the expected `SerializableFinder`. See my comment below on `_createFinder`.  If we can do that, this whole class goes away and eliminates some complexity.
But createFinder cannot be put together with SerializableFinder, otherwise it will easily lead to indirect reference to "dart:ui"", and reference to "dart:ui" in the test code will cause it to fail to run
The main purpose of using DeserializeFinderFactory here is to decouple from "dart:ui", so I think it should not be added
DeserializeFinderFactory will be used in some multiple searchers, such as Ancestor and Descendant
Ahh ok, that makes sense.
I mean specifically this method here. Where is this used?
Called by CommandWithTarget https://github.com/flutter/flutter/blob/bae44ef34971cd7549118300d6e82a0cc6c33bea/packages/flutter_driver/lib/src/common/find.dart#L50-L52 https://github.com/flutter/flutter/blob/bae44ef34971cd7549118300d6e82a0cc6c33bea/packages/flutter_driver/lib/src/common/find.dart#L410-L422
Please add an example of what should be done here, and perhaps a comment explaining when you can leave this empty.
Please expand this.  I think I'm seeing it now, but I'm worried that future me will forget this again - and if I were reading the example to figure things out I'd have no idea what goes in here.
```suggestion ///   const Some(this.title); ```
should this be called mainExtend instead of max? (not sure what max is referring too....)
nit: maybe call this throwOnInteractions?
actually, this is kinda strange, isn't the intention of `verifyNoMoreInteractions` to insure that only expected invocations have happened so far? It's not really making any statements about the future, right?  Could we better express this as something like `expect(mockHelper.invocations, hasLength(<whatever>))`?
Same elsewhere.
Ahh right, I got this mixed up with something else. In that case, yeah checking the length would be the right way to do it
I'm not very satisfied with this part because it's almost duplicating `E2EPerfTest` except for what class it inherits. But I don't know if there's better way of implementing diamond inheritance. 
@liyuqian I moved it to a named constructor. PTAL. 
Nit: `timelineFileName = null` seems unnecessary?
Nit: maybe just call it `_kDefaultScoreKeys` as they're used both for e2e and non-e2e tests?
`timelineFileName` is a `final` and has to be initialized for the style guide reason. 
it's not default key for driver-based tests. what about `_kCommonScoreKeys`?
`_kCommonScoreKeys` sounds good.
This name sounds like a list rather than a map (slotToChild sounds like a map)
Why is this `children` here but `slottedChildren` in the cupertino file above?
Nit: I know you're just changing the variable name, but couldn't this be:  ```suggestion     assert(children.containsValue(child)); ```  Here and in a couple other places below.
I'll update it back.
In the Cupertino file above, the element contains both an indexed list of children and a map of what it was referring to as "slotted children", so I made the map name match what it was referred to in the comments.  However, it sounds like it's more confusing, so I'll rename all occurrences back to `slotToChild`
Yep - I'll update them all.  I'm not used to having a `containsValue()` function on a map 🙂 
This probably isn't the right place for it, maybe in events.dart
unsure if stylus should be treated like mouse or touch, probably the latter to be safe.
nit: revert this?
Unsure whether styles is more a mouse or touch device...
yeah, I have no idea really. The only stylus I've ever used was the one that came with the Nintendo DS. In that case, it was more of a precision assist for the existing touch screen. I could imagine for a stylus like that it would not be disambiguated from a touch event.
lol, I see you asked the same question above...
fixed
Should we be using the word "Mouse" in these?  I think something like "kPrecisePointerHitSlop" is more correct, since it wouldn't have to be a mouse (trackpads would have this set too, for instance). We use "precise" as terminology elsewhere (but we also use mouse some places too).
And people often use stylii in place of mice when they use it on a drawing surface. I think of stylii as being much more precise than touch, so I'd go with the more precise slop on them.
nit: it'd be nice if the variable was called `event` instead of just `ev`.
Can we rename `ev` to `event` here (and below) too?
Renamed to follow the precisePointer pattern
Done
done
Good to know!
nit: "The"
Done. Thanks!
I think the better order would be: stable VS, stable BT, pre-release VS, pre-release BT.
The combinatorics are getting a bit much for duplicating code at this point. I think a nested loop with the outer controlling whether or not to check for prerelease and the inner controlling the `requiredWorkload` would make it easier to understand what is the same and what is different in each check.
This block of four is used so often it would be good to just make a helper at this point called something like `setNoViableToolchainInstallation` that does all four.
Does this test actually need anything after the initial `setMockCompatibleVisualStudioInstallation` call? The `setMockPrereleaseVisualStudioInstallation` may have just been copypasta.  In general I would only expect a test to need to mock up to the first successful result.
Not at the moment, all mock after the first successful result are removed and duplicated code are refactored per your suggestions. please take a look at the latest commit.
Since you added a Dartpad example, you can remove the video.
Move the `const` to the `Padding` widget, since it can be const too.
@chunhtai Hi, Probably we can not modify the value of `confirmationNotification.paintOffset` here, just add this offset to the `_leadingController._paintOffsetScrollPixels` above. Otherwise, The function of `OverscrollIndicatorNotification` will be affected, I add a test case `CustomScrollView overscroll indicator works if there is sliver before center and modify glow position` below.
Can you separate this into a different test?
same here
I thought we are verifying the paint offset is correctly applied, what does the scroll direction do here?
Sorry for the comment is not clear, I will fix it. Line 375 set the `paintOffset` 50.0, `[OverscrollIndicatorNotification.paintOffset]` can special the indicator offset, also see https://api.flutter.dev/flutter/widgets/OverscrollIndicatorNotification/paintOffset.html So in this test case, the indicator should paint at 50.0 from its edge.
Done.
Done.
comment is a bit confusing
same here
Fixed.
Fixed.
Looks like these two could be `late final`?
`late final`?
late final?
isn't it also `int/*!*/`?
Or is that inferred by the tool? 
Presumably, `_IntrinsicDimensionsCacheEntry` would also be `/*!*/` ?
inferred
somehow it got that right
this was a shellcheck error, not sure if this ever did what it was supposed to.
`-gt` is correct.
I decided to make this required since we don't handle null in the switch below.
yay definite assignment analysis
This test uses too much mockito
The local comparator is used in a non-ci environment, so neither of these would be correct. 🤔 
WDUT about `ContinuousIntegrationEnvironment.none` ?
SGTM. The switch statements will want it to be accounted for, it'll just be a pass through then. :) Thanks!
This should say how it influences the overflow property.
What is "word base" or "alphabet base"? I think we'd need to explain this a little better.
same here.
Sorry for late response. I tried to fix, please check them out!
Here and below ```suggestion   /// the glyph causing overflow, and those that follow, will not be rendered. ```
This seems to just be a duplication of the sentence in line 164? Remove one of them?
Thanks for the advice. I will do that.
If this is not nullable, then almost every test in rendering/reattach_test.dart fails
This is surprising... running this test locally to take a closer look.
Instead of doing this, we should just default `explicitChildNodes` to false here:   https://github.com/flutter/flutter/blob/606abc915fb85e6896c85e19c1cf3fa4f526745a/packages/flutter/lib/src/rendering/proxy_box.dart#L3624-L3628  Just like we do for the `excludeSemantics` flag. Not defaulting it to false seems like an oversight. 
done!
Couldn't you leave `_mouseTracker.schedulePostFrameCheck()`, and just replace the body of that function with the contents of this one?  I.e., doesn't this code belong in the mouse tracker, and not the binding?
I think the idea is that `MouseTracker` does not schedule for itself. Instead it provides a method that should be scheduled, and the binding schedule things, just like how the binding subscribes to the pointer router. In this way, `MouseTracker` only provides 2 methods that is called outside, and is agnostic by whom, when, and how often they are called.
OK, makes sense.
It would be a little safer to factor this into _initWidgetState() 
Also `debugCheckHasDirectionality`? Here and below
```suggestion /// /// This class provides APIs for showing drawers and bottom sheets.  ///  /// To display a persistent bottom sheet, obtain the  /// [ScaffoldState] for the current [BuildContext] via [Scaffold.of] and use the  /// [ScaffoldState.showBottomSheet] function.  /// ```
```suggestion /// To display a snack bar, obtain the [ScaffoldMessengerState] for the current ```
```suggestion   ///       title: 'Flutter Code Sample for ScaffoldMessenger.of.', ```
```suggestion   ///         appBar: AppBar(title: Text('ScaffoldMessenger.of Example')), ```
```suggestion /// This class provides APIs for showing drawers and bottom sheets. /// /// To display a persistent bottom sheet, obtain the /// [ScaffoldState] for the current [BuildContext] via [Scaffold.of] and use the /// [ScaffoldState.showBottomSheet] function. ```
```suggestion ```
```suggestion ```
```suggestion ```
Do we still want to say that snackbars are typically shown with ScaffoldState.showSnackBar?
Scaffold feature events?
This isn't necessary. 
Saying that it's called within the build method sounds a little like it produces a widget.  Maybe say that it's called in response to a user gesture or an application state change? 
Looks like dev/snippets/config/templates/stateless_widget_scaffold_center.tmpl would simplify this example
I think we need to admit why this case is needed (sometimes snackbars are produced by code that doesn't have ready access to a valid BuildContext) and provide an example.  
I think we need a nullOK parameter
We should explain about scaffolds being registered or provide a link to doc that explains it.
Slightly better (IMHO) as: ```dart if (_accessibleNavigation == true     && !mediaQuery.accessibleNavigation     && _snackBarTimer != null     && !_snackBarTimer.isActive) {   hideCurrentSnackBar(reason: SnackBarClosedReason.timeout); } ``` 
If accessibleNavigation goes false, do we need to shorten existing timeouts (restore them to their normal values)?
Do we want to verify that scaffolds only get unregistered once?
Distributes or shows (displays)?
I could be missing something but ... looks like this could be   ```   final ScaffoldFeatureController<SnackBar, SnackBarClosedReason> controller = ScaffoldFeatureController<SnackBar, SnackBarClosedReason>._(        ...   ) ```
This name is a little confusing because it's not the status of the (a) snackbar that's changing. Just _handleStatusChanged would be OK
Assuming that this triggers the animation's status callback, comment as much here.
Why isn't _accessibleNavigation valid here?
to dismiss the snackbar?
I'd prefer it if we reserved `=>` for one-liners that returned a value (not void). Here and elsewhere.
Could specify alignment: Alignment.center on the Container instead
We use `const Text()` elsewhere
maybe factor out a debugHasScaffoldMessenger(), like debugHasScaffold().
As noted earlier: should we be doing some automatic adjustment of snackbar durations when accessibleNavigation is true?
Indentation and maybe use Container.alignment
This looks slick. But what happens if you write ```dart Theme(   data: ThemeData(snackBarTheme: mySnackBarTheme),   child: ... showSnackBar(mySnackBar), ) ``` We may need to explain this limitation.
Oops! Thanks!
Ah thanks, updated
Nice!
Whoops. Leftover. At one point I tried to follow the same conventions as ScaffoldState, but that was a much larger break and migration.
Can you explain more?
I don't think so, this is existing API that I relocated from ScaffoldState to here. The existing tests regarding accessibleNavigation & SnackBars pass. Is there a case we aren't covering?
How do you mean?
The assertion below, `assert(_snackBars.first == controller);` would be referencing `controller` before it is declared in that case.
This is from the original snackbar API.
AFAIK, because it may have changed during the course of the timer counting down. This is another artifact of the original snackbar api.
Should I put this explanation in the Hero documentation?
#64832 verifies SnackBars are matching expected a11y behavior.
That wouldn't really warn anyone about this case (unless they do a lot of recreational reading). On the other hand, this (Hero) issue doesn't come up that often, which is why it's not called out in the Hero docs. Hopefully it will not come up often due to snackbar heroics either.
The reader may not understand what you mean by _registered_ scaffold.
Should we `assert(_scaffolds.remove(scaffold))` here?
OK, I see.
Should we be checking the _MinuteTextField as well?
Good point, yeah we might as well
Seems like this code isn't correct, since TextSpan is not documented as accepting null children
supertype is nullable anyway
is the code that generates this string also removed?
looks like the point of this test was to check that our null checking gave a pretty error message. What's the error message now? Is it still pretty?
No, but it does need an ignore on dead code:  https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/painting/text_span.dart#L372  
It depends:  1. weak-mode, no null assertions - same error message 2. weak-mode, null assertions - null assertion error when constructing the TextSpan. Depending on the context that might be easy to read or ugly 3. strong-mode, static error can't be hit.
This was set twice
copy-paste strikes again
This should probably handle badly formatted output without crashing
```suggestion     void fail() { ``` 
```suggestion     } ```
Semi-colon was required as it's a local variable declaration, but I changed it to a local function instead to avoid confusion.
Shouldn't this be ios_content_validation_test?
+1
No, the enabled devicelab tests are `android_defines_test`, `flavors_test` and `ios_content_validation_test` in the manifest.yaml, the first two were enabled before this change. Sorry for the confusion. This change also removed `flutter_gallery_ios__compile` as it takes longer to run.
Any reason why we don't run each test by itself? can we also consolidate the configs in fewer files, seems like now we need to update three places. 
The devicelab `manifest.yaml` contains ~140 devicelab tests and is still being used in Cocoon backend and agent. Merging it with `try_builers.json` would require much larger changes.   After this change, to enable / disable a test we only need to change the `manifest.yaml`.
I'm missing context, how will the tests run in their own builders? 
Please see [this example build](https://chromium-swarm.appspot.com/task?id=4e1771414675dc10), the devicelab recipe will checkout the repo, read manifest.yaml then run the tests marked with on_luci=true.
I think we are going in different directions, in one hand we are moving tasks to provide more targeted signals and this PR is putting merging together multiple signals(multiple tests as a single task). Please add a TODO to split to one test per task.
Filed https://github.com/flutter/flutter/issues/64057 to track.
Does this comment need an update?
This comment is still accurate, but it's specific to the SSH port forwarder. Merged it with the comment in _SshPortForwarder.start.
Have Windows hostonly been migrated?  I see https://ci.chromium.org/p/flutter/builders/prod/Windows%20hostonly_devicelab_tests but it's failing.
I don't see hostonly_devicelab_tests for macOS on any builder, am I missing it?
we want this to ONLY run on post-submit?
This was an error, back to ||
This was an error, back to ||
Reverted to use ||
Some of this code could probably be deduplicated between here, TextField, CupertinoTextField, and TextSelectionGestureDetectorBuilder, but I think I'll have to fix https://github.com/flutter/flutter/issues/64190 first.  I'll make sure I clean up any deduplication when I fix that issue.
Same with onSingleLongTapStart below.
I believe there is now no way to make Select All appear for a SelectableText on iOS, so I've removed this test.
I don't know why this test was passing in the first place, but it started failing when I made this change, despite the behavior it describes being broken either way.  I've created the issue https://github.com/flutter/flutter/issues/64059 to deal with fixing it and unskipping it.
That seems consistent with native iOS in my experimentation.
How do we differentiate between precision devices? the mouse and stylus should not make a selection right?
I just double check it seems like selectable text is correct, but there will be different for long press on textfield when it has keyboard focus vs when it does not
Hmm I'm not sure but that would make sense. @gspencergoog Didn't you have a keyboard and mouse setup for an Android device?  Is there different behavior for longpressing with the mouse vs. a finger?
@chunhtai Are you talking about https://github.com/flutter/flutter/issues/64190 specifically or this PR?
I meant we probably can't merge those methods for selectableText and TextField/CupertinoTextField because they have different behavior when long pressed in native iOS ``` SelectableText -> always select the word Textfield -> If keyboard focused, then move collapsed cursor to the word boundary and shows selectAll                 -> if keyboard not focused, select the word ```  
for macOS at least, the mouse long press does not select the word
That continues to work even after this change.  The behavior on all 3 platforms is shown in https://github.com/flutter/flutter/pull/63994#issuecomment-676748652.
Would https://api.dart.dev/stable/2.9.1/dart-core/String/trimRight.html work?
In the event the message contents itself has trailing whitespace, we should still retain that
It shouldn't be necessary to call setState() here, rebuilding the frame should be enough. 
These comments are helpful. Wordsmithing: Tap the checkbox when tristate is disabled.
Yes, you are correct, it's redundant. I will fix it, thanks:)
Done.
Done.
This all looks fine however this particular callback occurs about 200 times in the tests and the StateSetter parameter is always called `setState`. Probably best to bow to convention and do the same here.
haha, actually, it appeared 238 times in total, and indeed most of them called `setState`. I will fix it.
Done. :)
What do you mean by 'save' here?
Ah, it's supposing that users are filling some forms in `Stepper` which needs to be saved. ```suggestion   /// change the text of the continue or cancel button as per which step are users at. ``` How about updating like this? Would it be better?
That sounds good to me! Thank you!
```suggestion   /// change the text of the continue or cancel button depending on which step users are at. ```
Applied. Thanks for your review! :)
Can you wrap a Scaffold around the transition?
Maybe better: "On the web it is used as the page title, which shows up in the browser's list of open tabs."
@goderbauer  Done :smile: 
Remove
Should this be moved, too?
Moved to an AndroidSDK method
Removed locating the android sdk, because if it wasn't found before it won't be found again
No - because if we fail to find the android SDK we inject this interface as null, and the intention of this code is to provide a method of looking up adb without the android SDK.   Now, I think we should eventually remove both of those behaviors, but it was too breaking of a change to do at once.
Fixed! my bad
Nit: having negative timestamp looks strange. Can we change `buildStart` from `0` to some positive numbers so `vsyncStarts` can still be nonnegative?
Done. 
I think that changes the meaning: it's referring to a whole gesture, not just an individual event.  Shouldn't it be something like this?:  ```suggestion /// pointer is pressed and moved, and then released or canceled. ```
```suggestion   /// Called when a pointer moves to a position within this widget without ```
```suggestion   /// not down (e.g. mouse pointers). Certain devices also fire this event on ```
```suggestion   /// This callback is triggered is during the callback of a ```
```suggestion   ///  * [MouseRegion.onHover], which does the same job. Prefer using [Listener],   ///    since hover events are similar to other regular events. ```
```suggestion   /// Triggered when a pointer moves to a position within this widget without ```
```suggestion   /// not down (e.g. mouse pointers). Certain devices also fire this event on ```
This didn't need to be a local
Maybe: "See https://flutter.dev/docs/development/tools/sdk/releases for previous releases of flutter"
Thank you for the feedback! Your version is better. Will use it instead of the initially chosen one. 
```suggestion           'for previous releases of Flutter.'); ```
```suggestion             'for previous releases of Flutter.\n\n' ```
Will it be more helpful for the developer if we used a descriptive URL parameter name? E.g. "revision", "version", "cache_key"?
good idea, will use `revision`
A reasonable follow up to this PR would be to add an automatic migration using the tooling that @jmagman already wrote, but its not something I have time for right now
Would love to combine more logic, iOS and macOS building should look almost the same.
I'm guessing it doesn't matter if it gets "tripped" twice in a row?
This makes sense for now. A better solution for both platforms would be to craft one-line error messages (not like the `=======================` errors we have now) and echo prefixed with "error " or "warning ".  This will show up as a real Xcode error instead of just a failure of a script exiting with nonzero, as discussed in chat one time.  ![unnamed](https://user-images.githubusercontent.com/682784/90298236-41b9e400-de46-11ea-8324-aa6d0b36934d.png) ![unnamed-1](https://user-images.githubusercontent.com/682784/90298237-42527a80-de46-11ea-8375-8e8afa8bfbbb.png) except that's supposed to say "This is an error message" and I'm too lazy to recreate this.
No, just as long as it gets modified at least once
Is this something we need to do for our `printError` calls? That is not that most difficult thing to add...
We are way too chatty with out `printError` calls to just prepend `error `.  For example, I believe every dart compilation failure line is a separate `printError`, including the `  _^_ ` whatever ASCII annotation line that points to the column of the printed line, so there would be like 5 Xcode errors for every dart compilation error, when there should just be one.  I may be misremembering though.  I have a branch for this I never finished, for iOS: logger.dart ```dart class XcodeScriptPhaseStdoutLogger extends StdoutLogger {   XcodeScriptPhaseStdoutLogger({     @required AnsiTerminal terminal,     @required Stdio stdio,     @required TimeoutConfiguration timeoutConfiguration,     StopwatchFactory stopwatchFactory = const StopwatchFactory(),   }) : super(     terminal: terminal,     stdio: stdio,     outputPreferences: OutputPreferences(       wrapText: false,       showColor: false,     ),     timeoutConfiguration: timeoutConfiguration,     stopwatchFactory: stopwatchFactory,   );    @override   void printError(       String message, {         StackTrace stackTrace,         bool emphasis,         TerminalColor color,         int indent,         int hangingIndent,         bool wrap,       }) {     String xcodeMessage = message;     if (message.contains('Error:')) { // <-- "Error:" was the best indicator I had for a dart issue.       xcodeMessage = 'error: $message';      } // <-- Probably need more cases here.      super.printError(       xcodeMessage,       stackTrace: stackTrace,       emphasis: false,       color: color,       indent: indent,       hangingIndent:       hangingIndent,       wrap: wrap     );   } } ``` xcode_backend.sh ```sh   RunCompileCommand "${FLUTTER_ROOT}/bin/flutter"                                \     ${verbose_flag}                                                       \     ${flutter_engine_flag}                                                \     ${local_engine_flag}                                                  \     assemble                                                              \     --output="${derived_dir}/"                                            \     ${performance_measurement_option}                                     \     --logging-style=xcode-build-phase                                     \ ... ``` assemble.dart ```dart     argParser.addOption(       'logging-style',       hide: true,       allowed: <String>['xcode-build-phase'],       help: 'Format logging.',     ); ```  On the right track?
Yeah that seems like a good place to start, though I would leave out the message introspection and instead configure it via the calls to printError
Hopefully no one ever adds `set -e` to the top like https://github.com/flutter/flutter/pull/50664.
Isn't the reason that we were doing this here was that if we fix it to not need the tripwire, we need to update the project with the input/output files? It seems like this sets us up to accidentally change the script later while forgetting that we need to fix all the projects in the wild.
I forget, is there something blocking us from merging this into the Dart script we're using for Windows and Linux? It would be nice to go in that direction instead of adding even more logic to the shell script version.
I'm confused here; IIRC you recently turned `trace` on for Windows and Linux to fix missing Dart failure output. Why do we want it for Windows and Linux but not macOS?
No, its do-able with some light refactoring besides the tripwire. If we can resolve that its 5 mins of work
trace only prints stderr by default, and forwards stdout to our verbose logging (hidden by default). with -quiet, xcode writes errors to stdout so we need to surface them.  > Why do we want it for Windows and Linux but not macOS?  Everything is doing something different with error logs 🕵️‍♂️ 
The project input/output files are correct and can work 100% of the time, if you are building through flutter. When building through the xcode UI, changing configurations does not lead to any sort of change in files on disk - so Xcode thinks that our task can be skipped.  I have no idea how to fix this.
> The project input/output files are correct  Right, but we took them out of the Xcode project when adding the tripwire. A fixed build flow that uses the input/output files and doesn't need a tripwire requires adding those back to the project. There's no world where we can fix the need for the tripwire without changing people's existing projects, so I don't see why we would want to move the tripwire creation from the project to the script.
  > changing configurations does not lead to any sort of change in files on disk - so Xcode thinks that our task can be skipped. >  > I have no idea how to fix this.  I thought we had a potential solution for this now, inspired by @jmagman's iOS work with App.framework: have three different copies of the framework in ephemeral, rather than just one (e.g., ephemeral/debug/..., ephemeral/profile/..., ephemeral/release/...) and control the linking ourselves with linker flags, including a configuration-variable-based linker search directory.
Couldn't we combine scripts, and have the tripwire logic based on OS (if we really need the tripwire here rather than in the project, which per my other comment I'm still not convinced of)
Oh, I see. Could we use the new stdout error regex logic I added for MSBuild here, so the logic is more unified?
different locations for debug/profile/release artifacts would definitely help. I can't say for sure if it would solve the issue completely 
with `-quiet` there shouldn't be any need, since only task stderr should be surfaced
> Couldn't we combine scripts, and have the tripwire logic based on OS  We could for new projects, with some backwards compat for macos_assemble (unless we add the project migration support, but like I said I don't really have time for that this week)
I was just thinking converting `macos_assemble.sh` into a thin `tool_backend.dart` wrapper, not doing an actual migration at this point. Just so we're not adding more bash logic and continuing to maintain bash complexity, when we already have a Dart version that's more testable and more maintainable basically ready to swap in.
But there are other differences in the code flow. For instance, won't your current approach mean that errors are printed in the normal color on macOS, rather than red on every other platform? And any code, future or current, that hooks into the logger mechanism to know what the errors are won't see the macOS error output as errors.  Whereas if you pass `.*` as an error regex (along with using `-quiet`) then macOS errors will use the same path through the logger as errors on other platforms.
Anyway, that part was a tangent. Going back to my main concern: what is the goal for moving this logic out of the project? This PR seems unrelated to the tripwire, and AFAIK nothing has changed since we made a deliberate decision to put the tripwire logic on this side of the divide (per my comment above).
Ahh, cool I didn't know it did that :) 
I think (now I need to double check, because I could have mixed it up) that ending with `&& touch` was causing failures of the actual script to be suppressed. I bet there is some sort of bash-fu to fix it..
Oh, I see. I missed that there wasn't anything else in macos_assemble.sh before, and thought the error exit you added there was to fix that problem.  Yeah, the current Xcode script is definitely wrong, because it's just two statements. Changing the `\n` to ` && ` should be the easy fix there.
I think it's worth commenting why this is done (i.e., the interaction with `-quiet`) since it's non-obvious without context.
Done
For private classes with constructors like this, why not use positional parameters?
Removing deprecated methods seems out of scope for this PR?
```suggestion /// Creates a grid of mouse regions, then continuously hovers over them. ```
Is there a constant line ending somewhere we can use?  I don't see one.
Does it pass if we expect `depsIndex != -1`?  I know that's not how it works now, but it seems more strictly correct.
I don't know if it matters that we aren't maintaining the line endings, probably not.
Good call. Changed to expect().
Yeah, I'm also worried that adding logic to retain Windows line endings would tickle the Cirrus problem.
you don't ever need `equals`
Nit: if the class is called `DevToolsServerAddress` it seems weird that it contains `bool success`.  How about returning null on failure instead of an explicit field?
That's true, I can make this a little simpler overall without the success/failure. I might add a failure message later on but I don't think it's needed now.
Are we sure other engines also does not need such a feature? @justinmc @LongCatIsLooong   If they need it, even if we don't use it now, we can change the wording.
In other engines, we handle everything on the framework side for read-only fields (e.g. keyboard arrows/shortcuts, clipboard, context menu, etc). I tried it, it works fine. And since no one complained about it, I'm assuming read-only fields (and SelectableText) works fine on mobile platforms.  In any case, thanks for adding mobile people so we can confirm 😄 
typo: "virtualk"
nit: no need for "etc" when providing an example
Should the last three use-cases use the `SelectableText` infrastructure in the case of read-only input?
nit: "use" implies that a connection is established but may or may not be used. However, it seems we never establish a connection when this is `false`. Suggestions: `shouldConnect`, `shouldCreateInputConnection`.
We treat skips as technical debt. Can the test body be changed so that we simply expect different behavior on different platforms? If not, let's leave a comment explaining why this test is web-only.  /cc @Piinks for more guidance.
True! If the test can be expected to work across platforms that would be ideal. If it's skipped because of an outstanding issue, there should be a comment with the issue link beside it. If it is being skipped because of platform specific behavior, you could execute the test conditionally based on the platform, or leave a comment saying why the test is skipped without plans to resolve it.
I agree with @mdebbar.  I'll try to keep an eye out for use cases that might need this as we go forward though.
It's the other way around. The `SelectableText` widget is the one using read-only field infrastructure :)
As we discussed yesterday offline, we can add an assert to line 462 with a message "readonly fields cannot autofill".
Done.
This column only has one child, why do we need the column here? Presumably, it can be removed?
I think this is more clear, but let me know if it doesn't seem accurate.  ```suggestion     // There's no need to format when starting to compose or when continuing     // an existing composition. ```
IIRC `TextRange.isValid` does the same: ```suggestion     final bool isValueComposing = value?.composing?.isValid ?? false; ```
ditto the using `TextRange.isValid` comment.
If the problem is with that specific formatter, can we apply the fix to the formatter instead?
Done it, the fix is now land on the specific formatter.
Ah so we previously missed the case where the composing finishes without actual text change. Nice catch!
nit: I think it would be easier to understand if the second expression reads something like `!isComposing && isPreviouslyComposing`
Using `isComposingRangeValid` is a bit too strong. It's mainly used for out of range check. To check whether `newValue` contains composing text, I think `newValue.composing.isValid` is preferred. Yeah I'm sorry the name is a bit confusing.
Also applies to the changes below.
I think the behavior change is worth documenting. We should probably add a "#Multistage text input" section or "#Composing Text" section somewhere in this class for visibility, and document the fact that the [maxLength] constraint is going to be temporarily lifted when the user starts composing, and when the composing finishes, the text may get truncated so it does not exceed [maxLength].
Also, ideally we shouldn't allow the user to start composing when they've already reached the length limit. 
> Also, ideally we shouldn't allow the user to start composing when they've already reached the length limit.  Strongly agreed with this one! I'll add it.
> `!isComposing && isPreviouslyComposing`  Conditions are really a science.
I've removed this comment, it seems useless.
```suggestion     // Return the new value when the old value has not reached the max     // limit or the old value is composing too. ```
I didn't realize NNBD had been turned on here already 👍 
This could be automated if we had a way to filter issues filed from this template. We could create a label like "infra: ticket" or add [Infra Ticket] to the issue title.
nit: The triage process should be its own paragraph
This template covers every new infra issue, not only the ticket queue. And adding "Infra Ticket Queue" project doesn't take more effort than adding a label or customized title.
Which process do you refer? This paragraph is for customers who want to file a ticket to the infra ticket queue.
If this is public on our site, I bet a lot of people won't know what we mean by "infrastructure" without more context.  Maybe instead of "to the infrastructure", "about Flutter's CI infrastructure"?
Ahh I see. I was under the impression this template was being used only for infra tickets. I would clarify what the difference is between infra ticket issues and normal infra issues.
Sounds good, reworded.
nit: can the line below this one be simplified just like you did in the constructor?
done
Remove? Uncomment?
How do we still have these just `test`s?
testbed experiments that didn't pan out.
Fixed!
Might want to update this comment to mention `isReplacing` instead.
Why the extra pump?
Remove debug print?
```suggestion   testWidgets('widgets move scopes during restore', (WidgetTester tester) async { ```
Why did the one above move to after the pump, and this one didn't?
Moved both to after.
Removed. It is not necessary. Must be left over from debugging something.
nit: It's unlikely, but the "is true for one frame after" could be misconstrued as "is true for one of the frames after" (i.e. not just the immediately following frame, but one of any of the following frames).  Maybe say "is true for the frame after" instead? Here and above.
trivial nit: please be consistent about whether a space appears after `switch` (space preferred)
per our style guide, please call the argument "value"
it's trivial, but ideally this line would be after the early return
trivial nit: no need for these blank lines
Small change but; ```diff + return fit == BoxFit.scaleDown; -   switch (fit) { -      case BoxFit.scaleDown: -        return true; -      default: -        return false; -    } -  } ```
switch cases are generally preferred over comparison in the repo, but so is the default case tbh  https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-using-if-chains-or--or--with-enum-values
nit: separate this out in two bullets, one for each of the `debugProfile...` flags
Can you please also update the documentation of these two flags to include a link back to this new flag?
Done
With my pleasure:)
Is there a use for retaining constraints on neither axis?  
Could you use `default` to handle `constrainedAxis == null` and then just do everything in the switch statement?
Nit: Not sure if you wrote this or copied it but just an apostrophe:  ```suggestion   /// passes to its child. If the child overflows the parent's constraints, a ```  If this is going to cause a CLA problem then make the change manually haha.
Were these being clipped before?
for science!
Don't think there's one in the framework or material or cupertino. But this PR does not change `RenderUnconstrainedBox`'s API or functionality.
per the style guide default should be avoided: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-using-if-chains-or--or--with-enum-values
Yes, 55 is the minimum height iirc
Ah got it, that makes sense.
Alone on an Infinite Canvas with No Constraints will be the name of my breakout studio album.
It wasn't clear that "normalized" in this context means "satisfies BoxConstraints.isNormalized". Maybe leave the qualifier out here and document that we're going to assert isNormalized elsewhere?
"some of its intrinsic sizing ..."? This widget doesn't necessarily know what the child's intrinsic sizing rules are?  Maybe just say: here's an example.   Ideally, you'd provide a rule of thumb about when to use this widget.
Maybe this is a little clearer?  This snippet guarantees that the child [Card]'s height will be at least as tall as its intrinsic height. Unlike an [UnconstrainedBox], the child will be taller if the parent's max height is constrained. If the parent's max height is constrained to be less than the Card's intrinsic height then a warning will be given in debug mode.
Probably don't need this reference (plus "the type constraints of constraints" is a typo), since the API  includes BoxConstraints.
A widget that imposes additional constraints on its child.  Best to lift these one-liners from the existing API doc; don't want to explain "boxes" vs widget here.
Should itemize the asserts we apply to parameters, and parameter default values, here.   I'm assuming (didn't read ahead) that child can be null.
Shouldn't this explain that it's for cases where the parent isn't the same size as the child?
Why don't we use Directionality.of(context) if the textDirection parameter is null?
If would be a little more helpful to explain that the we're transforming the parent's constraints and then using them to constrain the child's size.
will be or must be?  AFAICT we don't normalize incoming constraints. Is this really necessary? 
NICE
Makes sense. Removing the `normalize()` call from `performLayout`.
It does. Copied the docs from unconstrainedbox and didn't check.
Are you sure if it's only when they appear in the same route, or should it be global unique?
Not need global unique, but should be equal between rebuilding. 
If you like you can give them the same key, it works well. Because the identifier is a key chain
Actually, "in the same route" is not precise enough, isn't it? ```suggestion /// within the widget's closest ancestor [PageStorage] (such as within the same route), if you want to save all of their positions, ```
Also "if you want to save all of their positions" should be "if you want to save all of their positions independently" followed by "unique [PageStorageKey]s". Otherwise, their positions ARE stored, but overridden by each other.
NICE suggesting.
Done.
Not sure what I should be writing here, and what paths are required. the APK code size analysis seems to hardcode a path to arm64-v8a - I assume that should actually be the path to whatever aot output we find?
What does the command to generate the code size analysis look like now? does it still use a --analyze-size flag?
I think we could still leave this as APK right? Or is this code hit for iOS as well?
what about apk-analysis.json files? Additionally, if we are storing the apk-analysis.json files, why do we need to also store the v8 snapshots? An apk-analysis file will contain the v8 snapshot information
can you add a TODO here to add the precompiler trace option https://github.com/flutter/flutter/issues/63676, here and elsewhere
this is used for every platform now, but most of the time it is just looking at a directory
See question above on the format.
Yes
I'm not quite sure of the format of the apk-analysis file, seems like:  1. It needs to contain the snapshot, the path to libflutter.so, and some snapshot type key - right?  Should probably be called something else for the other platforms: apk-analysis.arm64.json, ios-analysis.json, et cetera
The apk-analysis.json file currently contains the unzipped APK data, processed into a json format that DevTools uses to parse AOT snapshot trees. At the libapp.so node (defaulting to only one ABI currently), we swap in processed v8 snapshot data. The ending result is that the apk-analysis.json file contains a tree structure of the apk where the AOT snapshot has been embedded into the default libapp.so node.  The "type" key, is do differentiate apk-analysis files from v8 snapshot files when inputting them into DevTools. I think if would be fine if the value of "type" was the target platform ("android", "ios", "macos", "linux", "windows")
Keep track of the path to the aot file path instead of hard-coding a specific arch
I just added it everywhere, easy enough
oh cool, I like this solution. But can we also edit the help for the --analyze-size flag then to say you need to also specify this? Otherwise, all users will always run `flutter build apk --analyze-size` one time and always get a warning to re-run it a second time.
oh I thought you called it codeSizeDirectory just for the AOT. If you're gonna have this flag for everything, perhaps outputSizeDirectory? Since there's more than just code that you're breaking down.
I'm somewhat surprised this logic isn't extracted from the function below since it more or less does the same thing. Shouldn't the next one essentially just call unzip then call this?
what's this second file?
Maybe not the case but I somewhat expected this to be a configurable variable somewhere
If so, we should make this clear somewhere in the doc
What happens if users do `flutter build ios --debug --analyse-size` here and on other platforms?
this is probably fine to start
ditto here
ditto here
(probably all handled in the same place, but) ditto here
We check that here: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/runner/flutter_command.dart#L691
precompiler trace file, its used for something :) @kenzieschmoll 
yeah good point, I think I could give this another go.
Yeah, will update the analyze-size flag
Added to the flag documentation
@kenzieschmoll is it go/dart-devtools-aot-code-size-attribution?
Can you help us fix the (new) line 107 for windows as well?
Does this mean only Android is putting out a zipped file. All the other platforms are just directories? That's neat. 
not sure what you mean?
You already did in ab1c196
Yeah, while iOS and macOS would eventually end up in a zip archive the tool itself doesn't build this - its done through xcode. The .app is pretty close, modulo some compression, but I think it is really more like an android appbundle in that Apple applies more thinning/compression before downloading.  For windows and linux there is no real "distribution" format yet, so the directory is the next best thing.
You didn't reply to this one :)
what about `android`?
what are your thoughts on giving this a more descriptive name? e.g. `android-code-size-analysis.json`, `windows-code-size-analysis.json`? It may be more intuitive for users to understand what is being "analyzed"
Here and in https://github.com/flutter/flutter/pull/63610#discussion_r471855924, I'd suggest s/code/output. Since it's not just code that we're analyzing. There's assets etc as well.
`android-output-size-analysis` or `android-size-analysis` sgtm. I think the important part is "size" to distinguish from other analyzable metrics (memory, perf, etc.)
actually, from an offline discussion `aab`and `apk`. Can you update the comment to reflect the possible options?
do we need to add more tests for windows, macos, and linux?
We don't yet have CI for the desktop targets :( 
I think 10 is probably fine (it's more or less a screenful) since lower sized packages are a diminishing return as we show them. There's always DevTools :)
commented code
Can you add some code comments for what this does?
> I think 10 is probably fine (it's more or less a screenful) since lower sized packages are a diminishing return as we show them. There's always DevTools :)  showing 10 is pointless, it will be almost identical for every single flutter using package. At this point we have removed 95 % of the useful console output, we might as well skip it all together.
Done
fixed
discussed on main thread
Nit: I think `final String driverFile;` looks safer than `String driverFile`. Can you do the following? ``` final String testDriver = driverFile ?? (semanticsEnabled...) ```
`with hybrid of host-driven and self-driven` seems to be hard to understand. How about `where the animations are self-driven on device without host interventions, but the timeline events are still sent to host to be processed.`.
Is it Ok to make this `controller` a local variable inside `_handleMessages` which gets constructed during each function call? The constructor itself looks very simple so I don't expect call it multiple times to have a negative impact.
It seems to me that we should do the following instead? ``` if (hybrid) {   await driver.requestData('profileDemos'); } else {   await runDemos(kProfiledDemos, driver); } ```
ditto.
Done.
Done.
Done.
Done
I made a class with `call` method to implement this, with single call of `Controller` construction. PTAL. 
This is wrong and needs to be reverted
this seems suspicious too
Reverted
Also reverted.
Can you add back the comment describing the colors? Thanks.
@goderbauer  Thank you for your information. 
Note: I'm not 100% sure this is the right approach.  Is it possible for the user to provide their own implementation of `AssetBundle.load`?  If not, maybe it would be better to change the type of `data` to a `ByteData` (removing the `?` on line 666) and just remove this check.  Actually, that might be a reasonable approach anyhow, even if it is user-overridable, since the user will still get an exception when `data` gets dereferenced on line 682; the only difference will be that the exception will be marginally less comprehensible, and the key won't be evicted from the image cache.  But maybe that's ok.  Anyhow, I'm open to suggestions.
yes `?` could be removed. But for now I would keep the `if (data==null)` for now.
I think we can probably just drop this. If the method is not supposed to return null, we can assume it's handled by throwing an exception.  I'm not quite clear though on when weak checking would be used. Could you explain a bit more about how that would happen?
@dnfield  Weak checking is when the user's app contains some files that are opted in to null safety (e.g. flutter) and others that aren't (e.g. their app and packages).  It does all the static checks for null safety, but the type system is fundamentally unsound at the boundary between opted in and opted out code.  For example, if you invoke an abstract method in an opted-in class that has a return type of `int`, that's supposed to guarantee that you'll never receive `null` as a result.  But if the concrete implementation of that abstract method is in opted-out code, it could return `null` without causing a compile time errors.  That's the sense in which it's unsound: your opted-in code can have a variable of type non-nullable `int` that contains a `null` value.  Effectively, non-nullable types can't be completely trusted if there is some opted-out code somewhere in the program.  Once the entire program has been migrated to null safety, the unsoundness goes away and `int`s are really `int`s.  Because of this, we have code in Flutter that looks to be dead code, but we want to keep it around until most users have upgraded their apps to null safety, so that we can continue reporting useful exceptions to them if they pass `null` to us where they shouldn't.  The type system thinks that code is dead but the reality is it's not, so we have to add the `// ignore:` comment.  The reason I'm having to make this CL now is because fixing a bug in the analyzer that was preventing some of the "supposedly dead" code from being recognized.  Does that help?  If not, I'm happy to discuss over VC.
Ahhh ok that makes sense.  Yeah we should leave this then.
nit: trailing comma
nit: trailing comma
In the previous change, the Expand child was on the subsequent line. It's a little easier to read that way.
It seems a little like overkill to factor out _HourTextField and _MinuteTextField, but OK.
Done
Done
Done
yeah I would have preferred not to, but it made it easier to properly test this.
Instead of commenting this out, the test should be skipped with the `skip` argument: https://master-api.flutter.dev/flutter/flutter_test/testWidgets.html  There also should be a comment with a TODO indicating when to re-enable this test.
Same here.
shall this be added back to framwork_config.star in `infra` repo?
```suggestion $text = "# Ensure File`n`$ServiceURL https://chrome-infra-packages.appspot.com`n`n# Skia Gold Client goldctl`nskia/tools/goldctl/`${platform} git_revision:b57f561ad4ad624bd399b8b7b500aa1955276d41" ```
Drive by suggestion: add docs that the revision refers to the chrome infra/infra repo, e.g. https://chromium.googlesource.com/infra/infra/+/b57f561ad4ad624bd399b8b7b500aa1955276d41
Previous node has ... 'previous' button
In theory, you could do all of this checking in just one slightly more complicated version of this test.
Well, sure, but doesn't that violate the principle of "one behavior => one test"?
Thanks, fixed.
OK, I modified the tests to test all of the behaviors in separate tests (so they fail separately), but using a new `TestVariant` subclass so that I don't duplicate code when doing so. Let me know what you think.
NICE
I feel like this is an analyzer error if it's not indented, but if I'm wrong then no worries.
No, it won't fail the analyzer, but it does need to be indented for readabililty. Done.
The change from an if to an assert here and below was just something I noticed while I was working on this. It's not related to the fix.
You mean the scale can still be 0 when there're more than 1 pointers? That sounds like a bug?
nit: this seems to be equivalent to  ```suggestion       _gestureType = _getGestureType(details); ```
nit: if `details.scale` is not 1.0 this gesture would have been reinterpreted to scale or rotate I think?
nit: can this be moved to around line 819 (inside the `switch` clause)?
Off-topic: I haven't tried it, but the heuristic here feels like a bit of a hit or miss? These values can have subtle changes even if the user tries to keep their fingers still. And once it's recognized as scale or rotate it can't be reinterpreted to something else.
Yes, for the first 1 or 2 calls to onScaleUpdate.  I interpreted it as meaning that the two pointers are exactly the same distance apart as when the gesture started for a tiny period of time.  In that case, maybe it's not a bug, even though it is kind of inconvenient.  Also when I wrote zero I meant zero change in scale.  The scale is actually `1.0`.  I've updated the comment to be clear about that.
Much simpler, thanks.
I thought the same thing at first, but I remembered that this is for the case where scale is disabled.  I'll add a comment about that actually.
Good catch, I should have done that originally.
Yeah there is probably a better way to do this.  Currently rotate is hardcoded to disabled, so it won't affect anyone, but it did work alright when I was using it.  The fact that it can't be reinterpreted is on purpose (at least at perceptible time scales) to avoid small amounts of scale rotation when actually just trying to do the opposite gesture.  Google Maps does the same thing.
It doesn't look like `ErrorHandlingFile` overrides `openSync()`.
This test is good. A test that you get a tool exit for the operations that `_validateReadPermissions` is also needed.
Ahh, yeah I did not run my integration test with this change after switching to the error handling file system. I could modify this so that it skips the random access file.
```suggestion   /// Attempt to find the length from the file to ensure that read permissions are correct. ```
done
Include this above with the other constants starting on line 83.
done
Not sure the implementation of `hash2()`, but this seems worse?
The hashcode itself is kind of pointless anyway - since it is hashing the lengths of the checksum/properties.
that's true
Wonder what else is using it.
The possibilities are limitless 
I'm not familiar with this code, should we printError here, or is this expected to run into `YamlExceptions`s?
At this point we're still discovering plugins - I think it should definitely be non-fatal, but I'm not really sure how actionable an error parsing the yaml would be. I will add it to the trace so it gets surfaced somehow
Yeah, trace makes more sense actually
Why do we still need `?` after `key.keyLabel` here?
Ok I see you've explained it in the PR description. But how come it doesn't trigger lint error?
You're right, I don't need the `?`.  Not sure why there's no linter error.
We shouldn't track this in two places.  Can you update the `create.dart` usage (which populates the `.iml` template) to `kAndroidSdkMinVersion` and delete this?  Also, I wonder why the ide templates aren't using that, they hardcode the SDK version instead of using `{{androidSdkVersion}}`: https://github.com/flutter/flutter/search?q=%22Android+API+25+Platform%22&unscoped_q=%22Android+API+25+Platform%22  Can you update those manually to 29?  I created https://github.com/flutter/flutter/issues/63522 to change these to use the template context.
@fkorotkov we're ready when you are :)
sure. Done.   re: the ide template stuff, ya it's a bit unclean. I think it was a template to unpack IntelliJ projects for the Flutter SDK itself rather than a Flutter project so it doesn't have the same templates. Still worth cleaning up. 
what do you mean? 😅 seems the image is working for you 🤔
ah ya LG. You were just mentioning on chat previously whether we needed 30. Awesome, thanks!
oh, right. I was asking in the context of using 30 in the `catalina-xcode-12.0-flutter`. I'll upgrade it once this PR merged or it doesn't matter and I can bump it any time?
You just meant creating a new catalina-xcode-12.0-flutter rather than moving all our current tests to catalina-xcode-12.0-flutter right? if so then ya, any time is good.
So the question here is do you want Android 30 as part of this PR #63252? cc @jmagman 
If I understand your question, it's 2 separate things. This is Android 30 for Linux and Windows, that one is Xcode 12 for macOS. We can do them separately. 
style nit: avoid "note that", see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-empty-prose
Also, it is unclear to me what you actually mean by this comment. Like any widget you'll have to rebuild the widget if you want to change any properties. 
Sorry for late reply. I tried to modify docs as you said. Hope this one would be better
```suggestion   /// It is usually more efficient to create children on demand using   /// [ListView.builder] because it will create the widget children lazily as necessary. ```
This is surprising, shape is never null, so this should always return non-null.
null can be returned with BoxShape.rectangle and a null borderRadius.
Nit: a new line.
The formatter removes the line at the end.
Covers basis of specifying true or false options, or using default (null) option
Let's check the right padding as well since it is part of the change.
same for sliver one
Let's keep this so I can figure it out next time, too.
This is the default and could be omitted.
Update https://github.com/flutter/flutter/blob/master/dev/snippets/config/templates/README.md to mention this new template?
I believe OutlineButton is outdated, and should be replaced with a OutlinedButton (note the extra "d").  /cc @HansMuller 
For completeness, the RestorableInt needs to be disposed in `dispose`. See also https://github.com/flutter/flutter/pull/63497.
Yes, please use OutlinedButton
...
i've filed https://github.com/flutter/flutter/issues/63510
removed
Nit: remove this new line to pass the license check.
Done. 
a fly by comment, shouldn't we assert in this case to indicate whoever simulating the keys event are doing it wrong?
Do you mean this should crash in debug mode but pass in release mode? I kind of get the intention, but still why would anyone release a piece of code that crashes in debug mode?
The reason is that unless they press the key that causes the problem during their testing, they won't know that it crashes in debug mode.  And I don't think an invalid key sequence should crash the app in release mode: it can be ignored if it gets that far.
Sounds good :) 
Maybe you can add this to the comment. Your explanation is pretty helpful.
OK, sounds good, added a comment.
Maybe comment where this is coming from or force the paragraph to actually use this size.
Why not just renderWrap.add(RenderParagraph(...))?
nit: lineHeight?
same.
Is making a list and `join`ing too clunky?
Is there a test that's just `--null_assertions` without a `--foo`?
Very difficult for my sleepy brain 🤣 
I just wanted you to know that I understand the fence post problem
I added a unit test that tests various flag combinations in computeDartVmFlags
fixed
Maybe `'Perform additional null checks...`
This one is removed due to duplicate of the assert in `dragFrom`. 
I think assert the value that's going to be used is more meaningful than assert the global constant. 
The line breaking here looks strange.
Nit: consider reusing the documentations from `FlutterDriver` such as ``` [duration] specifies the length of the action.   The move events are generated at a given [frequency] in Hz (or events per second). It defaults to 60Hz.  If [duration] is null, input events are assumed to happen at once, and [frequency] is ignored.  See also [LiveTestWidgetsFlutterBindingFramePolicy.benchmarkLive] for more accurate time control. ```
The `touchSlop` logic seems to be much more sophisticated than the `scroll` logic in `flutter_driver`, and it could generate more input events than `duration * frequency`. Shall we just create a separate `drag` function that doesn't have `touchSlop`, but use `duration` and `frequency` to decide how many events to be generated?
`touchSlop` comes in as a bug fix in #26438. I'm feeling it sophisticated too but I don't have good enough reason to change it. I'm expecting in the duration-frequency version, because `offset/(duration * frequency)` is very small (if the frequency and duration is reasonable), it will always go to single event for each individual input. However if a user is abusing these numbers (like duration * frequency gives 1), I don't want to trigger that bug, so I'm using this as a fall back. 
Done
As for driver, I feel it's just we are being lucky not having gone into that bug. 
Double checked  #26438, without this `touchSlop` the widgets that are having issue is the cupertino style switcher. I guess scrolling is not when there's problem. In `flutter_driver`, there isn't a `drag` but always scrolling. My understanding is `flutter_driver` has not reached the stage of being able to do all operations and no one has used `flutter_driver` to test dragging a cupertino switch. However, changing the timed version to `scroll` doesn't sounds good to me because the operation is not always scrolling either (like the one in `macrobenchmarks/picture_cache` which is using `scroll` in `flutter_driver` and causing confusion). 
I'm a little inclined to keep it simple until we've seen actual abuses (like `duration * frequency` gives 1) that require us to add such complex logic. Otherwise, we risk of making many of our tests potentially hard to reason about without actually helping anything. Specifically, since we're going to use this in places where `FlutterDriver.scroll` was used, I felt just matching `FlutterDriver.scroll` input events would be good enough to not trigger any new bugs.  Additionally, the old `touchSlop` logic seems to be specifically designed for `duration == null` case and breaks a single move event into 2 move events. Using such logic to break n events into 2n events looks unnecessary and unintended (suppose the offset is really large so each event's offset is large enough to be separated).
So I moved the timed part to `timedDrag` and `timedDragFrom`. PTAL
I also added a unit test for `timedDrag`. One more thing that's worth mentioning (already in a comment), the PointerUpEvent and its corresponding PointerData doesn't provide `button` field. 
We can restore all the changes here as `_separateDragOffset` is not going to be used by anyone else
There's no widget given so "the middle of the widget" seems to be an irrelevant documentation.
`[drag]` -> `[dragFrom]`? I suggest putting the identical comments in a template, so it's clear what can be shared and what cannot.
`slowDrag` -> `timedDrag`
Done.
Done.
Removed. 
Done. 
There's nothing wrong with this but personally, I'd write: ```dart final List<_ColumnBuilder> pickerBuilders = Directionality.of(context) == TextDirection.rtl   ? <_ColumnBuilder>[_buildMinutePicker, _buildHourPicker]   : <_ColumnBuilder>[_buildHourPicker, _buildMinutePicker];  ```
Yeah I agree, this is cleaner
Is this pump necessary even with the duration pump on the next line?  Same question for the material text field test.
The name of this file is missing an underscore, should be "text_field_restoration_test".
Good catch. Fixed.
We need one pump to start the animation. And another (with a duration) to finish it.
Nit: use `[offset], [speed], [frameInterval]` so the IDE/doc can cross reference with the argument declarations?
I don't think `[...]` can reference arguments. In all other docs `[...]` is only used for methods, functions, classes, consts, etc, but not arguments of a method. e.g. https://github.com/flutter/flutter/blob/master/packages/flutter_test/lib/src/controller.dart#L44  plus, in api.flutter.dev, we don't have an independent page for an argument. 
this seems wrong, it should just have the path contents
possibly an issue with projectDir
You shouldn't need to manipulate the path string like this - what problem is this solving?
This was a mistake I made. In the commit, I accidentally removed the `dir` in `project-dir` so the test failed and I couldn't understand why at the time. I'll remove this line in a subsequent commit. Thanks for the catch!
Maybe better: "An immutable style describing how to format and paint text."
This comment and name are pretty vague; there are different things that it could refer to (e.g., I would have guessed without having seen the implementation that it was the exterior bounds). How about `GetClientArea`? (I don't think we need `Window` in the name of a method on a window object; it's implied.)
OK, will rename to GetClientArea
qarni
Fixed in more recent commit
```suggestion /// await expectLater(tester, meetsGuideline(textContrastGuideline)); ```
This sucks. The plugin linter tests are going to hit this problem with Xcode 12, too. \cc @cyanglaz 
I'm not familiar with the syntax. Does "canFail" make the analyzer pass even hitting this problem?
Yes, it's running this check but not failing the test if the linter fails.  Flutter is missing an ARM simulator slice, so will fail on Xcode 12.
This would probably benefit from a little more detail. What does it mean to have "structured errors"?
Dartdoc cannot resolve these references: https://cirrus-ci.com/task/6118617987153920?command=main#L135  You probably have to capitalize the "w" in Window to resolve.
Hmmm, I'm not sure the capital is working either.  Maybe these don't need to be actual element references?  Something like:       /// Ensures callbacks for `window.onBeginFrame` and `window.onDrawFrame`
Right.  Will update.
(I'll give this a whirl.)
Can you make those hyperlinks?
would be good to point to things like FlutterError and so on where we have more detail
capital letter should work...
this comment is a bit confusing, can you explain more?
This should explain how it uses it
this should also add why people would want to look at this
missing ':'. This should talk a little bit more details
This should also include why we want to look at this
same here and everywhere
Tried to clean it up a bit, let me know what you think of the new version. It was meant to mirror the super method's documentation: [RenderObject.describeSemanticsConfiguration](https://api.flutter.dev/flutter/rendering/RenderObject/describeSemanticsConfiguration.html).
nit: indent 
indent
indent
It seems like only two classes(RenderViewportBase, SingleChildScrollView) are using this in their show on screen. Let's list two of them separately here 
indent
It maybe a little bit inaccurate, we do not override this method often, it just so happens that we uses this method for those occasion. 
Just to be clear, should the indent on the second line match the position of the `[` on the first line, or be indented even further?
it should match the position of `[`
nit, let's remove the `as described above.` It seems to not add much information
Is `ShrinkWrappingViewport` need `clipBehavior`?
`ShrinkWrappingViewport` seems to already have `clipBehavior`: https://github.com/flutter/flutter/blob/77b4505c8014330fba2f2706c658a64bc5d1891b/packages/flutter/lib/src/widgets/viewport.dart#L313
I mean line 314. This function has two return branches, :)
Ah yes, nice catch! Fixed now.
I like it! This is what I was trying to do but it is a much simpler way of tracking it.
Maybe we should update the docs on `RangeMaintainingScrollPhysics` indicate that there are more cases where the range is not maintained. 
Nice fixed!  We can not use the `oldPosition ` above, for example, the `_PagePosition.applyViewportDimension` will correct the pixels due to resizing from zero, and it will cause `RangeMaintainingScrollPhysics.adjustPositionForNewDimensions` mistake. I am currently fix this bug (#65015 ). 
This should be  ``` if ((oldPosition.pixels < oldPosition.minScrollExtent) ||         (oldPosition.pixels > oldPosition.maxScrollExtent)) ``` right?
`If the current velocity is non-zero`
oops. will fix in the reland.
oh wow, how did that not get caught by the tests, yikes
I'll leave this as-is in my reland and will let you follow up in #65015 (i'll review that shortly, sorry i missed that until now)
fixing it doesn't cause any test failures even! what on earth.
fix in https://github.com/flutter/flutter/pull/65135
remove the "not"? As in it used to throw and now it doesn't anymore?
oops yeah
just make the function async and `return;`.
then you can just await here
making this async is... exciting
though... why do you not return the same future as the other call to doSerialization? Or throw? Seems weird to do nothing when called redundantly, and return a future that completes before the earlier "real" call...
took me a while to understand these two sentences. How about:  A change in restoration data is usually accompanied by scheduling a frame (because the restoration data is modified inside a [State.setState] call, because it is usually something that affects the interface). Restoration data is automatically flushed to the engine at the end of a frame. As a result, it is uncommon to need to call this method directly.
`However,`
`frame, this`
sent
for -> of
"final to be persisted scroll offset" is dubious, not sure what you mean
sent
how can we guarantee this?
even if it didn't change?
RestorableValue only calls didUpdateValue if old and new value are different.
Reworded.
It just ensures that you don't call flushData from a RestorationBucket's `finalize` method (which is called during serialization).
ah now that it's not async that works
`childRect.left > size.width` should be `childRect.right > size.width`.  It's probably clearer to just write the function as ```   bool _shouldClipAtPaintOffset(Offset paintOffset) {     assert(child != null);     return  paintOffset.dx < 0 ||             paintOffset.dy < 0 ||             paintOffset.dx + child.size.width > size.width ||             paintOffset.dy + child.size.height > size.height;   } ```  It would be nice if you can also add another unit test that fails `childRect.left > size.width` but passes `childRect.right > size.width` :)
fixed, NICE code review, and clean code.
I will add a unit test too, It seems too easy to make mistakes here ^.^
Done.
@liyuqian I think this is the trouble. Somehow `flutter update-packages --force-upgrade` is downgrading this package. I posted a question in discord. 
Maybe I am misreading this, but won't you wind up with primary for both foreground and background color if we aren't in dark and enabled?  Should the foreground be `colorScheme.onPrimary`?
Yes! Good catch. I will add a test to verify this stuff.
nit: align the `:` with the `?` for clarity
Good point.  Looks like this is moot now, since @a14n made the type of `handler` nullable.  I've reverted this part of the PR.
This is awesome. Your PR LGTM.  My only question is if there is an official documented procedure for rolling the gallery here, and if it can be updated to reference this file.
I don't know. I'm asking right now.
+1, interested in how this works as gallery changes - don't we want master to test against the newest gallery?  this seems more reasonable for branches than master (but I may be misunderstanding)
If we always ask `flutter/flutter:master` to clone `flutter/gallery:master`, an error in Gallery might cause Flutter's build to fail. These tests always uses latest `flutter/flutter:master`. I think the best way is to use a commit hash instead of a branch, and set up a process to roll it regularly. (But this is a future task.) 
@christopherfujino @pcsosinski   There isn't a process to roll the gallery version yet. It would be a good idea to add this process, some time in the future.
The message we show when anything here is missing was written with the assumption that installing GTK-dev libraries would install everything in the list as a dependency, so doesn't list the individual libraries. Do we need to revisit that string? E.g., on Fedora is it relatively easy to get into a state where of the things on this list only `blkid` is missing?
In the particular case of `blkid`, if you don't explicitly grab it's location from pkg-config, it is implicitly assumed to be installed in the system root (see the linked bug).  This is not a problem if you manually install your GTK development packages locally (as instructed in that message), but it is a problem with the `flutter-snap` for example.  It's not good enough just to have `libblkid` available in the snap. Without the project explicitly asking pkg-config where it is, the linker makes guesses (as mentioned above).  I don't think it hurts to have `flutter doctor` check for this library in addition to the others, but if you think it unnecessary, we can take it off the list.
In short, the message **doesn't** need to be updated, nor does this library need to be on this checklist.  Really, the only necessary changes in this PR are the `pkg_check_modules()` and `target_link_libraries()` additions in `flutter/CMakeLists.txt`.
I'm fine with adding it to the list since it is in fact a dependency, I just wanted to be sure we didn't also need updated instructions. Thanks for the explanation; I understand now why we don't.
For my understanding: why this change?
This prevent usage of nullable type as type parameter and T is treated as non-nullable.
Why is this nullable when we assert that it is not null?
Ditto
Shouldn't this be `required TextDireciton textDirection`?
Ditto
We assert this isn't null. If we have to make it required that's probably better than making it nullable.
Or is this because the super class lets it be null?  Is there a big impact to changing the superclass in that case?
Ditto here - if it's all because of the super class we should look at just making the super class non-nullable as well.
More of a question: is `FlutterError.onError?(....)` allowed?
No but you can use `FlutterError.onError?.call(....)`
The overriden method documents that textDirection can be null https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L470-L479
Same here https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L449-L458
Same here https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L483-L487
Ahh ok. That makes sense.
After trying to make direction non-nullable there are several failure in tests. null is actually possible as argument for `BorderRadius.resolve`. So I'll revert the last commit.
Parent class value is nullable, this should be nullable too
I wasn't sure what to do with these. The key event data requires these are non-null
syncCall cannot be null,  though it doesn't effect this test
Null is frequently used to check if these are set in tests (here and elsewhere)
late doesn't work here with the override in flutter_test. I can't really explain it, because it doesn't make sense to me
You can just remove the entire line.  I think I just put in the nulls to highlight that for the test they weren't being specified. A comment would have been better.
Hmm, maybe the signatures got updated? Last I checked it had to be non-null, but this PR is a week or so old now
Analyzer is complaining about this one.
nit: maybe rename for clarity to `RecordedCanvasCall` and rename the subclass to `RecordedRotateCall`, etc?
I'm a little confused. Will this path appear in a user's app?
not at all
this was a test in the flutter repo that we checked in a .packages file for, there was an exception in our gitignore
Oh I'm sorry, it's been so long since I coded I forgot how to read a diff...
:P 
```suggestion       only_if: "changesInclude('.cirrus.yml', 'dev/**', 'packages/flutter/**', 'packages/flutter_test/**', 'packages/flutter_drive/**', 'packages/flutter_localizations/**', 'bin/**') || $CIRRUS_PR == ''" ```
Can we only add the link to stackoverflow? Too many choices may make it difficult to to chose one.
Maybe: Ask your questions about how to achieve a particular effect in Flutter or get help with using a particular API. 
sounds good to me, I've included both Reddit and SO following this [comment](https://github.com/flutter/flutter/issues/61094#issuecomment-668777210)
Sure thing
Note these newly created plugins will not be able to be used by Flutter apps with a minimum of 8.0 (compilation time error), so that's all apps currently in the wild now.  I really wish there wasn't an error for this, or at least I wish it was suppressible.  I'm willing to be convinced we shouldn't increase the plugin minimum requirement for a few stable cycles until more apps have upgraded to 9.0...
so you're saying an app can't use a plugin with a higher minimum ios version?
Yes. I'm going to revert the plugin min version bump, it seems like we need to talk about that separately.
This is not used for published plugins, it's generated for app and modules that need to import plugins.
SGTM
Per the gold team, the current refactor they are doing will make `master` -> `master_str` (where we are now) -> `master` Can we instead check to see if `master` is available, and if not use `master_str`? That would reduce churn and eliminate breakage for us in the interim.
SGTM. Can we encourage them to avoid the term "master" entirely?
I think it is based off our own branch naming convention. @LeandroLovisolo is that correct? 
```suggestion       "master_str": { ```
To satisfy the analyzer: ```suggestion Future<void> testWithOutput(String name, Future<void> body(), String expectedOutput) async { ```
nit: Indent the other lines so that they're aligned with the first line
Thanks, fixed 🙂
nit: remove extra whitespace before first line in test body.
use only one line of whitespace here instead of 2.
remove whitespace at the end of the test block.
We don't have a tool specific template, but https://github.com/flutter/flutter/issues/new?assignees=&labels=&template=BUG.md&title= might be a better link
I considered that but I thought it would make the error message sufficiently uglier as to outweigh the benefit.
This change is making the test slightly less precise (the `.called(1)`) is missing. instead of just having a `didCopy` boolean, can we have a `copyCount` integer?
Done
Just to double-check: No other pubspec file changed as a result of running `flutter update-packages --force-upgrade`? 
yes, since this was a dev_dependency it doesn't affect the version solving of any other package
```suggestion   /// This is why the default value is false. Most of the time, when you change the ```
```suggestion   /// expectation and re-use the old widget. ```
Is it necessary to have a list of BoxShadows here? Or can we just pass an empty list?
I guess it should not create a problem if we pass an empty list, since the method checks if there are boxShadows in the list to paint, or else it's skipped.
Let's do that and maybe add a comment that since there's an elevation of 0 equates to no shadows, it's just an empty List<BoxShadow> so future readers don't get confused
nit: already returns a bool, so no need to use an equality here: ```suggestion     assert(!kElevationToShadow.containsKey(widget.elevation), ```
I would avoid using the full set of values here. Maybe do a pointer to api.flutter.dev/flutter/material/kElevationToShadow-constant.html instead, since the problem with this would be any change to the values in kElevationToShadow might cause this to accidentally be off. For example, if we add an elevation value for 48 and forget to update this assert message, it'll be incorrect.   ```suggestion       'Invalid value for elevation. See the kElevationToShadow '       'constant for possible elevation values.' ```
Makes sense, I'll do the changes.
nits: Can we explain more? Like what's "Native stacktrace", where does user get dart stack trance, etc.
nits: use // for TODOs could you also link this TODO to an issue to track?
I don't think this has to be dynamic? Just `String?`.
nit: remove extra blank line
Done
nit: indentation. 
nit: indentation
This is intended. The cookbook article talks about floating bar, so I added it as a sub-node to the SliverAppBar list item. If that's too confusing or if we try to stay away from nested lists in API docs, I can correct this (and the other instance below).
I would prefer not nesting these to keep them simpler.
1 line?
Outlined for M2?
maxLines has to be null for the `expands` logic to work, so we limit to 2 characters
yep that is expected
Minor nit:  ```suggestion   testWidgets('DataTable sort indicator orientation', (WidgetTester tester) async { ```  The 'test' here is redundant, as they are all tests 😄 .
dart -> Dart
Good catch. Will do flutter -> Flutter as well. Thanks!
```suggestion     'This feature was deprecated after v1.21.0-1.0.pre.' ```  Is this suggestion exactly what you tried before, and it still didn't work?  What if you try 1.20.0-7.1.pre?
Instead of deprecating just the iOS13 value, should you deprecate this parameter now?  That way in the future we only need one follow up PR to remove this parameter.  Otherwise you need one to deprecate this and a second later one to remove it.
Sure, the parameter should be deprecated now to make user use default value.
I think it's still valuable to keep this test around.  Just leave off `iOSVersionStyle` so it defaults to iOS14?
The original tests are now default to iOS14 so we nolonger need these iOS14 tests. But should we add some tests for iOS13 style?
Oh I see.  No I think it's fine since iOS13 will be removed in the future.  Alright this looks good and should be merged when our build is green.  Thanks for following up with this work!
remove -> removed
I've ran "flutter format" to format this file. 
The flutter framework does not use use formatter, see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#formatting. Can you please undo the unrelated format changes?
Done. 
```suggestion           args[1]['action'] as String,           args[1]['data'] as Map<String, dynamic>,         ); ```
FYI @LongCatIsLooong, small autofill change.
Not sure I understand what this is for. Is this for autocomplete text fields?
Ah nvm I see it's for https://developer.android.com/reference/android/view/inputmethod/InputConnection?hl=uk#performPrivateCommand(java.lang.String,%20android.os.Bundle)
This test probably belongs to another file in the same directory: "text_input_test.dart" 
Adding the performPrivateCommand() in here because we introduced an abstract function performPrivateCommand in TextInputClient. This is used for resolving the compilation error. 
Dartdoc is complaining that there's no template for this macro: https://cirrus-ci.com/task/5126735421243392?command=main#L119
Called when the result of an app private command is received?
Added template in editable_text.dart
Done.
Was this a debug message, or intentional? If intentional why go to `stderr`?
That was just a debug print.  Removed, thanks for seeing it.
Any ideas on how to make this less gross? I tried to just have it return a `Timer` with an empty callback, but that lead to an infinite loop in the scheduler.  Should we make the `CreateTimerHandler` return a `Timer?` instead? If returning null works here, something must be handling a null values for the return value somewhere. 
You can make these `late`, then they won't be nullable. If they aren't set, then it will throw on first access, and it eliminates all of the `!`'s below.
Can be `late`.
I would just make these non-nullable and eliminate the `= null` assignments below.
This can be `late`.
This can be `late`.
I would just make these non-nullable and eliminate the = null assignments below.
Can be `late`, and below.
Why not make this late too?
Why not make this non-nullable and initialize it like it was?
Here's my suggested solution to it:  ```dart // ...  return DummyTimer();  // ...  class DummyTimer implements Timer {   @override   void cancel() {}    @override   bool get isActive => false;    @override   int get tick => 0; } ```
Thanks! That does indeed work. Very odd that a default empty `Timer` didn't do the same thing.
In this case it can't. It is only updated when when the pan updates. There is a check on line 46 to see if it is null after just a down event, signifying that the update wasn't yet called. 
Yeah, the logic here is a bit convoluted. It looks like they were trying to ensure that these detectors are properly disposed on shutdown with the `addTearDown` calls. This would mean that they are disposed even if an exception was thrown in the middle of the test. However, they also want to manually dispose of these as part of the test. If these are non-nullable, we might get the case where they are disposed twice.  But looking more closely at this, it looks like it didn't really need to dispose of them as part of the test. I will update this to clean it up.
Nope, it is checked for for null later in the test to check that it wasn't set until the drag updated. 
Yeah this one was odd. It is used to record the `primaryVelocity` from the drag end details, which itself is nullable, so it seemed prudent to keep the same type. 
It was because the instantiation of `TestGestureFlutterBinding` has the side effect of setting the `GestureBinding.instance` to itself. However, this was down outside the body of the `main` function, so it wasn't being initialized at the right time.  I have reworked this to move its initialization into the main and make it late. Thx. 
'.json' -> 'json'. Right now the output file name looks like `flutter_size_01..json`
Could we also make this a unique file?
perhaps we should store an output file for each platform - see https://github.com/flutter/flutter/issues/61629
can we generate a snapshot for each platform (see https://github.com/flutter/flutter/issues/61629)? we can write a follow up CL to consume all the generated snapshot files in SizeAnalyzer. Or do we actually need to generate different ABIs with the `flutter build apk` `--target-platform` flag?
Though I'm fine with getting this change in, and adding support for multiple platforms later if that ends up being a CUJ.
What do you mean by platform here - android/ios? or arm/arm-64/x86_64  Given the command UX we started with, I suspect only one platform at a time makes sense.
If we need to do multiple platforms, we'll need to create multiple BuildInfos anyway
Sure, how do you want me to surface that info to devtools? Or does it rely on the user dropping it into the UI?
It would rely on the user dropping it into the UI. I just meant using `globals.fsUtils.getUniqueFile();` to create the file if that clarifies!
I mean arm/arm-64/x86_64. One platform at a time sgtm
Done
Done
I think we could do this as a follow up, but it would require more plumbing.
Why do we allow `null` for direction?
It looks like subclasses are asserting that this is non-null?
When is the imageCache ever expected to be null?  /cc @dnfield 
Same question about the image cache here.  @dnfield (unrelated to this PR): Why do we expose the image cache twice: as part of the binding and as a global? Should one of them be deprecated?
I looked at the usage of `ImageSizeInfo` and was surprised that we allow `null` for these values.
How can this become null? The constructor asserts that it is non-null.
I think this should not be null
Ditto
No but it gets created by a virtual method. Can we make it late?
That predates my work.  @jonahwilliams might know.  I would be fine with deprecating the global.
I don't quite remember. It might have been global before we moved it into a binding
Did some digging, looks like it was moved into the binding in https://github.com/flutter/flutter/pull/13409 and the global was kept. I'll prepare a PR to deprecate the global similarly to how we deprecated the global `defaultBinaryMessenger`.
It is nullable because null can be used via gradient.dart `Shader createShader(Rect rect, { TextDirection? textDirection })` or with ImageConfiguration that accepts null `textDirection`.
I made it nullable because L117 there's `imageCache?.clear();`. I will change it to late non-nullable
This change makes the following test fails:  ```dart   test('PaintingBinding with memory pressure before initInstances', () {     // Observed in devicelab: the device sends a memory pressure event to us     // after PaintingBinding has been created but before initInstances called,     // meaning the imageCache member is still null.     final PaintingBinding binding = TestPaintingBinding();     expect(binding.imageCache, null);     binding.handleMemoryPressure();     expect(binding.imageCache, null);     binding.initInstances();     expect(binding.imageCache, isNotNull);     expect(binding.imageCache.currentSize, 0);   }); ```  I guess I can remove it?
Ahh I remember now.  This caused flakes sometimes because the memory pressure would get processed before finishing binding initialization on rare occasions.  I guess we have to leave it as nullable.
Please don't remove this test, this was a real failure. @dnfield I think re-ordered some of the initialization but I don't think it is solved.  Specifically, we can have a queued up message for us when initializing the binding, which might be a low memory event. I believe that gets forwarded immediately, but due to the binding order will run before the image cache is initialized. That doesn't mean that the image cache needs to be nullable, since this state isn't generally observable - but you do need to track whether it has been initialized somewhere.
Something like: ```dart late ImageCache imageCache; bool _imageCacheSetup = false;  ```
ok, after reading more carefully the comment I understood that it was not a good idea to remove it :)
@jonahwilliams I'm not sure to follow. Do you expect a change in this PR or are you just talking about a future change that could happen?
So I have to make a "breaking change" with:  ```diff -  const ImageSizeInfo({this.source, this.displaySize, this.imageSize}); +  const ImageSizeInfo({this.source, this.displaySize, required this.imageSize}); ```  Is it ok for you?
This type was very recently added and only used for debugging purposes.  It should be fine.
Actually there are several tests failures with this change and I'm not confortable how to change them. Could you made this change after this PR is merged?
That's fine
Sorry I made a mistake. The failures appear with `ImageInfo` where some tests return null image
The tests fail with the following diff:  ```diff --- a/packages/flutter/lib/src/painting/image_cache.dart +++ b/packages/flutter/lib/src/painting/image_cache.dart @@ -389,7 +389,7 @@ class ImageCache {      _PendingImage? untrackedPendingImage;      void listener(ImageInfo? info, bool syncCall) {        // Images that fail to load don't contribute to cache size. -      final int imageSize = info == null || info.image == null ? 0 : info.image.height * info.image.width * 4; +      final int imageSize = info == null ? 0 : info.image.height * info.image.width * 4;          final _CachedImage image = _CachedImage(result!, imageSize); ```
changed
nullable is fine for now
no longer necessary right?
ditto
nit: `shaderWarmUp?.execute();` might be more efficient
why do we need this? We just checked that value isn't null in this block
ditto
This should not be nullalble - the ctor asserts it's not null. We should remove the != null from hasListeners
We have to wait for #61042 to be fixed before removing null asserts on parameters.
because `value` is a getter/field a null check doesn't promote it to non-nullable.
`_codec` is not directly initialized in the constructor (it is in a `future.then()` so some code could has access before the callback is executed). I can make the field `late` but we could face LazyInitializationError if `addListener` is call before the async initialisation is done.  WDYT?
Ohh I see.  Yes that makes sense, this should just be nullable 
Ooh, nice. I will need to remember this one for some of the other tests I have were I manually reset these.
Do you also set `tester.binding.window.platformBrightnessTestValue = Brightness.dark;` to null?
Yes I should, done
Does this need to be clamped like it was before?
it gets clamped after the `switch`.
Ah I see, thanks.
One possible way to avoid this (tiny) breaking change is adding a new API `Future<void> settleAnimations()` to `WidgetController`. In it, `LiveWidgetController` can just wait for `!binding.hasScheduledFrame` without `pump` while `WidgetTester` simply calls `pumpAndSettle`. How do you think about that? We could also discuss it with Dan or Ian and see what they prefer.
Throwing an exception when there's no back button still seems to be desired. As `expectSync` may not be available from `WidgetController`, maybe we can use something else (e.g., [FlutterError]). That way, we can probably still preserve the `fails when there are no back buttons` test with a small modification.  [FlutterError]: https://api.flutter.dev/flutter/foundation/FlutterError-class.html
It sounds a good work around. The bad part is for `WidgetController` these two methods sound duplicate. I'm not sure which is better and I agree to discuss further. 
I wonder if it really is desired/consistent with other APIs. By removing the `pageBack` method, IDE reminds me that the `matcher.dart` is no longer needed: basically this method is the only method `expect`ing the existence of a finder, while all other methods are assuming a finder exists, and rely on when really evaluating a finder to raise an error. 
If we're going to do this breaking change, I felt a named parameter map `[duration], {timeout, phase}` is better than a positional one such as `[duration, timeout, phase]`. It should be compatible with most `pumpAndSettle` calls with just 0 or 1 positional argument, and will force `timeout, phase` to be spelled out if used.
nit: please make sure these are sorted alphabetically
We should remove this timeout feature, per https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#never-check-if-a-port-is-available-before-using-it-never-add-timeouts-and-other-race-conditions  Maybe just make the default null and assert that it is null in this version, and mark it deprecated in the superclass and the other implementation? Or maybe remove it entirely? Could be another PR to do that... I'd rather we didn't add more code that supported it though.
iirc you can make `guard` take an `int` and then just return `count` from the body.
if we're changing the API anyway, then definitely just drop timeout entirely.
is it a breaking change?
this whole method is a bit dubious to be honest (we really shouldn't be depending on material or cupertino in flutter_test). It's all just convenience methods. So once we have them anyway, why not also make sure there's a back button.  That said, whether we throw a FlutterError or a TestError (or whatever expectSync fires) doesn't seem to matter that much. This is a test framework, so expectSync is not unreasonable IMHO.
as it is you're still going to through when you try to tap a the button and there isn't one
It doesn't break our current test cases because the optional argument is not used in the flutter/flutter repo. @Hixie 
this implementation needs a test
Done. 
It is tested in `'Test pumpAndSettle on LiveWidgetController'` from `packages/flutter_test/test/live_widget_controller_test.dart`
Done. 
Removing timeout is a real breaking change, tested here: https://github.com/flutter/flutter/blob/67e9b2945ec6b09d4c1719a9aa81578e95cd6071/packages/flutter_test/test/widget_tester_test.dart#L473-L478 @Hixie 
Removed timeout. 
Shouldn't all of these `assert(foo != null)` clauses go away?  Here and elsewhere in the file?
You can make this `late`.
This can be `late`.
You should sync to HEAD again: the services NNBD conversion has landed.
Why can't this be initialized with `DiagnosticsTreeStyle.none`? Then it could be non-nullable.
This function body could be replaced by: ```dart     return nodeDelegator?.call(node, this) ?? (subtreeDepth > 0 ? copyWith(subtreeDepth: subtreeDepth - 1) : this); ```
This could also default to `DiagnosticsTreeStyle.none`, and be non-nullable.
Why not initialize this to "false"?
These clauses can all be replaced with lines like: ```dart ui.window.onBeginFrame?.call(Duration.zero); ```
That's a lot of statements to remove but done :)
I don't think it should. According to its `debugFillProperties`, `TestTree.style` is an optional value to override `properties.style`, with `null` standing for "do not override". 
I think the current one is more readable (but I removed the local var and make it a bang).
I think making it a nullable ensures we detect any and all changes that `performReassemble` can deliver. Although a non-nullable makes sense since our test only checks if it's changed to true, a nullable type makes more sense in the general case.
OMG. I'm so sorry, actually it turns out I was wrong about that: our rules have changed a bit.  They have to stay in for now because there are importers of Flutter that still don't have non-nullability enabled, so these are the only protection they have. We'll make a pass later and remove them all at once. There's a lint we can turn on for it.
I was about to say why we didn't have such a lint rule. I'll revert this change. Thanks for informing.
Same as the other one (https://github.com/flutter/flutter/pull/62616#discussion_r498576029)
I still think nullable is the way to go. I like the `expect(result, isNotNull);` line; removing it from the test feels off.
Discussed in https://github.com/flutter/flutter/pull/62616#discussion_r499060405
We should do a while loop on `indexOf(firstChild) > 0)` and only return on line 185 if firstChildScrollOffset < -precisionErrorTolerance, other wise we should continue downward to finish the layout.  If we set it to null here and return on line 185, the rendering binding will think the layout is finished and proceed to painting. 
lets add a expect(tester.takeException(), isNull)
For example this may cause a problem if the children after the firstChild change their size in this perform layout.
Ah, I think I see what you mean now. I'll update. Thanks!
This does not look right, the `earliestScrollOffset` is at the beginning of the first child already, we want to take `earliestScrollOffset` and minus the paint extent of child before the first child. I think one thing that is confusing of the original code is that line 177 ` earliestUsefulChild = insertAndLayoutLeadingChild(childConstraints, parentUsesSize: true);` will actually update the firstChild. So the firstChild in line 173 and line 179 are actually different.
Can you add a comment to explain why we need to do this check and why we use the while loop? (something about the paint extent can be zero)
Sure!
We could also change the sdk version, though it doesn't matter too much since it's shipped with Flutter.
If you want to do that, it would become `>=2.9.0`
I don't see any risk of that but since we are cherry picking this, let's make it as simple as possible. We can always update the sdk version later. WDYT?
I don't have a preference.
Oops, looks like I forgot to remove a TODO, do you think you could remove it as part of this PR? Looks like the formatting of that test is a bit off too.
Will this result in any visual diff from the ButtonBar?
Sure, done.
I don't think so. I've already done some image diffs before and after this PR, to check. Still need to check the test repo ofcourse. 
Add this in `main()` under `LoggingProcessManager loggingProcessManager;
done
Sorry, I also meant because `logger = BufferLogger.test()` is in setUp, match the pattern of `LoggingProcessManager` and just declare it here.
```suggestion   BufferLogger logger; ```
done
Yeah I did that and forgot the remove the other constructor call. Fixed in a new commit.
Is this needed for the docs fixes?
Yeah, the docs reference stuff from there, it wasn't part of the public API though and no docs were generated for it.
Alternatively, we could change the docs to not reference this. Let me check that this should actually be part of the public API...
You're right, just exporting this for the docs is strange since it isn't really part of the public API. I instead changed the location where it was referenced to not link it.
SGTM
über nit: It appears these are organized alphabetically except for this one. 🤓 
🤦  I will fix this in a follow-up PR (I want to submit this ASAP to avoid new warnings from sneaking in and pushing another commit would restart all the bots...)
As promised: https://github.com/flutter/flutter/pull/62611
Nit: add `flaky: true` to the new task.
Done. 
please use consistent indenting on all lines
nice catch
/cc @dkwingsmt or @gspencergoog Is it expected that the label can be null? If so, can we add something to the docs here to explain what that means?
/cc @LongCatIsLooong When is this expected to be null? Can we add that to the documentation here?
Should this be `late` to keep the laziness of the original code?
It's not supposed to be null but I might have omitted `currentEditingValue` in some of the tests.
Static variables and top level variables are already lazy in Dart so I think `static late final` is the same as `static final`. @leafpetersen or @lrhn is it correct?   If yes the analyzer could perhaps have an hint to prefer `static final` over `static late final`
By making `currentEditingValue` required and non-nullable tests on packages/flutter are OK.  I made it nullable because in the constructor it was not `@required` and not asserted as not null.  I'll make the change to have non-nullable type.
null seems to be possible regarding https://github.com/flutter/flutter/blob/7ec2d360bce51f010554be8d80572af4748a4a95/dev/tools/gen_keycodes/lib/keyboard_keys_code_gen.dart#L61-L73
Yes, null is possible, since it's possible that we don't have the key label data for a key.
Can we update the doc comment here to mention that?
This is odd. Returning null from here is always a bug, it means we missed a case in the switch. This should really be non-nullable (unless null is a legal value for affinity).
The `?? TextAffinity.downstream` is strange since `_toTextAffinity` effectively can't return null (see comment above).
This surprises me, why is null allowed here? (according to the doc it only sends string representation of enum values.)
Maybe `encoded['selectionAffinity']` can actually be null?
This is strange again. If `message` is non-nullable, then this method should never return null - it would be a bug if it does.
Done
Changed to non-nullable
Because `StringCodec` implements `MessageCodec<String?>` and its decode/encode methods accepts/returns null.
Changed
No idea :-( Let's run tests and see...
Thanks to CI (https://cirrus-ci.com/task/5831088616505344?command=main#L38) we have an answer:  ``` 00:00 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                   00:01 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                   00:02 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                   00:02 +0 -1: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart [E]                                                                                              Failed to load "/private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart": Invalid argument(s): AppLifecycleState null not supported.   package:flutter/src/services/binding.dart 207:5     ServicesBinding._parseAppLifecycleMessage   package:flutter/src/services/binding.dart 185:38    ServicesBinding.readInitialLifecycleStateFromNativeWindow   package:flutter/src/services/binding.dart 35:5      ServicesBinding.initInstances   package:flutter/src/gestures/binding.dart 65:11     GestureBinding.initInstances   package:flutter/src/semantics/binding.dart 24:11    SemanticsBinding.initInstances   package:flutter/src/rendering/binding.dart 32:11    RendererBinding.initInstances   package:flutter/src/painting/binding.dart 23:11     PaintingBinding.initInstances   package:flutter/src/widgets/binding.dart 257:11     WidgetsBinding.initInstances   package:flutter_test/src/binding.dart 318:11        TestWidgetsFlutterBinding.initInstances   package:flutter_test/src/binding.dart 914:11        AutomatedTestWidgetsFlutterBinding.initInstances ```
Looking at this code again, I think the idea is that if `encoded['selectionAffinity']` is null, this should default to `TextAffinity.downstream`.
`static late final` with an initializer is the same as `static final` (and also when non-final).  Without an initializer they are different.  +1 for a hint/lint.  cc @bwilkerson 
Actually this is null on web plateform and is the cause of #62724.
"the appropriate elevation for app bars." is really just noise. We could delete it.
Appbar => AppBar
primary => [primary]
nit: 2 space indent
"at the same time" seems confusing, this all properties are applied at instantiation time.  Maybe "along with"?
You're removing this because the reader can find this out by clicking through to `[AlignmentGeometry]` (and then transitively through to `[AlignmentDirectional]`)?
s/an/a/
`[SemanticsProperties.label]` ?
`[SemanticsProperties.label]` ?
It's probably worth adding docs to the class docs of `NavigatorState` that says you can get a reference to the class by calling `Navigator.of`
I actually didn't mean to remove this. Putting an updated version back in.
why does the order of the keys in the output map matter?
add some dart doc describing what this class is for
add dart doc describing what this method does. Add a note saying that `aotSizeJson` can be from instruction sizes or v8 snapshot (if that is correct)
make this documentation more specific. This method seems like it is specific to the lib/ directory in an APK. note that here
use string concatenation `'$totalPath/'`
This needs a copyright header too
this should be an exact version, then run `flutter update-packages --force-upgrade` to update the checksums
make these two named and required parameters
for the consts here, I would hoist them out of main at put them at the top level
this issue is marked as fixed, is this still necessary
nit: if _currentNode_ does not have any children 
i'm surprised that we are checking that `className.isNotEmpty` and checking that `libraryUri != null`. I would expect these two checks to be the same. Why are we checking for null on one and empty on the other?
Neither ancestors nor siblings are used in the test, so they currently have 0 coverage
what are we grouping by 2 for? perhaps put 2 in a const that describes what the number represents
does `childWithPathAsName.addValue(pathsToSize[paths]);` need to be called before `currentNode.addChild(childWithPathAsName);` so that the `childWithPathAsName's` value is summed into `currentNode's` value when calling `addChild`?
why 10? put in a const with a descriptive name
same comment here. why 4?
make these required named parameters
rename to addAotSizeDataToApkAnalysis
It's to make sure that the type field isn't just hidden at the bottom of the json because of the giant AOT data. I'm not sure when the user would need to check the type manually by opening up the json, but I was thinking it'd be better to make the type field more visible.
Done
Done
Done
Done
Done
Done
Done
Done
Done
`childWithPathAsName`'s value should already have been added to currentNode on the previous iteration of the loop.
Removed since those are not used (the entire `SymbolNode` code was copied from here: https://github.com/flutter/flutter/issues/51594#issuecomment-639823612)
Removed
Done
+1. Sorry my draft didn't have docs but all public fields of public classes should have docs. 
Using required named parameters will be clearer than positional parameters here.
From other PR: if this function now does 2 things, reflect it in the name.
From other PR: using zipinfo rather than unzip could be an optimization (feel free to do it in a separate PR)
add some code comments here
If this isn't used outside make it private
add code comments here for what this is doing
add code comment here. e.g. we picked this specific file to match and print the aot content because it's likely the most popular architecture and other architecture sizes should be similar so it's not worth repeating
I'd somehow via the names make it clearer that _printLibDetails prints a tree and _printEntitySize prints a line
This can probably be private. Also add comments
ah is this why those parameters were in the constructor? There is already a dependency injection mechanism. See other tests using `testUsingContext`. Then you can remove those construction params. 
Done
Done
Done
Done
Done
I think snapshots for all three platforms will be included in a follow-up CL. Should I still add the comment?
Done
Removed
Added a TODO
Done
Done
@jonahwilliams helped me put in those constructors explaining we might not want to use the `global` keyword. Would removing the construction params force us to use the `global` keyword?
Yes, new code should not use the global zone injection - it makes testing the code very brittle as we've found that new contributors frequently do not understand which interfaces need to be overriden.
2020
2020
new line at end of file
confusingly it should be 2014
This needs a bug assigned to it
this should be a printError and not a regular print
Prefer hoisting this into a private static, to avoid recompiling the regexp every time it is created
formatting is off a bit here, indent the required params by 2 spaces
Done
Done
Done
@peterdjlee 
So the new consensus is to do constructor injection through the entire graph? Is there a tracking bug to migrate existing code?
you need a newline here to make analysis pass
https://github.com/flutter/flutter/issues/47161 , but I haven't done a good job of keeping it updated
Do these need to be relative imports to fix the analyze bot?
Looks like other files have relative imports! Changed to relative imports.
FYI, as far as I know we do not document requiring zipinfo to be installed, so switching may not be straightforward
both zipinfo and unzip are built-in on macOS and neither are built-in on Ubuntu so we're more or less in the same position either way. 
No, we're not in the same state - we require unzip and warn if it is not installed and do no such thing for zipinfo
ah I see, SG, let's leave it then. This makes it simpler. 
This is conflicting with the doc comment above it.
Fixed
'[SemanticProperties.label]'?
Nit: `s/used, if/used. If/`
(and elsewhere in this file)
`* The time picker widget ([showTimePicker])` ?
Typo of the old code `Scrpllable` -> `Scrollable`.
Done. 
Nit: `See also [dragUntilVisible].`
Done. 
LOL. What exactly does a "Customer Clipper" do?  Doesn't sound like something we'd want to implement. :-)
Haha! 
Maybe we should make a little `join_paths` helper function for this file that does what `path.join` does, so we can keep the simpler inline logic (and don't need to duplicate it more times if we need to add more paths)?
Done
`k` is really only for constants. This shouldn't be top-level, since it needs to inject Platform
I don't think you should re-use flutterGit here, since this is now secretly looking up the value on the Platform.  The test is easier to read with a constant
I believe this is supposed to be "**In** its build,..."
We usually reference the Widget (and not its State).
dito
Can you wrap this call in an assert so it gets optimized out in release builds?  Also, the method name should start with `_debug`, maybe _debugVerifyInsertPosition.
nit: formatting is off here.
While there's less duplication, the code is actually a lot harder to read now than it was before with the if/else branches. I think I'd prefer the old style.
and I will wrap this into another assert so that we don't spend time call into another method in production code.
same here
instead of doing if else can you merge this two by doing newEntries?.contains
we will also need to update the error text to be more generic if we merge this too check.
Could you leave a comment linking this path with the useSyntheticPackage setting in the flutter tool?
nit: if you have a return here you don't need the else below.
There is one small missing feature: you could check that generate is true and if not warn that the sources won't be importable. 
I just [added the feature](https://github.com/flutter/flutter/pull/62395/files#diff-d27c3ed6f283118c1a9719f24ec8a4f5R42) and [a test](https://github.com/flutter/flutter/pull/62395/files#diff-e3ab382c96a655e902c9ff5ba96fa840R71). PTAL
Use `var proj = FlutterProject.fromDirectory(environment.projectDir); flutterProject.manifest.generateSyntheticPackage` instead of parsing the pubspec yourself.
nit, just return the result:  ``` return buildSystem.build( ... ) ```
Can you pull this parsing logic out of the the Pub class?
?
what is this change fixing?
nit: remove comment, doesn't really need describing
instead of catching the exception, use:  `expect(() => .., throwsToolExit(message: ...)`
It doesn't fix anything, but I thought that it was a little clearer to me to just be explicit since `fromDirectory()` is simply the same thing as `globals.projectFactory.fromDirectory()`.
you could drastically reduce the nesting here by re-arranging the code a bit:  ```dart if (!exists) {   return; }  if (condition that causes type error) {   ...   throwToolExit(..); }  ``` i.e. check for errors first, and early return/throw
ahh, right
`expect(() => ..., throwsA(isA<Exception>())`
you should also check that the logger error text contains some part of the message you added
Please don't implement your own mocks. Either use the Mock/Fake class from mockito, or use the FakeProcessManager
`return await` does not really do anything, you can return the future directly
Is there an existing function which already handles this? If not, should I move this somewhere more centralized?
This code looks correct to me, I am curious though why we want to & with the offset.zero at the first place @goderbauer 
I think we forgot to change this when the code was moved in https://github.com/flutter/flutter/pull/13983 a loong time ago!
I don't think this is needed very often. Usually you only care about their relative position to the parent. Having that just here seems fine.
Nit: Demo code should either consistently use or omit the `.0` on doubles
To follow Material Dialogs, should we put the OK button last/left?
```suggestion   /// centered within the available space. ```  maybe?
If this is null, then it uses the inherited text direction right? Probably worth mentioning that in the documentation.
To match the other lines ```suggestion     properties.add(DoubleProperty('overflowSpacing', overflowSpacing, defaultValue: 0)); ```
The above setters follow the pattern of returning early if its the same, should this one too?
The above setters follow the pattern of returning early if its the same, should this one too?
Nit: ```suggestion     final bool isRtl = textDirection == TextDirection.rtl; ```
```suggestion       RenderBox nextChild() => rtl ? childBefore(child) : childAfter(child); ```
Nit/Suggestion: ```suggestion   testWidgets('Empty OverflowBar', (WidgetTester tester) async { ```
Nit: Should probably be consistent with keeping/omitting the `.0` for doubles.
Nit: Unnecessary new line
👍
👍  
👍   
👍   
👍   
👍   
👍
I had it this way originally but I suffer from a personal loathing for logically capitalizing acronyms, so `rtl`.
👍
👍
👍
I find that omitting the `.0` makes code easier to read however it was necessary to introduce one in these expressions so that they eval to doubles instead of ints. I realize that it's inconsistent but I've tried to be consistent about that.
I wonder if we should make this default match the material spec for button spacing? Or is that assuming too much? It would just be nice to just wrap an array of buttons with an `OverflowBar` with no params and have it match the old `ButtonBar` layout by default.
For a dialog you'd also need to end-align the OverflowBar and somewhere you need to ensure that the OverflowBar can be scrolled into view.  Using 0 for the spacing seemed appropriate for the widgets library since it's probably the wrong place to have an opinion about spacing.
Ah, I missed that it was part of the widgets library 😄. Totally makes sense for it to be there and that the default should be 0. 
nit: double space
... will be still be ... ?
I believe `children` of an `MultiChildRenderObjectWidget` also cannot be null. Mention that in the docs and add an assert?
Is this calculation correct? I'd assumed that if width is big enough everything gets layed out in a row and then the hight would not be the sum of the children heights, no?
Yes, you are correct, this method is incorrect. The min intrinsic height should be: if the sum of child intrinsic widths fit, then the max child height, otherwise the sum of the child heights.
I've fixed this however I still need to add some tests for min/max intrinsic height.
It shouldn't be necessary to qualify Brightness with `ui.`. 
The extra level of indirection provided by `ThemeData.fallback()` doesn't provide much value. Maybe just use ThemeData.light() here. It's a little clearer.
This API doc should really incorporate a `[MediaQueryData.highContrast]` link somewhere.
This would be a good place to reiterate the link to the spec that we're matching. Here and below.
Fixed
Done
Done
Added a comment with a link but there is no published high contrast spec yet. These links can be updated once there is.
use a typedef here.
Probably just `VoidCallback`?
This probably deserves a comment explaining why we have this wrapper object instead of just using the `listener` directly.
Wondering if this would be even faster with a regular for loop. (The code would definitely be prettier without the casting).
Why's entry nullable?
What if `entry.listener()` calls `removeListener` for itself? Wouldn't that set `entry.next` to null and the iteration would end early? 
(If we don't have a test for this scenario, we should add one)
It is required by LinkedList. We cannot do `LinkedList<VoidCallback>`.  We could change `LinkedList<_ListenerEntry>` by `DoubleLinkedQueue<VoidCallback>` maybe?
`entry.next` may be `null` when reaching the end of the list. We need it to be nullable for the `entry = entry.next`
Ah, I see. I didn't look at the interface for LinkedList. Never mind. 
Makes sense. 
Good catch  I should add tests for `addListener(() { notifier.notifyListeners() })` too
... and O(N) _for_ removing ...
nit: the comma should be part of the previous line.
nit: let's call this localListeners again to avoid confusion.
nit, the " " (space) should be moved to the previous line.
nit - typo "immediately"
Could we avoid this copy by getting the next entry before we invoke the current entry's listener?
I wonder if any modification invalidates the list (theoretically). Iterable says modification during iteration is generally not allowed and may throw errors, although not necessarily for List. However can we do a lazy copy, i.e. only copy when the list is first modified during the dispatch?
@dnfield That would break the behavior of "listeners added during notifyListeners are not called immediately"  We could keep track of the last listener before the iteration to work around that. But the complexity is that removeListener can be called at any given time. So the "last listener" may change over time 
lets move the check `parent._debugLifecycleState ==  _ElementLifecycle.defunct` to the first before we check attached
Done.
Can we do this one in a separate PR to make a potential revert easier? This one is a little more risky and may break things (see animations package).
ack - will update it tomorrow morning
Done
It's not clear to me what this additional doc is supposed to tell me. What is the context? (That context should also be added to the doc comment).
nit: I find the phrasing of this slightly confusing/misleding - e.g. where is the cache?  Perhaps something like this:  ``` Loading an image from a file creates an in memory copy of the file, which is retained in the [ImageCache]. The underlying file is not monitored for changes. If it does change,  the application should evict the entry rom the [ImageCache]. ```  We should add similar documentation on `FileImage` in the painting binding.
We should also explain _how_ to evict the image - which is a little difficult to do with an [Image.file] constructed widget, and so we should probably explain that if you expect the underlying data to chagne you should directly work with a `FileImage` provider so it can more easily be evicted on changes.
I think it would make sense to just explain in the docs above this they the provider does not monitor the file for changes and to call the [evict] method if the underlying image data changes.
Updated, thanks :)
I'd put the creation of the cache in `populate_script` of the cache instruction since cache might fail to be downloaded or have some other issue.
please add more context about what this flag does, and why it would need to be passed
there is an android unit test for passing debugging options, that should be expanded to cover this flag
there is also an iOS unit test for flag passing, please update
Added a few more context. Please let me know if that looks good.
Done.
Done.
How about something like  ''' Removes all existing persistent caches. This allows reproducing shader compilation jank that normally only happens the first time an app is run, or for reliable testing of compilation jank fixes (e.g. shader warm-up). '''
Nit: `tabbar` -> `tabBar`
Done
Doesn't this eliminate most of the files?
What about something like this instead? (and do use r'' strings).  ```suggestion final RegExp _pattern = RegExp(r'(<code[^<>]*>)(?!.*?<code[^<>]*>).*?({@[^}\n]*}).*?(<\/code>)'); ```  And why do you have the `?` after the `}`? are macros expected to not be terminated? I mean sure, if someone is misspelling them, they can also not terminate them, but that seems unlikely. 
Given this sort of error, do we want to just search for all words beginning with "@" outside of code blocks? Or is that too many false positives?
It eliminates class-level and library-level files. The majority of files are documentation for properties, which are getting checked. My hope is that we can get this fixed soon-ish on the dartdoc side.
Added `r`.  Since it is essentially free, I do want to catch the error where a macro is not terminated (or has been terminated with a `)` instead of a `}` etc).  I don't fully understand the regex suggestion. Wouldn't that match things inside a code tag?
Unfortunately, that has too many false positives. If that becomes a common source of error, we could also match on something like `(@foo}` and report an error for those.
Yes, I wasn't thinking about the regex in the right way: my suggestion would only match inside of a code block.  Please ignore it. :-)
Yeah, I figured. OK.
nit: Can you expand the doc comment above to include that this will return null if there's not enough data to fit a curve?
This one is surprising. I expected this to be non-nullable.
Why's `+=` no good anymore?
I am surprised that the return type can be null here. 
Why the `?` when the next line is a non-null check?
Oh, do getter and setter need to have the exact same type?
done
Not sure why I made it nullable :-/ Changed
I should have made `_pendingDragOffset` nullable at some point and change it again later. Updated.
It can be null because the catch block doesn't throw and then the result remains null
>do getter and setter need to have the exact same type?  Almost. The rule is that setter can accept the return of getter. See https://github.com/dart-lang/language/issues/331
This one can go back to `+=` as well then?
Fixed. Thanks!
nit: remove `catch(_)`
Done.
nit: don't use "we"  Can this be tested somehow?
I'm not sure if it's worth testing here since it's tested in the SDK, but DDS will throw an exception if another client is already connected to the VM service.
I suppose if this were accidentally removed, the devicelab tests would already be failing.
Yeah, the last time I tried to land this after I stopped swallowing the exception I found this issue. The iOS devicelab tests were very unhappy so it'd be hard to miss.
any reason not to remove on release builds too? It would probably be easier to test this if you removed the header on each request, see the existing devfs_web_test.dart
Probably not many people will use flutter run to serve their production app, but it is not recommended to remove it as this header is used to avoid click-jacking attacks.   I don't think is possible to remove a default header in a request. When creating a response you can add a map of headers but don't see how to remove one. Also, I can't override it as the opposite(eg X-Frame-Options: ALWAYS) doesn't exist.  `shelf.Response.ok(_kDefaultIndex, headers: headers);`
> Probably not many people will use flutter run to serve their production app, but it is not recommended to remove it as this header is used to avoid click-jacking attacks.  But flutter run is still a debug mode essentially, its not a full app server. If it isn't safe for release mode it isn't safe for debug or profile mode.  Yeah, I'll admit I'm not familiar with the shelf APIs. This approach sounds fine as long as you test that the header isn't present somehow
```suggestion       // Allow rendering in a iframe. ```
Not sure why we were specifying `color: Colors.white` before; it's OK to leave the parameter out now? Here and below.
I think so. I just checked this in dartpad and it looks fine without the white color for `RaisedButton`:  https://dartpad.dev/5c0e3ff90da4da543a2d850d1690f259  Not sure why it was specified in first place.
Glad to hear that it wasn't needed.
We should handle null here - I imagine we'd want to throw if it's null, but not throw like this.
If we timed out here, shouldn't we throw?
nit: avoid abbreviation - perhaps just call this `delta`?.  We should also document that delta is assumed to be in the `AxisDirection` of the scrollable.
This sentence isn't complete.
until `finder` is visible?  And I think the `and` should be an `or`.
The last clause here is awkward.  Maybe `but the caller must specify the scrollable that builds child specified by finder`?
Should have tests that test how this fails (e.g. what exceptions are thrown) on failure conditions.
I'm expecting throw will happen at `element(finder)`. See my added fail test case.
Done
Done.
Done. 
This sentence should have been deleted after I added timeout. 
Done
I added doc on throw. 
Not sure which `null` you mean but I added some `assert`. Let me know if I misunderstood it. 
Wouldn't the user want to know that the throw happened here because the timeout was hit? If we let element(finder) throw for us, it doesn't necessarily mean we timed out.
Ahh, maybe we should rename timeout to something like `maxScrolls`?
Changed `timeout` to `maxScrolls`. 
If `element` throws, The only way to exit the `while` loop is to trigger timeout. I agree `maxScrolls` should be more reasonable name here. 
We should assert that widget(scrollable) does not return null before using it.
`assert(scrollable.evaluate().isNotEmpty);` should do the job. And according to `WidgetController.widget` implementation  (https://api.flutter.dev/flutter/flutter_test/WidgetController/widget.html) this will not give `null` if there isn't such a widget but throw, which happens at `.single` (https://api.flutter.dev/flutter/dart-core/Iterable/single.html)
The finder isn't necessarily of that type
And if your concern is `Element.widget`, `assert(widget != null)` is in its constructor. 
> The finder isn't necessarily of that type  If the type is wrong, it won't give `null` either. Then what I should do is `assert(finder.evaluate().single.widget is Scrollable)`. But if I should do this, shouldn't that happen in `WidgetController.widget`?
Now that I had a look at other APIs, non of them are doing `assert(finder != null)` or `assert(finder.evaluate().isNotEmpty)` (e.g. `WidgetController.getSize`). Probably I shouldn't do this either. @dnfield what do you think?
removed those assert. 
The cases when we do assert != null is when getting renderObject from element, which makes sense because along widget->element->renderObject, we can have prior exists without latter, but not vice versa
Ahh ok, I see now. This would throw a cast error if it was the wrong type of widget already, not return null.
nit: instead of "we", document the part of the tool that is waiting normal.
Done.
```suggestion     runApp(MaterialApp(home: Center(child: CountButton()))); ```
Maybe ```suggestion   /// Called to indicate that there should be a new frame after an optional delay. ```  And add in the doc ```   /// The frame is pumped after a delay of [duration] if [duration] is not null,   /// or immediately otherwise. ```
we should probably make it clear that the time that is advanced is the FakeAsync clock when you're using this in `flutter test`, and the real clock in live environments.
Similar things are already in the xxxTestBinding.pump. I added a sentence in `WidgetTester` for this but I don't think it should be in `WidgetController` because `WidgetController` does not necessarily come with a test binding and there isn't the context about FakeAsync because controller is assuming the binding to be general. 
I believe Android/iOS are not supposed to play a sound when you accidentally tap the undismissable barrier. Does this change that?
No, this doesn't change that, because Android/iOS don't have an API to play a system sound, so on those platforms, this platform channel message will be a no-op.
Can you document here what platforms support this?
Okay, let's add some documentation to `SystemSoundType.alert` that describes the behavior on the platforms to make this clear. 
I'd suggest investigating whether it makes sense to pass an `onError` callback to this `listen()`. If there is an error added to a `discoverer` stream, you probably don't want it to propagate asynchronously to the containing zone.
`discoverer.devices` is a `Future<List<Device>>`, I'm making it into a stream with `.asStream()`.  Are there cases there could be errors on that stream?  Streams give me heartburn.
I just realized this doesn't need to be a stream at all.
The edge case Zach mentioned is a bit more obvious when streams aren't used. In this case, after  `Future.any` completes the first future, the second future may still complete w/error. That would cause an unhandled exception to be thrown into the zone.  You could simulate this a similar 2 discoverer setup where one throws an error after another turn.
Done, added test for this as well.
I think this is almost the behavior we want, thought it's not quite the same as before. Previously if a discoverer crashed, we would surface that and go straight to crash logging. Especially if we don't match an exact device, knowing that some discovery has crashed is probably important, but I don't think that it should stop users from running on unrelated devices.  Unsure what the right solution is.
Maybe if there is any error, and the target device isn't found, print an error directing the user to `flutter devices` or `flutter doctor --verbose`.
I was happy with the old crashing behavior so we'd at least see it, but I'm still missing something related to why it matters if it's unhandled and thrown into the zone.  > That would cause an unhandled exception to be thrown into the zone.
I was actually wrong about this. Future.any will explicitly discard errors thrown by future's other than the first. I think what you have here is good
Great! Once this is proved to work, let's add ios and ios32 versions of this in another PR as those are currently flaky.
As we've discussed earlier today, this probably goes to the E2E package.
As discussed offline earlier, this `FrameTimingSummarizer` could either go to a standalone Dart package in `flutter/packages`, or we can put it into the SDK side by side with `FrameTiming`. For those who are monitoring Flutter's performance on real user devices, I think this class would be used hand-in-hand with `FrameTiming`. @Hixie : do you have any preference where we should put `FrameTimingSummarizer`? (We have to put it somewhere so many of our perf tests can depend on it instead of duplicating it multiple times.)
Can we use a `WidgetController` here instead of a more specific subclass `WidgetTester`?
A lot of the following code is very similar to `runDemo` in https://github.com/flutter/flutter/blob/master/dev/integration_tests/flutter_gallery/test_driver/transitions_perf_test.dart.  As we plan to preserve both Flutter driver timeline perf tests and e2e FrameTiming perf tests for a while (partially because timeline still has a lot more information that `FrameTiming` doesn't), it's probably better to use a single piece of code in both places. Maybe now is a good opportunity to let `FlutterDriver` implements `WidgetController` so we can share the code?  This would guarantee that driver tests and e2e tests are measuring similar animations, and avoid the risk that someone changes one test and forget to update another.
Yes, let's do this before landing the duplicate code into the repo :)
According to our discussion earlier today, it seems that we're not planning to measure transition duration in the e2e test. If so, why do we still do this Firebase specific work as only e2e tests can run on Firebase?
This piece is shared with the original flutter_driver based transition_perf test. I just moved it into an `if` so in the e2e it doesn't go through this by not providing a transition_duration file name. I don't know why it talks about firebase.
It's hard. `WidgetController` has everything depending on a binding (it can be a test binding or a real binding), but `FlutterDriver` doesn't have a binding. And the finder in `WidgetController` and that in `FlutterDriver` don't share base class. 
So to do that, the path in my opinion would be to write a mixin separating the controlling part (not the setting up part) of `WidgetController` and share this with `FlutterDriver`, and similarly for both finders. Even with that, there are some APIs doing the same thing but are named differently, meaning the result will be a breaking change. If we still consider abandon `flutter_driver` for driving the test, I don't think it will be worth it. 
Two things: `pumpAndSettle` and `pageBack`:  - `pumpAndSettle` can be replaced by `pump` for a duration, and with policy not being `fullyLive` (which is fine because we don't need accurate control of time but want to wait the frame). The issue is, wait for settling in flutter driver I believe is part of adb (or its equivalence of iOS debugger), while here we are forced to estimate the time, resulting in potentially extra frames, meaning the metric may not be a faithful equivalence of the original driver test;  - `pageBack` can be implemented separately or promote to `WidgetController`. To promote, I need to delete this line: https://github.com/flutter/flutter/blob/30aef0a3b9611763f8e60985e7cca9cb30c1ea6a/packages/flutter_test/lib/src/widget_tester.dart#L1072 because `WidgetController` doesn't have a test context and doesn't have this expect stuff. Justification for this is `WidgetController` is not `expect` one widget for other finders in the API, so is other places for `WidgetTester`. I'm not sure if I should.  
I think our conclusion is both this and the summarizer can first go to a separate package in a personal repo, and then to flutter/packages. 
Or alternatively, make `pumpAndSettle` an abstract method in `WidgetController` and implement it in `LiveWidgetController`. The tricky part is that there's a `EnginePhase phase` optional order/un-named argument in `pumpAndSettle` in the middle of `duration` and `timeout`. `duration` and `timeout` should be part of the API but `phase` only makes sense for `WidgetTester`. This will be a breaking change but luckily ALL `pumpAndSettle` calls in the repo doesn't use this argument. 
A demo of the change #62640 
Oh, sorry that I remembered wrong. I had a second thought that `watchPerformance` might go to E2E because it seems to be just for reporting with the E2E binding. Either way should work and the difference seems to be either letting E2E depend on your new package, or letting your new package depend on E2E. 
Just to add more info: along side with `FrameTiming` means it will be in the flutter/engine repo. 
Hmm... your concerns seems to be very legitimate. In that case, for Flutter driver timeline perf tests, can we just control the test inside `transitions_perf.dart` which is running on device instead of `transitions_perf_test.dart`? Then it seems that the host side `transitions_perf_test.dart` only needs to send a signal to device to start the control sequence (and the host will start capturing the timeline tracing events). The device-side code in `transitions_perf.dart` should be shareable with the E2E test?
Ah, I didn't realize this code was already there before your PR. It seems to be added by @yjbanov 4 years ago https://github.com/flutter/flutter/blame/30aef0a3b9611763f8e60985e7cca9cb30c1ea6a/dev/devicelab/lib/tasks/gallery.dart#L47.  Yegor: do you still remember why we're doing this as I'm pretty sure we're not using Firebase test lab until very recently? What could happen today if we remove it (the gallery transition test is still not running on Firebase yet)?
Haven't tried but sounds do-able. If that's the case the issue I mentioned above about using `WidgetController` and thus #62640 becomes necessary, and the measured result may be different with the original flutter_driver ones because it's almost a new test (a host-driven and self-driven hybrid test). Will try after #62640 lands . 
Done.
Done.
Done. This part I think I missed in our previous discussion. I also moved it to the new package `end_perf` but I think it might be better to e2e, replacing current `e2e_driver`. 
Why are we removing `kDebugWarning` here?
Done with the newly merged `pumpAndSettle`. 
https://github.com/flutter/flutter/pull/62064/commits/3e83f94d0c67a46bcb653966bd49cd208b6b2ea7 is an implementation of making `flutter drive` test share the driving code with the e2e test (making it a hybrid of host-driven and self-driven). 
I now removed this extra work, but I'll wait to see if there's anything breaking that we didn't realize. 
This diff looks strange.  Maybe remove `flutter_gallery_instrumentation_test` in a separate PR to make it cleaner?
If we plan to use this file both in e2e and flutter_driver-timeline tests, maybe we should rename this file?
It was moved to e2e_perf (watchPerformance). Now I will need to find a new place for it. 
Nope, this file is not reused as a whole. For the reused version `run_demos` function will be in a separate file. 
Somehow during rebase it goes in. It's removed now. 
Nit: add a TODO here with a Github issue to remove this file once it made into e2e.
Do you already have a plan on how to avoid this message?  From here, it's unclear how severe this warning is, and how it might be fixed. If there's no immediate plan to fix this, having more details here or in a Github issue may help a lot in the future.
Done
Ahh I should have removed it long before. This is due to the early version of `e2e_driver` doesn't expose timeout API. After the `timeout` is set to a good value this warning is no longer there. 
This has been around forever, but it'd be really nice if we could suppress the non-JSON text like this when `--machine` is in the args 😄
It should be safe to write this to stderr too, right? I was looking at this a while back but that change ended being hard to land due to integration tests asserting stderr was empty
Hmmm, not sure.. I think there are probably many places that assume stderr is for errors. I think PowerShell may also (or at least used to?) print stderr in scary colors.. some common tool like Git was always causing my grief because it wrote some status messages to stderr and made it look like it'd crashed 😞 
ack
If we're disallowing color changes in the logo widget, why allow them here?
No good reason. I'll remove it from here as well.
```suggestion     // Test TextField's cursor & selection color. ```
```suggestion     // Test the selection handle color. ```
```suggestion     // Test TextField's cursor & selection color. ```
```suggestion     // Test the selection handle color. ```
```suggestion   testWidgets('ThemeDate.textSelectionTheme will be used if provided', (WidgetTester tester) async { ```
```suggestion     // Test TextField's cursor & selection color. ```
```suggestion     // Test the selection handle color. ```
```suggestion     // Test TextField's cursor color. ```
```suggestion     // Test SelectableText's cursor color. ```
```suggestion     // Test the selection handle color. ```
```suggestion     // Test TextField's cursor & selection color. ```
Please add the diagram that you have on the PR to the docs: that makes it super clear what you're talking about.
We seem to be on a nice trajectory here :-). How about : The color of the cursor. Here and elsewhere and in general.  For example: The color of the TextField's selection handles, instead of "The color used to paint the selection handles on the text field".
Doesn't indicate the current text insertion point? Here and elsewhere.
that defines the configuration for the rendering of text selection => that defines the appearance of text selection
This works because the TextField doesn't actually use TextSelectionTheme directly right? Otherwise we'd have to include a Builder.
NICE
`TextField` looks up the current theme with `TextSelectionTheme.of(context)` in the build method, so it should work fine here. 
```suggestion   /// found, then this method will return null instead of throwing. ```
You might add a comment that you can detect whether or not the action is available (found, and not disabled) using `Actions.find` with its `nullOk` set to true.
Done
Done
This is a bug fix. Previous runs with `--profile` is fine so this `assert` isn't a critical check. And the original version neglect the fact that old events will fade.  
`usually considerred` -> `usually be considered`
`location` -> `startLocation` might be clearer.  Nit: It may be helpful to document that `Offset center, Offset totalMove` means dragging from `center - totalMove / 2` to `center + totalMove /2`. Alternatively, it may be more intuitive to take `Offset fromLocation, Offset toLocation` and just drag from `fromLocation` to `toLocation`.
`moveEventCount` might be clearer than `intervalCount`.
The integer milliseconds observed from devices look suspicious to me... Did we lose the precision somewhere in the engine? Even with 60hz input, 16ms or 17ms seem to be sufficiently different from 16.67ms which could make resampling be ~4% off?
Also document that the jerk here is not `$ d^3 x / dt^3 $ as typically defined in physics. Your explanation in the PR description should be helpful here.  Ideally, the `jerk` and `jank` should be documented in the signature of this function as these are the return of this function.
My very early work of recording gestures shows that, all touch screen event has timestamp of milliseconds precision. For mouse input in desktop and web Flutter the event timestamp is microsecond. I think you can still find those datas in our 1:1 docs.  I think that's from the OS level, not the engine. 
Done
Done
Done
Done.
Nit: filename `scroll_smooth_measure.dart` sounds a little strange. Maybe `measure_scroll_smoothness.dart`?
It would be interesting to also add a 59hz-input-60hz-display case that simulates the Fuchsia usage. I think we can do 2 cases in this single test by extending your `TestVariant`?
Are the following lines in the gradle file needed to make the test run, or are they just added to keep this gradle file up to date with other gradle files generated by `flutter create` with a newer Flutter version?  If these are specific to this test, it might be nice to document why they're needed as it doesn't look to be obvious.
How's this `40E3` picked?
This paragraph above is a little hard to read... Maybe the following is better ``` /// For smoothness it filters out the frames that either are delayed for too long,  /// or are too slow to build. Those frames are counted in `dropped_frame_count`. ```
`go/tq-smooth-scrolling` is internal so delete it.
"Smoothness (`abs_jerk`) is measured by  the absolute value of ...", "Its average (`average_abs_jerk`) is calculated for the overall smoothness", "frames with `abs_jerk` larger than 0.5 is counted to `janky_count`".  Let's also refactor the code to rename `jerk` to `absJerk` to make it consistent with the documentation and report keys. 
"not using" -> "using"
It's copied from what's in `flutter create` and is necessary to load e2e plugins. Without this I will get:  ``` Plugin project :e2e not found. Please update settings.gradle.            /Users/minglyu/flutter/dev/benchmarks/complex_layout/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java:4: error: package dev.flutter.plugins.e2e does not exist import dev.flutter.plugins.e2e.E2EPlugin;                                                              ^                                          /Users/minglyu/flutter/dev/benchmarks/complex_layout/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java:14: error: cannot find symbol     E2EPlugin.registerWith(registry.registrarFor("dev.flutter.plugins.e2e.E2EPlugin"));     ^                                                                      symbol:   variable E2EPlugin                                             location: class GeneratedPluginRegistrant                              2 errors                                                                                                                                          FAILURE: Build failed with an exception.                                                                                                          * What went wrong:                                                       Execution failed for task ':app:compileDebugJavaWithJavac'.              > Compilation failed; see the compiler error output for details.                                                                                  * Try:                                                                   Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.                                                                          * Get more help at https://help.gradle.org                                                                                                        BUILD FAILED in 27s    ```  I didn't add comments because it's just updating this to newer version, and newer test cases in `dev/benchmarks` are already the newer version. 
Moved it to overall comments about the return value. 
Done. 
Done.
Done. 
I tried 35 and 45 and find the result qualitatively same. I'm expecting it to be a few frame interval. With single frame like 16 or 17ms the result has significant fluctuation in my early test. 
My apology! I tested it again on iOS and also android devices and lost that pattern. I can't find why in the beginning of my project I found that pattern. I'm removing to integer millisecond part.
Why is a 1 frame delay needed here?
```suggestion               // No composing text so the width should not be too wide because ```
The information is sent to the platform every frame if needed.
Can this lag cause jitter when the true information is received? 1 frame swapping between an estimate and true info may be a source of jank.
For multiline text, first and last may not get you the bounding boxes you expect for the left and right positions
We should add a test for this case as well.
The "true" information does not trigger a UI update of any sort when it's sent to the platform. It will be used as an estimate the next time iOS requests this information. 
Could you elaborate a bit on this? I would expect the marked text to be continuous and has a consistent writing direction, because it's produced by the same IME. Is it because the text within the given `TextRange` could be using different fonts so they might be grouped in different `TextBox`es even if they are on the same line?
I guess the line can have more than 1 run. 
updated
```suggestion       // Invalid range. ```
```suggestion       // Collapsed range. ```
Nice way of getting rid of all of the exclamation marks elsewhere in the file.  I'm still figuring out all of the NNBD stuff but it's looking pretty slick.
Please use https://master-api.flutter.dev/flutter/foundation/mapEquals.html from the foundation library instead of importing package:collection
Okay thanks for telling. :)
Nit: There should be a line break here.
Style nit, here and below: ```suggestion     const Map<int, MaterialColor> sampleMap = <int, MaterialColor>{       0: Colors.lightBlue,       1: Colors.deepOrange,       2: Colors.blueGrey,     }; ```
Done!
okay :)
nit: space after `if`
nit: indent by 2 everywhere
This example uses a [LayoutBuilder] to build a different widget depending on the available width.
Optional suggestion: This will make the sample an interactive dartpad, which means you can resize the window and actually see this in action! :)  ```suggestion /// {@tool dartpad --template=stateless_widget_material} ```
If you choose dartpad: ```suggestion /// This example uses a [LayoutBuilder] to build a different widget depending on the available width. Resize the /// DartPad window to see [LayoutBuilder] in action!  ```
The analyzer is failing due to a trailing whitespace here.
I forgot to mention, making this a dartpad means we can remove this boilerplate. ```suggestion ```
```suggestion ```
Here's a dartpad example: https://github.com/flutter/flutter/blob/e64fe11542238376fdfbf351d81e22d08296da45/packages/flutter/lib/src/widgets/basic.dart#L4563 :)
In the other NNBD PRs this annotation was completely removed once a file was migrated. Why keep it here?
Oops, sorry. It was old code I didn't change.
Just checking - 'iff' as in 'if and only if', or typo?
Yeah I meant "if and only if".
As a recursive void method, the name `getViewHierarchy` seems confusing. How about `updateViewHierarchyString`?
Line at the end of file
Done.
Done.
Add a TODO to add the test back, and (nit) since we do need a rewrite, this is probably ok to just remove, but may also consider using `}, skip: true);`
added a TODO
Don't you want to have some expectations after this line?  Or is it just that you expect it to not crash? At the least, you might want to verify that the `Text` actually received a hover event (in which case, you probably want to surround it with a `MouseRegion`).
I'm just expecting it not to crash (or rather, not to trigger the assert in the original version before the PR, since that one can actually run on profile mode). The `location` can be anything in the app for the test purposes but it's just `moveTo` has to have a location. 
But let me know if you think I should catch the event. @gspencergoog 
I would suggest at least one expect in there that makes sure that the hover event occurred. Something like: ```dart   testWidgets('Input PointerHoverEvent', (WidgetTester tester) async {     PointerHoverEvent hoverEvent;     await tester.pumpWidget(MaterialApp(home: MouseRegion(child: Text('Test'), onHover: (PointerHoverEvent event){       hoverEvent = event;     },)));     await tester.pumpWidget(const MaterialApp(home: Text('Test')));     await tester.pump();     final TestGesture gesture = await tester.createGesture(         kind: PointerDeviceKind.mouse);     final Offset location = tester.getCenter(find.text('Test'));     // for mouse input without a down event, moveTo generates a hover event     await gesture.moveTo(location);     expect(hoverEvent, isNotNull);     await gesture.removePointer();   }); ```  It just makes it clearer that the test does something: without any expectations, someone (like me!) might look at the test and wonder if it is testing anything, or if the expectations were just accidentally omitted.  At the least, you could have a comment saying that the test is expected to not assert (which is probably all you can do for the first test in the file).
Done with a little different. 
`initCommand` doesn't need to be a function, you can re-use the same List<String> in both spreads.
I don't think this one is really carrying its weight
since this isn't a function any more I would name it something like "sharedArgs"
How about sharedCommandOptions?
Sounds good!
could you leave this on the same line?
By having `_handleViewNeedsPaint` inside the `if else if` branch, it seems that `_handleViewNeedsPaint` won't be called for hover events now but it was called before this change? I wonder if that's intended, and whether hover should trigger some painting.
It's intended, because  1. the original version, if I neglect the problematic `assert` sentence and considered it an `if`, basically doesn't draw hover event; 2. If we are to draw hover event and scroll event, I would think a better practice is to have a separate list/map for that and keep the original one just for down event, because it's more meaningful to plot them in a different way.  
To paint hover event, would probably better to be a TODO, if we decide to paint it. 
To clarify, `paint` method for this class is only painting `_pointers` data. So if all events are down-move-up, than it always needs paint. But for other events, it originally should violate the assert, and nothing will be added to `_pointers`, so it's a fake (literally, not in the test sense) `_handleViewNeedsPaint`.
Discussed with @CareF offline. This `_handleViewNeedsPaint` only triggers repaint of the `_pointers` positions which do not include non-down (e.g., hover) pointers. So we don't have to call it if it's not down or already tracked in `_pointers`. The repaint of the test app should be driven by `super.dispatchEvent` and that should be the place where the test app responds to hover repaint.
nit: prefer not shadowing parameter names in the enclosing class, which can get confusing.  I don't have a great idea for a name here.  This does make me wonder if there are other cases we should be explicitly passing the isolate reference around though.
Is there a reason we're not just setting the outter `isoalte` to `isolateRef.load()` here?  Should we be asserting `isolate == isolateRef.load()` somehow?
Ahh I see, this could be other isolates the application uses that also started paused, right?
Analyzer wants a type annotation on this array.  
nit: ```suggestion   /// Input that always occupies at least 2 lines and has an infinite max. ```
Fixed in new commit
Don't forget CupertinoTextField!  ```suggestion   /// These apply equally to `TextField`, `TextFormField`, `CupertinoTextField`,   /// and `EditableText`. ```
I think this could be confusing because the horizontal limit isn't exactly *specified* (it's the width constraint). Also, you don't have to hit the horizontal limit when newline characters are used.  Maybe just say "Expands vertically as needed."?  ```suggestion   /// Expands vertically as needed. ```
Just formatting the lines here:  ```suggestion   ///   /// If the value is set, it must be greater than zero. If the value is greater   /// than 1, [maxLines] should also be set to either null or greater than   /// this value. ```
Done :)
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
If this fails, I assume we're OK with the default exception handler's report?
Yeah. I don't think it can be improved.
`To do set` -> ` To set`?  Nit: `a normal test` -> `a normal unit test`, and add `{}` to the `if` in the sample code?
I think our API doc should start with a short paragraph with a sentence. The old doc does not seem to follow that convention. Maybe we shall fix it too. CC @Hixie @goderbauer 
> Nit: `a normal test` -> `a normal unit test`  I think it's not necessarily a unit test. This is more often used for integration and performance test. 
Done other than the above. 
Added a new sentence. 
Yes, if you have the chance please change the first paragraph to a one-sentence summary.
@CareF : your `git push` probably failed as Github still shows your commit 6 days ago as the last commit.
> @CareF : your `git push` probably failed as Github still shows your commit 6 days ago as the last commit.  My bad! I pushed again. @liyuqian 
Nit: `triggered` -> `[pump]ed`?
Nit: is `ignores [scheduleFrame] requests from the framework` more accurate than `prevents the framework from requesting any frames from the engine itself.`?
Nit: `pump` -> `[pump]`
Nit: `new frame` -> `artificially [pump]ed frame`?
`and for requesting` -> `and requesting`?
I'm not sure I should use `pump` here because it's not only from pump but also from animation. I'll leave this to @sfshaza2 for language advice. 
`prevents the framework from requesting any frames from the engine itself.` is the original version in `LiveTestWidgetsFlutterBinding.framePolicy` doc I moved from. I agree the new version but will leave this conversation un-resolved for visibility. 
`new frame` is the original version. But I agree this is more clear. Also leave it open for visibility. 
means => results in 
which might => and might
If you know your test file wouldn't be => If you know that your test won't be..... 
set it to => set the policy to persistently in that particular test file => in that particular file.
By "a normal test" do you mean one that won't call pump extra times? Maybe: ``` To set a policy that won't cause the test to pump extra frames, add the following to the `main()` function, before calling [testWidgets]:  ```
The major difference with what? fadePointers? ``` The major difference between [fadePointers] and [benchmarkLive] is that the latter ignores... ``` OR ``` The major difference between this policy and [benchmarkLive] is that the latter ignores... ```
Perhaps: ``` This allows all frame requests from the engine to be serviced (including frame requests that are artificially triggered), but... ```  I wouldn't use pumped instead of triggered.
=> ``` Therefore, animations won't run in this mode because the framework generates an animation by requesting new frames. ``` 
I'm having trouble unpacking this sentence: ``` Compared to [fullyLive] this policy ignores the frame requests from [pump] of the test code so that the frame scheduling respects the situation of that for the real environment, and avoids waiting for the artificially [pump]ed frame frame when driving the test in methods like [WidgetTester.handlePointerEventRecord] or [WidgetTester.fling]. ```  ??? Perhaps the following?  ``` Compared to [fullyLive], this policy ignores frame requests from [pump]  so that frame scheduling mimics that of the real environment, and avoids waiting for an artificially[pump]ed frame. (For example, when driving the test in methods like [WidgetTester.handlePointerEventRecord] or [WidgetTester.fling].) ``` 
=> ``` This policy differs from [benchmark] in that it can be used for capturing animation frames requested by the framework. ```
I like the new sentence, but the sentence after that. Oy.   Original sentence: ```   /// Whether to have [pump] with a duration only pump a single frame   /// (as would happen in a normal test environment using   /// [AutomatedTestWidgetsFlutterBinding]), or whether to instead   /// pump every frame that the system requests during any   /// asynchronous pause in the test (as would normally happen when   /// running an application with [WidgetsFlutterBinding]). ```  Clearer sentence:  ```   /// Whether [pump] (with a duration) pumps a single frame   /// (as would happen in a normal test environment using   /// [AutomatedTestWidgetsFlutterBinding]), or   /// pumps every frame that the system requests during an   /// asynchronous pause (as would normally happen when   /// running an application with [WidgetsFlutterBinding]) ... ```  Then what? The original sentence needs a final clause. Whether it's one pump or many... what then?
I didn't write this but I think normal here just mean the test is like what we typically write a test, not the kind of test with tricky hack. 
I'll keep the original version because `artificially triggered` is from test file, not the engine. 
Done
Done
Done with the second. 
Done
Modified to your version. 
I changed the sentence to "The policy decides ..." to make it complete. I can't think of a clause. 
This is where the actual widget cache logic will go. Once this PR lands, the only thing that needs to be done is to wire it up, pending some agreements about the parser APIs
analyzer started flagging these for some reason
TIL about `&=`
should this be `printError()`?
this method is pretty massive, not a nit, just an observation
In this case, its okay for this method to fail - the tool can fallback to the regular re-assemble and still do a hot reload. I'd like to leave this as a trace to be a bit more conservative
Yeah, historically it was really hard to change because we didn't have good test coverage. And the last time I changed it significantly I accidentally broke hot reload for some people :( 
nit: small doc comment describing what it does
doesn't need to be `async`
@jonahwilliams another option is to remove this from the high level context, and instead make it required to initialize `XCDevice` since that's the only place it's used. https://github.com/flutter/flutter/blob/859fce9010895ce5bcdb913a8373b5b1a194a1fb/packages/flutter_tools/lib/src/context_runner.dart#L250-L257  would become: ```dart  XCDevice: () => XCDevice(     processManager: globals.processManager,     logger: globals.logger,     artifacts: globals.artifacts,     cache: globals.cache,     platform: globals.platform,     xcode: globals.xcode,     iproxy: IProxy(      iproxyPath: globals.artifacts.getArtifactPath(        Artifact.iproxy,        platform: TargetPlatform.ios,      ),      logger: globals.logger,      processManager: globals.processManager,      dyLdLibEntry: globals.cache.dyLdLibEntry,    ),  ```  This would make https://github.com/flutter/flutter/pull/61762/files#diff-ebc648b2067d73f2af30539f5d3a59faR503 become: ```dart iProxy: _iproxy, ```
IMO Leaving/Removing from the context injection isn't really that important. As long as we're not introducing more globals into classes that have already been cleaned up, I have a separate plan to remove the context w/o breaking g3
`XCDevice` is close to being cleaned up, I already did this exercise with https://github.com/flutter/flutter/pull/53203 (which was further pushed down in https://github.com/flutter/flutter/pull/53307,  we can't do in this case since g3 wants to override).  I've just convinced myself, I'm going to do this pattern from the beginning.
Are these changes here related to the fix, or just cleaning up something? I assume scope can no longer be null when it might have before?
Actually, I made those changes thinking that these couldn't ever be null, because the `rootScope` can't be null, but if the `_manager` is null, it still could be.  I reverted these.
nit: remove empty line
nit: remove empty line.
I had this name wrong in the last PR. Fixed it here.
👍
Good catch adding these missing properties!
You should be able to use a pumpAndSettle here and below instead of the multiple pumps and durations, if you haven't tried it already.
I could only replace one, I think it has to do with the cursor blinking and the timing needing to be right
Strange, is the `pump` without a duration needed as well?  And what if you combine the two with durations into one with `Duration(seconds: 1)`?  There are [other tests](https://github.com/flutter/flutter/blob/f98a00c7506a0a4a3a53372e574a048a884ca03b/packages/flutter/test/material/text_field_test.dart#L1664-L1666) that do this sort of thing, though not testing the cursor size.  Anyway I think the main thing is to just make sure it's clear to someone else reading this code why the pumps are there, so maybe just add a comment. 
It wasn't, I simplified this test and others doing the same thing, and added a comment
```suggestion /// app. When using [SliverAppBar.flexibleSpace], the [SliverAppBar.expandedHeight] /// must be large enough to accommodate the [SliverAppBar.flexibleSpace] widget. ///  /// Furthermore is included functionality for stretch behavior. When /// [SliverAppBar.stretch] is true, and your [ScrollPhysics] allow for ```
We can simplify this a bit, and let's actually move it to the 'flexibleSpace' of the `SliverAppBar` class where it is relevant. The `AppBar` does not have an `expandedHeight`. ```suggestion   /// When using [SliverAppBar.flexibleSpace], the [SliverAppBar.expandedHeight]   /// must be large enough to accommodate the [SliverAppBar.flexibleSpace] widget.   /// ```
Sure @Piinks I will make the required changes.
All the daemon commands are exclusively machine mode, so defaulting to true instead might make more sense here
formatting is kind of weird. Would get on one line or use 2-space indent
Add a comment to explain here. Probably link to the comment that proposed the workaround.
+1
done
qq: how does this ensure that pointer id doesn't reach the limit? As pointed out in https://github.com/flutter/flutter/issues/61421#issuecomment-659715358
The `MotionEvent` pointer ID limit is an internal Android implementation detail that AFAICT isn't documented anywhere.  This patch ensures that the pointer ID value will be less than the number of active pointers.  The version of Android that I looked at apparently accepts pointer IDs in the range 0 through 31.  So realistically this patch will keep the pointer ID values within a safe range given that a user is unlikely to have >32 pointers active simultaneously.  Given that it isn't a defined part of Android's API I didn't want to try to hardcode a limit here.  But we could enforce a maximum number of active pointers on the framework side if this is a concern. 
 ```suggestion   /// Defaults to [AutovalidateMode.disabled] if `autovalidate` is false which ```
Turns out this is a breaking change. The public field is removed, not deprecated.  This affects (at least) [flutter_form_builder](https://pub.dev/packages/flutter_form_builder). https://github.com/danvick/flutter_form_builder/issues/465  Ideally, should (with appropriate deprecated tag) put something like ```dart bool get autovalidate => autovalidateMode != AutovalidateMode.disabled; ```
@pedromassango oops did we miss this one?
Hmm. Just checked `form.dart` file and I don't see any reference for `final bool autovalidate`. We did removed this intentionally in favour of AutovalidateMode property.  Maybe this is referencing a old commit file?!
> bool get autovalidate => autovalidateMode != AutovalidateMode.disabled;  This is interesting and would prevent the breaking changes 🤔  @chunhtai do you think this we should put it back?
@skyeskie What are the use cases of using this Widget's property?
I think we should put this one back, but we should do ``` autovalidateMode = autovalidateMode ?? autovalidate ? AutovalidateMode.always : AutovalidateMode.disabled ``` Same as what we do for other formfield
Alright, I will send a PR to put it back ASAP
`FormField` has the exact same issue (below, 363-368)  @pedromassango I personally don't use this, but just ran across when `flutter_form_builder` refused to compile, specifically when it tries to access `autovalidate` on `FormField` in its `FormBuilderCustomField` class [here](https://github.com/danvick/flutter_form_builder/blob/2d5f61b3863b058b9b6213aac25f6b62b65bd44e/lib/src/form_builder_custom_field.dart#L96). 
The PR is: https://github.com/flutter/flutter/pull/66267  @chunhtai I think we should add it back on formField widget too, right?
`FakePlaatform` has a typoo
Thaanks!
Nit: `run_app.dart` may be better?
Done
`-t test_driver/run_app.dart`
`cubic_bezier_perf` is not just for the SkSL shader wram-up. As you noticed before, `cubic_bezier_perf__timeline_summary` is a normal driver test without SkSL, and only `cubic_bezier_perf_sksl_warmup__timeline_summary` involves SkSL.  Therefore, I think one should still be able to use `flutter drive -t test_driver/run_app.dart --driver cubic_bezier_perf_test.dart` to run the non-SkSL test locally.  I wonder if `cubic_bezier_perf_sksl_warmup__timeline_summary` had any troubles if you did the change above?
> I wonder if `cubic_bezier_perf_sksl_warmup__timeline_summary` had any troubles if you did the change above?  It runs as expected, but it may make difference in therms of the performance metrics. Locally I don't see significant difference except for `worst_frame_rasterizer_time_millis`, but that one is usually flaky.   I still added the change but let me know if I should revert it. 
Done
It's fine to change `createCubicBezierPerfTest` as is now. You may need to also update `createCubicBezierPerfSkSLWarmupTest` and make sure that `cubic_bezier_perf_sksl_warmup__timeline_summary` devicelab tasks run successfully locally.  For this README file, I don't think you have to give a special treatment to `cubic_bezier_perf`. You should be able to just include it as a normal `[test_name]`.  Finally, what `worst_frame_rasterizer_time_millis` difference numbers are you seeing? Is it for `cubic_bezier_perf__timeline_summary` or `cubic_bezier_perf_sksl_warmup__timeline_summary`?
> Finally, what `worst_frame_rasterizer_time_millis` difference numbers are you seeing? Is it for `cubic_bezier_perf__timeline_summary` or `cubic_bezier_perf_sksl_warmup__timeline_summary`?  40ms for using run_app and 12 ms for using the warmup version. 
I don't see anything for `createCubicBezierPerfSkSLWarmupTest` that needs updating. 
Oh, you didn't remove `cubic_bezier_perf.dart`. I think you can remove it and just let `createCubicBezierPerfSkSLWarmupTest` use `run_app.dart` too.  In terms of the performance difference, 40ms/12ms might be within the [noise range][traces]. Do you have detailed numbers, like is it within the range of 80ms-120ms for the non-warm-up version?  [traces]: https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3Dworst_frame_rasterizer_time_millis%26test%3Dcubic_bezier_perf__timeline_summary%26test%3Dcubic_bezier_perf_sksl_warmup__timeline_summary
I should have mentioned, my numbers are tested on Pixel4 rather than Moto G4. Moto is always flaky on my local side due to #59263. And the difference I mean both using `PerfTest` (or equivalently `flutter drive`) but with `run_app.dart` or `cubic_bezier_perf.dart` (this includes some codes for warm up). Test takes quite some time. I'll test a couple more times before updates.
Update: run 4 times for using `run_app.dart` and `cubic_bezier_perf.dart` for `createCubicBezierPerfTest` on MotoG4. No significant difference is observed, but `worst_frame_rasterizer_time_millis` looks slightly better for `cubic_bezier_perf.dart` (89.064, 83.331, 94.123, 83.505 vs 97.895, 87.275, 100.392, 106.045). 
Line 31-35 could be removed as we'd still prefer `flutter drive --profile -t test_driver/run_app.dart --driver cubic_bezier_perf_test.dart` . I also created https://github.com/flutter/flutter/issues/61757 to track the removal of `cubic_bezier_perf.dart`.
Done. 
This is definitely something we could clean up to0, by just checking in a handwritten package config.
(not now)
nit: just return the result of errors.where directly.  ```suggestion     return errors.where((AnalysisError error) { ```
```suggestion       ? '$issueCount ${pluralize('issue', issueCount)} found.'       : 'No issues found!'; ```
This code is less clear than what it is replacing. Consider:  * Keep `if/else` branching as flat as possible, so it is easier to follow the conditions. * Use a StringBuffer to build up intermediary strings. * use required on parameters that need to be passed, or else provide them with default values (unless that default value can be null)
```suggestion       issueCount: errorCount,       seconds: seconds,       undocumentedMembers: undocumentedMembers,       dartDocMessage: dartDocMessage,     );  ```
if you are using early returns, you don't need `if/else` only:  ```dart if (condition1) {   return 1; } if (condition2) {   return 2; } ... ```
Here and else, please try to use 2-space indent consistently
why does this need to check for both info and warning to be set? Seems like it should only be fatal-warnings
warning severity level higher than info, see above experiments. e.g. if fatal-infos, both error, warning, info will be fatal.
Instead of having two flags, could we have one option that takes different severity levels? Like `--fatal=infos` ?
Since error is always more fatal than info, if user has opted for fatal info, then it makes perfect sense to make it fatal for error too and also that feels like the expected behavior. 
```suggestion         expect(result.messages.first.message, contains(mockDevice.id)); ```
I believe the message types have equality defined, so you could do:  ```dart expect(result.messages, [   ValidationMessage(...),   ValidationMessage(...), ]); ```  This will probably give a better error if the length changes
nit: remove else and un-nest return
by convention property names should typically lower case. So perhaps 'router', 'route', and 'event' instead of PointerRouter, PointerRoute, and PointerEvent.
similarly, renderObject instead of `RenderObject`.
for this one you should give the property a lower priority level as you don't want it to actually show up as that will make the error confusing to read. I think `level: DiagnosticsLevel.debug` is what you want. https://api.flutter.dev/flutter/foundation/DiagnosticLevel-class.html
Could these two be `late final`?
Actually, it looks like completer could just be final and initialized right here instead of in the constructor?
Indeed!
I would expect this one to always return a non-null value. At the time when you can read it, `_lifecycleState` has always been initialized.
Since you changed it above: Change this one also to the new function syntax?
Changing this line to:  ``` AppLifecycleState get lifecycleState => _lifecycleState!; ```  causes a lot of failures in tests. For instance:  ``` Null check operator used on a null value   package:flutter/src/scheduler/binding.dart 340:58   SchedulerBinding.lifecycleState   package:flutter/src/services/binding.dart 180:9     ServicesBinding.readInitialLifecycleStateFromNativeWindow   package:flutter/src/services/binding.dart 34:5      ServicesBinding.initInstances   package:flutter/src/gestures/binding.dart 66:11     GestureBinding.initInstances   package:flutter/src/semantics/binding.dart 24:11    SemanticsBinding.initInstances   package:flutter/src/rendering/binding.dart 32:11    RendererBinding.initInstances   package:flutter/src/painting/binding.dart 23:11     PaintingBinding.initInstances   package:flutter/src/widgets/binding.dart 257:11     WidgetsBinding.initInstances   package:flutter_test/src/binding.dart 302:11        TestWidgetsFlutterBinding.initInstances   package:flutter_test/src/binding.dart 898:11        AutomatedTestWidgetsFlutterBinding.initInstances   package:flutter/src/foundation/binding.dart 57:5    new BindingBase   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding&PaintingBinding   package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding&PaintingBinding&WidgetsBinding   package:flutter_test/src/binding.dart               new TestWidgetsFlutterBinding   package:flutter_test/src/binding.dart               new AutomatedTestWidgetsFlutterBinding   package:flutter_test/src/_binding_io.dart 25:7      ensureInitialized   package:flutter_test/src/binding.dart 298:100       TestWidgetsFlutterBinding.ensureInitialized   package:flutter_test/src/widget_tester.dart 123:71  testWidgets   material/tabbed_scrollview_warp_test.dart 79:3      main   package:flutter_goldens/flutter_goldens.dart 43:17  main   dart:async                                          _completeOnAsyncReturn   package:flutter_goldens/flutter_goldens.dart        FlutterLocalFileComparator.fromDefaultComparator   dart:async                                          _completeOnAsyncReturn   package:flutter_goldens_client/skia_client.dart     SkiaGoldClient.getExpectations   dart:async                                          _completeOnAsyncReturn   package:flutter_goldens_client/skia_client.dart     SkiaGoldClient.getExpectations.<fn> ```
Done
Thanks for fixing the string `four` to `three`. However, can you leave these all as `1.`'s, so that they can be re-ordered, new ones added or existing ones removed without needing to edit each number?
Okay I will change them to `1.` again @christopherfujino 
Grammatically I think the original was correct, there is a single description, and it should be both "clear" and "concise".  ```suggestion      concise description of what the problem is. ```
I can't visually see the diff on this one...what was the change?
I think the original was correct. Consider the (simplified) version: "It's powered by the same graphics library that underpins Chrome and Android". Now with modifiers to "graphics library", "powered by the same hardware-accelerated Skia 2D graphics library that underpins Chrome and Android." Alternatively, this sentence could be re-written "It's powered by the same hardware-accelerated 2D graphics library that underpins Chome and Android: [Skia]."
It is the final space, highlight both and you will be able to see it 👀  It is my markdown linter, says it is best practices. if you think it is not necessary I will remove it as soon as possible
Yes, I totally agree with you 👍
As development is in the present tense, I think the original was preferable.  ```suggestion during development of the framework. The tools in this directory ```
what's the diff here?
this is actually referring to "layer performance", so I believe the original is preferable.  ```suggestion   low-level engine primitives, such as layer, picture, and semantics performance. ```
The clip art library is not "the public domain", it is either "public domain", or more explicitly "in the public domain".  ```suggestion Which is public domain. ```
I would agree but try reading it like this:  This directory contains tools and resources that the Flutter team uses during the development of the framework.  The verb `uses` is present so I think it is correct. It symbolizes present tense  
Try highlighting both together. The extra space after the period is removed.
Ah okay, tbh I was confused here so I will change it.
Okay 👍, "in the public domain" is more descriptive
Probably `"the"` is more accurate here.  ```suggestion Running the devicelab will do things to your environment. ```
This is actual log output, please don't reformat.
Yea You are so right 👍
Okay 👍
Okay 👍
It's testing "that" certain apps can be still be built. Original was correct.  ```suggestion This project is meant to test that apps using the current `android/settings.gradle` ```
Please keep these as `1.`'s, so they can be re-ordered/deleted new ones inserted.
Please keep the numbers as `1.`'s, so they can be re-ordered, deleted, or inserted.
original was correct ```suggestion output, which dartdoc places back into the documentation. Any options given to ```
I think this line is too long (we prefer 80 column lines)
This line now looks too long (prefer 80 column lines)
what's the diff here?
also looks like you added a comma, not sure github diffing algorithm didn't pick it up, this LGTM
Ah okay I thought it was a copy\paste mistake
Ah okay I thought it was a copy\paste mistake
I prefer the original, but don't have a strong preference, you can leave your version if you like :)
LGTM. again, weird the diffing algorithm didn't highlight (it usually highlights trailing whitespace changes).
I have removed the last space
Okay will change it
OKay will do it
Updated It! 
Great! 👍
Okay thanks 😊👍
I think because they are doing updates to the site currently, so maybe sometimes things don't work correctly
I don't get it. that is is for singular and apps is plural. correct me If I am wrong
The original was correct here. It is not a list of 3 items, but referring to the Android platform, where there are two components built: the Android component and the Flutter component.
Okay I will change it now
you are correct, in that "that" is for singular, however, in this sentence "that" does not refer to the "apps", but to the fact of whether or not those apps can be built.
Ah okay
Your PR here is adding this text which I don't see on master, maybe this got deleted in a recent change and when merging back in master you accidentally restored it?
I guess but what I didi isn’t fetch all new things and see what was changed so I changed nothing but I will make sure
When there's a merge conflict you have to manually look through all the changes and decide which makes sense to keep. [This change](https://github.com/flutter/flutter/commit/7bef51acc979ee467c02a7503a8990a6edbb0ae3) removed the this README text, so with your merge conflict you need to also remove it.
Fixing the issue where a wrong platform view surface is used.
Had to add this to ensure the driver tests are running.
Did you mean to check `verboseExceptions` somewhere?
You're right, the `throwOnError` check here is redundant, since we already know it's true from the check on 453. This should be `if (verboseExceptions) {`. Fixed and added another unit test.
this matcher was never used
I forced non-const constructors here because I'm not sure if `operator ==` is called on equal const objects. Am I wrong?
Nit: `s/tester.//`
Done
MaterialApp has a build-in navigator. Can you just use that one instead of adding another one to simplify this a little? (same for the test below)
You'd also end up with less modal barriers making the expect below a little more sensible :)  
Done
This looks like a good solution. One thing though, is that if the user has a typo in this env variable (or if it the remote is down), we should explicitly show the override value in any error message. If you check line 654 of this file, we throw an error if a command we run does not return a 0 exit code. Even though this error includes the complete command that failed, unfortunately, if `FLUTTER_GIT_URL` env variable is wrong, we won't hit an error until line 257, which tries to run the command `git fetch $_versionCheckRemote $branch`, which doesn't include the upstream URL in it. Probably the better version would be to add a `catch` around 262, and IF we have an explicit `FLUTTER_GIT_URL` override set in the environment, `globals.printError('Warning: the Flutter git upstream was overriden by the environment variable FLUTTER_GIT_URL = ${globals.platform.environment['FLUTTER_GIT_URL']}');` (something like that, I didn't test it).  Also, this change should have unit tests in the file: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/general.shard/version_test.dart. Using the `testUsingContext()` function, you can provide a `FakePlatform` and `ProcessManager` overrides (if you search the codebase for `FakePlatform`, you'll find a lot of examples) where you set the environment variable and then expect that you are getting the correct git commands to the `mockProcessManager`, specifically the one setting the upstream.  Let me know if you you run into any obstacles!
Unfortunately this isn't really testable since it can't be changed after the first time it's set.  I wrote a unit test for this that passed on its own, but failed when run with the entire test suite because it always returned `https://github.com/flutter/flutter.git` because a previous test had initialized it.  How about: ```dart String get _flutterGit => globals.platform.environment['FLUTTER_GIT_URL'] ??     'https://github.com/flutter/flutter.git'; ```
Good catch
I have finished print warning and unit test. But test running failed unexpected. Sorry for troubling but I have a problem now.
nit: Missing a space between `catch` and `(` ```suggestion     } on VersionCheckError catch (error) { ```
This change is temporary for demo purposes only. After flutter/plugins#2873 is landed this will be updaged.
I'm not completely sure why this `internalRun` needs to be rewritten... what lines of code should I focus on reading?
L439 ~ 446, the metric key list. This E2E version cannot get vsync related metrics. 
Other than that, I'm expecting E2E tests to share `testDriver` file and to have different timeline file name (L393, L394). It may also make sense to change the name of the result file from `**.timeline_summary.json` since it's of different format and not timeline. 
Mentioning this, I think '--trace-startup' is no longer needed. I'll delay the update to keep the above line numbers valid. 
nit: prefer "linux/android" when possible.
Done
To minimize duplicate code, maybe we can let `internalRun` take options like `bool reportsVsyncMetrics = true, bool needsTraceStartup = true`, and then just use `internalRun(reportsVsyncMetrics: false, needsTraceStartup: false)` in the e2e test?
Nit: `FrameTimingSummarizer` seems to be a more informative name.
This file probably also belongs to `test_driver` as this is unlikely to be used as a unit test. BTW, I guess we'll update `WidgetTester` to `WidgetController` in this file?
This file probably belongs to `test_driver` as this is unlikely to be used as a unit test. 
When this PR is out of draft, we should try to minimize duplicate code as it's hard to maintain.
I'm not expecting to use that demo very soon but if you think I should, maybe I'd better change this PR back to draft as that demo is far from use-able. 
And the reason I'm putting it in `test/` rather than `test_driver` is that E2E recommends so (https://pub.dev/packages/e2e#test-locations), and the test file (`cull_opacity_perf_e2e.dart`) should be able to run using `flutter test`. 
Same reason above. https://github.com/flutter/flutter/pull/61509#discussion_r456103995
If you mean re-use the warning string from `packages/flutter_driver/lib/src/driver/vmservice_driver.dart`, that one is private and need an extra line break to align the warning message. 
Done
And although it's out of draft, I'm still thinking it as experimental and expecting to see how it will go with device lab. If it's going on well, I think it will worth discussing if `FrameTimingSummarizer` and `watchPerformance` should go to e2e, `flutter_test` or stays with test codes.
Changing from `WidgetTester` to `WidgetController` for `driverOps` and `setupOps` for now, but this specific case it's not used. 
As [`FrameTiming`] is in the SDK, I wonder if we can also put `FrameTimingSummarizer ` in the SDK just in case that developers also want to monitor their app performance in the wild (e.g., https://github.com/flutter/flutter/issues/37437). What do you think, @Hixie ?  [`FrameTiming`]: https://api.flutter.dev/flutter/dart-ui/FrameTiming-class.html
Nit: call this `macroPerfTestE2E` to reduce confusion between this and the driver version of `macroPerfTest`.
@CareF : in terms of the warning message, I think we could have an extra line break in both cases, and just move this to a public const inside some file in `macrobenchmarks` so both e2e and driver tests can import?
As we're no longer using `flutter_driver`, I wonder if `benchmarkOps` would be a better name than `driverOps`? Now I also feel that `Ops` was a lazy naming that I created earlier. I hope we could also have a better name for that :)
We can now use `benchmarkLive` here?
Nit: compute `frameBuildTimeMicros ` in the constructor and make `averageFrameBuildTime ` and so on as public `get` functions so it would be easy for `FrameTimingSummarizer` users to get only a subset of stats in the future.
Nit: I feel it's safer to use a simple O(n) scanning algorithm here than a cleverer O(log n) binary search. We don't have unit test coverage for this function so it might be easy for someone to break this in the future without noticing it.
@CareF : how do you think about the last comment about reducing duplicate code?
Is it true that we don't need this file if flutter/plugins#2859 landed? Since this PR doesn't need Timeline, I wonder if we only need a part of flutter/plugins#2859 without the Timeline support.
My bad. This comment was added here for my first trial version. Now this file is a little different with flutter/plugins#2859 but the larger idea is similar. 
`flutter_driver` cannot import things from `macrobenchmarks` because the latter is not a published package and is not a dependency of `flutter_driver`.  There's another similar thing in https://github.com/flutter/flutter/blob/07caa0fbfe5186cc8a11902cc46377cebd592088/packages/flutter_test/lib/src/widget_tester.dart#L324-L334 . I think it might be better to put in `flutter_test`, if we have to. 
I interpret `driver` here as the operation to *drive* the test, rather than from `flutter_driver`. What about call them `driverCallback` and `setupCallback`. And maybe i should also `typedef` the callback. 
Then `kBuildBudget` would have to be a getter (or a const) so user won't expect to change it to change the related result. 
Done
Done
Done
Done with the change, but let me know if `kBuildBudget` should still be a value that can be changed by customer, in which case it will need to be a member variable of the class. 
Done. A little sad when I finally find small algos are useful somewhere but it turns out not a good practice :(
Removed the comment. See new comment in flutter/plugins#2859
I had a slightly different design but still reduce the duplicate. Let me know if that looks good. 
And these three are not exactly the same. One is `flutter run`, one is `flutter drive` (and I just noticed a nit, the one in `vmservice_driver.dart` should have an additional `-t` (#61922) and E2E should be both (just updated this)
I realized I shouldn't do this because `data` is incremental. 
So it seems that I'll have to do the same as the `TimelineSummary` where multiple list generation and sort on the same object is performed... Or I'll have to make a cache system (I don't think I should...). Currently I reverted that moving to constructor change. Let me think about the trade-off. 
Let's file an issue and put a TODO here to use https://github.com/flutter/flutter/wiki/Engine-specific-Service-Protocol-extensions#get-the-display-refresh-rate-_fluttergetdisplayrefreshrate instead of the hard-coded 16ms. If you have time to kill, you can resolve it later.
Ah, I forgot that the other one is in `flutter_driver`. Yes, let's reuse the `flutter_test` one if possible since this E2E test would depend on `flutter_test` anyway?
It says milliseconds in the comment but I believe it's in microseconds.  Nit: `p90FrameBuildTimeMicroseconds`? `p90` seems to be clearer than `percentileXYZ90` and it's nice to put unit microseconds in the name.  Take a step back, I feel that the best solution might be to directly return a `Duration` here, and only do `inMicroseconds / 1E3` in the final JSON construction. This would remove all unit issues, and open the possibility of using nanoseconds if one has to. I think this should be easy to do as `Duration` supports all common operators such as `<, +`.  Same applies to all other similar functions. 
I feel sorry too... Here's how I think you might be able to add it back in the future:  Writing that algorithm is a good, what feels unsafe is to make it as an private little function without any unit tests. In the future, if `FrameTimingSummarizer` turns out to be something that we want to add to our API, then we can invest a lot more time in it to improve its ergonomics and efficiency. At that time, we shall certainly make the algorithm as efficient as possible, and add many unit tests to guarantee its correctness. (Right now we're just trying to unblock our critical path asap.)
As you pointed out in https://github.com/flutter/flutter/pull/61509#discussion_r457753936, most people who use this function probably don't expect the `List<FrameTiming>` to be mutating in their first thought.  I'd suggest to let your `watcher` record a `List<FrameTiming>`, and give that final list to `FrameTimingSummarizer` after that list is fully recorded.  You can then extract the build and raster duration and sort in the constructor. I feel it's probably still cleaner to call `_findPercentile` in each getter so you don't have to introduce a lot of class member fields.
Done with modification to `flutter_test`
Done with refactoring `FrameTimingSummarizer` using factory constructor. 
The internal data of `Duration` is `int` in microseconds. 
And it doesn't have a `operator /` method. The only one is `operator ~/ (int)`. Difference is within microseconds which I assume is fine. 
Done with #61958 
(moved to factory constructor)
Nit: when a function has a lot of arguments, Flutter usually put them under `{}` so it would be like the following ``` const FrameTimingSummarizer._({   this.frameBuildTime,   ... });  // Use it with argument name provided to reduce confusion FrameTimingSummarizer._(   ...,   averageFrameBuildTime: frameBuildTime.reduce(add) ~/ data.length,   ..., ); ```
Nit: as we're moving away from `flutter_driver`, I wonder if `ControlCallback` is a better name than `DriveCallback` as the callback takes a `WidgetController`. CC @dnfield for suggestion too as I imagine that we'll use this in all future e2e performance tests.
`than` -> `then`
`{}` means named arguments, and optional if not marked as `@required`, with default value if not assigned `null`. Here I don't think they should be optional. I added all `@required`. 
Done
Done.
Could we eliminate the ButtonBar here? 
We can, but then we would lose some of the padding around the buttons that the `ButtonBar` provides. Might trip up some golden tests. 
I think you can get the same effect with ```dart Container(   alignment: Alignment.center,   padding: EdgeInsets.symmetric(horizontal: 8),   constraints: const BoxConstraints(minHeight: 52.0),   child: Row(     mainAxisAlignment: MainAxisAlignment.end,     children: <Widget>[       TextButton(         onPressed: _handleCancel,         child: Text(widget.cancelText ?? localizations.cancelButtonLabel),       ),       const SizedBox(width: 8),       TextButton(         onPressed: _handleOk,         child: Text(widget.confirmText ?? localizations.okButtonLabel),       ),     ],   ), ) ```
There's special behavior in ButtonBar that puts the buttons in a column if they don't fit in a row (good for i18n cases or custom button text), so I'd say we keep the button bar until we have a good replacement for that
Is that really an issue with the time picker? Can the picker become narrow enough to require making a column out of the OK/Cancel buttons while otherwise remaining usable?
I think it may be possible in other locales (german perhaps?)
OK, with me to leave this as-is for the moment. I'm going to write a row-unless-theres-no-room-then-a-column that we can replace ButtonBar with. Until then, this is good.
update-packages fetches all of the packages of all of our dependencies, which is massively bloating the zip size
cc @gspencergoog any reason not to do this?
One of the main reasons we created the downloadable archives in the first place was to enable people (mainly in China) to work offline by downloading an archive (on a machine with a connection), putting it on a USB stick, unpacking it on another machine, and being able to run.  If we don't fetch packages, that won't work anymore. If we don't think that is a scenario we care about then that's fine.  We also thought that the out of box experience of unpacking it and building an example was improved because you didn't need to immediately wait for pub to run: it just built (but that's a fairly small thing).
we already fetch all of the dependencies for the flutter tool, and anything needed to run a flutter template. Pulling in all of our dependencies, the zip size has gradually increased to 848 MB
Rather than excluding by git, could we just exclude everything from the `dev/` folder specifically?  That way, if we move to distributing the gallery some other way (e.g. by pub somehow?) this won't break.
I floated that idea and the concern was that it could break the offline workflow. Lacking good integration tests this is a minimal fix to reduce the size
Want to put this one at the end of the list after the platforms? I thought for a second you edited this accidentally.
Woo!
Woo!
Woo again!
Done!
Would it be possible/useful to make this one of those interactive dartpad examples? The users could hover over the button and see the color change for themselves.
Additionally, it might be useful to show hovered or focused: blue, pressed: green, default: red in this interactive example so users can see the different states in their browser. 
I've made the examples interactive.   I didn't change this example as you've suggested because I wanted developers to see the `states.any(interactiveStates.contains)` idiom.  
This should be inside the `if (parent is RenderObject)` check
This assert can fail if the parent visits multiple children - it can be removed.
Maybe call this `isVisitedByParent`?  Otherwise it may be confusing to read since the child _is_ a child of its parent.
Nit: `s/,/;/`
Nit: Remove new line
Nit: I think this can be private
Should percent be used here? If so, what about localization?
Will these be reversed for RTL?
This matches what `Slider` currently does. If they are to be localized, that would have to be a separate PR
Good catch, I'll reverse them for RTL
assert that children is empty since the method ignores it?
I'd recommend writing the test with `tester.getSemantics` and `matchesSemantics` (example: https://github.com/flutter/flutter/pull/60329/files). That makes the test a little less brittle (we don't have to update the test when semantics above the Slider change.
This means, the accessibility focus rect (that green rect that Talkback draws) will always cover the first half of the slider for the first thump and the second half of the slider for the second thump - no matter the thumb position, right? Is that the expected behavior for a range slider? I would have expected the semantics nodes to be around the thumbs...
Correct, the thinking was that splitting the area in two makes the widget more accessible due to the larger targets (`Slider`'s semantic node is around the whole slider, for instance). It also helps when the two thumbs are on top of one another
Cool, I'll look into that. It feels more resilient
Can you update the documentation of this property to include what the default value is?
Done
nit:  ```suggestion /// Here is an example of a basic [OutlineButton]. ```
nit: should it be: ... which computes the smallest width ... ?
same.
The magic is here.
_debugFastReassembleMethod might need to become public in the future, in case I can't evaluate in the scope of the binding library and still use whatever type.
nit: maybe better: "debugFastReassembleMethod must be set to use fastReassemble."?
Maybe add a little more documentation here? E.g. it appears that this has to be set every time before  fastReassemble is invoked?
Define a typedef for the function type.
Would also be good to document what `cb` needs to do.
Is there potential for a race condition here? E.g. while we wait asynchronously for the end of the frame, somebody sets debugFastReassembleMethod to a new function, which then incorrectly gets nulled out in the next line?
Isn't `_` reserved for "ignored" params per style giude?
I'm not sure how best to document this. Unlike other APIs, no one should ever set this themselves (and if it is set it will get blown away)
Good idea, I should grab this callback in a local at the start
I'm being overly defensive because there is a chance that a user creates a widget which matches the parameter name, and `_` seems like the least-likely collision
I could name it like _param_flutter_please_dont_collide_123223232 - that seems less likely
The documentation wouldn't be for people writing a Flutter app, but for people working on the framework or the tool when looking at this again in the future :P 
Done
Updated, PTAL
Done
Done
For the test it doesn't really matter, so I named it `x`
Move this up to right after you've assigned it to fastReassemblePredicate?
Done
Will this test pass on release branches?
Yes - because we need to create arguments before we know what the current flutter version is, all of the features are always displayed
If test is just intended to catch inadvertent changes to the scrollbar's appearance, then `777, 3, 20, 297` etc is OK. If there's simple explanation for the values, it would help to include a comment about that.
All magic numbers removed.
Beautiful!
is also => are also
The previous explanation seemed more complete to me, because it explained why.
Can you also add "macOS: [not available]" (and iOS) or something, so that it's clear that it isn't available on macOS/iOS? Or at least a statement that it isn't supported on systems that aren't listed. What happens if I specify `SystemMouseCursor.wait` on a system that doesn't support it?
I added the following comment ``` /// If the platform that the application is running on is not listed for a cursor, /// using this cursor falls back to [basic]. ``` (Thought I did, thanks for pointing out).
Should we instead fix `FocusableActionDetector` to not remove the `Actions` and `Shortcuts` widgets when disabled, and instead just empty out their maps? There is some performance cost to building them, but if they cause churn in the tree, that could be offset by not causing it anymore.
It would break some tests because that introduces a 1 frame delay to descendant `Focus`'s semantics (`isFocusable`) . Currently since we change the shape of the tree, a new `Focus` widget gets inflated so there's no delay (line 1090):  https://github.com/flutter/flutter/blob/4195ad4ef605851be64e649ec2d292645d7425f7/packages/flutter/lib/src/widgets/actions.dart#L1081-L1103
(Is this expected?)
Well, I would think that anything that cares about the focus changing shouldn't care about the 1 frame delay, since focus changes already happen in a microtask, so that already happens often.  And semantics shouldn't care about a 1 frame delay either.
I think I added that part because the focus changes were increasing a build benchmark, and I was trying to reduce the number of built items for things that were disabled.
If a switch is disabled then `isFocusable` should be removed from its semantics flags in the same frame, no? 
The focus itself won't actually be removed until the microtask runs, so if the semantics removes it immediately, it might actually be early (and wrong until the task runs).
Updated. But it still seems confusing to me that when the UI is disabled the semantics is telling us the component is focusable.
Yes, ideally it would be resolved immediately, but it causes too much of a performance hit to update focus while the tree is rebuilt, and would mean that sometimes (during the build) two things could have focus at the same time, or that nothing has focus, which complicates a lot of logic.
Would it be possible to update the focus tree after we finalize the layout (instead of in a post-frame callback)? 
It would help to explain how this differs from benchmark and fullyLive, and when I'd want to use this instead of one of those.
nit: space between `duration ??`.  Why are we awaiting a delay of the duration before stting a timer for the duration again below? Won't that mean we get double the duration expected?
`benchmark` is actually very different: it's ignoring all animations. But yeah I should update the docs, and restructure the two parts from https://api.flutter.dev/flutter/flutter_test/LiveTestWidgetsFlutterBindingFramePolicy-class.html and https://api.flutter.dev/flutter/flutter_test/LiveTestWidgetsFlutterBinding/framePolicy.html . But before that I still would like to hear if the general idea is reasonable. 
It's an early return. When the policy is `benchmarkLive`, the below part is not executed. 
What's the number here for other flags, on host unit tests and on device?
Ahh sorry, I missed the scope of the return here.
This won't work. Tests might be executed in random order, and the code "on top of them" isn't guaranteed to run inside the test itself.  You either have to set the frame policy in the test and have that just work, or create separate test files for different policies.  You _might_ get this working if you use `group`s.
All other flags don't response to frame requests from the engine, including the benchmark, and they basically don't track animation unless manually pump-ed. So these numbers are not relevant for other flags.  As for the number on host and on device, that's the issue why I'm getting flaky result. The number here comes from my local test on my macbook, and it seems on Cirrus they get different number, varying from 60+- ~90+-. Is there better place to test these number?
To reduce the number of new files introduced, can we put this under `macrobenchmarks/test`, and create a new page in `macrobenchmarks` for the purpose of `simple_scroll`?
It would be nice to put your local results in the PR description to set the expectation of those two different flags.
I don't feel comfortable doing that because it's technically not a performance benchmark but more like a test to check the functioning of a feature. But if you insist I'll make the change. 
Done. 
The reporting of metrics like `average_delay_fullyLive_millis` and `average_delay_benchmarkLive_millis` makes me feel that this is more or less a performance test. It's testing the performance of the input events simulation which justifies `benchmarkLive` (i.e., everything would still run if we don't have `benchmarkLive`, but the simulation performance would be bad and inaccurate). Such performance metrics also prevent future accidents that suddenly make our simulation much less accurate.
Done. 
`// This page is currently not used for frame benchmarking` might be unnecessary as there are some pages here that are only for memory benchmarking and they don't have frame benchmarking either.
Nit: Flutter repo prefers `n += 1` than `n++`. I can discuss the reasons in our next meeting if you're interested.
By doing so I'm avoiding extra operation to select the page. It might be a good idea to do the same for other pages with E2E test version, or to put this together with the util code in #61509 
This file is modified from https://github.com/flutter/plugins/blob/master/packages/e2e/lib/e2e_driver.dart
This looks strange. Does `handlePointerEventRecord` mostly return all negative delays? Shall we use `abs` just in case of positive delays? We might need to add some documentations to `handlePointerEventRecord` to describe the meaning of positive and negative delays, and set the expectation if most of them are negative or positive.
`Ignore any request from pump but respect other requests to schedule a frame.`
Yes mostly negative. It's positive only when `Future.delayed` complete earlier than the set time. My local test shows it's 0~3 out of 200+ events with tiny positive values < 100us (**micro**seconds). I don't think I should use `abs` because this list is only shown in debug mode and `abs` makes less use of the info. But it does make sense to change the behavior of `handlePointerEventRecord` for the major result being positive since we are calling it delay, and add docs to that. 
Update about the number. When putting this on a more complex environment, sometimes (not sure when, it differs from run to run) the fluctuation becomes larger, and positives can go as much as ~10% and up to 500us. Still tiny compare to frame interval though.  
nit: space before {
The first if branch below also assigns 0.0 to extra. Remove that?
nit: space before {
nit: remove extra blank line
Do you need this? Wouldn't the test fail by itself if it throws an error?
does a warping => "warps" from one tab to another, non-adjacent tab, with an animation.   On the face of it, it's not clear why this route might have been disposed as a consequence of the warp. The test appears to set up a situation where the old Navigator will have been disposed - not its route. Can you explain this scenario in a little more detail?
Minor nit, but it might be nice to make sure that each of the settings overrides the other (i.e. provide all three shadow colors to verify that the widget setting overrides the other two if they are all specified).
OK, I've added some tests like that.
I think this could be said a little more briefly:  If [sortColumnIndex] is non-null, then the table will be sorted by the values in the specified column. The boolean [sortAscending] flag controls the sort order.
Sure @HansMuller I will change it.
```suggestion   /// Defines the background color of `ListTile` when [selected] is false. ```
nit: ```suggestion       ), ```
nit: indentations and trailing commas ```suggestion       MaterialApp(         home: Material(           child: Center(             child: StatefulBuilder(               builder: (BuildContext context, StateSetter setState) {                 return ListTile(                   selected: isSelected,                   onTap: () {                     setState(()=> isSelected = !isSelected);                   },                   title: const Text('Title'),                 );               },             ),           ),         ),       ), ```
I feel like it doesn't make sense to put these checks here as the method name says "_validateLegacyYaml", but the code is actually validating the new format.  What do you think about fixing it in the `validatePluginYaml`? We have something like:  ```dart if (usesNewPluginFormat) {   if (yaml['platforms'] != null && yaml['platforms'] is! YamlMap) {     const String errorMessage = 'flutter.plugin.platforms should be a map with the platform name as the key';     return <String>[errorMessage];   }   return _validateMultiPlatformYaml(yaml['platforms'] as YamlMap); } else {   return _validateLegacyYaml(yaml); } ```  We can make it as:  ```dart if (usesNewPluginFormat) {   if (yaml['platforms'] != null && yaml['platforms'] is! YamlMap) {     const String errorMessage = 'flutter.plugin.platforms should be a map with the platform name as the key';     return <String>[errorMessage];   }   return _validateMultiPlatformYaml(yaml['platforms'] as YamlMap); } else if (usesOldPluginFormat) {   return _validateLegacyYaml(yaml); } else {   return <String>['The flutter.plugin.platforms key in the `pubspec.yaml` is not found. '                               'An instruction to format the `pubspec.yaml` can be found here: '                                'https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin']; } ```
This is great! Thanks :) 
Yeah, put the check inside the method `_validateLegacyYaml` is weird. I will modify it later, thanks for the suggestion : ) !
Thanks! Feel free to @ me when it's ready to be reviewed again :)
What about:  ``` Cannot find the `flutter.plugin.platforms` key in the `pubspec.yaml` file. ```  We want to push users to use the new format.
We don't need the "See:" here.
OK.
oops
```suggestion   ///   /// If `textDirection` is [TextDirection.rtl], then the direction in which   /// text flows starts from right to left. Otherwise, if `textDirection` is   /// [TextDirection.ltr], then the direction in which text flows starts from   /// left to right.   /// ```  The test is failing due to trailing spaces.
Will fix it.....Thank you..
Although this is a correct statement about `textDirection` in general, it's not really help for understanding how the `Row` lays out its children.  If you rephrased the point (in terms of the row's children) and explained the implications of the start and end parameters, that would help.  #58019 was really a request to enhance the `Row` _class_ API doc, by mentioning the support for RTL layout a little earlier. 
Sure. @HansMuller 
This link is broken. I don't think this asset actually exists in https://github.com/flutter/assets-for-api-docs?
@Piinks  Yes it is but I have also created PR for that too, [#115](https://github.com/flutter/assets-for-api-docs/pull/115)
```suggestion /// The [textDirection] property controls the direction that children are rendered in. /// [TextDirection.ltr] is the default [textDirection] of [Row] children, so the first /// child is rendered at the `start` of the [Row], to the left, with subsequent children /// following to the right. If you want to order children in the opposite /// direction (right to left), then [textDirection] can be set to /// [TextDirection.rtl]. This is shown in the example below. ```
```suggestion   /// If [textDirection] is [TextDirection.rtl], then the direction in which ```
```suggestion   /// text flows starts from right to left. Otherwise, if [textDirection] is ```
Good idea!  How about totally removing the suggestion to re-install the SDK manager. ```suggestion       'Android license status unknown.\n'       'Run `flutter doctor --android-licenses` to accept the SDK licenses.\n'       'See ${_androidSdkInstallUrl(platform)} for more details.'; ```
Thank you very much for supporting my idea! this suggestion has been committed! @jmagman 
what is `defined_in_file`? is this a pod magic function?
nvm, I grepped the codebase and found y our other comments about it
maybe flutter_parse_dependencies_file_for_ios_plugin? to make it more explicit
is this intentional?
add a code comment or reference issue for when this can happen?
No, I meant to revert this.  Good catch!
I don't think it can ever happen AFAIK, I think I just wanted a way to surface Something Bad Happened and stopping instead of copying from a nonexistent directory in https://github.com/flutter/flutter/pull/59044/files#diff-76053fa099530bf75a339336cccbc2efR23.
I copied the comments to this file.
```suggestion       // State for all pointers which are currently down.       //       // The `hitTestHistory` is equivalent to `GestureBinding._hitTests`, which is important for       // `_handlePointerEvent` to replicate `GestureBinding._handlePointerEvent`. ``` Explain the property so that readers can understand without referring to another file.
Can you comment when this will happen?
Isn't it the same as `timeDiff` so that it's basically the same as L714?
By "parallel implementation" do you mean this is a makeshift implementation and will be replaced in the future?
Put executions into a `test` body. Code outside of `test` can only prepare stateless data and utility functions.
When something along the way is expensive and causes miss of a frame. My experiments using #60796 + e2e usually have 2 or 3 packet out of like about 200 that falls here on a MotoG4 with the complex_layout test case and a set of input simulating scrolling, which looks like doing GC or something. 
No because `Future.delay` doesn't promise exact delay time. 
I mean the implementation is almost the same, but due to there is not a subclass relation I have two copy form there. 
I tried but failed. `runApp` inside a test body will result in `await SchedulerBinding.instance.endOfFrame;` to never complete. 
Just call `tester.pump` right?
This reference also make sense since the implementation is copied from `GestureBinding`. I'll have both. 
I think I misunderstood the question for the above reply. Ideally L714 should give a negative value but this should give zero (and is indeed zero in #60796 's unit test where it's using a fake async), but since `Future.delay` is not exact, there will be a little extra delay. 
@dnfield there isn't and shouldn't be a tester because getting a `WidgetTester` will introduce its own controller, making the `LiveWidgetController`'s signal directed to the wrong place. This is also one of my failed version before this PR.
Sorry I made a mistake. Previous unending await is caused by another reason. 
Ahhhh ok.  In that case you can just manually drive the binding. But I'm surprised putting this in a test body makes a difference, especially since you're not using testWidgets.
I see. Can you add a comment saying "Recalaulate time diff because (...)"?
@dnfield Sorry the difference I thought it was is caused by some other things. 
Ok then I suggest changing it to ```suggestion   // This function is identical to [GestureBinding._handlePointerEvent] to replicate    // the behavior of real cases. ``` (or something appropriate.)  The "parallel implementation" is a jargon that refers to what I mentioned in the first comment.
Done.
nice!
'was deprecated after 24 hours of its debut '
Shouldn't this be `ElevatedButtonThemeData`?
Yes, you're correct, thanks for pointing that out.
I think the characters issues was getting triggered by this code I removed @justinmc . Normally we don't need to invalidate the packages when a dependency changes because the pubspec must have changed, but the flutter sdk is special and needs a bit of help.  I think we missed it because so much else triggers a pub get that in most cases you won't notice
I don't really like this, in theory adding a yaml wouldn't re-trigger pub get,  that would have to be done automatically
Ah nice, thanks for following up on that!  The [issue](https://github.com/flutter/flutter/issues/59645) is still getting the occasional comment from someone experiencing the build problem, so hopefully this PR will clear that up.
Why the move to an assert?
I'd be concerned about an update or bug in this list breaking the tool if our test coverage isn't good. Moving to an assert lowers the risk.  On the other hand, its entirely unrelated to this PR, so I should remove it anyway
`savePackageConfig` is a utility function written in terms of public APIs:  https://github.com/dart-lang/package_config/blob/9c586d04bd26fef01215fd10e7ab96a3050cfa64/lib/src/package_config_io.dart#L131  Maybe the tool should do this more manually to avoid the possibly brittle filesystem type check.
Maybe also test a malformed 'generate: ' to make sure the tool doesn't crash.
Neither writePackageConfigJsonUtf8 nor any of the other utility methods are exported
Oh, whoops. I misread. I thought I saw it using https://pub.dev/documentation/package_config/latest/package_config.package_config_discovery/PackageConfig/writeBytes.html
done
You could also locally override dart:io with an IOOverrides, but that is possibly not actually an improvement over the type check here.
This seems like a bandage fix, because it only applies to indexed stack. I believe there are more widgets that may not paint all of their children. Further more, you may run into circular dependencies if that widget is in Cupertino library.
This api feels weird, you may as well don't create an ink if inkNeedsPaint = false
OK
I feel the same way. I'll see if there's a better plan.
The dropdown menu button need to rebuild automatically. If we have to manually pump a new widget, that is a bug in the dropdown menu button itself.  In other word, if a `tester.pumpAndSettle()` does not work, we need to fix the code in dropdown.dart instead.
nit, add a new line at the end
It is possible that the offstage widgets want to paint themselves.
> The dropdown menu button need to rebuild automatically. If we have to manually pump a new widget, that is a bug in the dropdown menu button itself. >  > In other word, if a `tester.pumpAndSettle()` does not work, we need to fix the code in dropdown.dart instead.   #35736 discusses why the widget does not automatically update the UI
our style guide suggest we only use arrow function if content fit into a single line.
same here
indent is off
Can you add a `Regressing test for https://github.com/flutter/flutter/issues/59963`
closing parenthesis in the new line
unused import?
ok
applyPaintTransform needs Matrix4,  change to: import 'package:vector_math/vector_math_64.dart' show Matrix4;
You could also expose this like time dilation so it is configurable at runtime
The alignment is so, so close to perfect
Out of curiosity, what does this do on the web?
nit: Extra '.'
"Developers using ..."  Can you give some more concrete advice here?
If possible, this message should contain suggestions to fix the problem.
Consider adding some comments here about what each of these steps is doing.
Rewrite for Windows terminals that don't support emoji here:  https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/base/logger.dart#L366
'I' also looks available. Big 'I' for a big image warning makes some sense, I think.
It currently does the widget inspector.  If we're ok with changing that I'll use it.
Lets not change the existing bindings if possible
Ah, okay. The help message only claims 'i' for the widget inspector, but the resident runner triggers it with both 'I' and 'i'. I would be okay with keeping 'i' for the widget inspector and using 'I' for this. @jonahwilliams thoughts?
That is, I would be okay with the help message being the source of truth about what they keys do, rather than what the resident runner implements.
SGTM, if its not documented it might have been an oversight/mistake at some point.
Ok, I'll take over upper case I for this.
Isn't this configurable at runtime?
Done
Done
Added a line explaining how to fix.
Ah right, I always forget that we export everything 
Updated this a bit.
Done
Done
No color filter, but it does vertically invert the image and flip.  I have a feeling we don't want this on web - on web you should be serving smaller assets. Should I just disable it completely for web?  /cc @yjbanov 
Ok - I'm fixing the resident_runner_web for this, and I've updated copy in a few places to mention resizing the asset itself as the most preferable option, particularly on web.
do we actually know the image size on the web?
dang, didn't know we had all these
![PB9d7](https://user-images.githubusercontent.com/8975114/87119152-04a07780-c232-11ea-922a-d5aea8784f2a.jpg) 
Why not just do this?: ```suggestion       return LinkedHashMap<MouseTrackerAnnotation, Matrix4>(); ```
add `show Matrix4`?
Why not just do this?: ```suggestion       (_) => (LinkedHashMap<MouseTrackerAnnotation, Matrix4>()), ```
The linter. With `LinkedHashMap<MouseTrackerAnnotation, Matrix4>()` the linter reports "Use literal when possible".  With `<MouseTrackerAnnotation, Matrix4>{}` the compiler reports a type mismatch. This is the last I can do...
Explained above 
Well, that is pretty confusing.  I guess it's because the real type of `Map` is `_InternalLinkedHashMap` and not `LinkedHashMap`. It's probably no less efficient, since I'll bet `LinkedHashMap` is implemented as an `_InternalLinkedHashMap` internally, but ewww...
I brought it up in https://github.com/dart-lang/linter/issues/1649#issuecomment-656929040. Hopefully it raises some attention :/
I think probably how this should be landed is by bumping the min sdk version in the pubspec to be a 2.9 release, and removing the // @dart comments in the opted in files entirely.  @jakemac53 @jonahwilliams does that sound right?
That sounds like an approach with less churn. Is 2.9 _the_ null safety language version, or could that change?
2.9 will *not* be the final null safety language version.  It is likely, but not guaranteed that 2.10 will be the final null safety language version. 
okay, in that case we should definitely do it in the pubspec so there is only a single location, right?
I prefered to explicitly use `// @dart = 2.9` during the incremental migration for simple searchability. Once all framework is migrated I will remove it. Note that the [pubspec.yaml sdk version is already pointing to 2.9](https://github.com/flutter/flutter/blob/master/packages/flutter/pubspec.yaml#L8).  Does it look good to you?
If it makes the process easier, I would say to use it - but file an issue to clean up the overrides once it has all landed.
I think that's better, and it's how pub packages need to migrate (because otherwise you're allowing sdks that don't support null safety, which won't work).  I think with flutter, because you provide your own copy of the sdk, you don't run into the versioning problem, but it still seems like the right approach to me.  But I don't know all the details of how package:flutter works - it's Not Like Other Packages.
Ok, works for me.  Note that if/when the Dart version bumps to a 2.10 pre-release, there will a bit of a bump - you won't be able roll 2.10 in until you change all of these from // @dart = 2.9 to // @dart = 2.10.
could we set it to 2.10 now?
> could we set it to 2.10 now?  You could try it, but I wouldn't really recommend it.  You're more or less relying on undefined behavior in that case.  It might just work, in which case it's probably fine, but it also might work in some places and not others, or suddenly stop working, or whatever.
If this is really just about tracking which things are migrated, maybe consider just using some other arbitrary string to tag them?  // @dart = migrated ?
Ok I'll remove it directly. I don't use it too much now.
Is there an issue on file that we could link from here?
Why do we turn this one off?
Why is this change necessary?
This feels like a strange thing to add to flutter's public API. Looks like it is only used in one file. Can we just add it as a private thing there? Or, instead of using promote, can you just do the following in the code:  ``` num n = 42; n = n as int; n.isEven; ```
Why `late`?
What's currently stopping us to do this?
`someMap[someKey]` is optional, while `(int value) => value + 1` is only invoked if `value != null`.
link to issue added.
This is needed to avoid warning on null assertion on non-nullable variable. For instance:  ```dart void m(String s) {   assert(s != null); } ```  This could change with https://github.com/flutter/flutter/issues/61042
Without this change there's an error because `removedPackagesAndClasses[className]` is nullable and you cannot use operator + on a nullable value. Without `.update` we should have used:  ```dart removedPackagesAndClasses[className] = removedPackagesAndClasses[className]! + 1; ```  The update version avoids repetitions and is less error prone imho.
I don't remind the issue but @Hixie suggested to add this function.
IIRC this will make the field lazy initialized.
`late` is a little dangerous for public member. I'm not sure the TODO is still relevant. I'll check.
It won't do anything in this case (other than maybe make it slower to access). It allows you to (yourself) lazily initialize it but leave it as a non-nullable type.
Sorry if this wasn't clear, but my question was meant as: "Why are we declaring this field as late? It seems unnecessary here."
Agreed, `update` does look nicer. Thanks for the explanation.
If the variable itself is already non-nullable, why do we still need the assert? Wouldn't we want to clean that up and remove it?
It was lazy before - I think there was a misunderstanding around what `late` means. If assigning immediately it has no meaning @stereotype441 should we have a lint for this?  To restore the lazy behavior that existed before this would have to be a nullable field type, and you would have to restore the old logic.
I am not sure I fully understand, `lastWordStart` seems to be private to this method?
Either way, It would probably be good to have a comment on this line explaining why we turn this off.
@jakemac53 that's not correct. late with an initializer means lazy.
Now I am confused. What is the difference between those two lines?  ```dart late final int foo = 1; final int bar = 1; ```
Nothing, because you can't observe laziness with a value.  But:  ```dart class A {   late final int foo = (() {print("hello"); return 1;})();   final int bar = (() {print("world"); return 1;})();   A(); }                                                           void main() {   var a = A();   print("says");   a.foo; } ```  outputs ``` world says hello ```  because a `late` variable with an initializer only evaluates its initializer on first use.  cc @munificent this is something we're going to have to explain carefully.
Thanks for the explanation!
>If the variable itself is already non-nullable, why do we still need the assert?  See https://github.com/dart-lang/language/issues/1018:  > At first glance, it might seem sensible to remove the assertion on the grounds that c can no longer be null, but that's only true in strong mode. Flutter will have a long tail of users running in weak mode until Dart 3.0, and assertions like these are necessary to help prevent them from passing nulls to Flutter APIs.
Finally I removed this function for now.
comment removed. I added it to remind me that a lint could be done to use `late`.
Thanks for the context and adding it as a comment.
If we're no longer using 'flutter::profiling', how are we going to handle the code in https://github.com/flutter/engine/blob/f10f17257300b232d0b16c95c63a641a3e158207/shell/profiling/sampling_profiler.cc#L52 ?
`[kProfilingEvents] name` instead of `[kProfilingEvents] category`?
Should these parameters be added to a SnackBarThemeData too? Maybe create a follow up issue for it.
We'll add a SafeArea here that's not used if `isFloatingSnackBar` is true. You could break it out to a conditional below, not sure if its better?
This could be more specific and mention that: For a floating snackbar the start padding is 16, and for non-floating 24. If it includes an action, the same padding will be added at the end.
nit: top and bottom padding could be constants
I think I prefer to leave these out of the theme for now, but could follow up with that if it is asked for
Good call, done
done
done
it's only horizontal-only by default right? maybe update this comment to say what it will be applied as
Oops, fixed
It can not be used if [margin] is specified.
Might explain that, if the width is specified, the snackbar will be horizontally centered within the available space.
Less the margin, right?
ButtonTheme. UGH. This part of the implementation needs another look; future PR.
Done
Done
Right, done
yeah, snackbar is another one of those widgets to update with new button universe
This might have been too breaking. I can updated to a separate lookup so that it does not affect the run workflow
It might be worth keeping the "h", except that the help message could explain how the server mode is different from the browser mode.
Should these have return types?
Technically these could return null, void, Future<x>. This is the pattern used by the engine already
I guess we're not linting generated code. We could make them return `dynamic` for explicitness.
I did add more details in the web server startup below (see web_devices.dart), that way it shows up in IDEs too
done
try and stick with a 2-space indent, here and elsewhere
nit: add a trailing `,` and place the closing paren on the next line.
Since you're refactoring this - could you document the reason these two messages are almost the same? Or make it more obvious by other means (moving the rest of the message generation here?)
Please consistently use the string buffer, you can use `write` as an equivalent to the concatenation below.
I add dartdoc comments
Xcode 12 didn't like this and removed it.
☠️ ded
moar ded
Remove dead code tests
This wasted time shelling out to tooling in nonexistent directories when creating a new project.
rip
rip
rip
rip
TIL about testWithMocks
Will add this to my deprecate/remove list :) 
technically, you could pass in `defaultInfo.reportFlavorNotFoundAndExit` as a tear-off, since the throws matchers just require a zero-arity function. Just an FYI
Audited, got a PR coming your way.
wow...
yeah, I think it might be better to pull out each discovery instance, and then inject them into the constructor? Then the devicemanager is just responsible for ... managing the devices, and not creating the world
this will have to wait for a google3 roll, there are some updates needed internally
Let's make these null by default.
For both: ```suggestion   /// Must be greater than or equal to 0.0, defaults to null. ```
Let's add a test that checks the behavior when both are not provided, or both null.
Why are there two instance of Align here and in the animated tests?
For all, these lookups could be: ```dart final RenderBox textBox1 = tester.renderObject<RenderBox>(find.byKey(key1)); ``` Or if there were only one instance of the class: ```dart final RenderBox box = tester.renderObject<RenderBox>(find.byType(AnimatedAlign)); ```
need to check the assetPath != path, otherwise the tool recognizes `assets: - foo.txt` as its own asset variant.
This was getting hit in devices_test and failing if it grabbed the wrong context, I did some minor cleanup but it needs to be fixed later so that there is no accidental caching
Reminder: remove null safety mode flags here
What do you mean by "that includes spaces"? Does this only happen if I hit the space bar on the english keyboard?
Yes that's right, for the case that the input is RTL.  I'll clarify.
It is not the type of keyboard, but rather the mark inserted is based on the directionality of the immediately previous run of text. This ensures the whitespace is treated as part of the same directionality run instead of defaulting to the underlying direction of the field.
@GaryQian Alright I tried to clean this paragraph up a little bit, and I removed this example sentence entirely.  I think it was making things even more confusing by introducing uncertainty.  They first sentence says it as clearly as possible: typing LTR text into an RTL field will produce LRM characters if it includes spaces.
Maybe add a slight justification for this so that it is a bit more understandable:  "This is to eliminate ambiguous directionality in whitespace and ensure proper caret placement"
Where is this set?
I wonder if there's some way we can be more explicit about requiring a `AppRunLogger` context logger whenever a daemon `AppInstance` is used (injecting it into the constructor instead of grabbing out of the context?).    Seems error-prone that one layer needs to know `AppInstance` is only used for `attach` and `run` (and not `drive`, say) and to set context `AppRunLogger` and then the next layer needs to assume it's been set correctly without enforcing it.
The right way to do this is probably to make the Domain require an AppRunLogger in the constructor. We can pull it out of the context and cast in run/attach - at least until those don't use the context.  Though really, we could probably express all of our loggers as a single class (except for maybe BufferLogger) and then it would just be about configuration
nit: consider adding a comment here or at the top of the test explaining that this mimics the start of a gesture as seen on a device.
don't need a line break here
This is OK, but it shouldn't be necessary to use a key to identity the OutlineButton (here and elsewhere). This will work as well: ```dart tester.getSize(find.byType(OutlineButton)) ```
This kind of comment is really important, glad to see that you've taken a crack at it.  It would help to include similar comments, anywhere that the sizes aren't obvious. ```dart // The expected width is the sum of: //   the width of the icon //   the gap between the icon and the label (8) //   the width of the label (50) //   the horizontal padding: start 12, end 16 ``` 
nit: we conventionally have the `child` widget be the trailing named parameter in Flutter. ```suggestion               onPressed: () {},               child: const SizedBox(width: 50.0, height: 8.0), ```
nit: we conventionally have the `child` widget be the trailing named parameter in Flutter. ```suggestion               onPressed: () {},               child: const SizedBox(width: 50.0, height: 8.0), ```
nit: ```suggestion   /// [TextStyle.color]. The [TextStyle.color] depends on the value of [enabled] ```
This should not be `=` I believe
I could make a method on `PubspecDependency` to handle this, but  .. this whole thing is pretty convoluted as it is, and all the classes are in this file anyway.
It seems like there should be a bounds check on `lines.length` somewhere in this loop.
Yeah, an invalid pubspec could cause this to crash. I'll add a check and throw with a more appropriate error.
Could we throw if ` call.arguments` isn't a `Map`?
nit: I couldn't find the definition of "main axes". Maybe "horizontal axis or vertical axis"?
It appears to me that if the user initiates a horizontal drag, then they won't be able to change the direction to vertical later (in the same gesture). Maybe add documentation for this behavior too?
Can this be done in `_onScaleUpdate` to avoid checking `_gestureType`?
Will do, that sounds better.
That's right.  I'll document it.  It seems to be how Google Sheets works on my iPhone too.
Good call 👍 
This is a rewrite of the EarlGrey [FlutterViewControllerTests](https://github.com/flutter/flutter/pull/61007/files#diff-fd7097c2fc18cf84af75aeee43e84608).
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/AppDelegate.m](https://github.com/flutter/flutter/pull/61007/files#diff-9e149ff1c1dcf4b51edd1f16e15eea54) but git didn't follow the rename.
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/AppDelegate.h](https://github.com/flutter/flutter/pull/61007/files#diff-857228bf10c8c1e20cb51a974a25baa0) but git didn't follow the rename.
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/Launch Screen.storyboard](https://github.com/flutter/flutter/pull/61007/files#diff-95f972d78b529be67ee75548a2086d30) but git didn't follow the rename.
I wanted something identifiable as the home page.
Mostly copied from [dev/integration_tests/ios_add2app/README.md](https://github.com/flutter/flutter/pull/61007/files#diff-14972bc6e76cd3b7d00d54d922a9c95f).
This was essentially copied from https://github.com/flutter/flutter/blob/023532d9919463404e0ae2a8aa47d07247ad7e65/dev/devicelab/bin/tasks/ios_app_with_extensions_test.dart#L79  Next PR will convert that test to use this new function.
This was deprecated with https://github.com/flutter/flutter/issues/54408 and is a no-op.
Woo one fewer bash script!
Intentional?
ditto
FWIW, EarlyGrey is about to publish a Flutter plugin. 
Oh, I get it now, these would correspond to the one you're removing for other platforms. LGTM.
There's no more add_to_app_tests on any platform, so we don't need a windows or linux one.
Hm, this isn't working, I'm still getting errors from these files.  You guys have any hints to get it to ignore `ios_host_app/flutterapp/lib/main.dart` and `ios_host_app/flutterapp/lib/marquee.dart`?
how about `**/flutterapp/lib/**`?
I think you were looking at an outdated diff. Also `./dev/integration_tests/ios_add2app_life_cycle/flutterapp/lib` exists and is a real package.
> Ugh, didn't even get to the analyzer this time. Still trying to figure out how to have floating dart test files that aren't really in a package, but will be copied into a newly created package by an integration test. >  > ``` > Warning: pubspec in /tmp/flutter sdk/dev/integration_tests/ios_host_app/flutterapp has out of date dependencies. Please run "flutter update-packages --force-upgrade" to update them correctly. > ```  I don't think that test is even using the analyzer, it's just checking the pubspec checksum
https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/commands/update_packages.dart#L180
can this be `testWithoutContext()`?
All of the createTestCommandRunner tests hit the context due to FlutterCommand. I started refactoring things out, but I got stuck on output preferences and rolled it back a while ago
I think this is more readable as includeInputDecoration ? cons InputDecorationTheme(...) : null
Done
adding this with a post frame callback concerns me because there may now be a 1 frame lag where the render object is inconsistent for the selection and the inspector overlay. Can we update the root render object earlier to avoid this issue?
nit: end comment with a period.
here and elsewhere, prefer to end comments with a period.
give these descriptive variable names instead of m1 and m2 or remove the variables names completely as each variable is only used once.
For example. maybe instead have _RenderInspectorOverlay check what its immediate parent is.
bonus points: add a golden image test or two that renders the selection. just like the screenshots you included with the CL, that makes it really obvious what is going on.
this object isn't really related to the selection so it is a bit confusing to have as a public member of the InspectorSelection object. Can you remove it from here and maybe only track it in _RenderInspectorOverlay? That would seem like a great place to be tracking the root render object that we are trying to render relative to. 
I ended up passing the _RenderInspectorOverlay parent to the layer.
I'll experiment with how to do golden tests, because I've never used them. Thanks for the suggestion!
@jacob314 I've created a golden image test. The image is attached at the end of the PR description.
to be defensive, maybe add an is check in case the parent is not a RenderObject.
inspectorRoot seems like it is unused. remove.
This is adding a tight dependency that the _RenderInspectorOverlay has a parent that is a Stack and is the last child of that parent. That is probably ok but is a little fragile. We should either add a key to the Stack that is the parent of the _RenderInspectorOverlay or document in the code where the Stack is used that we are making assumptions about its child.
https://dart.dev/guides/language/effective-dart/design#avoid-starting-a-method-name-with-get
wow I'm surprised this multiple WidgetInspector case works this well :)
Good catch. It was a remain of a different implementation I had for that.
I thought about the key, but I wasn't sure about passing it through arguments all the way down. It looked off. Also the key would have the problem of calling findRenderObject in the first frame right? I'll add a comment to the Stack at the top as you suggest. 
Actually, that is a function local to the test. I used the same name convention as the other tests that access the inspector state. I think we should keep the name for consistency with the rest of the tests. What do you think?
Very niche use case I would say, but I was surprised as well to see it working perfectly fine in a sample app where I took it to the extreme. Multiple MaterialApps and even nesting between them ^^ 
sgtm
as long as it is documented in the build method it is fine as is. 
nit: Tweak to  // Be careful changing this build method.
nit: `as last child` -> `as the last child`
It's somewhat confusing that `value.composing.isValid` and `value.isComposingRangeValid` seem so similar but mean different things.  I can't think of a way to make it more clear though 🤷 
I guess we could use null to represent an editing value that has no composing range. That would be a breaking change.
Probably not worth it.
```suggestion   }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767 ```
```suggestion   }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767 ```
```suggestion   }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767 ```
nit: maybe rename to something clearer like `useUniquePaint`?
Done (renamed to `benchmarkPaint` as discussed offline)
Is there no mac equivalent? Like the spinning beach ball? 😜
Are these equivalent? Or specific to certain browsers?
`allScroll` mentions falling back on `move`, and here it is vice versa. Is there a specific condition or precedence for one or the other?
I probably should doc this, but mac decides when to show the spinning beach ball by itself (when the application does not respond a blocked callback for a while), and does not expose a way to manually trigger it. 
Good catch, this is actually macOS.
Yeah, I thought `move` should be ubiquitous so that `allScroll` might fall back to it, but it turns out no platforms have `move` but no `allScroll` at all. I'll remove this fallback.
Is this a unique ID for each `PointerEvent` or can multiple PointerEvents have the same motionEventId?
Can we document this in a more platform-independent way so we can re-use this for the other platforms as well?  Exact wording would depend on the answer to the question below. Does this id uniquely identify the event across framework and engine? Or (if there are multiple PointerEvent with this id) does it identify the native event that generated this framework-side PointerEvent uniquely on the engine side? Something like this should be included in the doc comment.  After that, we can also include a platform-specific paragraph that on android this maps to the ID of the underlying MotionEvent. Or something like that.
A name for this property that doesn't tie it to Android's MotionEvents (and hence can be reused for other platforms) would probably also be a good idea.
Nope, this is unique per `PointerEvent`. Multiple `PointerEvent`s can not have the same `motionEventId`.
I will try to address this and the comment below here:   What do you think of `embedderPointerEventIdentifier` as a possible name for this? Given that this is different from `pointerIdentifier` -- which is used for hit testing, whereas `embedderPointerEventIdentifier` is used to tie back the current pointer event to the platform equivalent which resulted in this event.  If you agree with that, I can elaborate the dart-doc to explain the intent of this field along with the differences between this and `pointerIdentifier`.
Can we just shorten this to `embedderId`?
The doc should still include the explanation how it is different from the other IDs in this class.
SG
... to the embedder event that created it?
Maybe add a section about Android explaining that on Android this is the ID of the underlying MotionEvent.
The naming convention here seems mixed?
If we're going to include comments like this, maybe remind devs that AnimationControllers can be created with `vsync: this` because TickerProviderStateMixin.
This is the main application widget; here and elsewhere. 
Just being pedantic: these templates import the material library.  The updates look good.
```suggestion `MaterialApp` instead. These templates import the  material library. ```
```suggestion `CupertinoApp` instead. These templates import the  cupertino library. ```
```suggestion These templates create a `WidgetsApp` that encloses the snippet widget. These templates import the widgets library. ```
nit: replace generate with create?  (in the code and doc comment above too)
Any reasons this cannot be a regular `testWidgets` test? You should be able to just instantiate the custom binding in the main before all `testWidgets` methods.
Aren't those arguments the default for pump? If so, let's remove them.
What does this comment mean?
nit: space after `while`
Does this while loop actually run? I would have expected that `SemanticsUpdateBuilderSpy.observations` is empty because you cleared it above and then pumped a frame that didn't change any semantics?
Can you add an expect before the while loop to check that `SemanticsUpdateBuilderSpy.observations` actually contains the expected number of nodes?
Instead of doing the while loop I'd also have more confidence in the test if it would just check individually that all expected nodes are in `observations`.
```suggestion       // We should have looped through all the observations. ```
What's this typedef for?
Why this second MergeSemantics?
nit: remove extra blank line.
There should also be a test where we modify the semantics of a node that gets merged into another node and ensure that only the (updated) merged node is send over.
I am surprised that it sends this many semantics nodes. I would have expected 2: the root node and the merged node. Is that because of the `MaterialApp` used in the test? Can we remove it (and replace it with the individual widget we need, e.g. a Directionality widget) to make this test more targeted? Otherwise we will have to update it whenever the semantics of MaterialApp change...
remove extra blank line
Can you achieve the same effect by removing this MergeSemantics and setting `container: true` on the semantics node below? Seems slightly simpler then the nested merging...
```suggestion     description.add(DiagnosticsProperty<Tween>('widthFactor', _widthFactorTween, defaultValue: null)); ```
```suggestion     description.add(DiagnosticsProperty<Tween>('heightFactor', _heightFactorTween, defaultValue: null)); ```
I may be clearer here and below to say Must be greater than or equal to 0.0, defaults to 1.0.
Good point.
Oops 😆 
I thought these could be greater than 1.0?
They can 😬  Just pushed the correction :) 
@hansmuller just astutely noticed the Align-ment (😆 ) here is off. Can you fix this nit before we merge?  ```suggestion        assert(widthFactor == null || widthFactor >= 0.0),        assert(heightFactor == null || heightFactor >= 0.0), ```
Hahaha 😆  done
This `assert` doesn't take into consideration for multiple input events at the same time. This often happen for `PointerAddedEvent` and `PointerDownEvent`. 
I'm not 100% sure when I need pump. Another possibility is to pump in the beginning of this else clause and in the end of this guard async call.
Is it true that we should only expect `PointerAddedEvent ` and `PointerDownEvent` here? If so, I wonder what `assert` we can put here.  Nit: maybe it's less error prone to write ``` if (condition) {   doSomething(); } ``` than ``` if (condition)   doSomething(); ``` We have both styles in our code base and I personally prefer the first one because I've made some mistakes before with the second style.
For now, I think we can probably `assert(...framePolicy  == ...fullyLive/benchmarkLive)`and remove `pump` as this is probably only used in our tests. If in the future we want test something with some other `framePolicy `, we can then figure out where to put `pump` with the guidance of those use cases.
As we discussed today, we probably want to simulate at the `_handlePointerDataPacket` level instead of the `_handlePointerEvent`?
`framePolicy` requires `LiveTestWidgetsFlutterBinding`, which is not what we use for unit test. And my unit test also depends on this. If I have to change the behavior here I would rather just `pump`, which is what we are already doing for `WidgetTester.drag` anyway
I still feel it's better to leave the testing API `PointerEvent` and do the conversion when accepting json input, as #60741 (I'm keeping this PR up-to-date with our discussion), because this API is also useful as accepting a controlled sequence of input for testing, see my test case, and `PointerEvent` is easy to write and `PointerData` is raw without logical pixel conversion, history dependent to decide type, etc. Also, for release mode binding, `PointerData`->`PointerEvent` conversion happens before anything goes into loops for hittest or widget reaction. 
> Is it true that we should only expect `PointerAddedEvent ` and `PointerDownEvent` here?   For the test runs I did, yes. But I can't say for sure. According to the documents I think `PointerEnterEvent` and `PointerScrollEvent` may also go here. This depends on runtime history of the input events and is hard to track the source.   But since it's test, I would say I''ll still add assert and if people find something in the future they can add more.
This comment doesn't look clear to me... What does "The class" mean here? Is it the `Map`, or `_LiveTestPointerRecord`, or something else?
Is this the `PointerEvent` version of the `PointerDataPacket` in the sense that each `PointerData` in the `PointerDataPacket` is converted to a `PointerEvent`, and put into this packet?  If so, maybe `PointerEventPacket` is a better name to signal the relationship between this and `PointerDataPacket`.
I think this is the time stamp when the engine gives the whole packet to the framework? The time stamp of when the event happens should be `events[i].timeStamp`?
Sounds good.
This seems to suggest that `pack.timeStamp` is relative to the start of `handlePointerEventPack`. It might be helpful to clearly document it in `PointerEventPack.timeStamp`.
We might want to record the actual `timeDiff = pack.timeStamp - binding.clock.now().difference(startTime);` here to see how close it's to 0, and see how well we simulate the timing of those packets. Maybe put this logic and the for loop into a helper function so line 480-482 can use it too.
I mean `_LiveTestRenderView` but I can delete it. It's just when I read it it took me some time to find out what this `_pointers` is used for. 
What I mean here is, this member variable is only used to draw a cross sign at the location of the input event.
If if helps you, it probably would help other too. `// _LiveTestPointerRecord records these pointers to draw touch positions.` might be clearer?
I'm thinking collect `timeDiff` in a list and return it.   And I realize one more thing. The current code kind of promises the first event (which I offset it to default `Duration.zero`) is almost certainly goes to the `timeDiff.isNegative` branch and becomes a negative timeDiff, which is not a good behavior: it should be rounded to zero. 
`handlePointerEventPack` to `handlePointerEventPackets` for the recent renaming, and make it plural to signal that there's a list of packets. `records` may be better names as packets too.
pack -> packet
similar rename update.
Add a warning here and remove "// maybe trigger a warning". No one is probably going to add warnings or paying attention to this if this is just a comment.
@liyuqian @dnfield This one is one of the places I have to modify framework. And I actually am considering it a bug: if there is a customized Widget that's specifically reacting to `PointerAddedEvent` in some way, because of this, such behavior won't be able to be tested using `flutter_test`. 
As a work around in my specific project, I can skip all recorded `PointerAddedEvent`. I'll write a failed test case tomorrow but it will look weird.
I believe it's no longer needed since the timediff is returned. 
Cool - it's fine if it looks weird, as long as it's valid :)
how does this differ from Timer?
This isn't so much "Execute a callback in a later time for the binding" so much as "advance the clock and execute the callback". Why not just have people use `pump`, which also advances the clock?
please see style guide regarding line wrapping (if there's a newline after `(` there should be one before `)`)
serials -> series
flutter -> Flutter
for -> as the
I'm not sure what this paragraph means. Shouldn't this always be zero in a unit test, since the clock is artificial?
why not implement it?
`PointerEvent` -> `[PointerEvent]`
please start documentation sentences with a capital letter (see style guide)
`PointerEvent` -> `[PointerEvent]`
this is insufficient documentation
see style guide for writing prompts
wrapping
missing space after `for` (no space implies it's a method call)
`} else {`
wrapping
wrapping  fwiw, if you're using dartfmt for formatting, you'll get the right formatting here if you either set a wider line width or if you put a trailing comma on the last argument
The idea here is that the same thing, we do it differently for different bindings: for Live binding we wait for a real period of time, but for the binding with a fake clock, we add time and then perform the callback. The `addTime` method only add to timeout but don't add the fake clock time, which influence for example animation. The pump schedule a frame which is not preferred here. 
For unit test yes. But the whole idea for this is to make the same code and API used for unit test as well as integration test on a device.  flutter/plugins/E2E for example is using WidgetTester for running tests on device. 
I would like an auto formatting tool but we have a lot of things in our style guid that's different from dartfmt, and dartfmt will change the whole thousand-line file :(
I now don't feel very comfortable with this renaming. `PointerDataPacket` is just a list of `PointerData` without timestamp https://api.flutter.dev/flutter/dart-ui/PointerDataPacket/PointerDataPacket.html but this class has a time stamp. I'm thinking if `PointerEventRecord` is a better name, and so is `PointerDataRecord` if we are going to change the API from accepting `PointerEvent` to `PointerData`. 
please file a bug and link it here
nit: is there a clearer name we could use for this? Maybe just `delay`? 
nit: here and below, space after `for`.
nit: consider rewriting this loop as:  ```suggestion expect(logs.first, 'down $b'); for (int i = 1; i < logs.length - 1; i++) {   expect(logs[i], 'move $b'); } expect(logs.last, 'up $b'); ```
The reason I'm calling it a timeStamp is the data comes from timeline timestamp in my recording package. But since there's no recording context here maybe I need another name. I don't like `delay` because it's too similar to `delayed` that's used `Future` everywhere. Maybe `timeDelay`. 
So happy with this review! My personal preference is your version but I'm seeing that if-in-for style everywhere in `controller_test` (e.g. https://github.com/flutter/flutter/blob/afd745e8933fe35659d347bb0740e56c263da3ec/packages/flutter_test/test/controller_test.dart#L288-L295 ) and I was thinking if I was wrong about this preference. 
timeDelay SGTM
I'm thinking implementing it should be mostly the same as the implementation in `WidgetTester`, but when I had a look at how we are using this `LiveWidgetController` in the repo I found very limited to a few test cases in `dev/`, where 1. `dev/benchmarks/complex_layout/test_memory/scroll_perf.dart` is using `fling` which already is pumping regardless.  2. `dev/integration_tests/flutter_gallery/test/live_smoketest.dart` and `dev/integration_tests/flutter_gallery/test_memory/image_cache_memory.dart` don't pump at all 3. `packages/flutter_driver/lib/src/extension/extension.dart` is used in `flutter_driver` and don't have pump.   From these use cases I believe 1 is just not taking much consideration about pumping while 2 and 3 already suggest not to pump. 
And `LiveWidgetController` is not unit tested. 
Already had a no-op forwarder for desktop
I guess this was this unused?
completely!
This test has the same name as above, guessing one is incorrect?
Good catch, should say disabled here
`[new Foo]` is the DartDoc syntax for referring to the Foo constructor
transparent => translucent
It's probably pedantic to say so (so don't change this line), but this color overrides the default row color. That said, we should document what the default color is, before explaining how to override it.
Since we're renaming the parameter, it seems like calling it activeColor, would be a tiny bit more straightforward.
This is just the joy of factoring. Maybe: ```dart final Color rowColor = index > 0 ? rows[index - 1].color?.resolve(states) : null; ... color: rowColor ?? defaultRowColor.resolve(states), ```
math to a => match a
TIL, reverting that line change.
Done.
Would `{TestBindingEventSource source,}` instead of `{TestBindingEventSource source = TestBindingEventSource.device,}` have the same effect here and reduce the confusion?
I think so. @Hixie 
I'm guessing for an `enum`, leaving it `null` is not preferred. 
Is there something missing here?
```suggestion     return _colorIsUniform && _widthIsUniform && _styleIsUniform; ```
here and below: The previous formatting was better as it made clear where the condition ends and where the body of the if starts.
Can this (and the other two above and below) be written in a single return statement:  ```suggestion     return right.width == topWidth && bottom.width == topWidth && left.width == topWidth; ```  (Please double check that I transformed the logic correctly...
This error will be grammatically incorrect (is vs. are) if more than one property is not uniform (assuming that can happen).
same here.
Can you also add this information to the doc of Overflow.visible?
should be -> must be
Yeah, it is possible for more than one to be listed. I wasn't sure if it was worth handling the is/are. I've tried a tweak, let me know what you think. :)
See comment above.
I guess we can just `Canvas(recorder);` to avoid the unused variable warning?
given the .none constructor, should we assert it's non-null here?
additional white space after this line
same here
```suggestion /// The optional `routeSettings` parameter sets the [RouteSettings] of the modal bottom sheet ```
```suggestion   testWidgets('Verify that route settings can be set in the showModalBottomSheet', ```
since you already defined the routeSettings, can you directly check for identity? `expect(retreivedRouteSettings, routeSettings)`
Yes, that's doable
This seems not addressed yet?
Missed that. Just resolved it.
interesting, this uses posix paths on windows too?
nit: maybe put this in a constant, with some docs on where exactly it comes from, like "we only support this particular sdk, see doctor blah blah".
Is this covered by our existing doctor checks?
Yes, CMake always uses posix-style paths. That's what the use of `TO_CMAKE_PATH` in the other generated file is for, but here it was easier to just convert it before writing it.  (The reason for all the escaped Windows paths in the other file is that those aren't used by CMake, but passed through back to the tool script, so I want them to stay untouched.)
The change below (line 220) makes it part of the `doctor` flow.
Done.  It hadn't occurred to me that this may mean that the next major version of VS won't actually work since the generator is hard-coded; I don't know if these values are forward-compatible. But since this is in the tool, not the ecosystem of plugins and projects, we can easily add switching logic here later if that turns out to be the case. (Unlike the requirement in the old method of having a hard-coded toolchain version in the project file, which was one of the things that really worried me about the ecosystem longer term.) I added a comment to that effect on the constant.
Can you document the problems that this can cause if this is turned on for nested navigators (or whenever you have more than one navigator doing this)?
Still need to regenerate the localized sources.
These strings do not have localized sources. They were set to 'TBD' because that was the standard before when we added new strings that needed to be localized. Now, we just use the English source as a placeholder until the localized source is present (for Pashto, it will not be anytime soon since Google does not support it at the moment).
But I think he is saying that the `material_ps.arb` has been updated, so don't we need to run `gen_localizations` update the generated localization info with this changes to Pashto? Just like we would need to do if these updates came from the translation team.
Right, that's what I was getting at.
Oops, thanks for the clarification! Done
Since these values are never set, it would be preferable to mark them `final`
formatting: put the start of the map on the same line as `_severityMap `
formatting: if you use `{ }` for a method body, its preferable to start the actual implementation on the next line. Only use `=>` for methods on the same line. 
```dart if (...) {   return ... } else {   return ...; } ``` can be written simply as   ```dart if (...) {   return ...; } return ...; ```
Please don't ignore the analysis errors.
indent seems to be off
Thanks for the review. I addressed the indent and other minor styling issues (like adding trailing `,`) and pushed. 
```suggestion   /// The summary dill with null safety enabled for the dartdevc target. ```
can we make this its own artifact?
Yeah, that is a good idea
same here
Thanks, it'll help me with my refactor, though I still might get trapped in merge conflict hell...
Flutter repo requires all types to be explicitly written even though they can be inferred. In this case, specifying `Queue<ui.PointerData>` should be better than the inferred `List<ui.PointerData>` to have a faster O(1) `_queueData.removeFirst()` than O(length) `_queueData.removeAt(0)`.
This function seems to assume that `_queueData` is sorted in `timeStamp`. Its current implementation seems to make a lot of unnecessary assignments of `_last, _next` in the beginning, and then continue to iterate through `_queueData` to its end unnecessarily. Would the following code be better and ready for a bisect optimization if we find the queue to be long in the future? ``` if (_queueData.isEmpty) {   return; } _last = _next = _queueData[0];  // So _last and _next won't be null in any case. int index = 0;  // The index of the first data whose timeStamp >= sampleTime for (; index < _queueData.length && _queueData[index ].timeStamp < sampleTime; index += 1); if (index - 1 < _queueData.length) {   _last = _next = _queueData[index - 1]; } if (index <_queueData.length) {   _next = _queueData[index]; } ```  (BTW, Flutter prefers `i += 1` instead of `i++`.)  With either implementation, the edge cases seem to be non-trivial. It might be nice to add unit test cases where `_queueData` is empty or `_queueData.length == 1`.
Ditto. Flutter repo requires explicit types.
Ditto
Nit: `bool get hasPendingData=> _queuedData.isNotEmpty;`
Flutter repo requires explicit types and `final` (instead of `var`) if possible.
For multi-touch, I think we'll need to construct one resampler per touch pointer, right? Maybe it's nice to clarify that in the class doc. In general, this class could have more documentation on how it should be used, or how it should not be used :)
The plural `positions` make me think that this could return multiple `PointerData` perhaps for multi-touch. But it actually can return at most one `PointerData`. Maybe add comments to reduce confusions, or maybe return `ui.PointerData` instead of `List<ui.PointerData>`?  Also, `_sampleMoveOrHoverPosition` seems to better describe this than `_samplePointerPositions`.
Flutter repo requires explicit types and `final` (instead of `var`) if possible.
Flutter repo requires explicit types.
The resampler here doesn't seem to support multi-touch in one resampler. Shall we assert that `_pointerIdentifier` is always the same unless it's cleared by `ui.PointerChange.up` or `ui.PointerChange.remove`?
`if (data.timeStamp != _next.timeStamp)` seems to be equivalent to `if (sampleTime == _next.timeStamp)` in this context. The later condition seems to be more intuitive to not process early as we're so lucky that the sampleTime is exactly the next event's timestamp, so we should process the later `data` in the future.
Nit: `Stop if change is not up or remove. Otherwise, continue to allow early processing of up and remove events as ...` seems to be clearer than `Stop if change is not up or remove, which are allowed to be processed early as ...` to me.
Done
We need to keep something like the previous code now that we're using a queue. I made it more efficient by stopping when the first data with time stamp greater than sample time is found. The amount of data processed here should always be low. The only time we might set last/next multiple times is when input frequency is higher than refresh rate and it would need to be extremely high for this processing to become a problem.
Done
Done
Done
Done
Done
Good idea. Done.  Also explained in the class description that multiple instances are needed for multi-touch.
These expressions are not the same. This expression prevents us from processing data past the _next data. We allow _next data to be processed early for up/remove changes but we need to stop processing if we've gone past _next. Let me know if there's a comment I can add here to make this more clear.
Done
+1 From the doc it is not clear to me why I would want to use this.
I made that clear right below here. Let me know if something else is needed. Maybe explain why someone would want tot resample events? You can also find two examples of how this code is used in the fuchsia codebase:  1. https://fuchsia.googlesource.com/experiences/+/refs/heads/master/benchmarks/bin/scroll_flutter/lib/main.dart 2. https://fuchsia.googlesource.com/experiences/+/refs/heads/master/settings/lib/widgets/lib/src/utils/pointer_events_listener.dart  These examples use a map of resamplers for all touch input. data.device is the key that determines what resampler to use.
Ah yes, I forgot those events past `_next`. I was only thinking the first data with `data.timeStamp > sampleTime`. I think it's probably clearer to write `if (data.timeStamp > _next.timeStamp)` as `_next` is the `data` with the smallest `timeStamp > sampleTime` so we're not expecting any `data` with `sampleTime < data.timeStamp < _next.timeStamp`. This time I tried it with unit tests below to make sure that it's not trivially false like the `if (sampleTime == _next.timeStamp)` condition...  Overall, I wrote the following to dump all my thoughts. From the comments below, it seems that the fling smoothing ("up"/"remove" early processing) would only be guaranteed when the input frequency is no greater than the display frequency? ```         // When this line is reached, the following two invariants hold:         // (1) data.timeStamp > sampleTime         // (2) _next has the smallest timeStamp that's no less than sampleTime         //         // Therefore, data must satisfy data.timeStamp >= _next.timeStamp.         //         // Those data with the minimum data.timeStamp == _next.timeStamp         // time stamp are processed early for smoother fling. For data with         // data.timeStamp > _next.timeStamp, the following lines break the while         // loop to stop the early processing.         //         // Specifically, when sampleTime < _next.timeStamp, there must be at         // least one data with _next.timeStamp == data.timeStamp > sampleTime         // and that data is _next itself, and it will be processed early.         //         // When sampleTime == _next.timeStamp, all data with data.timeStamp >         // sampleTime must also have data.timeStamp > _next.timeStamp so no data         // will be processed early.         //         // When the input frequency is no greater than the display         // frequency, this early processing should guarantee that "up" and         // "remove" events are always re-sampled (by linear interpolation).         assert(data.timeStamp >= _next.timeStamp);         if (data.timeStamp > _next.timeStamp) {           break;         } ```
All the above unit tests add all events at once, and then sample gradually later. In practice, I'd expect most cases to add a few events, sample some, and then adding a few more, and then sample again. Shall we also unit test such cases?
Sounds good. Then maybe it suffices to add a comment like "Find _next to be the data with the smallest timeStamp that's no less than sampleTime, and the _last to be the previous event before _next." for easier understanding.
Thanks for taking a detailed look at this. I changed to `if (data.timeStamp > _next.timeStamp)` and included your comment (with some minor adjustments) in the code.  Yes, this early processing only works when input frequency is lower than the sampling frequency, which is when this has been determined to be critical. Good call to explain that in a comment.  We could allow the "next" sample time to be passed to the resampler and process up/remove until that time to enable the same for high frequency input events. Some experiments on devices with high frequency input events would be useful to determine the value of this. I can imagine it being useful when input frequency is 2x the refresh rate. 
Done. Latest code as a new "stream" test that behaves more like what we see on real devices.
Yeah, a quick explanation as to why somebody would want to resample events would probably go a long way here.
Is this `_isDown` a duplicate of `event.down`?
Nit: `///` => `//`.
I see in the unit test this can return a list because there may be multiple events at the same time. Does it also makes sense to comment it here in the doc comment? 
Nit: maybe it's a little clearer to name this as `_dequeueAndSampleNonHoverOrMovePointerEventsUntil`, or maybe keep the current name and add the following lines to the end of it ```     // Add resampled pointer location event if tracked.     if (_isTracked) {       events.addAll(_samplePointerPositions(sampleTime));     } ``` 
Yes, I cleaned up this code in latest version. Thanks for the hint.
Done.
Done.
Done.
Nit: I think `scheduler ??= SchedulerBinding.instance;` can be simplified a little to `scheduler ?? SchedulerBinding.instance;`
It would be nice to add cases like `or when the high input frequency is not a multiple of the display frequency (e.g., 120Hz input and 90Hz display)`.
Ditto: it would be nice to add cases like `or when the high input frequency is not a multiple of the display frequency (e.g., 120Hz input and 90Hz display)`.
Should we try to remove the resampler when an up/remove event happens? I'm not sure if some OS would generate a very large number of different `event.device` that would eventually make this look like a memory leak.
It's helpful to comment that `samplingOffset` is usually negative.
Is this only used for tests? If possible, it seems to be safer to override `SchedulerBinding.instance` in the test instead of providing one more changeable field for `GestureBinding`.  As a binding (singleton), it seems to be sufficient to just instantiate a subclass binding. For example, see https://github.com/flutter/flutter/blob/88118bcbd1e20de25875e43da62ceea7357feb4e/packages/flutter_test/lib/src/_binding_io.dart#L24-L28 and _https://github.com/flutter/flutter/blob/88118bcbd1e20de25875e43da62ceea7357feb4e/packages/flutter/test/services/binding_test.dart#L59_
Is  ``` final SchedulerBinding? instance = scheduler ??= SchedulerBinding.instance; assert(instance != null); ``` equivalent as  ``` final SchedulerBinding instance = scheduler ?? SchedulerBinding.instance ``` ? since the second is null-safe protected already.
`Duration.zero` is probably easier to read than `const Duration();`. So is many following. 
Nit: an extra line break between this and previous, as a style guide to have a single sentence to start the doc string. 
Can we be a little more specific for the comment or maybe remove it if not necessary? `Process events for sampleTime.` sounds already implied by the name of the method. 
Correct me if there's other reason, but can we move this part to `_flushPointerEventQueue`, so  1. `_pendingPointerEvents` will mean the same thing with or without the resampler;  2. relevant codes will be at the same place so it's easier to understand and maintain. 
Nit: position and delta? 
If I understand the code correctly, only `PointerUpEvent` and `PointerRemovedEvent` is skipped, `PointerAddedEvent`, `PointerCancelEvent`, `PointerDownEvent`, `PointerEnterEvent`, etc, are all resampled with almost the same algorithm with `PointerMoveEvent` and `PointerHoverEvent` as in `_samplePointerPositions`. I wonder why should we, and if we can have some part explain the resample algorithm in the doc of the class. 
ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto
Ditto
And generally speaking, should we skip all events that we don't recognize/designed and only limit resampling to what we know?
And is there anything else that may require resampling? One thing I can think of (but not sure) is `scrollDelta` for `PointerScrollEvent`, which looks like need a quite different logic than what's here. It might worth filing an issue to record that. 
Remove from latest change that is using SchedulerBinding.instance for testing.
Done
Done
Yes, I'm removing resamplers that are inactive in latest change.
Done
Done.
Done
Removed it.
Good idea. I've done this in latest change. I've also changed to resampler code to take a callback as that integrates better gesture bindings and avoids unnecessary use of a temporary list. 
All events except `PointerAddedEvent` will be resampled given that we have future events queued that allow us calculate a resampled position. I've found that it's important to resample all events to ensure that the beginning and end of touch based animations are smooth. E.g. if we're not resampling `up` then it will appear as a sudden change in velocity when this event arrives unless the code is careful to take time stamps into account when determining velocity.  I explained that all events except 'added' are resampled in the doc of this class.
Done
Done
So should this number depend on the frame refresh rate? e.g. on 90Hz device like Pixel 4, should this be smaller? 
If this offset can be device refresh rate dependent, should we also calculate this number instead of set a fixed one? I was told we can get the refresh rate from a service protocol extension `_flutter.getDisplayRefreshRate`, if that information is somewhat helpful. 
The ideal value typically depend on:  1. Sensor frequency. 2. Platform processing overhead. E.g. how long does it take for the event to arrive here. 3. The amount of input latency that an app is willing to add for smooth event processing.  Best way to find a good default values here are through experimentation. The value used by default for now has been proven to work well on Fuchsia systems where the sensor is ~60hz. Shorter duration will result in poor resampling results as it becomes more likely that we don't have events queued that can be used for resampling.
Refresh rate is not meaningful for this offset. input sensor frequency is but that's not something that platforms typically expose.  I think we should create a follow up task to determine good default values for different devices. The best way to do that is likely through some automatic test that can also be used to detect regressions. Automatic test is how the current default value was established on Fuchsia.
So as a particular case, Pixel4 has input frequency about 120Hz, and refresh rate 90Hz, and one use case we are planning for the resampler is to help resample this 120Hz input to 90Hz, for better scrolling smoothness. Does this sounds like need a smaller `samplingOffset`?
We could reduce this to -21.333 and add refresh rate interval on top of it. Not sure that's much better though as the 21.333 value is still what needs to be determined through testing. We currently add 16.667 to this value here assuming that we start producing a frame for the currentSystemFrameTimeStamp at that offset. That's not the best assumption but making it "1000 / refreshRate" is also not good as that gives the appearance that we're always using the interval as frame scheduling offset.
According to https://api.flutter.dev/flutter/scheduler/SchedulerBinding/currentSystemFrameTimeStamp.html, `currentSystemFrameTimeStamp`:  > On most platforms, this is a more or less arbitrary value, and should generally be ignored. On Fuchsia, this corresponds to the system-provided presentation time, and can be used to ensure that animations running in different processes are synchronized.  which sounds like we should use `currentFrameTimeStamp` instead. 
samplingOffset being too large will not hurt smoothness but it will hurt input latency so it's in our interest to keep it as low as possible while still making sure resampling works well.  If input frequency is 120Hz then we need 8.333 ms to ensure that we have 2 input events that can be used for resampling. We need some margin for events to be delivered from the input driver to flutter. Let's use 4.667 ms to account for the situation when device is under heavy load. 90Hz doesn't really affect anything but I'd guess that the app [VSYNC — App reads input and generates next frame](https://source.android.com/devices/graphics/implement-vsync) (when flutter produces a frame) is relatively low on a device with that refresh rate. Let's guess 9 ms.  Given above, I'd try using samplingOffset=Duration(milliseconds: -22);  // 8.333 + 4.667 + 9
It's critical that this time stamp is in the same clock as the time stamps from input events. And it's also critical that this is never adjusted or scaled like currentFrameTimeStamp. This is something I [brought up](https://github.com/flutter/engine/pull/15936#issuecomment-579026468) when we were discussing if this code should live in the framework or in the engine. I was told that we can rely on currentSystemFrameTimeStamp working like Fuchsia on other platforms. Maybe this documentation needs to be updated.
Could a `PointerScrollEvent` reach here and trigger the assert?
Good point. I've updated the documentation to make it clear what event types are supported and gesture binding is not limited to touch events.
formatting nit:  ```suggestion           event.device, () => PointerEventResampler(),         ); ```
nit: can we just use a regular for loop over the values since key is unused anyways?
Why do we need to store the current sampling time in an instance variable? Can this not be calculated when needed by doing `scheduler.currentSystemFrameTimeStamp + samplingOffset`?
nit: leave this in one line
true shouldn't be in `
```suggestion   /// resampling. The [samplingOffset] is expected to be negative. ```
Are positive values ever ok? Is zero ok? If not, we should add an assert that warns if you add something that is not acceptable.
Add to the docs: When would I typically set this to true if I want resampling? e.g. before runApp?
... can be used _to_ get ...
...of _adding_ some _added_ latency...  Can the second added be removed?
addd -> added ?
All these should be enclosed in `[]` instead of ` so they are linked in the docs.
same here.
when _the_ position?
formatting nit: add a trailing comma and put each argument a its own line.
should we add a `copyWith` to the events instead of doing these "is" checks?
formatting: trailing comma and one argument per line (here and elsewhere)
Can you add that information as a comment here?
Isn't it possible that _sampleTime is outdated when this code runs? For example, after some frames have been rendered, the first input event is received. At that point, this code runs, but _sampleTime is still zero, no?
Done
Done
Yes, this was a leftover from then the scheduler could change for testing. Removed _sampleTime from latest change.
leave what in one line? "... _resamplers = <int, PointerEventResampler>{};" is broken into multiple lines by "flutter format" and I prefer to follow its recommendation. let me know if you meant something else.
Done
Done
Yes, I was hesitant to doing that before I had general buy-in for these changes. Added a copyWith function to PointerEvent class in latest change.
Done
Yes, but that just results in us dispatching the first event directly, which is fine in practice as that's typically a PointerAddedEvent. However, this has improved in latest change as we're now using the current scheduler frame time and the offset directly.
Done. Typically during initialization but can also be changed dynamically if desired. Also made some minor updates to the code to handle dynamic changes better.
Added a comment. Non-negative values are allowed and will just result in no resampling. Just like setting the value to an absolute value that is not enough for the device does.
Done
Done
Removed
Done
Done
Done
Done
the flutter repository doesn't use flutter format, see also: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#formatting  From that section:  > Prefer avoiding line breaks after assignment operators.
`=>` should only be used if everything fits in one line, see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#consider-using--for-short-functions-and-methods
nit: this line break is akward
Can `hasPendingEvents` and `isTracked` ever be anything but true/false? If not, you can omit the `== false`?
See style guide about not breaking at assignment opperator.
Also true elsewhere in the PR.
Shouldn't the return type be the more specific PointerAddedEvent?
format nit: here and everywhere below add a trailing comma and put ) on its own line with indentation same as the line with opening (
Done
I am wondering whether we can separate the resampling and the gesture binding a little more, e.g. you only set a PointerResampler on the gesture binding that you want to use and it encapsulates all the logic that's currently in the binding here.  /cc @liyuqian 
Done
Done
Done
Done
Fixed
Done
I added a _Resampler helper class to the latest version of this change. It encapsulates the logic to manage multiple PointerEventResamplers and the details of how the scheduler is used to determine sampling time.
Can everything below also get encapsulated inside `_Resampler`?  For example, instead of calling `_resampler.addEvent(event)`, we can send in a list of events `_resampler.addEvents(_pendingPointerEvents)`. The `_resampler` can also save the callback `_handlePointerEvent` as its field so it can schedule a sample callback by its own?
We would fail to detect when resampling is disabled in that case but we could introduce some callback cancel logic to handle that. We would also need some wrapper to ensure that we're not violating the "if (!locked)" condition. The overall complexity might increase but if encapsulation is highest priority then it might still make sense. Wdyt?
If it's locked, could we miss some events? If so, maybe we shall reschedule a callback if `locked`.
This looks like better in the setter of `resamplingEnabled`.
I think this is put here for the `assert(!locked)` condition as `stop` will fire the remaining events.
we need this here to be sure that assert(!locked)
Should be fine as _flushPointerEventQueue() is called from unlocked sometime after this
I did this additional encapsulation in latest version of this CL
It's immediately initialized. It seems that `late` is not necessary?
I needed this to be able to pass "_handlePointerEvent, _handleSampleTimeChanged" to this ctor. Let me know if there's a better way to solve that.
Sorry I misunderstood the keyword. 
Is it true that when this constructor is called (i.e., `event.device` key is absent in `_resamplers`), `event` can only be `PointerAddedEvent` or `PointerDownEvent`?
No, that would only be true if resampling was enabled before the first pointer event. If you enable resampling after first receiving a down event then we'll need to create the resampler here when processing a move event.
Does this mean that, when the pending event queue in the resampler is not empty, but there are no more future inputs, these pending events will stay in the queue and will not be processed, since _flushPointerEventQueue is not called? I realize this when I'm trying to move resampler to handlePointerEvent. cc @liyuqian
No, the `_Resampler` will schedule `_handleSampleTimeChanged` after frame callback which will call `_flushPointerEventQueue`. See: https://github.com/flutter/flutter/pull/60558/files/b7802f69f91e1b5466d6b5b58e98193160964ca5#diff-6305361e0c7677f0eebfb05dfcbe0336
This recorder does not look empty. It looks like `WidgetRecorder` without the `drawFrameDuration` timeline. If that's all the difference, why not use `WidgetRecorder` and simply ignore the `drawFrameDuration` numbers?  If this class is really necessary, let's discuss how it fits with the other recorder classes. Perhaps it should be a super-class of `WidgetRecorder`? We should also add substantially more documentation for this class. In particular we should document when it should be used.
nit: rename to `_didStopCallbacks`.  For consistency, `WidgetRecorder` should also support multiple callbacks, but perhaps making this class a super-class of `WidgetRecorder` is a good way to gain both consistency and code reuse.
This is not used afaict.
Changed the name. I don't understand "WidgetRecorder should also support multiple callbacks" (since it does support) and I'll assume it's no longer valid after removing `EmptyRecorder`.
Should this still be skipped for the PaddleValueIndicator? I think that shape might paint the stroke around the thumb portion of it
No, the value indicator is on the overlay so it float above the thumb widget and doesn't create any problem. I just checked and can confirm this.
What happens if overlappingShapeStrokeColor is null?  The SliderThemeData constructor's doc says: ```dart   /// Create a [SliderThemeData] given a set of exact values. All the values   /// must be specified. ```  None of the parameters are `@required` and all default to null (per our conventions for themes).
It still passes because we expect to find a circle of theme.sliderTheme.overlappingShapeStrokeColor.  None of the parameters need to be specified. If it is not specified in the SliderTheme then the Slider has default parameters that are based of the ColorScheme 
Is the early return above not sufficient here?
It is sufficient for this crash, but `_xcdevice.observedDeviceEvents()` is nullable, callers shouldn't need to understand why it can return null (that it can only return null if Xcode isn't installed).
@HansMuller the only difference from the previous pr is that the Material.transparency will no longer absorb hittest.
swallow => obscuring
the ink splash effect => ink splashes produced by flexibleSpace children.
nit: at this point the caching does seem to be worth doing anymore? You need to find the child's render box in order to verify the cache is still valid. It's only avoiding redoing the `inflateRect` calculation which seems cheap. 
Good call.  I removed the caching.  I'm assuming `findRenderObject` shouldn't be too much of a performance hit, but I'll watch out for slowdown.
Since this will be the first place a user is exposed to the term "velocity tracker", describe what it is or reference another doc
Maybe briefly describe what's special about iOS scroll velocity to help bootstrap the next maintainer
Why this name? Either somehow describe the "free scroll start" nature of the velocity tracking in the class doc or just call this ios velocity tracker.
Not sure I understood this comment
sounds stronger than what the code seems to be doing. You're just weighing the initial velocity more rather than matching the initial velocity no?
also seems like you're always using exactly 3 samples no?
"initial free scrolling speed" is a bit vague
Please add to the velocity_tracker_bench microbenchmark too
I thought we wanted to avoid having iOS in the name? Would be nice to know that I was mistaken.
"4 `_PointAtTime` samples" is what I meant
`Horizontal/VerticalDragGestureRecognizer.isFlingGesture` has a threshold for `VelocityEstimate.offset` for it to be a fling: https://api.flutter.dev/flutter/gestures/VerticalDragGestureRecognizer/isFlingGesture.html  Initially I used 4 samples and that broke some tests so I had to record more points. Will point to `VerticalDragGestureRecognizer.isFlingGesture` in the comments.
I was trying to say this is the velocity of the scroll view not that of the gesture. Reworded.
It's still not too clear what the difference is and why this needs to be a separate class rather than changing VelocityTracker. 
You mean the difference in terms of the strategies used? Does > /// A [VelocityTracker] subclass that employs a weighted average strategy to /// estimate the velocity of the associated pointer, to match iOS scroll view's /// fling velocity calculation.  sound better?
As opposed to what though. I was looking for a text that saves the next maintainer from seeing thing as redundant, try to merge the 2 classes into one, spend 2 hours and then realized that the approach for the 2 are conceptually different (which the maintainer could have discovered in 10s by reading this text)
Added a simple comparison of the 2 velocity tracker classes.
<optional at this point, up to your judgement> can this just be done by composition? i.e. most platforms use a VelocityTracker with a VelocitySampleScorer of [1, 1, 1, 1, ...] and iOS uses a VelocityTracker with a VelocitySampleScorere of [8, 5, 2, 1] or something? 
You mean the weighted average can be expressed in terms of a least-squares estimator? Not sure how I can achieve that, could you elaborate?
Remove this?
Looks like this PR also includes the changes from https://github.com/flutter/flutter/pull/60396. Is that intentional?
Yeah, I am still waiting for the tree to go green for #60396 to land. When it does, I will merge it into this PR, and it won't show up as a diff.
Good! 
delete?
Fixed!
I know this is copying existing functionality, but should we skip earlier if we're on windows?
doesn't have to be here, but from looking at this code it looks like we could replace this with a mock.
I think this is sort of - badly testing that chmod doesn't throw.
Oh, I missed that this was using the real file system. `chmod` is a no-op on Windows in any case...  `  void chmod(FileSystemEntity entity, String mode) {}`
makeExecutable too:  `  void makeExecutable(File file) {}`
nit: might be worth mentioning that this should be used if someone is using `package:stack_trace`, with a small example of how.
nit: Same doc nit, this might be a better place for an example than the typedef  nit: avoid abbreviations, `(StackTrace stackTrace) => stackTrace;`
We can be confident that `StackTrace.current` never needs demangling - this is a bit of a nitpick, but I think  ```dart if (stackTrace == null) {   stackTrace = StackTrace.current; else {   stackTrace = FlutterError.demangleStackTrace(stackTrace); } ```  Of course, if we're already in an error state, any time this might save is pretty inconsequential.
Maybe we could add an explanation here about how to use the new static global to fix this.
There should be a comma after this if you have parameters on a new line.
Why are we removing this test?  Can't this still happen?
Well this one is a bug I didn't notice. 
The typical way to handle animations is to use an animated builder in your widget tree:  https://api.flutter.dev/flutter/widgets/AnimatedBuilder-class.html
This change is already in the tree. If you remove these lines and rebase on the latest Top of Tree it should be there.
Other tests with animation in macrobenchmarks are doing similar thing with `addListener`. I added the modification but let me know if I should keep consistency with other test cases. 
The AnimatedBuilder is designed for animating widgets so this is the most Flutter-y way to express this benchmark.   There are some details that could be better, mostly about how much of the tree to wrap and potentially protecting the extent of rebuilds with RepaintBoundary widgets. But given that just about the entire tree changes on every frame (other than the Scaffold and the Table widget itself both of which are just wrappers) - wrapping it all is a reasonable strategy.
A nit: This line, and others that reference widget.row and widget.column did not make sense to me as the names "row" and "column" usually refer to a single row or a single column. But then I saw that these properties are the number of rows or the number of columns. Better names would be "rows, columns" or "rowCount, columnCount" to make it clear that it is a count rather than a reference to a specific element.
I see that, and I think I copied their design at some point when I was writing some benchmarks, but those particular pieces of code aren't the suggested approach for our developers to use when creating animations.  We could think about updating the other benchmarks at some point, but the benchmarks aren't meant to be code examples for developers and changing them now could potentially impact their performance and obsolete their long history of accumulated data.  Maybe a compromise would be to add a comment to them indicating that the animations should be managed with AnimatedBuilder widgets, but we are keeping the code as it is to preserve historical measurements.
@flar I added the comment here. Does this look fine? 
I don't think we need to call out app developers, the statement applies regardless of who is reading the code. There is also a typo there.  I'd go with:  ```     // Animations are typically implemented using the AnimatedBuilder widget.     // This code uses a manual listener for historical reasons and will remain in order to     // preserve compatibility with the history of measurements for this benchmark. ```  A similar use of `addListener` also appears in the cull_opacity benchmark.
Not sure what the "and truncates any..." part of the doc is referring to.
`linux-desktop`?
`macos-desktop`?
`windows-desktop`?
This will change everything, not just desktop; is that desired?
This change doesn't seem to have any associated test changes. If we want this behavior change, we should test it.
That was *my* intent, yes.  Whether it's desirable it up to review. ;)
nit: the line is getting a bit too long. Maybe convert this to use curly brackets?
Can this be typed as CustomPainter?
Unfortunately not, since I'm accessing properties from the private CustomPainter subclass, `_DialPainter`.
```suggestion /// decommissioned and replaced with the hierarchy deserialized from the newly ```
```suggestion /// listeners when they get decommissioned. In response to the notification, ```
```suggestion /// operating system may, however, terminate the app to free resources for other apps ```
```suggestion /// dispose of them and claim a new child as a replacement from a parent in the ```
Can you explain why they should be minimal?  Are there size restrictions on the platform(s) for serialized data, or is it a performance/memory consideration?
Why does this matter?  Is this just a race, and it doesn't matter which one wins?
nit: I'd either change the "rarely" above to "never", or the "must" with "typically".
```suggestion   /// still part of the bucket hierarchy or to [dispose] of them as well. ```
tiny nit: might want to reflow some of these paragraphs (this line looks longer than 80 chars).
```suggestion /// bucket for storing restoration data is made available. ```
Expanded the comment a little more. It is a race between the framework polling the engine for the data and the engine pushing the data into the framework. Who wins, doesn't matter. It's the same data.
I added a sentence that this is due to sizing restrictions on the platforms.
"minimal" means "of a minimum amount" already, so saying "as minimal as possible" is redundant. You could say "should be as small as possible while...", or just "should be minimal while..."
nit: document that the object has to be cast-able to a `Map<dynamic, dynamic>`, otherwise will throw?
Lowercase `a` after the colon
Instead of doing this, use [`checkMethodCallHandler`](https://master-api.flutter.dev/flutter/services/MethodChannel/checkMethodCallHandler.html), or make `_isListeningForEngineUpdates` just make that call.
If this is any kind of map this actually will not throw until you attempt to access something. The example below does not throw unless you uncomment the print.  ``` void main() {   var intMap = <int, int>{2: 3};   var stringMap = intMap.cast<String, String>();  // print(stringMap.keys.first); } ``` This also means the type checks and casts are incurred on every access, instead of once at the beginning. If you wanted something that threw eagerly, you could use Map.from instead  
I think this is save, but maybe have an assertion above this that the completer is either null or not completed, which I think will give this a better error callstack in the case where it's already compelted.
e.g. here it's not clear to me if a subclass could/would ever call this method after the completer has completed.
Ahhh. Should we really be exposing this method then? 
Link to an issue for this
Hashing the runtime type seems strange - why are we doing that? Can you document it here?
No `,`
The thought occurred to me when reading some other docs - is it worth specifying that the type of termination we're talking about is when the OS terminates us with a warning as opposed to a hard crash (e.g. a segfault) or power failure?
Done.
Removed that, I think this was left-over from copying this from elsewhere.
Looking at this again, I don't need this method at all. I am removing it.
Added the assert. This is save because this is the only place where the completer is completed and right after its field is nulled out. So there's no chance to ever complete it again. Nevertheless, the assert is a good idea.
I added the word "gracefully" here. I don't have a bullet-proved definition of when OSes do and don't do state serialization, so I'd prefer to be not too specific here.
This is fine to call after the completer has completed. It will just replace the current `rootBucket` with the new one. If there's no completer, it just means that currently nobody is waiting for the root bucket. 
Shouldn't this be in an assert in the ctor body?
why is this required?
nit: This would be more efficient as:  ```dart if (_parent != null) {   parent._dropChild(this);   parent_ = null; } ```  right?
nit: since get is a language keyword, it might be good to avoid having it as a member name.
This seems prone to issues for the caller - if the manager is null, this data might not actually get stored.  I think at the least we should document this, but it might be a nicer API if we asserted the manager isn't null here instead and required callers to make sure the manager is initialized.  Alternatively, we should make this return a bool as to whether it actually scheduled serialization or not, so that a caller can think to check that and initialize the manager if it's not already.
https://dart.dev/guides/language/effective-dart/design#avoid-starting-a-method-name-with-get
Similar comment for this one - if I've arrived in a state without a manager, this won't actually get removed right?
What if we made these more like streams with multiple subscribers? Would we still have this problem?  Alternatively, could we just have the framework "automatically" hand over ownership from A to B?
Does this mean has been claimed && is in _rawChildren?
So maybe a slightly different question than my one above in the explanation about finalizers - what if instead we just asserted that there was only one owner at the end of it all?
I thought we linted against this usage, saying to prefer for loops.
Elsewhere you're allowing manager to be null, but not here. Maybe add an assert that it's not, or use the `?` again.  Similar question to the public methods though - what happens if it is null here? Seems like bad news.
Ditto
nit: avoid using language keywords for variable names.
What happens if we claim the same name someone else already uses?  Can/should we assert that's not the case here?
Why have this method _and_ dispose?
(IOW why not just fold it into dispose)
Can we assert in any methods above that the object hasn't been disposed?  Should we just fold performDecommision into this?
nit: avoid parenthetical. Maybe `new scope, or namespace,`?
Or just drop it entirely.
From reading this and the previous doc, it's not clear to me why I'd ever not use this widget.  Alternatively, could we just simplify these into a single widget that takes a boolean about whether it should create a root bucket if needed or not?
not use this widget -> instead of the other RestorationScope widget.
What happens if this is inserted into the tree after frames have already started rendering?
Also: what happens if anything below this throws? Should we try to resume frames, or should we just have a hard crash? Right now it seems like an app could get into a state where it throws in here and just never renders frames again.
assert(!_disposed)
alternatively, remove the disposed property, which seems unused elsewhere.
Yes, changed.
I really want people to provide this, otherwise they will get bad error messages in case of duplicated IDs.
I changed it to read/write.
AFAIK, the lint only applies to things that implement Iterable. This is a map, which doesn't do that. Nevertheless, changed to a real for loop.
would implementing didUpdateWidget help for the finalizer stuff above?
Done.
The same things as with claiming a child that already exists: We let it slide for now and at the end of the frame check that the old owner has given up the child. I updated the documentation to say that.
Dropped. It's cleaner.
`_disposed` is used in RestorationMixin.dispose. This is to make the life of developers using the mixin a little easier. If we don't have this we'd have to enforce that properties are only disposed after calling super.dispose().  Will add the dispose check to this and the other methods next week (left a TODO to remind me).
We don't want to hand over ownership from A to B. B needs to have a fresh, new bucket. When A is disposed, its internal state is destroyed and needs to be removed from the restoration data as well. When then at the same time a new widget B is instantiated (which just happen to have the same ID) it should not have access to the restoration data of A.  So, multiple subscribers to the same bucket wouldn't really help. We want the data in those buckets to be separate. For a short period of time (while one bucket goes away and the other one is created) we just need to be able to tolerate that two buckets exist with the same id.
Yes.
That's exactly what we do in `_finalize` below. Unless I am misunderstanding?
Fixed.
Fixed to use ?
I don't see how that would help. What is your idea?  
From https://master-api.flutter.dev/flutter/rendering/RendererBinding/deferFirstFrame.html:  > Calling this has no effect after the first frame has been sent to the engine.  It's a pattern we use elsewhere in the framework [1]. If we crash, you'd be stuck at the splash screen. As a dev, you'd see the crash in the console. As an end-user being stuck there doesn't seem more or less useful then seeing our error widget...   [1] https://github.com/flutter/flutter/blob/9cbe1dccf3a0988343ba429417f0943f5519da69/packages/flutter/lib/src/widgets/localizations.dart#L529  
Dispose and decommission are different. Decommission is a notification that this entire bucket subtree is getting replaced with a new bucket hierarchy. All the children are informed about this so the owner of them can dispose them and claim a new bucket.  Dispose simply removes the information of this bucket from the hierarchy. The child bucket continue to have a live of their own and the owners of those child buckets may get them adopted by other parents.  Decommission = notification down the tree to stop using any bucket in this hierarchy. dispose = delete the data from this bucket, child buckets can continue to live if they want.
It will get removed from the local _rawData and hence is no longer in the bucket.  Since without a manager the _rawData wasn't persisted anywhere there's no other place to remove it from.
The assert is a great idea. I will do this next week (left a TODO for now, so I will not forget until next week).  > Should we just fold performDecommision into this?  See other answer why decommission is more then just a dispose.
My thinking is that those are two separate responsibilities: When I get handed a bucket, I can store all the data I want in it. It is, however, not my concern to decide how/where the data is persisted. That's the responsibility of whoever owns the bucket and provided it to me. They need to make sure that it is hooked up to a manager.  Not requiring a manager also has the advantage that we can unhook a subtree. For example, when a widget is in the way of transitioning out in an animation, we no longer need to persist its state (in the state we've already recorded that it is gone). We can then just unhook the bucket.
If you implement a stand-alone widget, you want to use a regular restoration scope to create namespaces for restoration ids. The widget can then be used in applications that want to do state restoration and those that don't. If the regular restoration scope doesn't find an ancestor scope, it will not cause any information to be contributed to the restoration data. In fact, the entire logic of retrieving the restoration data from the engine, parsing it, encoding the restoration data when it changes, sending it to the engine will not trigger.  If you'd use a RootRestorationScope, even in an application that doesn't want to do state restoration all that logic now triggers for the part of the app that's wrapped in this thing.  So that's the biggest difference: RootRestorationScope essentially forces you into doing state restoration. The regular scope doesn't have any opinion on whether you actually want to store restoration data or not.  The root restoration scope should only be used at the very top of the app (in fact, I am going to integrate it into WidgetApp).  Let me update the docs on this a little to make that clearer.  > Alternatively, could we just simplify these into a single widget that takes a boolean about whether it should create a root bucket if needed or not?  Yes, we could just have this implemented in one widget with a flag. The implementation of that widget would be pretty complex though. And I feel that the difference in functionality is more than just a config flag. It is a whole different widget.
```suggestion /// time, the data in the bucket should be kept to a minimum. For ```
nit: just a suggestion (reads better): ```suggestion /// provided to, for example, the [RestorationManager] to restore the application to a ```
Maybe an implementation comment about what these maps are used for?
Maybe describe when the `dispose` must/may happen, and whether it will be done automatically, or needs to be done by the implementer. (e.g. "in response to notification of the decommissioning").  Could `decommission` be described as a "notification to dispose"?
Is there a limit as to when? Does it need to happen before the next frame, or can I just store them all up in a cache and dispose them all at once when I exit the app/save a doc/trigger a timer?
nit: wrap comment
```suggestion   /// values. Whenever the information that the claimer needs to restore its ```
Shouldn't this be `if (_debugDisposed)`?  When would it be null?
I may be missing something, but wouldn't that let you resolve issues where a widget is moving from one part of the tree to another and transferring ownership of a bucket?
GitHub ate my last comment thread here.  Perhaps we could add a debug flag here that prints or warns somehow if serialization is being scheduled without a manager?  I don't want to eagerly add features, but this seems like something that could become confusing for users. Maybe it would help if I better understood how you could end up unhooked here. 
What I was looking for here is what happens when:  1. You persist some data 2. You get unhooked from the manager 3. You try to update the data  And then your application restarts and you have data you thought you removed.
From reading some more, I think it would not help. Disregard.
You're right, fixed it. (I think this was a c&p error) I also added tests for this.
For future archeologists, the comment thread started here: https://github.com/flutter/flutter/pull/60375#discussion_r453093743
After talking this over with Dan, I agree that we should assert here for now that the manager is not null. If in the future we support that unhooking mechanism I was talking about we can revisit that decision.
Since you're asserting it's not null, you can drop the `?` right?
Oh, it might be null if it's decommissioned. I see.
```suggestion /// guarantee that descendants have a bucket available for storing restoration ```
```suggestion /// which effectively turns off state restoration for this subtree. ```
Are there any platforms that this doesn't work on? Or do you just mean platforms that don't use splash screens (e.g. Windows, Linux)?
```suggestion /// Manages an object of type `T`, whose value is a [State] object that it wants to have ```
I was reading this paragraph, looking for the "other thing", thinking that the first thing was the "The mixin checks", but after reading it again, I think that the "one of two things" part should come after the "The mixin checks" sentence, so that the first thing is the case of finding data, and the second thing is not finding data.
In another PR, this seems like a great place to put a code sample.
```suggestion   /// null, which is effectively turning off state restoration for this subtree. ```
nitty suggestion: ```suggestion /// This widget is usually used near the root of the widget tree to enable ``` (just because "close" can mean "near to" or "to render no longer open", and I kept reading it incorrectly)
```suggestion /// Restoration data can be serialized out and, at a later point in time, be used ```
nit: ```suggestion /// serialized as part of the restoration state. It is up to the [State] to ``` Somehow "serialized out" feels redundant. I could go either way, though.
```suggestion /// instantiated to initialize member variables within [State.initState]. ``` Is the "or" not needed?  If you did mean to include the "or", then this sentence is a little awkward, and I'm not sure what you mean.
```suggestion /// described by the new restoration data. All initialization logic that depends ``` 
```suggestion   /// [State] objects that wish to directly interact with the bucket may ```
```suggestion   /// is restarted. ```
I removed this line since it is duplicated from the docs above and I made the docs above more precise.
Yeah, that's what I meant. Changed the comment to indicate that better.
The value is not a State object. The State object wants that value restored. 
I rephrased this.
Should this implement ValueNotifier<T>? As it fully matches the prototype
The semantics are slightly different, though. `ValueNotifier` notifies when `value` changes. This one notifies when `toPrimitives` or `enabled` changes. And you can construct cases where `value` changes, but `toPrimitives` or `enabled` doesn't.
Why not use a `String` directly?
Instead of:   ```dart   RestorableNum<int> _counter = RestorableNum<int>(0);   RestorableTextEditingController _textController =        RestorableTextEditingController();    @override   void restoreState() {     registerForRestoration(_counter, RestorationId('counter'));     registerForRestoration(_textController, RestorationId('name'));   } ```  Would it make sense to have:   ```dart   RestorableNum<int> _counter = RestorableNum<int>(0, id: 'counter');   RestorableTextEditingController _textController =        RestorableTextEditingController(id: 'name');    @override   void restoreState() {     registerForRestoration(_counter);     registerForRestoration(_textController);   } ```  
That's possible. But I figured that keeping the line with the instantiation free of the ID clutter makes the code a little easier to read. In your IDE when you click through to go to the definition of the `_counter ` variable you're most likely not interested in its restorationId. Furthermore, it keeps all IDs neatly in one place (the restoreState method) making it easier to see with one glance what IDs are in use. 
But the current syntax could complexify custom APIs built on the top of the native syntax.  Say we want to make a function that returns a `RestorableProperty`, then we would need a tuple to return both the property and its ID:  ```dart Tuple<RestorableProperty, RestorableId> example() {   return Tuple(MyProperty(), RestorableId('example')); } ```  vs  ```dart RestorableProperty example() {   return MyProperty(id: 'example'); } ``` 
```suggestion /// {@endtemplate} ```
Fixed. (here and in one other place) Thanks.
Why would you need to return the RestorationID? Either you return an un-registered property and whoever receives the property is in charge of registering it (under an ID of their choosing to ensure it doesn't clash with anything else in their namespace) or you return a registered property in which cause whoever receives the property doesn't need to care about its ID.
I had state-management libraries in mind – which will have to implement a way to interact with the restoration API outside of a `State`/the widget tree.  Provider will definitely want to expose a way for users to define restorable properties, where they would define both the ID and the property from outside a `State`.  It may not be too bad, as we can use `Map<Id, Property>` instead of a tuple. I need to play around it.
typo: `@template`
do we want to make this be created by a virtual method so that it can be easily overriden?
Fixed.
Good idea. Added `createRestorationManager` to parallel `createBinaryMessenger`.
docs should probably point to createRestorationManager
ID
IDs
maybe add a parenthetical giving an example of when this might happen
ID stands for identifier, so "Instead, a small identifier (e.g. an identifier or resource locator)" is weird. Maybe "e.g. a UUID" or "e.g. a database record number" or something?
as above, add a parenthetical talking about when this might happen
\`\`\`json?
or javascript maybe
docs should mention P
docs should mention P
mention P
especially for remove, it's important to specify if the given P has to be accurate (or could be dynamic)
we could wrap this body in an assert to prevent people from depending on it in release builds (just have it always return false or something)
double space
maybe give more color as to why we have this convention
is effectively turning off -> effectively turns off
maybe mention that restorationId can be null but this disables restoration.  or have a separate constructor for disabling restoration, and make this one require non-null.
can child be null?
say more about the arguments
...if [restorationId] is not null
this seems like the real value of this widget, may be worth mentioning this earlier. earlier comments make one wonder what the point of this widget is.
discuss arguments, what inherited widgets should be in scope, what is expected of the binding
SizedBox.shrink or SizedBox.expand might be trivially more efficient
might be clearer (if strictly less technically correct) just saying "Manages an object of type `T` that a [State] object wants to have restored during state restoration" or some such.
comma before "the mixin checks"
move this below the methods that are called before it is called
might be clearer to say something like "after this is called, initWithValue will be called with this method's return value" or "the value return by this method is then passed to initWithValue", and then separately say "see also fromPrimitives which is called when ... instead"
is it expected that `x.fromPrimitives(x.toPrimitives()) == x.fromPrimitives(x.toPrimitives())` ?
maybe also assert _id != null, _owner != null?
help of an
maybe make this a comment rather than part of the template (i.e. remove the `///` on that line)
extraneous blank line
interesting question... i'm guessing the idea is that the class makes the API more self-documenting?
using an
this would be a good place for sample code (showing the use of UnmanagedRestorationScope)
what will be the lifecycle state of oldBucket?
"when the [State] is in a certain state" sounds weird
presumably in that case it has to be called again if restoreState is called?
we should also mention how to unregister such a property
mention T
The code registering the property (i.e. the code with the bucket) must be the one to come up with the IDs, otherwise it can't properly avoid name clashes.
might be worth adding some prose here saying when to use RestorableNum over the other two.
do you intend the _RestorablePrimitiveValue subclasses to be for nullable types or non-nullable types?
shouldn't we also save the selection?
Fixed here and elsewhere in the file.
No, that's not allowed. Updated doc and added assert.
Moved to earlier
Yes.
Actually, T can be removed here. Done.
Saving the selection seems to only make sense if we restore focus, which we are currently not doing.
Turns out, the dartdoc parser doesn't like that.
After thinking about this, I've removed the RestorationId class and replaced it with a string. The class didn't add too much value...
About this, it sounds like this could be a common use-case for testing. Should it be built directly inside `tester`?  Like:  ```dart tester.restorationGraph = {   'root-child': {     'my_id': 'Hello world',     'sub-bucket': {       'my_id2': 'Hello world',     },   }, };  await tester.pumpWidget(   RootRestorationScope(     restorationId: 'root-child',     child: Column(       children: [          TextField(restorationId: 'my_id'),          RestorationScope(            restorationId: 'sub-bucket',            child: Whatever(),          ),       ],     ),   ), ); ``` 
I specifically want to avoid hand-crafted restoration data in widget tests. That data can easily change (e.g. because one of the widgets is updated with an extra RestorationScope) making these tests very brittle. Instead, you should get the widget tree into the state that you want to test and then use `tester.restartAndRestore()` (or a combination of `tester.getRestorationData()` / `tester.restoreFrom(data)`) to test that you can restore the tree from its current restoration data. That way, the test remains valid even if the restoration data format changes.  With semantics we initially made the mistake that the tests were too tightly coupled to the actual semantics tree, making them very brittle whenever we had to change the shape of the semantics tree for reasons unrelated to the actual test.
Made a note. I am going to add more samples in a follow-up since this PR is already gigantic. 
Do document out discussion over chat: I am intending them to be non-nullable since that's gonna be the new default for dart. I added some more asserts to express that intend. If we in the future need a nullable type, we can add one. Those could be named with a trailing N (for Nullable), e.g. RestorableIntN, RestorableStringN, etc. similar to how in lisp functions that return a bool end in p.
That's a fair argument.  My fear is, by breaking this in two steps, it may make the test brittle because of some state that is reused between before and after the restart. Because `restartAndRestore` doesn't fully restart the process. Singletons/Global variables are still there. And a `setup`/`tearDown` won't help, as this is within one test, not between two tests.  If we had a `tester.setRestorationData` that was executed as the first line of a `testWidgets`, this would be compatible with `setup`/`tearDown` and avoid some hassle for users of packages like `get_it`, which is relatively popular (even if I don't like it)  Raw `provider` usage would be unaffected though.
Would it make sense to use keys for this? Like associate a `RestorationScope` with a `Key`, and target this bucket specifically:  ```dart RestorationScope(   restorationId: 'foo',   child: RestorationScope(     key: Key('bar'),     restorationId: 'bar',     child: TextField(restorationId: 'id'),   ), );  ...  tester.setRestorationDataFor(find.byKey(Key('bar')), { 'id': 'value' }); ```  This would avoid having to specify the entire object and allows targeting a very specific scope – which should make the issue you mentioned less problematic
This TODO is causing an error on triple-head (tip-of-tree Dart, engine, framework) flutter analyze tests at https://ci.chromium.org/p/dart/builders/ci.sandbox/flutter-engine-linux/11403
What's the failure? In the logs from the linked run I am only seeing directory-related failures (e.g. `No such file or directory`). How are those caused by a TODO in a comment?
The "flutter analyze" step with log of stdout at https://logs.chromium.org/logs/dart/buildbucket/cr-buildbucket.appspot.com/8873492683668712848/+/steps/flutter_analyze/0/stdout has a failure due to that TODO
I am removing the TODO here: https://github.com/flutter/flutter/pull/62500
The color that [Material] widget uses to draw elevation shadows.  Please add a brief section about ThemeData.applyElevationOverlay here (similar to the TBD one for Material.shadowColor).
The [shadowColor API doc](https://api.flutter.dev/flutter/material/Material/shadowColor.html) needs to be updated. - should explain that the default is defined by [ThemeData.shadowColor] which is black by default. The doc should also include a link to ThemeData.applyElevationOverlay and briefly explain about shadows and dark mode.
Nit: the infra team now prefers to use `linux/android`
Adding a benchmark should never involve deleting code so this diff should have been a red flag during the reviews...
This is not intended. Some how when I copy paste things I override it :( I added it to a new patch #60412
I've already fixed this in https://github.com/flutter/flutter/commit/2962912d68fb72d6c9fd60f652e27f3593d692d6  It has already been pushed to the main tree.
Moved to be a part of `AndroidViewController` and renamed as `_AndroidMotionEventConverter`.
@blasten This can be it's own class or we can add `pointTransformer` field to the `PlatformViewController` class. Then Android could just use `PlatformViewSurface`. What are your thoughts on this? 
Sounds good
nit: `assert(transformer != null);`
What do you think about moving `_AndroidMotionEventConverter` methods to this controller?
gotcha. nice adapter for these two interfaces :)
I think it makes more sense to separate them. This class has to maintain a state and record `PointerEvent`s. I felt the logic was easier to follow if all of this was in it's own class. 
What about migrating this controller to use the new one?
subjective: what do you think about adding a new factory method? Maybe, `initNativeAndroidView`, and `NativeAndroidViewController`.  Feel free to use a different name. :)
That makes sense to me. I don't know if we should use the word `Native` though, since we already have a some confusion surrounding that term. E.g. `NativeAd` vs native platform view ad. 
could we add a new suite in `test/services/platform_view_test.dart` that uses the new controller?  We could start by duplicating the existing tests and covering any change in behavior between the two controllers.
this should be `event.device` + unit test
Actually, this isn't `event.device`. We will need to add a `deviceId` to `MotionEvent`, and most likely each of the Android-specific values.   @goderbauer do you know if there's a recommended pattern for adding platform-specific data to `PointerEvent`? It looks like we will pretty much need to pass each of these constants.  None of these values are sent from https://github.com/flutter/engine/blob/712f619737f1323fd2908b397aa8bd64fb2ccbe5/shell/platform/android/io/flutter/embedding/android/AndroidTouchProcessor.java#L171
nit: this line can be removed
```suggestion   group('AndroidViewSurface', () { ```
Is there any difference in behavior between `AndroidView` and `AndroidViewSurface`?
Can we use a similar approach that @gspencergoog used to add platform-specific stuff to the keyboard events? See `RawKeyEventData` [1] and its platform-specific subclasses.  [1] https://master-api.flutter.dev/flutter/services/RawKeyEventData-class.html
Well, I wouldn't go that route.  That's all there because of legacy that we didn't want to break. We're planning on removing it and moving it all to the platform side now.  Better would be to pass that data you need in a platform independent form and add it for all platforms.  Context: https://flutter.dev/go/platform-based-key-events
It looks like `RawKeyEventData` is constructed from a system channel message, and the params are passed in a `Map`.   Perhaps, the equivalent is to add a `Map` to `MotionEvent`, and then populate the `PointerDataPacket` in  the engine. https://github.com/flutter/engine/blob/637a8e7cd0440e5c97706aad89ba3f4decd432ee/lib/ui/hooks.dart#L294.   Does this sound resonable?  
After studying this further, I agree with greg that adding platform-specific stuff to the pointer events like that is not a good idea. 
After some offline discussion, the conclusion was to add a unique identifier to `MotionEvent` that can be used to lookup the original motion event in the platform.
Use a switch when checking the defaultTargetPlatform.
nit: indentation
@mdebbar @goderbauer as we discussed before, we want to have an api to force create a browser history entry or not.
It looks like you can replace this with: ```dart _heroController = MaterialApp.createMaterialHeroController(); ```
Can this be moved to a method?
nit: "if we use"
where does this get set if _usesRouter is false?
typo: `s/tne/the`
this documentation is woefully inadequate. :-)  It should say things like what format it's encoding the data to (JSON, looks like), what the vocabulary is, what the meaning of each part is, etc.
why do we use JSON here?
nit: per the style guide, the order of the constructor arguments and the order of the properties should be the same.  We should make that order make sense when reading the code (e.g. routeInformationProvider and routeInformationParser should always be together).
Please see the style guide regarding requirements for documentation. There are writing prompt in the style guide for ideas of things that you should include. The most important idea, though, is that when you're writing the documentation, you have to think of why people might be reading it. They are reading the documentation because they have a question. What is the question? That's what we need to answer.
(for what it's worth, the question i had was "why would i use this"; looks like the answer is something to do with the back button dispatcher)
not sure what "whether" means in this context... maybe "with the assumption that it is a navigating event"? We should make sure to define "navigating event".
is -> are
I'm not sure what that means. If I don't call the method, how is the callback ever going to be called?
if -> If
(also below)
"This is useful in the web application because the web platform relies on these reporting to support browser backward and forward buttons." -> "When a Flutter application is running on the Web, navigation events are used to implement the browser's back and forward buttons."
else?
or can it be null?
none-web -> non-web  I wouldn't encourage people not to support this on non-web, because it'll make porting to web harder. I would just say that it's only used on Web currently. Maybe describe it as additional data for higher-fidelity state restoration on Web, which is unused on other platforms?
Having a boolean as an argument after the callback makes it hard to read. I suggest either splitting into two methods or move the boolean argument before the callback.
"name" implies this is just an identifier, but really it's a whole blob of data... "state" is also super generic... we should come up with better names here given the current design. I'll think about better names...
Should we call `_processInitialRoute` when previous `routeInformationProvider` was null?
nit: this file could use some `dartfmt` :)
Does it work if you make the argument optional, then call `_rebuild()`?
Will this go away after your HeroController patch is in?
should this be set to `_createRectTween`?
Maybe define a color variable, set it once and use it in this and the router branch to avoid this duplciation?
A WidgetApp that uses the [Router] instead of a [Navigator].
Mention the default?
Mention the default when this is null?
nit: end with `.`  This doc also needs to describe what the routing information is.
Why is this json encoded?
Since this will potentially include the restoration data: Do the JSON encoder and the StandartMessageEncoder support the same stuff?
Should this one have a default value and assert that it is not null?
It would be helpful to have some implementation comments explaining what these mean.
Should routerState have a dedicated API where you pass in the reporting status and the callback at once? Seems odd that these informaiton are passed in through different paths.  Also, does _reportingStatus need to be reset after the callback?
nit: format this to indicate what is condition and what is the if-branch.
nit: add empty line before.
Why do we need to do this on every rebuild?
It seems like a strange side effect?
It's more then just a string, no?
It doesn't have a parse method.
yes
that is a private method in the MaterialAppState. Since is will only be use once in this static method, i found it does not worth to be turned into a private method any more
This pr will remove this all together https://github.com/flutter/flutter/pull/60655/files the hero controller will only be initialized in initState
you are right, i forgot to update this. There are several PR that are aim to clean up the hero controller https://github.com/flutter/flutter/pull/60655/files https://github.com/flutter/flutter/pull/61662/files I will update this once they are merged
System.navigation method channel uses JSONMethodCodec, but anything that can be serialize to a string will be fine, do you have any suggestion we should use here?
`location/ configuration` maybe?
Anything that can serialize into string will work because it go through the system.navigate channel or we can create a new system channel with standardmessagecodex
Map will work. Alternative we can create a new system channel with standardmessagecodex just for this
It is reset after _reportRouteInformation
We only want to report the route information once per build cycle. There is no api in the state class to inject this logic. rebuild is the only place that i can think of. 
good catch, we need to call _handleRouteInformationProviderNotification
Why do we need to report these once per build cycle? I expect we only need to report them when the current configuration changes?
Sorry for confusing, `routerState._reportRouteInformation();` will only report url update if reportingStatus = must or maybe. What i meant was that the router may detects configuration change multiple times within a build cycle, and we only want to send one url update within that cycle.  I should rename `routerState._reportRouteInformation();` to something more descripitive. maybe `reportRouteInformationIfChanged`
This comment should go above `final Color materialColor`.
remove this comment here?
The docs should tell me when its not reported automatically and I need to use this method.
When would I want to do this as an app developer?
Is this _rebuild necessary Wouldn't the routerDelegate notify its listeners in response to `setNewRoutePath` if a rebuild is required?
Should this be more clearly named `nextStatusToReport`?
And what happens if I do `navigate` and `neglect` in the same frame?
same comment as below.
same here (although I am not 100% sure about this one)
Why compare the serialized version?
I would have expected that we compare this configuration to whatever the last reported configuration was and when it has changed, we run it through `restoreRouteInformation` and `routerReportsNewRouteInformation`?
Why does `RouteInformation` need to have an opinion at all whether and how its serializable? Isn't that up to the implementation of `RouteInformationParser` to decide how to send it over?
When do we need to make the report? At the end of a frame? Could we just schedule a postFrameCallback when we detect that a report may be necessary and then do the reporting in the callback?
This should say something along the lines: When the configuration returned by this method is passed back to setInitialRoutePath or setNewRoutePath, the Router should configure the Navigator in `build` exactly like it did when the configuration was obtained.
Actually, the post frame callback may clash with the restoration post frame callback and we don't have a way of ordering them.  > We only want to report the route information once per build cycle.  Also, why do we need to restrict this to once per frame? Can we not do this immediately when we notice a configuration change?
That means two changes happened: one that requires navigation, and one that doesn't. I think navigation should happen in this case.  This would be a good addition to the docs.
Currently it throws an exception says  ``` 'Both Router.navigate and Router.neglect have been called in this'             'build cycle, and the Router cannot decide whether to report the'             'route information. Please make sure only one of them is called'             'within the same build cycle.' ``` I can't think of a use case where this can happen, and it may be confusing if the user does two contradictory events within the same build cycle. We can follow the suggestion @mdebbar mentioned if there is indeed a use case for this.
If we allow multiple update per frame, the state restoration cannot keep up with it.
`nextStatusToReport` to me feel like we are reporting the status(_RouteInformationReportingStatus) to someone, but this is actually the current status to decide what to do when the next time we report the routeinformation. I will think of a better name.
the best we can do without adding more complexity(without asking developer to implement the compare method for configuration) will be comparing the identity, and that will usually be different if `currentConfiguration` is dynamically generated. If they do end up have the same identity, that means developer is caching the result somewhere in the routerdelegate and that is bad, too.   That is also true for the state in route information which cause the the router may always report the route Information back to route information provider. 
If we put the serialized method to the route name provider, then we will be pushing the responsibility to figure out whether it has changed to route name provider as well because router cannot tell whether it has change by looking at the identity alone.  The RouteInformation reported from route name parser will always be different because they are usually dynamically generated.  This causes one issue, that the router also have the api to force the route name provider to report the route information back to engine even if it has not changed. we have to somehow send the reportingstatus to the route information provider, this may make the api confusing.
I think we always want to rebuild at the end of the notification. I feel it does not hurt the performance and it will not be error prompt as well.  When I was writing router delegate it make sense to notifying the router to rebuild when i am actively changing the app state. However, it seems weird if the router told router delegate something has changed, the route r delegate has to notify the router to rebuild after it update the app state.  This has tripped me a lot when i was rewriting the stock app and they are all tricky to figure out. I feel no harm to add the rebuild here.
that could work...
I don't really see why RouteInformation is aware of the details of the message channel being used. That seems strange. Shouldn't the code that sends and receives the data be the one to encode it/decode it?
we should just change System.navigation to not use JSON.
nit: indent this more and put the `) {` on the next line to make it easier to read.
nit: fix indentation 
Wondering: should the generic type just be Object? Here and elsewhere.
```suggestion /// The route information consists of a location string and ```
configures
remove one "with"
nit: use `*` to turn this into an actual list.
nit: remove one `to`
why the `?` here?
isn't it already `none`?
use switch/case with enums.  Instead of lumping all cases into one in this switch/case, maybe separate them out. It would also make the code easier to read. You can factor common logic out into private methods.
Why `?`
I wonder if it would make sense to take one `RouterConfiguration` object here, which basically wraps these three. If we have opinionated versions of these, you'd just have to pass one OpinionatedRouterConfiguration instead of four different objects?
This still seems like a hack. Can we just use the regular mechanism of scheduling a postFrameCallback to do the update here? If necessary we can then later introduce a synchronization mechanism in the postFrameCallback to send restoration state and router information over together, e.g. the postFrameCallback of both the RestorationManager and the Router could communicate send their final information to a third party and the third party then sends it over in one go to the engine in a microtask. We can add that synchronization when we need it (i.e. when the web engine is actually going to combine these two information).
this should be a method instead of a getter since it does more expansive stuff then just "get".
trivial nit but please (as per our style guide) put these in the  same order everywhere and ideally an order that has the four delegates either in the order that they get normally called or in the order that you'd want to learn about them in. Right now the code is inconsistent about what order these four names are sometimes put in.
(for example, this is a different order than above)
Technically, this is an unnecessary rebuild. Just because somebody wants to add a new history entry for whatever reason, doesn't mean we need to rebuild the router, right? If we uncouple the reporting from buidling, e.g. with a postframecallback we could avoid that, no?
this sentence tells me nothing about what this does. :-) it just repeats the same words as in the name of the types involved...
`Android`
nit: grammar issue here; "still respects pageless routes" maybe ?
It is unusual to hock into setState like this. Can we do it the other way around? Instead of calling `setState` we call our own method (e.g. _markNeedsRebuild) or whatever, and from that method we trigger the setState and schedule the reporting? I think that makes the code a little clearer because when you see a setState call in the code you don't necessarily expect it to have the reporting side effect.
we really should not be using json
Why the `?` here? If `oldWidget` is null, it would already crash in the previous line when accessing its `backButtonDispatcher` there.
Same here.
"In Web applications"  "the" here is confusing because it refers to an already-introduced web application... but nothing has been introduced so far.
Avoid "you" in documentation; the reader might not be the one who wrote the code, they might just be trying to understand it.  Avoid "decide" in documentation, for similar reasons.  "When overriding this method, ..."
"returns null, which prevents"
"prevents ... from reporting"
"a subclass can" or "subclasses can"
"In common use case" -> "Typically"
nit: formatting (add a trailing comma and give each argument its own line
Same for the other methods below.
formatting nit: keep this in one line
nit: just keep this in one line?
"The [parseRouteInformation] method must produce an equivalent configuration when passed this method's return value."
"descendant"
nit: just keep this in one line?
descendants
that have
handles
this wrapping is slightly confusing. Can we put it all on one line maybe?
(similar comment in other places)
nit: formatting, there should be a closing `)` for the `FlutterErrorDetails(` with the same indentation level.
It seems that doing it in a post-frame callback is the right behaviour. It can wait until we merge this and the state from goderbauer's work into a single message to the Web engine, but eventually we'll want to combine both into one message, and we'll probably need to resolve what happens when you have multiple conflicting routers. Doing everything in a post frame callback that then calls an API that schedules a microtask is the usual way we resolve this kind of thing.
Shouldn't there be changes to RouteNotificationMessages as well? It currently assumes that the arguments are all simple route names and not what we pass in now.
Doesn't didPushRoute just give you a route name instead of a complex serialized object? Do we need new API to obtain a RouteInformation Object from the engine? Or maybe this method should have two params: location and state.
This isn't the right location to serialize/deserialize. The serialization should happen in `RouteNotificationMessages.maybeNotifyRouteChange` just before things are put on the channel. And the deserialization of the engine information should happen in whoever calls our WidgetsBindingObserver implementation.
I find it weird to wrap backButtonDispatcher and routeInformationProvider together because they are pretty much standalone objects.  I am ok with wrap both route name parser and router delegate together, but I couldn't figure out what will be the api looks like if we provide an opinionated one. 
oh my, this is a terrible typo
fixed
This should document what methods the channel supports, see docs for other channels.
Is this called instead of didPushRoute or in addition?
Depending on what methods are supported, can we re-use the navigation channel for them?
remove print?
Does this optionally need to take restorationData?
nit: separate some of these by blank lines? (at least between the end of initState and this line)
Why `Object`? Can this just be true/false?
Since the postframecallback is so long, maybe put that in a separate method?
assert here that _currentIntentionToReporting is not none?
Why "maybe"?
What's the setter for? Shouldn't you always go through routerReportsNewRouteInformation?
What's the difference between the value stored in _currentRouteInformationInEngine and _value?
nit: space after :
Should this also listen to didPushRoute?
We should always send this information to the engine, it's up to the embedder to ignore or process it.
This is more than just a routeName.  Also, why do we need to send the old information as well? If the engine needs it, it should keep a copy of it.
oops
instead, because the web engine will notify both router and navigator channel. These two method need to be two complete separate path. Otherwise, it may double notify the listeners
This setter is for developers who want to navigate to a different location by changing the PlatformRouteInformationProvider.value directly.  In this case, we need to notify the router and report this event to the engine directly.  I think this is a very useful feature, because developers can still build up browser history entries even if they didn't implement the routerdelegate.currentConfiguration
in some situation, the _value will be one step ahead of _currentRouteInformationInEngine. For example the value setter
I remember we decided to make web engine notify both router and navigator channel. This will cause it to receive the event twice.
Good question, I remember the last time i check the previous one is not used and discarded. I probably should just remove it.
That needs to be documented. Also, should that then be called debugSetRouteInformation and only work in debug mode?
But why do we need this?
Actually, I think we should just remove that. The feature goes against what Router wants to archive: That the current configuration of the navigator depends on the app state. If you want this, you should make your app state contain a routename string.  If your app really needs it, you can implement your own RouteInformationProvider with this functionality.
The way it is it will stop working for all other embedders, though. Should we change it so that this listens to both and then document that embedder should call only one of them? We could also update WidgetApps to listen to the new one in addition to didPushRoute to make the old Navigator approach work for embedders that decide to call the new API?
I am thinking maybe we should just make a breaking change to add a state parameter to didPushRoute and make both router and navigator channel uses it. The embedder can send message to whichever channel they like but just not both at the same time.  I can't think of other cleaner way to do this, either we need to deal with debouncing or the embedder need to migrate their code.
Why wouldn't it work to have two methods and the embedder decides which one to call? The Router just responds to both.
Existing apps will have to migrate their apps to listening on both, otherwise web application will break. Although they also need to migrate if we make the breaking change, the former will be a silent break which may be tricky to find out.  I think we will also want to merge these two if we start from scratch anyway. What do you think?
Why do existing apps need to migrate? Isn't the change just to also listen to the other notification in the framework here:  https://github.com/flutter/flutter/blob/3aa0b48a2750197017c819588fa2e793244fa080/packages/flutter/lib/src/widgets/app.dart#L1058 
If we make a separate method for the route information channel. An app has a custom widgetbindingobserver will need to migrate their code to also listen to the new method. Otherwise, the widgetbindingobserver will not work properly in web application.  If we merge the two method, we will make a breaking change by introducing an additional state, and restoration state parameter in `didPushRoute`.  For both cases, existing app will need to migrate.  
Would it work to have two separate methods and the default implementation of WidgetsBindingObserver.didPushRouteInformation just calls WidgetsBindingObserver.didPush? That way, you can listen to them separately, but if you don't upgrade your app everything continues to work even when the engine calls the new methods.
That is brilliant, I will do this way. Thanks!
nit: space before `location`
What happened to these messages? Don't we need to keep them?
```suggestion   ///    the application navigates to a new locations. ```
The -> the
Oh, was the documentation here just outdated and these don't exist anymore?
Why do we need this class if `RouteInformation` already has a field for restorationData?
Maybe `didPushRouteInformation` should be given a RouteInformation object as an argument. That way, we can easily add more data to this message if necessary. Basically, I am thinking:  1. move RouteInformation class to binding.dart 2. replace the arguments of this method with a routeinformaiton object 3. remove the restorationdata for now and once we know what type that would have we can easily add it back into the object.
The call to invokeMethod itself should be in the services library (see e.g. the static methods in `system_chrome.dart`)
yes they are outdated
@goderbauer  we have to do this check because method channel invoke method will throw if there is no corresponding listener on the engine side.
I have to reuse the old method until the engine side method is in place otherwise it will throw an exception.
... are stored ...
Should the navigator channel be an OptionalMethodChannel to avoid that problem?
nit: space between `if` and `(`.
same blow.
Just remove the else? Same above.
This shouldn't be typed "Object". Maybe take everything that's in the map as named arguments?
Instead of duplication the code, forward the call to routeUpdated?
Make these named arguments?
I just realized we are not exposing this api in the package level, we should be good to remove this without a breaking change
i missed that we were creating this with `dynamic` as the type here. That seems to defeat the purpose of having a `T` type argument on Router...  Not sure what the right answer is, but we should probably find a better solution than defining the API with `T` then ignoring it.  (I noticed this because we're changing `dynamic` to `Object` as part of the NNBD transition.)
I was struggling hard on this one too, you can not set T for a single constructor, and it is weird to define on the class level because non router constructor does not care. we could separate out router constructor to a class or method on its own, but that seems to add a whole lot of complexity to the code. For now, it will let you initialize with different type of route information parser and router delegate, but it will throw on build
🤕 
This is why we would sometimes use the real fs
occasionally gets stuck if these aren't locked/unlocked
I thought it would simplify the debugging if I replaced testbed with testUsingContext ... that was sort of true.
tests occasionally get stuck without this
this direct write to stdout sometimes hangs the test, not sure why
We don't actually depend on the packageConfig values for the unit test. The correct change is probably to make the loader an injectable class that could be mocked out for testing. This would be a temporary fix so that we can start shuffling tests.  Open to alternative approaches too
Can we update the `FileSystemUtils` constructor to be `const`?
ahh, nevermind, then its dependencies would have to be const too...
Based on discussion, I'm going to keep pulling on this string by  1. Checking if this reproduces with a simpler test case.  2. Making the package loader injectable
The `ProjectFileInvalidator` is stateless so this is OK.
The write buffered error below is already using print, so I figured this is OK
OK! turned out to be a similar issues to FsUtils
We're ignoring the adjustment parameter here, same as before (@pennzht - why is that?). Maybe update the API doc?
Is the value just based on [MediaQuery.viewPadding] or is it the same as viewPadding?
We want to make it clear that minViewPadding doesn't change when the soft keyboard goes up and down.
Whey are we using rectMoreOrlessEquals here and elsewhere? It would be OK to just include an explanatory comment.
According to the docs, the Y offset is not affected by the adjustment for the mini Top positions. It looks like only the X is adjusted. https://github.com/flutter/flutter/blob/9322c80825bb582954410408de39c0ef90b395ec/packages/flutter/lib/src/material/floating_action_button_location.dart#L40
It's also dependent on `_resizeToAvoidBottomInset`, I'll update the docs. :)
I'll add some more clarification. :)
Oh I borrowed a little from other FAB tests. I'm not sure we have to use `rectMoreOrLessEquals`. I'll see if I can simplify.
Ah, just checked. This is required as it accounts for the precisionErrorTolerance. The tests will not pass otherwise.
We're providing API doc for this override, so it would be helpful to reiterate the point about ignoring the adjustment parameter here.
Device discovery created by instantiating DeviceDiscoverers looks up this entry from the cache, will fail if the path does not exist.
Same here
If the generator is not provided, one is created but that looks up the dartSdk path from the cache.
🤦 
I thought it was hard to write tools tests, but turns out I had no idea...
the nice thing is ... there are no issues with the tests using testWithoutContext, so at least we are on the right path 👍 
👍
this should be `platform_views_scroll_perf_hybrid_composition` now.  Maybe: `platform_views_hybrid_composition_scroll_perf`
does the test file name matter? The root directory is already different. (now `platform_views_layout_hybrid_composition`)
Can we `@Deprecated('Prefer BuildInfo.packagesPath')` instead of hinting in the name? Edit: I tried this and there were no analyzer warnings where it was used.  Does that annotation not work?
Did we disable it for the framework? FYI @goderbauer ?
In practice, I tend not to use deprecated because it would flag the framework warning lint
That's annoying.
This is an example host project, and was updated by running the integration tests.
```suggestion     @required String webBuildDirectory, ```
```suggestion           webBuildDirectory: getWebBuildDirectory(), ```
```suggestion        _webBuildDirectory = webBuildDirectory, ```
```suggestion   final String _webBuildDirectory; ```
```suggestion     _fileSystem.directory(_webBuildDirectory).uri, ```
```suggestion       final File file = _fileSystem.file(_fileSystem.path.join(_webBuildDirectory, 'index.html')); ```
D'oh
was the process manager never getting called?
I guess not, since these are now `testWithoutContext`. cool.
Negatory, but we have a rule that a context injected FIleSystem requires a context Injected ProcessManager
rather than using both a `switch` and an `if/else`, I would only `assert(undocumentedMembers >= 0)`.
You could make this easier to test by making it a static or top level method, since it doesn't depend on anything in AnalyzeBase.
Why remove the doc comment?
I don't think these should be exposed as public fields. You could instead define `_handleAnalysisStatus` and `_handleAnalysisErrors` as closures and keep these objects above in the method body:  ```  // Its OK to define methods with names in other method bodies. void handleAnalysisStatus(bool isAnalyzing) {     if (!isAnalyzing) {       analysisCompleter.complete();       subscription?.cancel();       subscription = null;     }   }  try {   subscription = server.onAnalyzing.listen((bool isAnalyzing) => handleAnalysisStatus(isAnalyzing)); ``` Alternatively you could pass analysisCompleter/error as method arguments
See comment about making `generateDartDocMessage` static/top level - then this class isn't needed
AnalyzeOnce class name is enough, No additional comments.
Get new knowledge Thanks
Yeah you're right, its not a very helpful comment
This will not work on Windows. Best to use the path package https://pub.dev/documentation/path/latest/path/basenameWithoutExtension.html
This a nice improvement over what we have. The generalization of the idea might be a little better: match filenames with a suffix that matches a legitimate locale string preceded by an underscore. You can use https://pub.dev/documentation/intl/latest/locale/Locale/tryParse.html to check each possible suffix. 
We're looking for the language code in the filename unconditionally now
It returns null not "null", right?
It would be useful to verify that ap_localizations_en_CA is recognized as en_CA but app_localizations_en_CA_foo is not.
You're right. In one my previous changes it was returning null because I used `toString()` incorrectly. I'll update the comment
I just tried `en_CA_foo` and it somehow parses the locale as `foo`. It seems that `Locale.tryParse` checks for the format of the locale identifier, so it would still be helpful to validate that the language is a valid one.
I feel like calling it `useNewStyle` isn't very future proof... eg. what will happen when Apple changes it again in iOS 15?  Perhaps a better solution might be to create an enum something like: ``` enum ActivityIndicatorVariant {   iOS13AndEarlier,   iOS14, } ``` I'm not super happy with the naming above, but hopefully the intent is clear.  And whatever naming convention we go with, there's a bunch of other cases where code introduced in this PR talks about the "new" style that should be updated to use the new naming (eg. the names of the tests, the array of alpha values, etc) 
You've removed `_kTickCount` (which is reasonable given the change), but this comment still refers to it.
It would probably also be worth adding a comment to each enum case to describe the specific behaviour
Nitpick: Not sure what triggered these changes. Have the Flutter formatting rules changed, or is this just based on  the auto-formatting preferences from whatever IDE the PR author is using?  There's a bunch of formatting changes in this PR that mask the actual changes under the covers.
The file is formated using dartfmt. I think the diff tool should be able to show the actual change in a darker color.
Fixed in latest push.
I've added the enum `CupertinoActivityIndicatorStyle` to control the style. The default style still remain iOS13 until the official release of iOS14.
I recommend that we remove this enum and `style` flags and only support iOS 14.  If we wait a few weeks to merge this PR so that it misses the next stable release, then the following stable release should happen pretty close to September and the likely release of iOS 14.  Flutter's usual policy is to support only the latest version of a design style.  For example, see https://github.com/flutter/flutter/pull/36087 where switches were updated to match iOS 13's style several months before the release of iOS 13.  Otherwise, if we really want to support both versions right now, we need to have a plan for deprecation. That probably involves creating another issue and adding TODOs to the code saying that it needs to be deprecated. Then someone needs to merge a PR to deprecate this, and then later another PR to remove the iOS 13 code altogether.
I think developers need time to adapt the app for iOS14 and user also need time to update to iOS14. We still need some time to deprecate the old style instead of remove it directly. It will be better to support the new style before official release of iOS14 to give developers enough time to adapt their UI.  I've added a TODO for changing default style to iOS14. (Maybe I will do that.)
Sounds good, if you want to do it this way then I'm on board with that.  Thanks for adding the TODO.  I think the deprecation process should look like this:  Roughly 1 month before the release of iOS 14, we should merge another PR that adds the `@deprecated` flag to the `style` parameter.  This PR should also change the default value to `CupertinoActivityIndicatorStyle.iOS14`.  This will have the effect of automatically updating users to iOS 14 style if they haven't specifically set their style.  The PR should be merged 1 month before iOS 14's release so that the PR is released to stable around the same time.  After iOS 14 is released and everything is working well with the new indicator style, we should merge another PR that removes the `style` parameter and `CupertinoActivityIndicatorStyle` altogether.  This will force everyone to the iOS 14 style.
We can either keep https://github.com/flutter/flutter/issues/60047 open until the final step is complete, or we can create 2 new issues to track the two points above.
`style` is ambiguous with other unrelated things in Flutter (like [TextStyle](https://master-api.flutter.dev/flutter/cupertino/CupertinoTextField/style.html)).  I think we should rename `style` and `CupertinoActivityIndicatorStyle`.  Maybe to something like `iOSVersionStyle` and `CupertinoActivityIndicatorIOSVersionStyle`?
```suggestion   /// The style that is used in iOS13 and earlier (12 points). ```
```suggestion   /// The style that was introduced in iOS14 (8 points). ```
```suggestion   /// Defaults to [CupertinoActivityIndicatorStyle.iOS13]. ```
Sure, we can keep the old issue and update the progress.
I've renamed it to `iOSVersionStyle`.
why do we need a pump?
Probably because mouse region takes a frame after `addPointer` to update itself? If so I recommend doing it in the following order: - createGesture - addPointer - pumpWidget - down - up (or other gestures)
This is weird. I thought whether the text position handling is position- or word-based should be completely decided by the input device, i.e. Android or Windows touch devices should also select words based on word, while macOS should almost always be based on position. (Not only to this function but also `onSingleLongTapMoveUpdate` and `onSingleLongTapStart`)  Also AFAIK the `TargetPlatform` is defined more like how it looks instead of where it runs. +cc @stuartmorgan  
Perhaps it is to allow the focus to take effect.  That also happens in a microtask.
FWIW, I tested on an iPad with the Apple keyboard. Tapping words selects to word edges. Using the trackpad instead selects by position. 
we should figure out why we need the pump and say so in a comment
if you mark this @required, does it catch any cases where we're not setting it? we should make sure to set it everywhere, even if we don't end up marking it actually @required.
anything that looks at enums should use `switch` and explicit cases, not `if` or `default`, per our style guide
I'll figure out if the pump is needed or not, and either remove it or explain why it's needed.
Yeah I think we should ditch target platform and decide solely based on the pointer kind. Perhaps even have a global function that decides whether the kind is a precision device.
On Android, doing a touch tap does a precise placement of the cursor. The word edge behavior is a Mac/iOS/iPadOs thing. So this should remain platform-dependent.
I already went through all the usages and made sure to add the `kind` argument. The only exception is the one generated from semantics, in which case there's no device kind associated with it. Should I just use `touch` as the default?
Oh there's a `PointerDeviceKind.unknown`. I think it makes more sense to use this instead of defaulting to touch.
My point was in support of this current implementation. I don't think it'll be avoidable to have to account for both dimensions since native behaviors are so diverse. 
Ok, this 2-dimensional criteria looks good to me.
```suggestion   }) : assert(builder != null || detailsBuilder != null,          'DragTarget.builder or DragTarget.detailsBuilder must be set.'),        super(key: key); ```
Might as well require that only one of them is non-null, enforcing by constructor assertion.
```suggestion       widget.onMove(DragTargetDetails<dynamic>(data: avatar.data, offset: avatar._lastOffset)); ``` Among other occurrences in this PR.
Besides being a weird (while probably unavoidable) design, is it still necessary to rebuild on every movement if only `builder` is provided?
Is a public `onMove` property necessary for your demand?
```suggestion   /// The [detailsBuilder] is similar to [builder], except that:   ///   ///  * The [detailsBuilder] is called on every [Draggable] movement within the [DragTarget],   ///    and triggers rebuild.   ///  * The [detailsBuilder] vends a [DragTargetDetails], which contains both the   ///    [Draggable] data and the local position. ```
```dart /// /// See also: /// ///  * [detailsBuilder], an alternative option to [builder] but provides detailed update and triggers rebuild on every movement. ```
The event of mouse movement (according to [MouseTracker](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/mouse_tracking.dart#L543)) is exit, enter, then move. Might as well use the same order here, by moving the move event to after entering? 
Is it better to call it [DragTargetDetailedBuilder] (as well as other related symbols)?
Calling this unconditionally is problematic.
I changed it to [DragTargetDetailedMovementBuilder] to highlight that it uses 'details' and also fires on movement. Feel free to suggest something else.
Yes, in order to trigger logic (outside of the build tree) in the same way as onLeave, etc.
Agreed, good call.
Actually, why do you need the detailsBuilder? Doesn't the onMove callback give you enough information to change the state from the outside to what you want?
See my original bug description: https://github.com/flutter/flutter/issues/58982 It would be unergonomic to trigger a second rebuild outside (of the initial movement rebuild) when the user wants to update children.
Why would there be a second rebuild? If I remember correctly, onMove is executed between frame (before DragTarget can rebuild in response to the move), so any state changes that are triggered in the onMove would be applied in the same frame as the DragTarget rebuild, no?
Here's didDrop (existing code) and didMove (new code, modeled on the existing patterns). It calls setState() first, then calls any relevant callbacks.   ```   void didDrop(_DragAvatar<Object> avatar) {     assert(_candidateAvatars.contains(avatar));     if (!mounted)       return;     setState(() {       _candidateAvatars.remove(avatar);     });     if (widget.onAccept != null)       widget.onAccept(avatar.data as T);     if (widget.onAcceptWithDetails != null)       widget.onAcceptWithDetails(DragTargetDetails<T>(data: avatar.data as T, offset: avatar._lastOffset));   }    void didMove(_DragAvatar<Object> avatar) {     if (!mounted)       return;     if (widget.detailedMovementBuilder != null)       setState(() {});     if (widget.onMove != null)       widget.onMove(DragTargetDetails<dynamic>(data: avatar.data, offset: avatar._lastOffset));   } ```  Even if it were to work without needing to add it to the next frame, that's not apparent to the caller. I feel that most Dart/Flutter developers will instead assume that callbacks may be called during rebuild, and will always schedule it on the next frame, e.g. would use onMove: ``` onMove:(details) => SchedulerBinding.instance.addPostFrameCallback((_) => setState(()=>_coords = details.offset)); ``` 
The order of calling setState and calling the callbacks doesn't matter here. setState just marks this widget to need rebuild in the next frame. It doesn't actually do the rebuild.  Scheduling a postFrameCallback like that in response to a gesture callback is also very unusual. You wouldn't do that in a GestureDetector's onDrag/onTap/etc. either.
I've confirmed that the postFrameCallback is not required, i.e. I can just call setState() in the onMove() callback. However, I think many flutter coders instinctivly avoid setState() within a build _method_ out of habit, even though it is ok in this context since it is part of a callback outside of the build phase. But yes, I agree it's not needed. More thoughts in the other comment below.  
Maybe extract this out into a private method and call it below as well.
This fails with devices attached!
Seemed to be calling real filesystem, but I'm not sure how
setUp so that test state doesn't leak
doesnt do anything
no idea why this was here
again, prevent leaking test state
it is now, no idea why this test was passing
this is tested via various devicelab and integration tests, the unit tests has too many mocks to be useful and was failing with some wicked stack traces
That is, it is now available on stable channel so the test should have failed
Looking at the implementation of `NoDevicesManager`...should we just delete this test?
I'm sort of assuming this is testing the devices command logic for error states and not the devicemanager. I think `AndroidSdk: () => null,` was an early attempt to disable all devices, but that doesn't work in a web/desktop world
Well, I guess we're still testing some code here. I take it back.
Shouldn't the default `FileSystemUtils` use the file system and platform from the context (and thus the overridden test mocks)?  And if that's not happening, would removing contructor injection `FileSystemUtils` fix this? This worries me that you can override the ProcessManager + FileSystem but still end up using the real filelsystem.
Hitting real artifacts, failing if they did not exist
Hitting real cache, failing if it didn't exist.
hitting real file system, failing if a .packages didn't exist
This test apparently doesn't rely on this value, avoid looking up potentially null home dir path
This fails if .packages doesn't exist
missing windows check, was creating this as a windows style file path even if configured paths were possix style
This was calling the real fsUtils in the test. Rather than inject it I replaced this with roughly equivalent code. I'm not sure how useful ensureDirectoryExists actually is.
This was calling real artifacts, falling if they did not exist
Renamed this to stop my IDE from autosuggesting it when i type `test`
Similar to above rename
I switched this to only use a linux file system/path to make it more obvious where we were failing to correctly configure things. I.e., the windows path in the toFilePath on URI
This seems like the right property to for this: ```   /// For example, the [Chip] class sets this to false because it can't be   /// disabled, even if no callbacks are set on it, since it is used for   /// displaying information only. ```  Looking good =)
you should have a newline here
Good catch! May have gotten lost when manually merging some conflicted testing structure stuff.
This is scary. I do agree it will be convenient to have ability to wait a period of time, but this may be a source of flakiness.  I was actually thinking about solving this problem before, is it possible to get all the the timer and microtask created within a zone(maybe be caching when someone calls ZoneSpecification.scheduleMicrotask and ZoneSpecification.createPeriodicTimer), and provide some kinda of api to expose those?
In general, I agree with you.  This PR does not make things less or more flaky. If your test relies on some condition to resolve asynchronously, then it may or may not get a chance to resolve when runAsync returns. This PR aims to make that *a little* better by trying to flush the microtask queue before returning. It makes sense but indeed, it is not a guarantee and thus it does not reduce flakes.  What it *does* do is to expose the pre-existing ugliness to developers. Now we have a ominous parameter `minFramesUntilIdle` which, if we want to, we can default to 0 so we don't wait at all (current behavior). With increased documentation and this new parameter, we are giving developers a strong signal that `runAsync` is working as intended and if they want less flakiness, they should consider changing their code.  Without this change, people are surprised by the behavior of runAsync and try to "fix" it by doing stuff like this:  ```dart runAsync(() => // some code that causes a side effect in my widgets); runAsync(() => pumpEventQueue(times: someRandomNumber)); // I found this API that's supposed to help, I guess? ```  Fiddle with `someRandomNumber` until it passes. There's no other solution to this that I am aware of.  I am trying to make this part of the API and documentation so at least developers *hopefully* understand what they are doing and why they are doing it. If they start seeing flakes, they can refer to documentation and see why it is happening.  Replace code above with:  ```dart runAsync(   () => // some code that causes a side effect in my widgets,   minFramesTillIdle: someRandomNumber, // Ah, but now I see this is a synchronization issue. ); ```  As for exposing timers and microtasks, I think that's a problem for an IDE to solve. While debugging these tests, the users should be able to see what kind of timers and futures are now "frozen" because we ended the real async zone. I have a generic bug for this that I am hoping will get some traction.   I tried to save this information and perhaps print a warning message that there are unresolved tasks and such but it is too noisy. It alerts when there's no need to alert (such as no side effect) and it doesn't alert when it needs to (e.g. some IO operation will eventually post a microtask but we have no evidence of that now).  The final thing we agree on: This problem bothers me :-). I think this PR makes things a bit more transparent (but, like you said, not any better).
For exposing timer and microtasks, I meant expose a handle for the user to await for them. The problem is some of our code (image decoding for example) create futures without any reference for test to await for, and that is the main reason people want to do pumpEventQueue and hope those futures get resolved.
It is not just Future's. Image has streams and other subscription mechanisms as well.  Is it possible to capture all those in a zone? I know that Future.delayed creates a Timer but I don't think an `ImageCompleter` stream would create anything that's observable in a zone. I will test this out and get back to you.  We would also need to create a polling mechanism with a completer to track timers and return when all timers return false for https://api.dart.dev/stable/2.8.4/dart-async/Timer/isActive.html as Timers themselves do not provide this functionality AFAIK.
I believe the imageCompleter is just a wrapper over a codex future, the future will either be a wrapper of timer or microtask, but then i think you are right that we need to find a way to flush the timer. flushing microtasks should be as easy as creates await Future.delay(0), but timer is tricky.
Maybe things will be easier in the fake async zone that the runTest use, in there we can control the time flow so even if we do fakeAsync.flushTimer(Duration(hours:1)) it will be finished in a instant. we can expose all the timers and make a API that is something like ```await tester.resolveTimer(Timer timer)```
I am not sure I understand. Futures/Timers cannot cross over zones. We cannot move a Timer that was created in real async zone to fake async and resolve it there.  However, I made some promising progress. If I keep track of timers, I can do this:  ```dart       final Completer<void> sideEffectCompleter = Completer<void>();       const Duration checkInterval = Duration(milliseconds: 100);       Zone.root.createPeriodicTimer(checkInterval, (Timer timer) {         timerCache.retainWhere((Timer timer) => timer.isActive);         repeatingTimerCache.retainWhere((Timer timer) => timer.isActive);         if (microtasks == 0 && timerCache.isEmpty && repeatingTimerCache.isEmpty) {           timer.cancel();           sideEffectCompleter.complete();         } else if ((checkInterval * timer.tick) >= additionalTime) {           timer.cancel();           sideEffectCompleter.completeError(TimeoutException('Timed out!'));         }       });       try {         final T value = await callback();         // This is something we can expose to user or we can await ourselves.         await sideEffectCompleter.future;         return value;       } ``` I want to build up a more comprehensive test involving streams. Let me know what you think.
I think you meant exposing Timers/Futures etc that we use in the widgets for testing. Even so, there are certain things where we "have to" rely on real async such as file io. Widget tests need to be able to load images from assets which means a certain part of widget testing cannot be in fake async zone. 
I am not familiar with file io, why couldn't it run in fake async?  The assets loading part should be fine because we mocked the asset channel to read file synchronously https://github.com/flutter/flutter/blob/aa0382e95d3fe19b9ee4becf3fdf4017c15a149c/packages/flutter_test/lib/src/_binding_io.dart#L40  The reason I brought up fake async is that i am thinking we can move away from writing test in runAsync if we can make the fakeasync in testWidgets expose the timer and microtask.
There has been numerous discussions about trying to run everything in fake async. See related issue: https://github.com/flutter/flutter/issues/23179 and specifically: https://github.com/flutter/flutter/issues/23179#issuecomment-452128558. For this to happen, we need to enumerate all the possible things that Flutter widgets might do and provide sync implementations of them (much like you did for file loading). I am not sure how feasible that is.  Even if it was feasible, do you think we can still make progress in making runAsync more robust and chase that problem separately? We should seek incremental and innovative solutions together. If we get rid of `runAsync` at some point, I would be *very* happy but it does not seem possible for the time being.
I see yes you are right, I don't have an idea to fix the issue you mentioned neither. i agree we should make runAsync more robust at least for now.
I updated the PR. I still had to introduce some "wait time" in there because microtasks can be scheduled by any async operation "back to back". However, I feel better about this approach because it is more deterministic and easy to explain. Let me know what you think.
The purpose of additional time is to increase the timeout value for the test section, I think we should not overload its usage. As of the current implementation it both increases the wait time for the timer/microtask and also extends the timeout.  It also raise another question, what if there are unresolved futures that user does not care about? currently it will always fail if there are unresolved futures after the additionalTime.  How about we expose a new api, something like `tester.resolveTimerAndMicrotask()`. this api create a periodic timer just like you do here, but the sideEffectCompleter will only resolve when there are no more timercache and microtasks. In the test, the developer can decide if they want to wait for the future by calling `await tester.resolveTimerAndMicrotask()`. If they have a bad test that creating unresolved timer or microtask, it will just hang.  We don't do any waiting at the runAsync tear down, it will be developers choices to decide what they want to do.
debug statement
where is this used?
Will be removed once we agree on implementation :-)
Will be removed once we agree on implementation.
> The purpose of additional time is to increase the timeout value for the test section, I think we should not overload its usage. As of the current implementation it both increases the wait time for the timer/microtask and also extends the timeout.  Fair point. I can introduce a new parameter and also use this parameter for signaling that runAsync() should not wait for additional futures.  ```dart waitForIdle: const Duration(seconds: 2), ``` I would rather not introduce a new API. I would expect, in the normal case, for users to actually care about the Futures that their widget code introduces in runAsync. They would not be using runAsync otherwise.  We should optimize for that most common case. Once this solution makes it to SO, everyone will simply copy and use them together anyway. The APIs being separate will lose its meaning.  I agree with you that there will be advanced cases where these futures should not be awaited but then we are getting into highly custom test code category. Users can then create a future that they want to await and do that. I will put all this in actionable error messages.  ```dart // Do not wait for idle. await runAsync(() => some code, waitForIdle: null); await runAsync(() => await someSpecialFuture); ```  Another reason: The interplay between the two APIs would need to be carefully covered. For instance what if this happens:  ```dart await runAsync; await resolveTimers; // What if runAsync runs into error. Now the user needs to check return value and make sure there was no error in the async block. // // some code later // await resolveTimers;  // Does this throw? Does it just return? Either option is error prone. ```  Let me know what you think.
I think i agree with most of it, but there are some more concerns i have.  > waitForIdle: const Duration(seconds: 2),  I think we don't need the duration here. this can be a true false value, and the test will either resolve the timer/mt or just timeout the test section.  >I agree with you that there will be advanced cases where these futures should not be awaited but then we are getting into highly custom test code category. Users can then create a future that they want to await and do that. I will put all this in actionable error messages.  I think part of this is also we have some unexposed future in our built-in widget as well (for example the image decoding in Image widget or localization asset loading). unless we expose those future in the widget state, user will not be able to resolve them If they want to test the result after those async load. That is why I kinda want to have a separate api to resolve this future. However, I am ok with not provide an API too since we can use the runAsync. waitForIdle to resolve the future. It just the test code maybe a bit more complicated.  >Another reason: The interplay between the two APIs would need to be carefully covered. For instance what if this happens:  I will expect resolveTimers called without an async zone (not in the runAsync callback) will just throw an error?
I see what you mean now. I thought you were proposing a separate API to await *after* runAsync was done.  Yes, providing a helper function to call inside runAsync callback is tempting. I still prefer the default behavior to be more robust because when things fail today, they fail without giving developers any direction on what might be the problem (such as defining a custom task future to await inside runAsync()).
I will think about this a bit more. Running this PR over google3 broke 24 tests. At least 2 of them were pre-existing bugs in the tests themselves that this uncovered! However, many are due to premature timeouts. Perhaps I will have to do what you are proposing after all @chunhtai and expose the periodic timer as a `Future` for apps to listen on. I will dive deep into some use cases and see what I missed. The good news is there are at least 9000 tests that exercise realAsync and only 24 failed.
Latest results: 10 failures.  - 2 due to pre-existing bugs in tests. - 4 due to the tested code creating a periodic timer that never resolves.    - I am inclined to warn people about this rather than awaiting on them. - 4 due to running *a lot* of tests in a single file. This is the problematic one. Since we now wait up to 500ms to make sure there are no new microtasks created, each test (that uses `runAsync`) is lengthened by half a second which means if you are running 120+ tests, your test now runs at least a minute longer.  Due to #2 and #3, I am now leaning towards your proposal to expose this as a separate method. It would be nice to make the default method more robust but it should not come at an expense of causing half a second delay per test.  I will put in some robust documentation as well so people can make an informed decision on when to use this API.
I think this should default to infinite. For example, how should we pick a right time for this? Either a duration that is super big or a duration that is close to the actual run time. The later will make test flaky.
If this is infinite, this Future will never complete.  This isn't a timeout. It is the length of idle period that we expect to observe before declaring the application as idle.  Suppose we have the following scenario and for simplicity, assume that microtasks are executed as soon as they are scheduled:  ``` microtask1 <--29 ms --> microtask2 < -----------------143 ms -------> microtask3 ```  If we have `expectedIdlePeriod` as 20ms, this function will return after microtask1. If we set it to 50ms, it will return after microtask2 because it will observe that there are no pending timers or microtasks but the amount of time that passed **since** the latest microtask (microtask1) is less than 50ms.  After waiting for ~50ms after microtask2 executed, it will run and claim that enough time has passed. If you set it to 500ms, all three microtasks will need to execute before the application is declared idle.  The longer you set this, the more confident you will be of idleness. However, it will also lengthen your test execution by that much. This is real-time wait.
Ah I see, it only resolve when  delta_time > expectedIdlePeriod and the timer/microtask caches are empty. That is a bit weird though, shouldn't we resolve the future as soon as timer/microtask caches are empty? why do we still want to wait in this case. I was imagining this kind of logic  if (delta_time > expectedIdlePeriod || caches are empty) resolveFuturesCompleter.complete(); else continue;
That was the first approach I tried but it does not work if your microtasks complete quickly but are scheduled by external events (such as network or disk io). That is the normal case.  For instance, if I am listing directories and stat'ing them one by one, this is what you would see in the microtask queue:  ``` 0 milliseconds: start 2 ms: end 15 ms: start 17 ms: end ... ```  For the vast majority of time (e.g. 2 to 15 ms), the queue is empty so you will prematurely think that the program is done.  That's why I had to introduce the idea of "idleness" into the code. Wait for a "silent" period where no microtask is fired. The length of the period is controllable by the user.
nit: I believe we use `*` instead of `-` throughout the code base for enumerations. 
We generally don't want to spam the console with warnings. 
should not -> must not?
document what the parameter does?
Looks like this doc is duplicated. Can this be a macro?
```suggestion   /// Waits for a stable state within a single [runAsync] execution. ```
Nit: sentences should start with a capital letter.
Adding API that we do not recommend to be used seems ... wrong.
> tests might be flaky  Adding another option to make your tests flaky doesn't seem like a good idea.
i understand now. Although we make it more transparent on what is under the hood of async zone, we still have not solve the problem that this api may encourage flakiness. I don't have a good answer neither but I have some other idea that i would like to share.  It is possible to write the resolveFuture to take in a integer number `count`, and the resolveFuturesCompleter will only resolve when there are at least that # of timers has gone from active -> non-active. This way we no longer rely on the duration of the future but the # of the future that should resolve in a test, and that should never change.
I would also love to add "not recommended" to `runAsync` FWIW :-)
I would be against that because it would make the tests really difficult to maintain. Suppose that we did a Flutter roll that changed the internals of PictureRecorder (added a new Future). Now all of a sudden we have to update all the tests and increase this number by 1. It is fairly arbitrary and does not add more insight to developer. They just have to guess the right number.  pumpAndSettle is the same by the way. We recommend that people test the number of frames pumped returned by pumpAndSettle() to make sure they got the right number of frames but in reality, no one does that. It is very difficult to maintain and it can change easily by your dependencies. 
nit: please use `[...]` for things like FakeAsync, runAsync, etc.
(basically everything that can be hyperlinked except parameters)
please see the style guide for writing style for documentation (https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo) -- e.g. "Note that" is against our style.
not sure what this comment means
that's a weird initial value, why that?
prefer `+= 1`
`-= 1`
also, error message should say why
(and what to do instead)
error message should say why
this seems to be encoding a race condition into the test framework, which is a no-no per the style guide
what's wrong with runAsync?
it doesn't matter how long you set it, it'll always be flaky
"note that"
> pumpAndSettle is the same by the way. We recommend that people test the number of frames pumped returned by pumpAndSettle() to make sure they got the right number of frames but in reality, no one does that. It is very difficult to maintain and it can change easily by your dependencies.  pumpAndSettle really only makes sense to test your own widget, it doesn't make much sense when testing something where you don't know how many frames are going to run. In general, app logic shouldn't be triggered on frames, so when testing app logic you shouldn't need to wait for things to settle. Just pump a frame to start animations, and pump a frame with a delay sufficiently later that all the animations are done.
- Zones.. testWidgets() has two zones, which itself is tough to grasp. runAsync within testWidgets ups that to three. Most developers don't understand zones and the side effects are bizarre and difficult to debug. - Makes it too easy to run into synchronization problems which is another thing that's difficult to debug.   Sorry for being generic. I can probably compile concrete examples for these. These are some of the difficulties I myself have run into and seen other developers struggle with.
nit: maybe we should restructure this block a little bit for clarity and lead with "if you're experiencing a hanging test, <reasons why this may be>". I imagine, if you scan the docs for a solution, it is because of a hanging test and you don't know yet that it is because of an un-completed task.
"The fake async environment..."
This method doesn't return a value
This isn't a safe change; most callers assume that the return-value is non-null.
The other way will be somehow prevent everything below the kept alive child from being paint. Let me scratch my head a bit...
This looks OK to me although it would help if the comment explained how we end up applying a paint transform to a child that's not supposed to be laid out or painted.  FWIW, I noticed that RenderFittedBox's applyPaintTransform() also uses transform.setZero() to defeat painting a child.
It is possible that children in the keepAlive list will want to paint themselves.
In such case, we give it => For cases like that, we give the InkFeature children a zero
Should these not be target platforms? for reference TODO on 431.
Actually going the exact opposite direction, target platforms are already super overloaded. Rather than say "hey we're building for ios_armA, ios_armB" we say "hey we're building for ios, with architectures armA, armB"
Ok, that makes sense. I'm thinking that, in terms of the cache refactor, I should re-write these as classes then, so that we can model the hierarchical relationship.
I think for caching we can flatten them back out to strings. But we should update the cache to distinguish between HostPlatform and TargetPlatform if possible
The logic that includes web is kinda weird compares to other platforms. https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/template.dart#L112-L114 As this PR doesn't try to change the logic there, let's add another test to ensure the web related files are not created if web is not requested. WDYT?
Can we just reuse the same method channel implementation in the <plugin_name>.dart and this web class just listen to the channel message?
I don't think so. If I modify the <plugin_name>.dart this script becomes backwards incompatible, right?
I added `unexpectedPaths` to the normal plugin creation (where by default `web` is not requested):  ```dart       unexpectedPaths: <String>[         'lib/flutter_project_web.dart',       ], ```  Isn't that enough?
oh I missed that. that's good enough thanks. 
So we keep the <plugin_name>.dart the same. And the `web.dart` file just listens to the same method channel like other platforms do.
Correct, in this case the web implementation listens to the same method channel. The fact that they both live right next to each other in the directory hierarchy is confusing.   Imagine this `web.dart` lives in a completely separate package, that's another reason why I wouldn't reuse stuff from the "core" plugin. (The core plugin must depend on the web implementation, so the web implementation can't depend on the core plugin, or we'd have a dependency cycle)
Again, my mistake. I was looking at something else. This is good. thanks 
Need to create at the global packages path due to:  https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/test/test_compiler.dart#L136 . IF this wasn't correct we would throw errors after the test finished.
Removes testbed as a smaller incremental migration towards context free
🕵️‍♂️   This was throwing in the packageConfig loader in the loadPlugins way down below
flutterPlatform.loadChannel reads the package config, which was hitting the real filesystem.
missing .packages file, would fail in the loadPackageConfig function. Renamed `fs` to `fileystem` because I can't help myself.
Nit: using `r'...'` would mean you wouldn't need to do so much extra escaping; it's commonly used for defining regex strings.
Actually, a second and more important change: you should make this a multi-line regex and allow for a newline between between the constant string and the ID (and remove the ^ from the start). If someone re-wrapped the file differently (e.g., running an auto-formatter with a long ID) this would break.  Right now it wouldn't matter since this is only used in a test where no editing has happened, but since this isn't test-only code it should be made robust against that.
context => contexts.  Here and in the other copies of this comment
I wonder if the caret metrics cache should just be invalidated whenever the text painter has to relayout and its width cache misses?
not too familiar with the text painter code, just asking because `TextPainter.markNeedsLayout` seems to invalidate the caret metrics cache.
Something like this ~~554a544~~ a86c3c8?  I like the idea, it seems to make a lot more sense and reduce the need for more state.  Let me get a double check from @HansMuller that it seems like a valid idea.
nit: "moves its right edge"
Sounds reasonable to me. 
I'm not sure how any of these passed with a missing file system override, but it looked to be using the real file system sometimes
replaced skip with platform override
nit. can this be `testWithoutContext`?
The fuchsia device still uses context :( 
LGTM then
Remove abbreviation
removed single group
missing file system utils meant this was using the real android studio sometimes
missing home dir would lead to lookup of bogus path. Not sure how it worked
This is troubling...
typo "texture the texture" to "the texture"?
I think both `low` and `none` can scale the texture and bilinear/nearest-neighbor is just the typical behavior instead of the guaranteed behavior (https://api.flutter.dev/flutter/dart-ui/FilterQuality-class.html). Maybe a better documentation is `When the texture is scaled, a default [FilterQuality.low] is used for a higher quality but slower interpolation (typically bilinear). It can be changed to [FilterQuality.none] for a lower quality but faster interpolation (typically nearest-neighbor). See also [FilterQuality.medium] and [FilterQuality.high] for more options.`.
Done
Done
Is this the right path to edit?
GDK? ```suggestion   /// "GTK_KEY_Eject"). ```
Yep, it's wrong. Turns out it wasn't the only case though - https://github.com/flutter/flutter/pull/60015.
GDK is the low-level part of GTK (GDK = Gimp Drawing Kit, GTK = Gimp Toolkit in original naming), so events are in the GDK namespace.
Ahh, OK, makes sense.  I was just pattern matching... 
I would also pass --no-version-check just to be safe https://github.com/flutter/flutter/blob/75fd73d81888966746821e65d37e1fc90dc56bfb/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart#L82
Sorry, landed this while the tree was green. Fortunately, in the command runner we bypass the version check if `--machine` is provided https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart#L82
It might be better to implement a copyWith instead of forcing us to go into flutter_test to make changes.
Change to `The framework was provided a mangled stack trace by a test binding`, the convention for assertion messages is to describe a true but unexpected state, afaik.
We should assert that the stack trace is actually mangled here.
This test can't fail, perhaps you forgot to assert `details.stack` is unmangled.
This part isn't the framework though - it's in the test binding code.
Done
It fails without the change to the test binding - it just not on this expectation. This is just here to make sure the test is doing what we think it's supposed to do.  The failure would come in the framework code where we get a Chain instead of a StackTrace.
Ahh, my bad, it fails in the reportError
I was just confused by the grammar then, specifically the `a` after `unmangled`
Ahh I see I'll clean that up
Done
should we say this on every class with a copyWith?
That's fair, I had this in here before adding copy with. Removing.
Can you add one of those issue references in case it gets lost in history?
Add: "Regression test for <issue link>" here?
```suggestion     // If the scroll offset is at zero, we should make sure we are ```
nit: end with a `.`
```suggestion   // meaning they have been multiplied by the ancesters and are thus relative to ```
```suggestion   // The number of elements (from the head) in `_transforms` that have been ```
Does this work when using 3D transforms? @goderbauer did some work to make sure that our hit tests worked with surfaces that weren't screen aligned (I'm thinking of https://github.com/flutter/flutter/pull/32192, but there may be others), and I want to make sure this doesn't reintroduce that issue.
tiny nit: This could be combined with the previous line.
I would assume these cases have been added to unit tests, which this PR do not break any of. Let me know there is anything else that needs manual testing or needs to be added to unit tests.
Why are we forcing this to null now instead of keeping the original event if available?
Just the assert should be enough, no?
Since we might add more parts in the future, maybe add some short private doc comments to the methods explaining what they are for? That way, if somebody needs to add another part in the future they know what to do.
Why is this method part of the base class if it's only relevant for _MatrixTransformPart?
Why does the matrix part get a convenient factory constructor, but the offset part doesn't?
What's the purpose of this class that just wraps a single value? Can this have a more descriptive name or add a doc comment explaining this a little more?
typo: ancestors
Unless it is faster doing it this way, would the implementation maybe be simplified by just having two separate lists, one with global transforms and one with local transforms? when we need to globalize, we just pop things of the local transform list and add it globalized to the global transform list?
Also, "assert" in the name makes it sound like this should only be used in asserts?
It's guaranteed that the last transform is always of type `_MatrixTransformPart`, which is the only type that implements `assertMatrix`?
Can _transforms ever be empty in the new world? Looks like the list is pre-seeded with the identity matrix and never cleared?
typo: pushOffset
This should continue to work fine even for 3D transforms, as far as I can tell.
Why are we switching this around? Even when it is disabled it should still respond to hovers?
Why do we still need to have a separate hit testing pass for mouse events? Can that not be integrated with the regular hit testing now as well?
Short version: In order to prevent the type system complaining, either we set this to null, which satisfies the current definition of `original`, or we change the type of `original` in the constructor, which also changes the definition of `original`.  Long version: An error will be thrown in this as-cast when converting other event types using `fromMouseEvent` (e.g. from `PointerDownEvent` to `PointerEnterEvent`). This as-cast was not here when this constructor was first created, but is reasonable since the constructor requires `original` to be `PointerEnterEvent`, which also makes sense since `original` was added for the transformed constructor to **transform between coordinate space**. So if we think it this way, this `original` should be null because `original` was not defined to suit in the type converting case.
I would say just the throwing is enough, since this does not make sense in production either (there is literally nothing I can return here).
Because the matrix transform part is special: It is the only kind that we can extract a matrix out of. This is important because ultimately we will need to extract a matrix to get the transform matrix.
This class is used as a reference to a primitive type.  ```dart class MyClass {   _Ref<int> number; }  MyClass a = MyClass()   ..number = _Ref<int>(1); MyClass b = MyClass()   ..number = a.number;  a.number.value = 2; // This also changes b.number.value ```  The reason why this is needed is explained at https://github.com/flutter/flutter/pull/59883/files/6bf779806cdf3329fa8ec42faeec59881668b8fa#diff-cef98733ade736b1a8f03a753c9151f2R160.
Yes. A widget should never turn off the mouse region when it's disabled.  The mouse cursor algorithm detects the first `MouseTrackerAnnotation` found and uses its cursor. If the `MouseRegion` is hidden behind the `IgnorePointer` then the widget will never be able to show its disabled cursor, and the cursor will incorrectly be the one of the widget behind it, as if the `TextField` does not exist. A test that is violated can be found at https://github.com/flutter/flutter/blob/3f4f91532f5959923ed5a25fc0bed83bdd207b46/packages/flutter/test/material/text_field_test.dart#L8170  The reason why this isn't found earlier is probably because `IgnorePointer` and `AbsorbPointer` failed to support mouse events (incorrectly, see https://github.com/flutter/flutter/issues/35213).
This is a really good idea. It simplified a lot of code and is proven to be equal in performance or even faster!
This is removed.
This is removed.
This is removed.
Removed.
Removed.
Without mouse,  * During hover events, no regular hit test is done. * During down events, a regular hit test is done, so this is an extra pass, but down events happen at such a low frequency that we might not really care. * During move events, no regular hit test is done (the result of down events is reused).  Conclusion: The only "extra pass" is the ones at down events, which do not really matter.
nit: typo after pushOffset
This assert is a little odd. Why do we assert after removing that there's still something in _transforms? Shouldn't we assert before?
I am more concerned about the extra code complexity that we have to deal with because the paths are not unified. 
The `_transforms` should never be empty, because there should at least be the pre-seeded identity matrix.  Of course it shouldn't be empty before the operation either, but that would be detected by `removeLast` anyway.
If the mouse device update is triggered by a pointer event, then the code path is indeed more complicated than necessary:  ```  GestureBinding.dispatchEvent -> PointerRouter.route -> MouseTracker._handleEvent -> hit test ``` Maybe we could've done the hit test at `GestureBinding.dispatchEvent` and pass it all the way to `MouseTracker._handleEvent`.  But the mouse device update can also be triggered after every frame, during the post-frame callbacks: ``` SchedulerBinding.handleDrawFrame -> MouseTracker._updateAllDevices -> hit test ``` In this case `MouseTracker` have to initiate a hit test for each device, without the participation of `GestureBinding` at all.   I'm not saying that a much more unified structure can not be achieved at all, but for now I'd rather touch as few things as possible in order to see the performance impact of the current PR.
reporting these as a full error seems harmful as this is much more of a warning than an error. It could be reasonable to add a `FlutterError.reportWarning` to handle this and other cases where we want to add warnings to the framework.   For example, existing errors all indicate that something has gone wrong and the user needs to take action. This just indicates that something might be inefficient. Existing heuristics like truncating all errors after the first error to de-emphasize errors that are follow on failures from other errors would not make sense for cases like this. If you had this error and then a real error then you would want that other error to be emphasized rather than this one which is just a memory usage warning.
should there also be a percentage threshold for this as well where we only warn if both the KB and percentage thresholds are exceeded? It would seem It seems like a false positive if we warned that a 64MB image was rendered in an area that would only require a 63MB but warning that a 2MB was rendered in an area that would only require 1MB would make a lot of sense.
nit: why not take the delta in bytes and only round to kb on display? As written this could introduce some slightly strange rounding errors where warnings would be issued when the size difference was actually slightly less than the threshold. 
make exception a FlutterError object instead of a raw string.
I've shifted this around to avoid some potential rounding issues. I still want the comparison to be in KB because bytes are too small, and my thought is that developers shouldn't be concerned with deltas < 1kb.
This is opt-in - the idea is that if the developer has opted in to seeing it, they want to take action if it happens.   If we had a facility for reporting warnings, that would work fine, but I'd rather not hold this up in trying to develop one and wiring it up in all the right places.  In my terminal, subsequent errors still have enough relevant detail, although it's good they're truncated a bit since you can run into this error on every repaint of the image, which may happen multiple times at the same size. For example, in testing this in a macOS application, I get this over and over again as the mouse moves across the application.
Done
I was considering this, but I think the absolute number is probably more useful for a few reasons:  - The developers likely to use this are working on smaller mobile/embedded devices, and are concerned with KB usage rather than MB usage. - A developer working on a screen with a high enough resolution to show a 64MB image (e.g. a 12MB/4K image) are probably not concerned with this anyway - a machine with that high a resolution will have enough memory where it shouldn't be a big deal.  I was considering whether we could add a percentage, but that seems to complicate the interface. That said, I'm not clear on how this would get exposed to a developer in an IDE/devtools - knowing that might help here.
If we can only choose one approach: either multiplicative (percentage increase), or additive (absolute KB increase), I'd prefer the multiplicative too. Here's a more realistic case for a low-end device: suppose we're showing 100 thumbnails where each image's full resolution takes 100KB, but thumbnail resolution only takes 50KB. An additive threshold of 100KB would not report warning, but together (x100) they use 5MB more memory. A multiplicative 50% threshold would catch that.
I think this is a very useful and actionable warning/error, and I'd love it to be opt-out instead of opt-in if I were developing a Flutter app. (Figuring out what opt-in features to turn on could be a big cognitive cost.)
"tag" sounds to me like "label". The value that we've assigned to it is more like "source". If we document it as "identify the source", why not just call it "source" or "debugSource"? Forgive me if my English understanding is limited...
That's a really good point.  I'm trying to think of a way we could capture both of these:  - A list of small images that together add up to a lot (e.g. a list of even small images that could still be half the size they actually are). - A single large image that, while a small percentage, still adds up to a lot (e.g. a 12MP camera image rendered even at device resolution)  We could add two properties, but that seems harder to manage and reason about to me. We could also probably track the images in a static map, and then check that the whole map doesn't exceed the maximum allowable KB.
I can rename this. I think I was originally expecing this to potentially be an object that might just hold the image cache key. 
It may also be simpler to have two properties (or a complex property) - something for a percentage over and an absolute max. We can figure out how tooling might set that later.
I think we could make it opt-out at some point, but we should start this way so that people have time to fix things without needing a manual roll internally.
Being able to make this opt-in by default would be a great goal. Adding an environment variable like `flutter.imageSizeWarnings` like the `flutter.inspector.structuredErrors` one @helin24 added here could be a good way to achieve that. https://github.com/flutter/flutter/commit/479f370379cc721d399cb8e3c0bcac79d58d17b4#diff-f01fcfe0b7237b22d168496f69be49baR947  Having the environment variable in addition to a service extension is useful as a service extension cannot be set immediately on app startup which means you miss errors that occur before the first frame renders.
I suspect the ideal UI for this is not individual errors but a table displayed in DevTools showing the aggregate unnecessary memory usage across all images and a sorted list of the worst offenders based on a combination of byte delta and ratio of waste.
That seems to lend towards just having a static variable that tracks this, and that we can push to devtools on demand.  I'll tinker with that some more.
great! I think this will be a really useful debugging feature.
So I think rather than two properties, this should work out if we use a percentage but base it on the natural log of the operands. So basically  ```dart if (math.log(displayBytes) / math.log(decodedBytes) >= allowedOverheadPercentage) {  // bad } ```  This should mean that you could pick a fairly reasonable percentage that will more heavily weight towards larger overheads, where it gets more important. WDYT?
that is clever but it would be really hard for users to get a mental model of what it means. I'm not sure I have a good mental model of what value of allowedOverheadPercentage would make sense as a threshold using logs and whether small images and large images are treated in a desirable way. It would be easier to say: we flag images as being too large if one of the following is true: displayBytes is more than X kb smaller than decodedBytes and the percentage increase in size it at least Y or displayByes is more than Z percent smaller than decodedBytes and the # of wasted bytes is at least Q
The criticism is fair. I'm still a bit concerned by the complexity getting introduced here.  Here's another thought:  Rather than having any threshold for this, we just have a method exposed over a VM Service extension to dump this out. We also call `postEvent` with all the details we have when drawing an image.  In an test, you could assert that the total memory overhead is whatever you want it to be. And in devtools, we can offer some kind of visualization of this.
`math.log(displayBytes) / math.log(decodedBytes)` is difficult for me to understand too. It's undefined if `decodedBytes == 1KB`, or negative if `displayBytes > 1KB, decodedBytes < 1KB`.  It would be easier to understand if it were `math.log(displayBytes) - math.log(decodedBytes)`, which is equivalent to `math.log(displayBytes / decodedBytes)`, so there will be a 1:1 mapping between the multiplicative threshold and this log threshold.
yes I agree that this is the sort of threshold that is better to iterate on in devtools than to hard code in the flutter framework. Based on user studies and feedback from users we can probably come up with much better thresholds than what we could guess here. +100 to using postEvent to just dump all images added and removed from the widget tree so filtering and display can be done separately. 
This toString doesn't seem very consistent with Flutter. Maybe remove it or extend DiagnosticsNode to use its functionality for more standard looking toStrings.
Ah yes meant to remove this
this is a nice way of running a vm service test! impressively self contained as long as you can run the vm service against the app you are testing.
This is assuming 16/3 bytes per pixel which is surprising unless I'm missing something (perhaps mip-mapping?).  Can you document why it is `4 * (4/3)`? I would have expected either 4 bytes per pixel or 3 bytes per pixel depending on if you are assuming an alpha channel.
missing comma before displaySize.
Nit: if you'd like to make sure you don't accidentally add an extra space you can write this code like this ```dart [ if (debugLabel != null) debugLabel, image, '@${debugFormatDouble(scale)}'].join(' ')] ``` not sure it is better. 
debugLabel should only be provided in debug build if it is using the debug naming convention.
We have this issue in various places where things named debug have to be available in profile mode. I can guard this with a `if (!kReleaseMode)` - is that what you're getting at?  I'm not sure what a better name for this would be.
Done
Added a comment. The 4/3 is mipmapping overhead, which we turn on if available in the engine - and really it's almost always on, unless you're doing software rendering.
paint a couple identical images as part of this test to verify whether output dedupes or not.
That's what's happening here - as long as they're in adjacent frames, they're getting deduplicated. It's the same image painted twice here.  Are you saying you'd like to see deduplicating in a single frame?
should we use a `Set<ImageSizeInfo>`  or  `Map<ImageSizeInfo, Size>` as we don't really care whether an image was rendered 10 times or 1 time.. We just care what the largest size it was rendered at was. I would expect the # of unique images should be significantly lower than the total # of issues for cases like using an image as a background texture uses multiple places in the UI. I don't have data though.
yes `if (kReleaseMode)` would be good. Can you point me at an example where we have other `debug` fields that are filled in profile mode? The ones I was aware of were all debug build only so I'm curious which ones have made it into profile builds.
yeah I was interested in a duplicate within a single frame as well as on the devtools size we don't care if the same image was rendered multiple times and we only care about knowing the largest size it was rendered at. there might be some edge cases where you have one image rendered in a bunch of places in a frame.
done
Ahh ok - I've reworked it so it will dedupe to the largest image in a frame, and added a test.
Can you add a sentence about this parameter to the doc comment above?
I updated the docstring in general here - there were some old no-longer-existant things in there and some formatting issues, as well as something that's changed about aspect ratio preservation.  PTAL
nit: This is getting hard to read.
Will these overlap? That is, would they ever need to go on the same event or command with different values?
The additional usage parameters should possibly be `Map<CustomDimentions, dynamic>` with a `toString()` before sending over to `package:usage`.  `FlutterCommand` (or elsewhere) could also have some getters for whether experiments are enabled maybe? Other suggestions?
No these don't ever overlap, using the same value SGTM
Added a private List<String> enabledExperiments and simplified the check. Updated to use Object and convert to String in the same place that the enums are converted
nit: use double quotes so you don't have to escape the `'` (I thought it was a lint rule?)
Switch painter in what way?
That's barely over 1 frame. Is that long enough? It looks like it will be jumping between the 4 corners way too quickly, no?
Doesn't Web use a simpler painter (CSS?) for simple widgets, and canvas for more advanced ones? According to my test the performance only regresses when the box has a partial border.  
This duration is actually only used for the `timeStamp` of the event. The actual events are dispatched as fast as possible. The idea is to test the execution time the hit testing function. 
Let's just inline all of these; once they aren't their own file I don't think we gain anything by separating them from the point where they are used.
do we want to exit after this?
The [`exec` command](https://www.computerhope.com/unix/bash/exec.htm) completely substitutes the given command for the current process, so there's no need to exit (it already has exited by invoking the other script).
Also, the final return value is the return value of the other script.
cool
I guess that means we should never reach the other switch cases on MINGW anyway?
What other switch cases?  I mean, no, it'll never even reach the "fi" because it execs the other process immediately.
Not sure if BuildIosFrameworks makes sense here
out-of-order has hyphens as an adjective.  What does "out of order" mean exactly?
Probably spiritually the same as `BuildAarCommand`, right?
Ahh yes, but it would need to be updated to support using BuildInfo the same way that BuildAar does.
Rephrased
Oh right.  I got that work confused with the assemble work.
See https://github.com/flutter/flutter/pull/59874
can you revert the formatting?
the indentations are off
I think the indentation has been changed here, probably due to the use of an autoformatter.  Could you change it back to match the original?
The indentation should align with `assert(child != null),`
Check this indentation too.
Have we already discussed the capitalization of AutoValidateMode vs. autovalidate?  It seems contradictory.
Should we also be deprecating `autovalidate`?  Or planning to deprecate it in the future?  If so, could we assert that autovalidate and autoValidateMode are not used together? As it is, removing autovalidate in the future may be a breaking change even for people that are using autoValidateMode.  Sorry if this was already discussed somewhere in the old PR and I missed it.
```suggestion /// Used to configure the auto validation of [TextFormField] and [Form] widgets. ```
+1, you can do that by not giving a default value to them in constructor but initialize it in the initialization list. We do want to deprecate the autovalidate, but it is causing a third party test failure (they have a more strict linting rule). Thus we have to do a soft transition...
Actualy no. I would suggest `autovalidateMode`.
I was missing this point, thanks.
@chunhtai do you have any suggestion on this?
I am not sure what the question is. What is the contradictory here?
I'm talking about the capitalization: autovalidateMode vs autoValidateMode
I vote for autoValidateMode. The autovalidate we used before seems like a typo to me. We might as well fix it now if we are going to introduce a new property.
Make sense.
Sorry, to be specific, I think we just choose only one of the following for our capitalization to be consistent:  1. `AutoValidateMode autoValidateMode;`  or  2. `AutovalidateMode autovalidateMode;`  But we should not mix/match between these two options.  The original parameter is `autovalidate`, which seems to align with option 2.
```suggestion          autovalidate == true && autoValidateMode == null ||          autovalidate == false && autoValidateMode != null,          'autovalidate and autovalidateMode should not be used together.' ```
```suggestion          autoValidateMode: autovalidate              ? AutoValidateMode.always              : (autoValidateMode ?? AutoValidateMode.disabled), ```
Are the order of operations going to work out correctly there without any parenthesis?
We seem to be the only framework that uses autovalidate while all other uses autoValidate. That makes me wonder if this is a typo or not.
Is it possible for autovalidate to be null at this point?
```suggestion          autovalidate == true && autoValidateMode == null ||          autovalidate == false && autoValidateMode != null,          'autovalidate and autovalidateMode should not be used together.' ```
```suggestion        assert(          (maxLines == null) || (minLines == null) || (maxLines >= minLines),          "minLines can't be greater than maxLines", ```
```suggestion        assert(          !expands || (maxLines == null && minLines == null),          'minLines and maxLines must be null when expands is true.', ```
As @chunhtai said this seems a typo and since we are about to deprecate `autovalidate` parameter I think it is time to make things right.
Thanks, I think this indentation is weird on master.  Looks better now.
```suggestion        autoValidateMode: autovalidate            ? AutoValidateMode.always            : (autoValidateMode ?? AutoValidateMode.disabled), ```
```suggestion        assert(          autovalidate == false && autoValidateMode == null ||          autovalidate == true && autoValidateMode == null ||          autovalidate == false && autoValidateMode != null,          'autovalidate and autovalidateMode should not be used together.'        ), ```
```suggestion        autoValidateMode = autovalidate            ? AutoValidateMode.always            : (autoValidateMode ?? AutoValidateMode.disabled), ```
```suggestion   /// If [AutoValidateMode.onUserInteraction], this form will only auto-validate   /// after its content changes. If [AutoValidateMode.always], it will auto   /// validate even without user interaction. If [AutoValidateMode.disabled],   /// the auto validation will be disabled. ```
Could there be any performance concern with this? Do we ever have forms with many many fields?  @chunhtai   This is probably ok, I just wanted to flag it.  I imagine it would be possible to check only the field that has changed here, but it might not be worth it.
```suggestion        assert(          autovalidate == false && autoValidateMode == null ||          autovalidate == true && autoValidateMode == null ||          autovalidate == false && autoValidateMode != null,          'autovalidate and autovalidateMode should not be used together.' ```
```suggestion        autoValidateMode = autovalidate            ? AutoValidateMode.always            : (autoValidateMode ?? AutoValidateMode.disabled), ```
I'm on board with that 👍 
Though, just above I see that we also have `autofill` and not `autoFill`...
autofill and autofocus seems like a validate word (by doing a google search). I can see people use it as a word, however, i couldn't find much usage of autovalidate as one word on the website. Maybe the word is more rare than autofill and autofocus, so people don't use it as much which make it not a word?
talked with @justinmc offline. We are both leaning toward using autovalidate now because all other auto- properties use lower case. It is not correct to defer the decision to the internet usages, because internet is known for its inconsistency, and that will make things complex. We should prefer a more unified API across the flutter app.
Great.So I will rename it to `autovalidateMode`. Is that right?
That's right, `autovalidateMode` and `AutovalidateMode`.
It does exactly this: it checks every element in the list and stops if it found that `_hasInteractedByUser ` is true or else keep checking until the last element.
One option would be to make the FormFields to update a property in the Form, this would prevent to iterate the whole list.
You mean `autoValidateMode`? yes, if `autovalidate` is false or true it will be null at this point.
Humm, I just noticed that we don't have any assertion that prevent `autovalidate` for being null.
Yes, I meant that `autovalidate` could be null.  @chunhtai Would it be ok to add an assertion that autovalidate is not null, or do we not want to potentially break users that are deliberately passing `null`?  It has a default value.  It seems like not asserting originally was a mistake.
> Yes, I meant that `autovalidate` could be null. @chunhtai Would it be ok to add an assertion that autovalidate is not null, or do we not want to potentially break users that are deliberately passing `null`? It has a default value. It seems like not asserting originally was a mistake.  Yes and TextFormField that also extends from FormField has a assertion fo this parameter. I already added the assertion for the DropdownButtonFormField widget.
I think adding assertion probably won't be a breaking change because i doubt that will break any test.
```suggestion        assert(autovalidate != null),        assert(          autovalidate == false ||          autovalidate == true && autovalidateMode == null,          'autovalidate and autovalidateMode should not be used together.'        ), ```
```suggestion        assert(          autovalidate == false ||          autovalidate == true && autovalidateMode == null,          'autovalidate and autovalidateMode should not be used together.'        ), ```
```suggestion        autovalidateMode: autovalidate            ? AutovalidateMode.always            : (autovalidateMode ?? AutovalidateMode.disabled), ```
```suggestion        assert(autovalidate != null),        assert(          autovalidate == false ||          autovalidate == true && autovalidateMode == null,          'autovalidate and autovalidateMode should not be used together.'        ), ```
```suggestion        assert(autovalidate != null),        assert(          autovalidate == false ||          autovalidate == true && autovalidateMode == null,          'autovalidate and autovalidateMode should not be used together.'        ), ```
I just realized that this comment is duplicated in a few different places in this PR.  Can you use a macro to avoid the duplication?  See https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/form.dart#L104 for an example of using a macro, and look for `@template` for an example of defining the template that the macro uses.
This might be a problem when there are a lot of fields, since it will be called on every key pressed.
What are the cases where _hasInteractedByUser gets set to false?  I guess when reset is called, but when else?  Maybe we could make an optimization like this:  ```dart if (!_hasInteractedByUser) {   _hasInteractedByUser = _fields         .any((FormFieldState<dynamic> field) => field._hasInteractedByUser); } ```
Is this a example of creating a template? https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L1092  If yes is `flutter.widgets.subscriptions` the name of the macro or in this case it is just pointing into another macro?  
Yes to both questions.  Sorry for being vague.  So something like this:  ```dart /// {@template flutter.widgets.form.autovalidateMode} /// Your reusable docs from above /// {@endtemplate} ```  Then reuse it in other places with this:  ```dart /// {@macro flutter.widgets.form.autovalidateMode} ```
Got it. Thank you
I'm wondering if this is the right macro name. I mean the main comment is placed inside the `FormField`widget so I thing the macro name would be: `flutter.widgets.form.formfield.autovalidateMode` or something similar. is that right? or in the macro name we just need to point the filename and the property name?  I'm interested to know more about macro. @justinmc do you have any resource to read about it?
I believe this is the actual docs for macros in dartdoc: https://pub.dev/packages/dartdoc#macros  As I understand it, the name is just a string to dartdoc.  Flutter has a convention of using a dot-separated hierarchy, but it doesn't matter to dartdoc.  I think you're probably right that `flutter.widgets.form.formfield.autovalidateMode` is a better name, but it should work either way.
The naming convention seems to not be mentioned in Flutter's style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
The PR will be merged when the tree is green, but let me know if you want me to wait instead!
Thanks. That said I think I made all the changes. Let me know if there is something else to be done.
This may be nit picking, but what if the _hasInteractedByUser is set to true due to one field has change, and later on the field get reseted? I believe the form will still autovalidating in this case. This may be an ok behavior, but we should mention it in the documentation.
Good catch!
Wow, lets just revert this for now.
instead of keeping track of a bool, can we keep track the number of field that is dirty? when ever a field become dirty or not dirty, we update that number  +1 or -1. The auto validate in the form will just be number>0
Or could _fieldDidChange receive some extra information to make this easier?  Like maybe the field(s) that changed, or maybe a bool indicating if it was a reset or not.
> Or could _fieldDidChange receive some extra information to make this easier? Like maybe the field(s) that changed, or maybe a bool indicating if it was a reset or not.  I like the _fieldDidChange receiving extra information approach because with this will be easy to extend this feature with validating only the field that has changed in the future (I mean if necessary).  Edit: And here https://github.com/flutter/flutter/blob/620eb27fb80309c7f8cf88f9d90e80cf79f69f50/packages/flutter/lib/src/widgets/form.dart#L225-L230 ~~we will not need to update the boolean property we will just need to check if _fieldDidChange parameter is null means that no form field has changed (the information of the changed form field will be null in this case).~~  Since all the form fields have changed We will just  set _hasInteractedByUser to false and don't provine any FormFieldState into _fieldDidChange().
I also would like to point out the following scenario if form has two textformfields, t1 and t2, and the form has autovalidate.onUserInteraction.  If user type in something in t1, the entire form starts to autovalidate. What should happen when the user reset the t1? should we still autovalidate the whole form, or should we stop autovalidate?
I feel like it would be nice if we stopped autovalidating in that case...  If we do that, we'd need some more logic here. Like when _hasInteractedByUser is true and changedFieldState._hasInteractedByUser is false, then we do the whole check of all fields like we were doing previously.  I wonder what everyone else thinks, though.
One way to implement that is by keeping track of number of dirty field as i mentioned in previous thread. I actually ok with either scenarios, just need to make sure we document that.
> I also would like to point out the following scenario if form has two textformfields, t1 and t2, and the form has autovalidate.onUserInteraction. >  > If user type in something in t1, the entire form starts to autovalidate. What should happen when the user reset the t1? should we still autovalidate the whole form, or should we stop autovalidate?  nothing will happen witht he Form and t1 will behave as if the user just entered in the form page.
I don't any problem with this approach right now, since we all agree that when a form field changes we auto validate the whole Form widget.
 > nothing will happen witht he Form and t1 will behave as if the user just entered in the form page.  Do you mean the form will not autovalidate after the t1 is reset? The current code does the opposite.
> > nothing will happen witht he Form and t1 will behave as if the user just entered in the form page. >  > Do you mean the form will not autovalidate after the t1 is reset? The current code does the opposite.  I mean it will auto validate after one of the form fields change again.
Is this an issue?
> I mean it will auto validate after one of the form fields change again.  The current code will keep validating even if the dirty field gets reset 
Maybe I don't understand you right. My thougts is that if a form field call reset() isn't normal to validate it again if its content changes?
That is different scenario. Touching a field that was reset before should start autovalidate. That is correct and our code does that.  The scenario i talked about was if a form started autovalidate due to one form field is dirty. What should happen if that dirty form field is reset? Our current code will make form still validating in this case.
What do you mean by dirty state?  Please let me try to reproduce this issue, I might have a feedback tomorrow.
for dirty, i meant user has typed in something.
@chunhtai I think I get what is the problem. So what we need to do is to prevent the form to autovalidate a field that was reseted?
Yes.
~@chunhtai can you please take a look a t this gist:~ https://gist.github.com/pedromassango/edb4b3d2fdef8524e7a2e6f1d664aee7  ~I created it to try to reproduce the problem. Can you check if the code there reproduces the issue?~  Edit: I reproduced with the above Gist by: type something in the first field then reset the first field and then type something in the third field. I noticed that the first form (that was reseted) was also validated. 
I think the problem is that when you type in something in the first field and reset the first field, at this moment nothing should be dirty and all fields should be cleared. the fact that only the first field is not validate is weird. Also if you rebuild the entire form the first field starts to validate again.  You can try this gist https://gist.github.com/chunhtai/09cace012092ace597cb8efb0189c96b type in something in first field, click reset form field and then click rebuild form.
> at this moment nothing should be dirty and all fields should be cleared.  I think this is not true because we only reset the first field not all the fields. If I reset one field I expect only that one to be reset not all the others.
> You can try this gist https://gist.github.com/chunhtai/09cace012092ace597cb8efb0189c96b > type in something in first field, click reset form field and then click rebuild form.  I solved this issue by notifying the Form widget when a field call reset. I'm wondering if this is a valid fix. Anyway I will push the changes so that you can test using your Gist:   Type in something in first field, click reset form field and then click rebuild form. Then, expect the first form field to not being validated.  Edit: Also let me know if this is a valid fix so I can write a test case for it.
what if both field 1 and field2 have been touched by user and field1 is reseted? The correct behavior is the entire form should still validate because field2 is still dirty. but this pr makes it not validate in this case.  >I think this is not true because we only reset the first field not all the fields. If I reset one field I expect only that one to be reset not all the others.  but all other fields have not been touched by the user. That means all fields are clean. Why do we still validating the form in this case?
@chunhtai this make sense. I created a method to auto validate only the fields that was chaged. So it currently ony validate the changed fields. Does this is a good solution? Or we must validate all the fields once one changes?
Or maybe we can have one more options in the `AutovalidateMode` class: - `onUserInteraction` - ... in the Form widget this validate fields that has change. - `validateAllOnUserInteraction` - Used in Form widget to validate all fields in the Form if one of them changes
I prefer not to introduce a different mode for this since validateAllOnUserInteraction only make sense for form, we need to deal with the case developer use this mode for field.autovalidatemode.  The `AutovalidateMode.onUserInteraction ` should validate all fields in the Form if one of them changes  If the developer wants the behavior where the Form widget only validate fields that has change. they should just set the autovalidateMode on all the individual fields.
> If the developer wants the behavior where the Form widget only validate fields that has change. they should just set the autovalidateMode on all the individual fields.   I clearly understand you. But I think that we need to consider that some developers see the Form widget as a way to validate automatically a group of fields, and by your sentence we are about to ignore this and maybe making the Form widget useless.  
That is possible, but we can always add that back if people really want a separate mode(even if they can still achieve it with a bit more code).  We can also document the behavior in the form widget and say if you want to only validate the changed field, you should set the autovalidate on each field. I feel we should not make it available now until there are strong enough demands considering it may potentially makes the api confusing (Why there is a AutovalidateMode that can only be used in form widget but not formfield widget?).  Would like to also hear about what @justinmc think.
Here's how I see it:    * Typing in any field within the form should set _hasInteractedByUser to true for both the form and the field that was typed into, but not other fields in the form.   * Resetting the form should set _hasInteractedByUser to false for the form and for every field.   * Resetting a field in the form should set _hasInteractedByUser to false for the field only, and if the result is that all fields in the form now have _hasInteractedByUser set to false, then the form should also set its _hasInteractedByUser to false.  Given this information, for the case that a Form is set to AutovalidateMode.onUserInteraction:    * The entire form should be validating whenever _hasInteractedByUser is true for the form.   * Therefore, when a form is validating, it's possible to stop it from validating by either resetting the entire form, or by individually resetting each field that has _hasInteractedByUser true.  ### How to implement this behavior, the easy way with poor performance The only reason that this behavior is complicated is because we are storing duplicate state.  The Form's _hasInteractedByUser is derived from the _hasInteractedByUser of all its children and could be written like this:  ```dart get bool _hasInteractedByUser = _fields.any((FormFieldState<dynamic> field) => field.hasInteractedByUser); ```  I know that I'm the one that flagged this as having poor performance, but what if we did this every build instead of every onChange? See my changes to this PR here: https://github.com/justinmc/flutter/commit/ef9c7bc9d9ca0efbcdd9ca8f6095b584867a3a13  If not, I'm starting to think that maybe we can just accept the performance hit and write a new issue to improve this later.  It's certainly possible to optimize this, but we could do it separate from this PR.  Most important is to get the behavior right first.
I definitelly agree with all that you said. I think this is the way to go then.
@chunhtai brought it to my attention that the build method will be called even more frequently than onChanged in my commit that I linked above 😞. Maybe we should just go back to saving _hasInteractedByUser as a bool that's calculated in _fieldDidChange.  Then open up another issues to revisit performance later.
Do I need to do anything else?  Cc: @chunhtai 
I think this is last thing required to merge this pr
@chunhtai I reverted some changes. Please let me know if there is something else to be done.
we may need this here ```dart Form.of(context)?._fieldDidChange(); ``` 
I removed it because it wan't there before.  Since it is not required for this feature I though that it is better to remove it for now and add in the next PR when making performance improvements.
This not a performance improvement but a corner case i just discovered. A field reset need to notify the form to recalculate its _hasInteractedByUser and rebuild. otherwise,  the form will keep validating all its fields.
Done
Do we expect 99% of people to care? If not, I don't think we need to make this configurable in the template; title and initial size were only done because it was so common for people to want to set them. In general, if someone wants to configure the template, the right way to do it is for them to just change the code once it's generated.  (In fact, we should remove window_configuration.cc at this point, and fold it into the files that set it, since we aren't expecting any more nuke-the-whole-folder breaking changes.)
I would say most people don't care, and the ones that do will just modify the generated code. So I'll happily remove the boolean.
@GaryQian I wonder why do we need _textPainter.inlinePlaceholderScales? aren't they always the same as textScaleFactor?
I believe that in actual use cases, it is indeed true, but it is also possible (at lower levels) to independently set them. This may or may not be necessary at this level, I can look into it to see if it is safe to remove.
The scales are added into the list through WidgetSpan.build() which gets its value from the textScaleFactor. I couldn't find a possible way to have a different textscalefactor.
Can we add logging, or metrics for this?
if that string is not a valid path, `Uri.file()` will throw. I'm thinking we should catch that, especially since we're re-constructing the absolute path.
For those of us on Macs, can you also ignore [`.DS_Store`](https://en.wikipedia.org/wiki/.DS_Store)? ``` 00:03 +0 -1: Check template manifest is up to date [E]                                                                                                                                 Expected: empty     Actual: Set:[               Uri:templates/.DS_Store,               Uri:templates/app/ios-swift.tmpl/.DS_Store,               Uri:templates/module/ios/library/.DS_Store             ] ```
Noooo
I always forget about .DS_Store
oh wait, nvm. i see the manifest is checked in.
```suggestion   /// the button is focused, hovered, or pressed. ```
Does it make sense for these MaterialStateProperty lerp classes to be their own public API? Perhaps down the line
Should this be read from the themeData.splashFactory instead?
```suggestion /// [ThemeData.containedButtonTheme] property. ```
```suggestion ///  * [OutlinedButton], a [TextButton] with a border outline. ```
Delete new line here
```suggestion   /// [OutlinedButton], one could write: ```
I think OutlinedButton padding should follow ContainedButtons (16 not 8)
I think OutlinedButton padding should follow ContainedButtons (16 not 8)
Why not use `Colors.black` here
Why not use `Colors.black` here
This should use the same padding as OutlinedButtons with Icons, (12 leading and 16 trailing)
```suggestion   /// [ThemeData.outlinedButtonTheme] is used. ```
I believe for TextButtons with Icons, this padding is incorrect. I think it should be 8 leading/trailing
Duplicated from above with only materialTapTargetSize changed, could be extracted into an inner function?
I didn't see a corresponding test like this in contained button tests
Should there be a test for all 3 buttons that confirms the behavior of:  ``` foo.style ?? theme.style ?? defaultStyle ```
Same comment as ContainedButton's test, could put this into an inner function to avoid duplicating
It might, we'll have to see if the pattern crops up again.
Yes. We're going to need to provide a way for developers to simply configure a theme based on a ColorScheme that uses the 2018 text styles and the InkRipple splashFactory. 
You're right, will fix that.
Good point, done.
Yes, done.
Added one.
'container' may be confused with the `Container` widget? Perhaps 'A simple set of visual properties that most buttons have in common.'? Or maybe 'group' instead of 'set'? Not a huge deal one way or the other.
Nice examples here.
While it is typically used instead of the textStyle color, when is it not? Might be good to specify when it is and isn't (unless it is more confusing to explain than use :smile:).
Is this necessary with the `other is ButtonStyle` check below?
Nice, succinct description!
`ThemeData.textTheme` and `ThemeData.colorScheme`.
So is the difference between `defaultStyleOf` and `themeStyleOf` that `defaultStyleOf` provides the default style for a given subclass, where the `themeStyleOf` can override the defaults for a given instance of the class? 
Nit: might want to break up to multiple lines for readability. 
Is the reason for having this class not just be a `ButtonStyle` is because we would want to a place for future parameters that are not part of the style but are specific to the `OutlinedButton`?
```dart       mouseCursor: t < 0.5 ? a.mouseCursor : b.mouseCursor, ```  Should we make a function for this pattern?
Is there any case where `textScaleFactor` can be 0?
Should it be ```` /// ``` ```` (with a space)? (Same for a few other occurrences in this PR)  https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/foundation/diagnostics.dart#L410
`themeStyle` is omitted. Is this because `defaultStyle` uses the same `visualDensity` and `tapTargetSize` as `themeStyle`? https://github.com/flutter/flutter/pull/59702/files#diff-d5a6a7e71470fb01469989a4553e89adR250  Could `themeStyle.visualDensity` and `defaultStyle.visualDensity` diverge in the future? If they might, it make sense to use `widgetStyle?.visualDensity ?? themeStyle?.visualDensity ?? defaultStyle.visualDensity` here, so that later we don't forget it. 
I think the following form is clearer (same for the other two `final double gap`s):  ```dart     final double gap = lerpDouble(8, 4, (scale - 1).clamp(0, 1)); ```
We also need to test copying with / merging two different `ButtonStyle`s.
I understand that it's necessary.  In the long term, I think it makes sense to introduce, say, a `Lerpable` mixin, so that we don't have to write duplicate code. Such a mixin can also handle `null` on its own.  What do you think?
The "widget ?? theme ?? default" pattern shows up a bit often (see below), so you can use the following form to reduce some duplicate code:  ```dart     T effectiveValue<T>(T Function(ButtonStyle style) getProperty) {       final T widgetValue  = getProperty(widgetStyle);       final T themeValue   = getProperty(themeStyle);       final T defaultValue = getProperty(defaultStyle);       return widgetValue ?? themeValue ?? defaultValue;     }      T resolve<T>(MaterialStateProperty<T> Function(ButtonStyle style) getProperty) {       final T resolvedValue = effectiveValue(         (ButtonStyle style) => getProperty(style)?.resolve(_states),       );       assert (resolvedValue != null);       return resolvedValue;     } ```  There is a slight difference, though: in your original version, we assert `getProperty(defaultStyle)` is non-null, but the final result could still be null (if `defaultValue` is a non-null object that always resolves to null). Here, we assert that the final value returned is non-null. You can still edit this code to suit the requirements.
Using the suggestion above, this becomes: ```dart         return effectiveValue((ButtonStyle style) => style?.overlayColor?.resolve(states)); ```
Using the suggestion above, this becomes: ```dart         final VisualDensity resolvedVisualDensity = effectiveValue((ButtonStyle style) => style?.visualDensity);         final MaterialTapTargetSize resolvedTapTargetSize = effectiveValue((ButtonStyle style) => style?.tapTargetSize); ```
Also, there's an extra space on L246 but the three `=`'s are not aligned.  
Done.
Done
Done
Done
Done
You're right, and that's what the spec says:  ![Screen Shot 2020-06-26 at 11 04 20 AM](https://user-images.githubusercontent.com/1377460/85887505-cd938600-b79c-11ea-9ad3-44d4e9b1efc6.png) 
Done.
Done.
Done.
Done.
I changed it to "visual properties that most buttons have in common"
Done
Yes
Done
That's a possibility, but the real reason was just to conform to the naming conventions for component themes and their configuration data classes.
I qualified a bunch of the API doc in this class with "typically" because it's up to the subclasses and even though the subclasses I've defined are typical, there's no reason to assume that all subclasses will be.
I think the two tests mean something slightly different. This test proves that `this` and `other` have the exact same type.  The `other is ButtonStyle` is weaker, since other could be a ButtonStyle subclass.
Do you think something along these lines could work to save a few lines of code?  ```dart class _LerpProperties<T> implements MaterialStateProperty<T> {   const _LerpProperties(this.a, this.b, this.t, this.lerpFunction);    final MaterialStateProperty<T> a;   final MaterialStateProperty<T> b;   final double t;   final T Function(T, T, double) lerpFunction;    @override   T resolve(Set<MaterialState> states) {     final T resolvedA = a?.resolve(states);     final T resolvedB = b?.resolve(states);     return lerpFunction(resolvedA, resolvedB, t);   } } ```  Then the calls could look like:  ```dart static MaterialStateProperty<TextStyle> _lerpTextStyles(MaterialStateProperty<TextStyle> a,    MaterialStateProperty<TextStyle> b, double t) {     if (a == null && b == null)       return null;     return _LerpProperties<TextStyle>(a, b, t, TextStyle.lerp);   }  ``` 
And actually, if that _did_ work, then you would be able to condense some of the methods above.  Something like:  ```dart   static MaterialStateProperty<T> _lerpProperties(MaterialStateProperty<T> a, MaterialStateProperty<T> b, double t, T Function(T, T, double) lerpFunction ) {     if (a == null && b == null)       return null;     return _LerpProperties<T>(a, b, t, lerpFunction);   } ```  And above you would do something like:  ```dart  return ButtonStyle(       textStyle: _lerpProperties<TextStyle>(a?.textStyle, b?.textStyle, t, TextStyle.lerp), ```
These two constructors end up being very similar. Do you think it would be reasonable to consider combining `ContainedButton` and `ContainedButton.icon` into one constructor? The constructor could have an optional (nullable) `icon` param, that, when non null, will place itself alongside `child`? 
nit: double space here and the one below  ```suggestion class _ContainedButtonDefaultBackground extends MaterialStateProperty<Color> with Diagnosticable { ```
I agree, in fact I'd written it that way. I changed it because the analyzer complained and I wasn't able to find a nice way around the complaint:  ```   error • The argument type 'num' can't be assigned to the parameter type 'double' •          packages/flutter/lib/src/material/contained_button.dart:419:41 • argument_type_not_assignable ```  I believe it's complaining because clamp returns a num, not a double. Introducing another line of code didn't seem to make the statement simpler either, so ... 
It's true that it's very common, however I'm not sure a function call would make it easier to read. If we were going to use a function for this kind of lerp statement, we'd have to apply it across the whole framework. That would be a different PR.
Good question. The documentation doesn't specify any limits: https://api.flutter.dev/flutter/widgets/MediaQueryData/textScaleFactor.html  The code handles all possible values, so there's no need to assert that its `>= 0` here.
Yes, good point.
Good catch! That was a mistake. It also implies that I need more tests.
Done
I've updated the code per MH's suggestion, https://github.com/flutter/flutter/pull/59702#discussion_r446395569  It's not a mixin, but it does eliminate much of the boilerplate.
Both suggestions are nice boilerplate reducers, I've incorporated them.
FWIW, the Foo and Foo.icon constructors are how this was factored before. We're not trying for API compatibility here, so there's no need to include the factory again. On the other hand, Foo and Foo.icon have different defaultStyleOf overrides because their default padding is different and because the padding's dependency on textScaleFactor differs. This and the difference in how the child is handled could certainly be blended together into one build method, but separating the two cases with a class (albeit a private one) simplifies that a little. 
I added a few additional copyWith/merge checks.
This is a nice way to factor the code, I've used it. The new version is even more closure-intense than the old one, hopefully the compiler will see how all of that can be flattened out.
I've added basic tests for all three new themes. 
@HansMuller What about let the user provide the minimum width/height as in the old buttons. I know we can always wrap it in a SizedBox but I think it would be great to have that option.
Also, this can avoid one more wiget in the tree :)
Specifying a minimum size is still supported: the `resolvedMinimumSize` you're referring to is based on the button style's minimumSize: https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/material/button_style.dart#L160   
I meant the Widgets that depend on this one does not have a way to provide a custom size like the `ContainedButton` and `OutlinedButton` they does not have a `height` or minWidth property for example, just like the old buttons.
It's true that the new buttons don't have explicit width or height parameters. However one can specify the minimum size for an individual button:  ```dart TextButton(   style: TextButton.styleFrom(     minimumSize: Size(100, 100),   ),   child: Text('I am at least 100x100') ) ``` For a fixed size button, you're right that it would be necessary to use a SizedBox: ``` TextButton(   child: SizedBox(    width: 100,    height: 100,    child: Text('I am 100x100'),   ), ) ``` 
Size is now parte of the button style? Is the last piece of code valid? I mean you set the size for the child instead of the whole button widget.  I need to try this :)
I think we can take advantage of the possibility of passing the widget size on its parent widget to allow users to customize the widget without the need for another widget.
The `minimumSize` is part of ButtonStyle (it was part of the ButtonTheme too, see https://api.flutter.dev/flutter/material/ButtonThemeData/constraints.html).  The second example produces a fixed size button, although it's not exactly 100x100 because padding. 
Sounds right. Thank you.
I'm not sure how this line could be reached because the spawned function will either return something or throw. The `dart:isolate` doc doesn't say too much about when and how onExit is used and interact with other ports.
This change broke a `compute` function for us, which returned null, starting in Flutter 1.20.x. I assume this is resolved by enabling the nnbd feature and returning an optional via compute?  
Do you have nullsafety enabled on your project?
@a14n no.
This should be fixed by #63515
nit: ```suggestion   testWidgets('ExpansionPanelList respects dividerColor', (WidgetTester tester) async { ```
nit: ```suggestion   testWidgets('ExpansionPanelList.radio respects DividerColor', (WidgetTester tester) async { ```
nit: trailing comma ```suggestion       ), ```
nit: slightly more description ```suggestion     // For the last DecoratedBox, we will have a Border.top with the provided dividerColor. ```
nit: slightly more description ```suggestion     // For the last DecoratedBox, we will have a Border.top with the provided dividerColor. ```
You missed updating the rest of the numbered list :)
Fixed, accidentally removed point 2
:+1: 
Thank you for updating this!
The `0.135` coefficient is actually accurate.  You can verify this in a native `UIScrollView` (or `UITableView`) by adding the following code to its delegate and flinging the scroll view:  ```swift func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {   let actualTargetVerticalOffset = targetContentOffset.pointee.y   let computedVerticalOffset = scrollView.contentOffset.y - (velocity.y - 0.01)/(log(scrollView.decelerationRate.rawValue))   print("actual target vertical offset: \(actualTargetVerticalOffset), computed from velocity: \(computedVerticalOffset)") } ``` The computed value is going to be very close to the actual content offset (but not exactly the same, I guess there's rounding/flooring happening in the actual implementation, so the final value snaps to physical pixels).  The default `scrollView.decelerationRate` value is 0.998 ([`.normal`](https://developer.apple.com/documentation/uikit/uiscrollview/decelerationrate/1619415-normal)), but the velocity is in a different unit here in `scrollViewWillEndDragging` (pixel per millisecond I guess), thus the 0.135 (0.998^1000).
The velocity we use to create the ballistic activity is responsible for the most content offset error here.
Is there a better place to export this?
This seems like the best option in lib/*.dart
Could combine these if statements  ```suggestion       if (focused && _focusedDay == null) { ```
Should the whole grid be colored for focus vs just applying the color to the focused day?
What is the reason for moving this into the PageView?
Could `oldWidget` not be strongly typed to `_FocusedDate` like I've seen in other InheritedWidgets? Then you wouldn't need to check the type
I believe we should always call super first (Except for `dispose`)
Call super first
Perhaps an RTL test would be useful?
Not sure, but it was how the original Android date picker handled this. As the navigation in the grid is a little different (you only use the tab to go in and out of the grid), it seems like a good way to indicate that. 
I wanted the headers to scroll with the days, so you could keep their context while they were scrolling. Looking at the spec, they have the headers moving with the dates as well (in addition they also have the nav controls scrolling, which seemed wrong to me). 
Yup. Good catch. Thx. 
Indeed it would. Added.
Gotcha, sounds good
Looks like you are right about the spec, but yeah I agree that the nav controls shouldn't scroll
ues => use
When would both `date != oldWidget.date` and `utils.isSameDay(date, oldWIdge.date)` both be true?
` { TextDirection textDirection = TextDirection.ltr },`
It is `!utils.isSameDay(date, oldWidget.date)`. It should return true if the date is different than oldWidget.date. This is a convoluted way of saying that though, so I moved some null checking into the `isSameDay` code to simplify this to just:  ```dart return !utils.isSameDay(date, oldWidget.date); ``` 
@goderbauer thoughts on this API change? It seems likely to be non-breaking. I could instead create a mocked window ... but this seemed more straightforward
Instead of adding the extra slightly awkward one-off API, could you just do the following in `app.dart`?  ```dart MediaQueryData data = MediaQueryData.fromWindow(WidgetsBinding.instance.window); if (!kReleaseMode) {   data = data.copyWith(platformBrightness: debugBrightnessOverride); } ```
How do you use it "through the [BindingBase]"?  As implemented, it appears to be a debug setting in the widget layer, determining what brightness the MediaQuery of WidgetApp inserts into the tree, no?
I guess it isn't really true - maybe "Used by MediaQuery to override the platform brightness?"
Sounds better, we should probably move it to widgets/debug.dart then since its more a debug setting of that layer?
Ahh, I missed the existing `copyWith` method - that seems more straightforward
I wasn't sure, the window is exposed through BindingBase which is where the Brightness comes from. If one was hypothetically depending only on foundation, it would not be usable if the brightness was in the widget layer
Ah, that's fair. If we add some more documentation to this property here I am OK with leaving it where it as.
nitty nit: missing a `.`
Maybe just say "See also:" since that's our style. You could incorporate this half-sentence into the explanation after the `[WidgetsApp], which` below.
Is this just no longer a thing - or why remove it?
its not a thing
Can dark be tested?
I didn't know what "[brightness](https://api.flutter.dev/flutter/dart-ui/Brightness-class.html)" meant, maybe 'Toggle the platform brightness (dark and light mode).'?
Good idea, fixed
I can't actually change the value in this test or I'll trigger reassemble and break the test framework. I will update the integration test
the integration test now confirms both brightness settings and that a bogus value does not change anything
Can you add a comment that this is purposely bogus?  It looks like a bug in the test.
Done
Done
nitty nit: just leave the `.toString()` on this line? Looks so lonely on the next.
maybe add that it only uses it in debug mode.
Gave it some friends
Done
Are the changes in this file related to deferred loading?
Yes. It was quite hard to pin this down. If you look at the description of the PR you can see the full details.  The TLDR is that this change is needed as the `Localizations` widget rebuilds itself after localizations have loaded. This change ensure that all of the printing widgets in the test will wait for all localizations to load first.
nit: adjust this to our style for constants?
nit for all the docs: In Flutter, if the doc is referring to a parameter of the method it should be enclosed in ` instead of []
We control the SDK version for Flutter, which error is it for us?
nit: put this on one line or use a trailing comma to have each parameter on a separate line.
Same comment about arguments and the CastError as above.
nit: add trailing comma and put `) {` on next line?
nit: keep this on one line or one line per argument
one line or one line per argument
nit: the multi-line argument lists in this file or not following flutter style.
nit: style
Done.
That's an interesting question.  When I tried, this, it gave me:  ``` The following _CastError was thrown building Home(dirty): type 'Foo' is not a subtype of type 'Comparable<dynamic>' in type cast ```  The interesting thing is that `CastError` is deprecated in the SDK version we're using, with the reason "Use TypeError instead".  So, it seems that the SDK is throwing a private, deprecated error?  The definition of `_CastError` is:  ```dart class _CastError extends Error implements CastError, TypeError { /* ... */ } ```  So... I'm not sure what the right answer is.  I think I'd rather it be `TypeError`, but that's not what the user will see, at least for now.
Done.
Done.  And I did it elsewhere as well.
Done.
Done.
Done.
As above... It's complicated.
I'm not sure why the SDK's not sending a `_TypeError`, as that is defined similarly:  ```dart class _TypeError extends Error implements TypeError, CastError { /* ... */ } ```
Fixed.
Done.
I guess we can leave the docs as-is then until its cleaned up in the SDK.
If `CastError` implements `TypeError`, then it is a `TypeError` - the comment is not necessary
Well, sure, but that's not what it prints when the error is shown.  It prints `_CastError`.
Oh, right. A _CastError is a TypeError, so we should just mention the TypeError in the doc.
But you can't use _CastError in your code anyways. I'd assume if you read the doc you are wondering what error type you're supposed to catch in a try-catch - and that would be a TypeError, no?
It would.  That's why this is complicated.  Nowhere does the stack trace output say "TypeError", yet that is the type of the error that you need to catch.
I think I'd like to leave it as just saying `TypeError`, and remove the parenthetical about `CastError` since that one is deprecated, and point out that the output may say `_CastError`.
OK, I updated it to say that.  See what you think.
Does this really need to be a mixin, they're a bit more complicated in terms of visibility? You could instead create this as a base class that extends FlutterCommand, and then have Create and AddPackage inherit from that.   
"Command to " is redundant. See the existing flutter help text:  ``` Available commands:   analyze           Analyze the project's Dart code.   assemble          Assemble and build flutter resources.   attach            Attach to a running application.   bash-completion   Output command line shell completion setup scripts.   build             Flutter build commands.   channel           List or switch flutter channels.   clean             Delete the build/ and .dart_tool/ directories.   config            Configure Flutter settings.   create            Create a new Flutter project.   devices           List all connected devices.   doctor            Show information about the installed tooling.   downgrade         Downgrade Flutter to the last active version for the current channel.   drive             Runs Flutter Driver tests for the current project.   emulators         List, launch and create emulators.   format            Format one or more dart files.   install           Install a Flutter app on an attached device.   logs              Show log output for running Flutter apps.   precache          Populates the Flutter tool's cache of binary artifacts.   pub               Commands for managing Flutter packages.   run               Run your Flutter app on an attached device.   screenshot        Take a screenshot from a connected device.   symbolize         Symbolize a stack trace from an AOT compiled flutter application.   test              Run Flutter unit tests for the current project.   upgrade           Upgrade your copy of Flutter.   version           List or switch flutter versions. ``` The only ones that list commands are referring to subcommands.
There is already a hook for this: FlutterCommand.verifyThenRunCommand
Why are these false? Can you separate the refactor from changing the default behavior?
```suggestion }  ```
How much if this test is copy-pasted from the create_test? This is really difficult to review if there are non-trivial changes
I would expand this comment a bit for each kind of template. Talk about what it does/does not generate
project -> plugin?  > The project will not compile until you add platforms implementation.  This isn't quite true, it just isn't useful
Can you hoist this out into a constant so it is easier to read?
Rather than conditionally checking here, you _might_ be able to only add web, linux, macos, windows to the list itself if the experiment is enabled. Then you can do:  ``` for (final String platform in platforms) {   context[platform] = true; } ``` 
I would recommend pulling this logic into a new class that is separate from the create command. in general the use of string processing here is concerning to me. The pubspec.yaml is already structured data, you should take advantage of that to add the platforms.
NVM, it was already there! my bad
Or remove this line?
done
updated, see if you like this.
Updated with a slightly different approach, please take a look and see if you like it.
nit, remove : ` please remove the argument and try again`
formatting
`platforms.join(',')` ?
clarify "respective folders"  - "platform folders (android/ ) ?
Maybe: Adding desktop platforms requires the corresponding desktop config setting to be enabled
hoist this into a const list at the top of the file
if no values are provided, this should give you an empty list, I think the wasParsed check is unecessary
please move to the top of the file
this is confusing, why do we need to only check projects if we're creating an example app
This is confusing, everything gets set to false by default, then everything get sets to true, then some are conditional set to false.
Assuming that someone is migrating an old plugin and trying to use add-platform, it would be nice to at least link to page explaining the formatting
missing a type check here, platforms could be anything
platformsToAdd.removeWhere(existingPlatforms.contains);
Does this rely on on having a fake platform key?
It seems like there are a lot of ways for this method to fail, and it requires a sentinel data in the form of the comment. Is there a way this process could be simplified by ignoring comments? Is add-platforms going to be usable if it requires a very specific structure?
done
done. Good call!
done
done
done
because I made the parameters defaults to all platforms. And for plugins, we only want to accept the `platforms` if it is passed explicitly by the user.
done
As a side effect, this method always generates the `GeneratedPluginRegstraint` files for iOS and Android unless the checkProject flag is true. When the plugin is not for mobile, this method still generate those files, including iOS and Android.
you are right, I deleted this method and updated the caller a bit. Please take a look see if it makes more sense.
done. We only need to show  this error if the `platforms` map is missing or not valid, other failing scenarios are just general invalid pubspec.
done
This logic doesn't. however it does remove the `some_platform`. The reason that `some_platform` needs to be there is that we need to keep the pubspec.yaml valid. Otherwise, other steps of the `create` command would fail (pub get for example)  Another way is to perhaps not having the whole `flutter` map in the pubspec if there are no `--platforms` specified, then add the `flutter` map programmatically when `--platforms` is specified. 
one way to improve this is to ignore the lines that starts with a `#`  Other than that, I don't find a perfect solution to update this without breaking the existing yaml comments. Which I think we need to preserve because those are great instructions for new users. 
This seems pretty fragile, what if someone develops android/ios and then wants to use add-platform to add a new desktop or web implementation?
I would say ignore the comments and focus on the structured data.
"that supports no platforms is generated"?
Space between `generateModule` and `?` and `module` and `:`
Missing space: "Platform folders (android/)"
I didn't see an issue tracking this crash, surprisingly (it's not the same as https://github.com/flutter/flutter/issues/43734)
(ew.)
Can we move the parsing and validation in this method by using FlutterManifest? ```dart final FlutterManifest manifest = FlutterManifest.createFromPath(pubspecPath, fileSystem: globals.fs, logger: globals.logger); ``` Then move `getPlatformsYamlMap` logic into `FlutterManifest` as something like this: ```dart   List<Map<String, dynamic>> get supportedPlatforms {     if (isPlugin) {       final YamlMap plugin = _flutterDescriptor['plugin'] as YamlMap;       if (plugin.containsKey('platforms')) {         return platforms = plugin['platforms'] as YamlMap;       }     }     return <String>[];   } ``` And put any missing type logic (if any) into `_validateMultiPlatformYaml()`.  (bonus, then androidPackage can become:) ```dart   String get androidPackage {     if (isModule) {       return _flutterDescriptor['module']['androidPackage'] as String;     }     if (supportedPlatforms.containsKey('android')) {       return supportedPlatforms['android']['package'] as String;     }     return null;   } ``` 
This should also work as the code is to look for the `platforms:` key and add an entry under it. i think I have a test covers this scenario: 'create a plugin with ios, then add macos'. It only removes 'some_platform' map, which is an invalid platform. 
Did you mean to overwrite all the comments when updating pubspec.yaml? Something like `file.write(pubspecYamlMap.convertToString)`? (I'm making up APIs here)  Or did you mean to skip comments like  ``` if (line.contains('#')) {   continue; } ```
makes sense
What if instead of trying to edit their pubspec and potentially corrupting it or changing their formatting or accidentally removing comments, we print out something like (assuming `--platforms=web,macos`):  ``` In order to support web and macos, update your pubspec.yaml platforms map. See https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin-platforms for details.    plugin:     platforms:       android:         package: com.example.hello (actually put the existing map we parsed for them)         pluginClass: HelloPlugin (actually put the existing map we parsed for them)       ios:         pluginClass: HelloPlugin (actually put the existing map we parsed for them)       macos:         pluginClass: HelloPlugin (put the suggested pluginClass)       web:         pluginClass: HelloPlugin (put the suggested pluginClass)         fileName: hello_web.dart (put the default fileName) ```
I think we need to wait until well after 1.20 is released to give the plugin consumers time to upgrade (not just the plugin author)
"You see this message because" is kind of clunky. What about "This plugin project..."
Given the time constraints and the downside of getting this wrong, this seems like a reasonable compromise in the short term. We can always circle back later if the feedback is negative
done.
done
Do you guys think `pluginExampleApp` is confusing? I am thinking it might be better just to call it `checkProjects` or `checkProjectsWhileEnsuringTooling` 
good point! done (with the androidPackage refactoring)
done 
pub is adding a check for non-iOS plugins to not able to publish if they don't set the min SDK constraint to 1.20.0 and they don't have iOS folders. This prevents the app authors from hitting the error if they haven't upgraded to 1.20.0
done
Sounds good, we can add the message for this release. I still think that this pubspec surgery something good to have for better UX in the future. I haven't found a better solution than doing a line by line parsing and testing tho.
done
Are you OK if we just fix it in this PR? Or do you think a separate PR would be better?
`--platforms=android`?
I'm fine with fixing here, I'm just surprised I couldn't find a crash report of this.
I think the non specificity of "checkProjects" is what's throwing me off (I know you didn't name it).  Like, check what?  If that was a better name, `pluginExampleApp` might make sense.
"Legacy" is only a useful term until the new version gets deprecated and you need like "legacy 2".  Maybe "Pre-multi-platform plugin format"?
`iosPrefix` is deprecated?
done. The test probably didn't even check for specific plugin folder, thats why it passed?
They may not have a `platform` key if they generated in an older plugin format, right? ``` Add below lines to under the `platform:` key in the `plugins:` section of your `pubspec.yaml` ``` ? Something like that?  I guess it doesn't matter so much because we gave them a link to more detailed instructions below.
Makes sense to me
By looking at the code of `ensureReadyForPlatformSpecificTooling`, I also not sure what that meant. @jonahwilliams  do you have any idea? Maybe we can add a TODO comment on that method to either fix the param name or add some doc/comments on the `checkProjects` param?
Makes sense! done!
yes. We don't need iosPrefix in the multi-platform format.
yeah, TODO for now. 
I think it makes sense to also give users a warning if they are using the old format, I updated the message for those users. PTAL.
2 space indent here
indentation of `'''` is weird.  ``` const String _noPlatformsErrorMessage = ''' << message text >>> '''; ```
find a detailed instruction -> find detailed instructions  add platforms in the -> add platforms to the
module or package
2 space indent
2 space indent
e.g. android/
_kAvailablePlatforms
_kNoPlatformsErrorMessage
The cast<String>() will throw if the pubspec is not formatted correctly, does createPlatformsYamlMap validate the structure?
2 space indent
``` return <String>[   if (templateContext['ios'] == true)     'ios',    ... ] ```
Add a newline here
Import common.dart and not test_api
done
done
done
done
done
done
done
done
done
done
done
done
done
Yes, `createPlatformsYamlMap` creates a valid <String, dynamic> YamlMap based on a Map<String, dynamic>
done
done
in #59408 @Hixie deprecated this and introduced a newly named property. Is this potentially breaking?
It is not breaking according to our breaking change policy. I didn't have to modify any tests and g3 is also fine. Therefore, I opted to not do the depreciation.
SGTM!
nit: maybe use `switch` instead?
That seems simpler to me, will do 👍 
I think using `default` clause is discouraged.
I'm not sure I follow this comment. Which will it be constrained to, kToolbarHeight or toolbarHeight?
See snippet just below this (291-302). The comments here have removed references to kToolbarHeight, but it is still in the sample, can you update the snippet to reflect a custom value?
```suggestion   /// Defines the height of the toolbar component of an [AppBar]. ```
I didn't change it because it was covering the default `toolbarHeight` case, in case if the user doesn't provide any toolbarHeight. You are right, it may create some confusion, I'll change it.
I'll improve it in the next commit.
The period here is causing the web test to fail.  ```suggestion       expect(error.toString(), contains('is not true')); ```
Thanks for pointing out, I have fixed it.
Awesome. Thanks!
nit line length
It would be OK to leave out "such as how to use them".
which defines cursors that are supported by most native platforms
This is just bike-shedding, but it feels like "enabledCursor" would be the natural name for this
More bike-shedding: maybe EnabledAndDisabledMouseCursor?
I guess textable is like clickable (but I don't think textable is a word).  Would it be OK to just call this "text"?
mouse pointer => the appearance of the mouse pointer
I agree with the concern, but "text" can confuse people with `SystemMouseCursors.text`. I'm aware that I'm fabricating words here and it's wrong grammar, but I wonder if we can just take it as a special nomenclature where "\<system cursor name\>+able" stands for the system cursor's might-be-disabled sibling.
That makes sense; I hadn't realized what the "able" suffix was really for.  
I wonder what your version means, because: 1. If it means some platforms do not support system mouse cursors, then they do not support mouse cursors. There hasn't been a platform that support mouse cursors that do not come with some system cursors. 2. If it means these cursors are only the most common ones, it's quite the opposite. `SystemMouseCursors` is meant to be a superset of all cursors from all platforms. Some of these cursors are only supported by 1 platform, we include them anyway, and they fall back to the basic cursor on other platforms.  And what does "native" platform mean, because all platforms are native.
stands => stand
I agree that native platform is redundant.  By "cursors supported by most platforms" I was implying that the superset of cursors we picked for SystemMouseCursors _mostly_ included cursors that were supported in multiple platforms. Otherwise developers could reasonably ask if we were really balancing portability with flexibility.
```suggestion /// with the more generic advice regarding [Directionality]. ```
ultra nit, and only if we're using American punctuation rules (personally, I think it's a dumb rule, but it is what it is): ```suggestion ///    AlignmentDirectional value." Should be a fully punctuated sentence. ```
The string here is a literal, not a quote, so I'm inclined to go with programming punctuation rather than usual prose punctuation.
nit: maybe mentioned what "handled" (or returning true) means, e.g. that the event will stop propagating and nobody else will see them?
Should we assert here that if the keyEventHandler was provided it returned true/false (and not null)? Assuming that returning null from keyEventHandler is illegal. 
If null is illegal, let's document that on RawKeyEventHandler as well.
maybe link to [addListener] as well from here and say how that's different then receiving the key events from here.
Done.
Done.
Done.
This is changing the behavior. Can we instead just assert that the values are in the right range as it is documented?
Nit: Please add new lines between each `test` to make it more readable
Nit: might be more readable if these were broken into more asserts (at least one per param?)
Why call this cancel instead of dismiss?
In what sense is this intent bound by default?
In the sense that the default shortcuts for `WidgetApp` have it mapped to the `escape` key. Is there a better wording I can use here?
I actually started with dismiss, but it seems like it could be more generic as a cancel/negative action/dismiss feature. It is fairly common in game interfaces to have the A button mapped to 'activate or select the focused thing', and the B button mapped to 'cancel/go back/dismiss'. That was my thinking, but if others feel strongly it should just be dismiss, I can put it  back. 
Mentioning "default keyboard shortcuts in [WidgetsApp]" is actually good enough, although maybe [WidgetsApp.defaultShortcuts] would be better.
I don't have a strong opinion about it; just noticed that in most of your descriptions of this intent/action you used "dismiss".
I think dismiss is better.  Cancel and dismiss are slightly different things, and this is definitely a dismiss.  Cancel implies that the user specifically doesn't want something to happen, or wants to interrupt something in progress. Dismiss means that they just want to ignore something or to acknowledge that they saw something and put it away. Users can always create a separate cancel action for the other sense if they need it.
Sounds good. I just renamed them back to Dismiss*. Let me know what you think. 
nit: empty line - Typically we use empty lines to separate logical procedures for better readability.
empty line removed
need to make this non-required for g3
Removing these APIs since they are unused, which simplifies null-safety migration
these tests now set the right version when the experiment is enabled but the library is not opted in
This regex looks like it's missing an initial escape `\` and has too many `\` in the middle, but it's obviously working? `\/\/\s*@dart`  Also: https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override ``` it would be possible to have a line containing just //@dart=2.3 inside a block comment. That will not count as a language version override marker. ``` Also need to check for block comments?  It would be unlikely someone would have a block comment containing it above the imports but hey that's the spec.
So 2.8 is pre-null safety?
Yes, I changed this back to pre-null safety since we can't actually run tests with sound null safety yet - the actual platform (dart:ui) isn' migrated yet.
Trim the whitespace before you check `startsWith`. Maybe also check for `library` `part of`?
Can you do one with tabs instead of spaces?
Good catch!
@jmagman I went through so many iterations of the RegExp I considered lifting the actual parser from the SDK
Anyway, will check for block comments too
Could `_packageConfig` be `null` if `loadPackageConfigWithLogging` fails?
Done
No, it will throw a tool exit if `throwOnError` is true (which it is by default)
Missing the // prefix so i's not really detecting it's in a block `//@dart = 2.9`
Same, missing `//`
This still looks malformed with the unescaped initial `/`.  Check me @christopherfujino, shouldn't this be `\/\/\s*@dart`?  How is this working?
Fixed
Fixed
Yeah, I looked at earlier, and agreed both that it looks wrong and that I don't know how it works. Lemme dig a little deeper...
I agree it is completely bonkers. Confusingly the obvious regex pattern didn't work, and I haven't been able to figure out why
@jonahwilliams ah! it's because you didn't use a raw string!
(thank you vim dart syntax highlighting @natebosch)
```suggestion final RegExp _languageVersion = RegExp(r'\/\/\s*@dart'); ```
2020
The doc should be clear that the returned String _is_ a language version override comment.
2020
For reasons(?), all copyright comments, including for new files, retain the original copyright date.
ditto
Will this mess up hit testing on e.g. Android? I would expect that on Android whenever you try to touch anything in the alert to a11y focus it, you’ll actually focus the modal barrier now...
nit: revert formatting change?
nit: remove this empty line?
Should this be `semanticsDismissible` instead of `barrierDismissible`?
Maybe add a comment here: `// To be sorted after the _ModalScope.`
Maybe add a comment here: `// To be sorted before the ModalBarrier`
Please add: "// Regression test for <issue link>."
Doesn't the barrier have a label and/or action we can use to identify it better? This could just be any stray semantics node...
nice catch, actually it should check both. the semanticsDismissible name is confusing, it means the semantics should include this modal barrier, barrierDismissible is the actual one whether the barrier is selectable. If the barrierDismissible = false and semanticsDismissible = true, the barrier is still excluded from the semantics tress.
Do we want to check the version of GTK here? If so this should be changed to `'gtk+-3.0 >= 3.22'` or similar. `pkg-config --exists gtk+-3.0 >= 3.22` or `pkg-config --exists gtk+3.0 --atleast-version=3.22` will return 1 if the version is not recent enough. You could use `--print-errors` to get error text or `--modversion if you want to do this yourself, i.e.  ``` $ pkg-config --exists 'gtk+-3.0 >= 10' --print-errors Requested 'gtk+-3.0 >= 10' but version of GTK+ is 3.24.18 ``` ``` $ pkg-config --modversion gtk+-3.0 3.24.18 ```  I noticed we're not checking the version in the engine BUILD.gn - it should probably be done there too.
Again version information should be here.
Version information...
This is the only package I saw that seems to have jumped >1 major version, however 0.6.0 seems to have been very short lived (only [5 days](https://pub.dev/packages/webkit_inspection_protocol/versions))
Formatting seems a bit off here, perhaps it makes more sense to add the key to the `FlatButton` instead?  Same with the OK button
I'm not super familiar with keyboard mappings/shortcuts. Is this some boilerplate that is necessary?
Is there a reason for this `Material` widget when there is one below it?
This had to do with the key'd widget needing to be inside the InkWell that handled the activation. I have decided that this is not a great way to handle this and removed it from this PR. I have a better way to more generically handle dismissing modal routes with a 'escape' that I will talk with Greg about and put together another PR. 
This was a way to have a key shortcut activate a specific widget. I was doing this so that using the 'escape' key would look like you had tapped on the Cancel button and 'enter' would look like you tapped on the Ok button. I have decided there is a better way to handle this in a generic way for dismissal, and the confirm shortcut is a bit problematic. I will rework these in follow on PRs. 
Nope 😄 . Nor is there a reason for the Row widget here either. Thanks for calling this out. I think this was some left over experimentation that shouldn't have made it in. Should be fixed now. 
Also what do you mean by "names" here? ```suggestion     help: 'Target device id (prefixes are allowed, names are not supported).\n' ```
nit: this doesn't really need to be commented
nit: I would early return to avoid the else  ``` deviceId = _findMatchId(await discoverDevices(), deviceId); if (deviceId != null) {    _workingDevice = AndroidDevice(deviceId: deviceId);     print('Choose device by ID: ' + _workingDevice.toString());     return; } throw DeviceException(   'Device with ID $deviceId is not found for operating system: '   '$deviceOperatingSystem'  ); ```
Same here
and here
I would name this and the enum to `FakeDevice`/`fake`. in Dart it is generally the case that classes with `Mock` in their name extend `package:mockito`'s `Mock` class
`environment `  is always null here, just use `=`.  Is there any reason you are conditionally passing environment? You could instead conditionally insert the device id:  ``` environment = <String, String>{   if (deviceId != null)     DeviceIdEnvName: deviceId } ```
I was thinking maybe in the future there will be more environment variables adding. But yeah I should have made it simpler. 
This comes from `flutter drive` help info (`Target device id or name (prefixes allowed).`), where both id string and model name (e.g. `moto` for a moto G4 device) are allowed. This feature depends on the classes from flutter_tool devices.dart that provides method for getting device name. `adb.dart` doesn't have that, so only id-s and id prefixes are allowed. 
Just realize but should I also replace the logging strings to "fake"? 
Here and above, it looks like there is some shadowing over `deviceId`, this point would only be reached if it was null right? Or is the intention to print the original `deviceId` passed as an argument?
Thanks for the catch! It is a bad design to log the unmatched null deviceId. Fixed. 
The script `dart dev/tools/localization/bin/gen_missing_localizations.dart` had no effect when I ran it at this point, so I'm assuming that it's not necessary to run it.  I've left it out of these docs.
When I ran this script in my other PR, it actually created a few labels in new English locales (like en ca) with the old values. I manually updated them to the correct values.  I guess this shouldn't be part of the process, though, and any new labels created in new locales with the old values should be translated like normal.
Manually updating them actually caused an analyzer error, which gives me more confidence that you shouldn't do that :) Those strings will get translated and set to the right values later.
maybe add a statement along these lines to the docs so that people don't get confused?
Good call 👍 
Wow. This could be the source of real bugs?
This looks like it could have been masking a bug. Wow.
nit: long line
This line is only 129 characters long.  The consistency on line length recommendations is all over the place (you're not alone, I've seen this comment in other reviews).  Is this really more readable? <img width="652" alt="Screen Shot 2020-06-11 at 9 31 20 AM" src="https://user-images.githubusercontent.com/682784/84414692-d2661080-abc6-11ea-9af2-3196f1415410.png">  I don't get why we care about "long" lines.  Your IDE wraps and scrolls and you're probably working on a ~27" display anyway (130 characters doesn't look long on a 13" laptop either).  I can't even get the Android Studio column guide feature to work, it always just shows 80 characters no matter what I put in the visual guide field.  [What decade is this?](https://en.wikipedia.org/wiki/VT100) <img width="1109" alt="Screen Shot 2020-06-11 at 9 33 10 AM" src="https://user-images.githubusercontent.com/682784/84414281-9d59be00-abc6-11ea-92d2-37a8edf191f5.png">  I'm all for consistency, but either we should have a linter or we shouldn't enforce it, and should just wrap where it's naturally readable.
I agree, I don't really have anything to go off of here (feel free to ignore nits). I would certainly prefer if we had a standard max line length,  _probably_ longer than 80 but I'm not sure how much until we hit the terminal width limit for @zanderso   The framework "hand-formatting" standard is really making this harder than it should be. Not to mention all of our lines are longer than they need to be due to the unnecessary RHS types for locals
Here is the relevant section of the style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#prefer-a-maximum-line-length-of-80-characters. In particular, 'prefer going over if breaking the line would make it less readable, or if it would make the line less consistent with other nearby lines.'  'less readable' is subjective, so at the end of the day, this really means something like, "come to a consensus with the code reviewers."  I would vastly prefer it if we could use dartfmt under packages/flutter_tools with a line limit of say, 100 or so, and just not have these conversations anymore, but I believe that ship has sailed.
Can we add a line here that says for modifications required in the host Android or iOS apps, make those modifications in your own wrapper apps that import the Flutter module?
Good idea. I'll open a new PR.
I was pointed to this as an example of why we should use dartfmt... It's worth noting that dartfmt never breaks strings, so it would not make this better. In fact it would make this worse because it puts a random newline before the `(` and then puts the rest of the line on the next line indented by four:  ```dart   void _printDeprecationWarning() {     if (deprecated) {       globals.printStatus(           '$warningMark The "$name" command is deprecated and will be removed in a future version of Flutter.'); ```  My recommendation for formatting this would be:  ```dart   void _printDeprecationWarning() {     if (deprecated) {       globals.printStatus(         '$warningMark The "$name" command is deprecated '         'and will be removed in a future version of Flutter.',       ); ```  (If you do that, then it happens that dartfmt will keep that output unmodified. But it won't proactively cut the string.)
Ruby std lib module available since Ruby 0.4, CocoaPods depends on it, safe to use here.
https://github.com/flutter/flutter/issues/45197#issuecomment-642201335
Is there potentially an end-date for these mitigations, or is this code needed forever? 
The primary purpose of https://github.com/flutter/flutter/pull/59044 is to move most of this logic into the tool so we can change it without requiring the user to regenerate their Podfile.  It imports a new Ruby helper (bleh) from flutter_tools/bin and then calls those helper methods.  So, 🤞 this is one of the last migration prompts we ever need (knock on wood as well).  So this particular migration prompt is to get them to generate the new version of the Podfile that imports from the tool.  It will be needed long as we want to support projects created in 1.17 that upgrade to latest.
All these tests are checking that the RichText is not null, is this necessary? I think the test would fail if it couldn't find the RichText anyways.
You're definitely right, I copied this from the `DefaultTextStyle` test cases, maybe it would make the failure more readable? 
This is really unfortunate, i.e. I would have expected:  ```dart  textHeightBehavior ?? defaultTextStyle.textHeightBehavior ?? defaultTextHeightBehavior.textHeightBehavior; ```  Would it be possible to change DefaultTextStyle.textHeightBehavior to be null by default, and have null mean `const TextHeightBehavior()`?  
We're going to need to explain how this interacts with DefaultTextStyle
We usually don't put vital info like this in the constructor's API doc
Instead of returning the inherited widget, we should return textHeightBehavior and `const TextHeightBehavior()` by default
Can we avoid referring to this (and having developers refer to it) using dart:ui?
I don't think this is needed; see related comments
Added some docs explaining the relationship.
Moved
Done
Discussed offline, but yes I'll adopt this pattern. 
Done, as discussed offline with the minor tweak of returning `null` by default.
Removed.
in the same tree as => below 
It seems to still be here.
Done.
This isn't your problem but it would be great if we could rename all the other variables to finish with Data. For example, `timePickerTheme` should be `timePickerThemeData` maybe we can start this change with this widget. 
Remove comment
Remove empty space
Why do all the variables have a _k in the beginning what happens if you replace that with just _defaultShape
single if statements should still use { } so instead of if (true) statment it would be if (true) { }
single if statements should still use { } so instead of if (true) statment it would be if (true) { } 
single if statements should still use { } so instead of if (true) statement it would be if (true) { }  
Great comment.
This should be a assert method instead with a comment.  Or maybe a throw instead.  If that is an error we should not return empty string.
return null seems wrong. Maybe you should write a comment why you are returning null over throws or assert method.
Same as above
swap onPressed and child
swap onPressed and child
The `k` at the beginning is because they're `const` (as per the style guide)
I think we've been mostly consistent in dropping the `Data` from the variable name since it felt unnecessary, so I'm gonna leave as-is.
These comments are actually used in some way to help with generating documentation. I'm not really sure how but I'm going to leave this in.
Space is useful to delineate sections here.
good catch, done
Done
Done
I can't take the credit here haha, this is from the existing picker
So the `_validateHour` and `_validateMinute` functions are passed into the `TextFormField` validator param and they basically use the presence of non-null strings to indicate an error state. So unfortunately, it has to be done this way.  This error means the user has type something that isn't a valid hour/minute and we want to update the UI to indicate that, so we don't need to assert or throw anything because this is about user-facing errors.
Same comment above but I'll clarify the comment a bit
Same answer as above
Done
Done
This is a pattern flutter uses for constants (prefix with k), so I'm going to leave as-is.  https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#begin-global-constant-names-with-prefix-k
should this only be indented 2 spaces?
Why is this assert here and not above with the asserts in the constructor definition?
Maybe a comment here that width stays null for X reason?
This might need a github issue to go with the TODO
It doesn't look like this method does anything (I may be misusing Github difftool)
This implies that if amSelected is false, then 'pmSelected' would be true, consider making `pmSelected => !amSelected`
`this._minSize`, cool
can you use += here and below?
can you use += here and below?
this should probably be on the same line as the return, or it could have a trailing comma for better formatting
Don't need `|| value.isEmpty` because `int.tryParse('')` (which is done below) will return null
Don't need || value.isEmpty
Could be `return newHour == null ? '' : null`
Same comment as above
Same comment as before about TODO possibly needing issues. I am unable to find the rule though.
Is it common to use __ instead of _ here?
this should be min48
Why is this an invalid hour?
nit: use `w` or `widget` for all of these finder predicates
same comment as above
done
Looks like it was already in the constructor, removed here
done
It's not required and so I'm just going to leave this, I'll be following up with that work
I think that may just be the github diff tool, it does do something.  ```   void _setPm(BuildContext context) {     if (selectedTime.period == DayPeriod.pm) {       return;     }     switch (Theme.of(context).platform) {       case TargetPlatform.android:       case TargetPlatform.fuchsia:       case TargetPlatform.linux:       case TargetPlatform.windows:         _announceToAccessibility(context, MaterialLocalizations.of(context).postMeridiemAbbreviation);         break;       case TargetPlatform.iOS:       case TargetPlatform.macOS:         break;     }     _togglePeriod();   } ```
done
I think so, good idea
thanks
yep
Done
true. done
Done
Done
Done
Leaving as-is, the rule only requires username, GH issue being optional. I'm going to be following up with a l10n pass anyways
nope, this is an unfortunate side effect of the IDE, fixed
good catch, fixed
Oops comment should read invalid minute, fixed
oops, fixed
done
If the type of dayPeriodShape was OutlinedBorder, then this property could be a BorderSide, which is more flexible and would make it possible to specify the appearance of the border independently of the shape.
If we had just one hourMinuteTextColor property but the implementation used MaterialStateProperty.resolveAs<Color>, then a MaterialStateColor could be used to specify select and unselected colors (as well as colors for other states if that made sense).  If the internal representation of the default color was MaterialStateProperty<Color> then you could effectively resolve color like this: ```dart theme.hourMinuteTextColor.resolveAs<Color>(states) ?? _defaultHourMinuteTextColor.resolve(states); ``` That way developers could use a MaterialState color to override the effective color for just one state (return null for the others) or all of them.  
Statements like this should to explain the default comes from the overall theme's color scheme
As with ColorScheme, need to explain that "brightness" refers to the overall theme's brightness.
Should be required, assert non-null.
If you read this carefully, it's not really correct.
It would help to mention [showTimePicker] in here somewhere.
see also [TimePickerTheme] also
Mode => Interactive input mode 
"Either a dial or text input." isn't really needed.  Not sure if the DartDoc will recognize [dial] as [TimePickerEntryMode.dial]
Looks like we're assuming that isSelected is non-null, so assert that.  Likewise for text
This looks quite a lot like _RenderInputPadding in button.dart. In a future PR, maybe we should create a shared public widget for this.
Does this work correctly if font changes or if textScaleFactor > 1?
origin 2-space indent was OK?
Looks onChanged is assumed to be non-null, assert here.
This is formatted a little unusually. Here's an alternative that's still unusual/compact: ```dart return !widget.isHour ? localizations.formatMinute(widget.selectedTime) : localizations.formatHour(   widget.selectedTime,   alwaysUse24HourFormat: alwaysUse24HourFormat, ); ```
Sometimes this kind of thing is easier to read if the short and simple clause is first
This is OK but it makes it clear that the TimePickerTheme's inputDecorationTheme is underpowered - it can't reflect the time picker's state. Maybe make this a MaterialStateProperty instead.  Also: maybe InputDecorationTheme is more flexibility than is really needed here (I realize that it's convenient).  Maybe all that is needed are two properties: a MaterialStateProperty<BorderSide> and a MaterialStateProperty<Color>.  InputDecorationTheme implies more flexibility than we're likely to test or anyone is likely to need.
prefer to reserve `=>` for one-liners that return a value ```dart setState(() { _autoValidate = true }); ```
What's 1.1 for? Aren't we constraint textScaleFactor to 1.0?
MediaQuery.of(context) => media
Shouldn't we be using ColorScheme colors here?
ButtonBar is problematic. Can we avoid it here?
We can have const values here ```dart orientation == Orientation.portrait ? const EdgeInsets.symmetric(horizontal 36, vertical: 24) : const EdgeInsets.all(24) ``` 
NICE
Yeah I based it off of the button.dart implementation and it could definitely be extracted in a future PR
I elaborated more on this,  some elements do scale up (like the help text and the buttons at the bottom), and 1.1 worked well while testing different scale factors.
I'm not sure what you mean, could you elaborate?
Done throughout
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
it does run into problems at higher text scale with the dot overlapping the text unfortunately.  I think this is fine though, the existing Android time picker has this problem.
Spoke offline and agreed that InputDecorationTheme provides enough flexibility to customize the TextFields if necessary
Done
Done
Done
I think ButtonBar gives some helpful logic (like moving to a Column layout if the buttons don't fit) so I'd like to keep it for now. I'll add a TODO to move away from this in the future.
I think you mean:  The [data] value of the closest instance of this class that encloses this context.  Or you could just say  The [data] value of the closest [TimePickerTheme] ancestor.
Ohhhhh that makes more sense, fixed!
If you define variables like this with one statement, then the default object doesn't get created unless it's needed. ```dart     final Color textColor = timePickerTheme.hourMinuteTextColor       ?? MaterialStateColor.resolveWith((Set<MaterialState> states) {            return states.contains(MaterialState.selected)              ? themeData.colorScheme.primary.withOpacity(isDark ? 0.24 : 0.12)              : themeData.colorScheme.onSurface.withOpacity(0.12);          }); ```
The color of the header text that represents hours and minutes.  If [hourMinuteTextColor] is a [MaterialStateColor], then the effective text color can depend on the [MaterialState.selected] state, i.e. if the text is selected or not.  By default the overall theme's [ColorScheme.primary] color is used when the text is selected and [ColorScheme.onSurface] when it's not selected. 
 Similar feedback about wording for this property as for hourMinuteTextColor:  The background color of the hour and minutes header segments.  If [hourMinuteColor] is a [MaterialStateColor], then the effective text color can depend on the [MaterialState.selected] state, i.e. if the text is selected or not.  By default the overall theme's ...
The color and weight of the day period's outline.
Done
Done
Done
Makes sense, fixed
```suggestion // See https://github.com/flutter/flutter/issues/59189 /// Currently, [NestedScrollView] does not support simultaneously floating and ```
Commenting here in case I forget when reviewing the tests: Did you add a test for this?
nit: maybe remove the "more on using" since its just fluff. "[SliverAppBar]s with [NestedScrollView]s" seems to work as a heading. 
nit: maybe add a high level comment here preparing the reader that the next few sections talk about the functionality and limitations of SliverAppbars when used within a nested scrolly thing.
Maybe preface this with the fact that pinned appbars in a nested scroller work exactly like they would in any scroll view. I was scanning the paragraphs for any drawbacks/limitations.
should -> will? I mean it actually does do this, right?
nit: add a space after the comma
High-Level comment: Reading this entire section, I am wondering if we can shorten this a little bit. Instead of giving longer explanations referring to the internals of the nested scroll view, maybe we can just say in each section whether that type of app bar does or doesn't work out of the box as expected. And if it doesn't work out of the box mention how the scrollview needs to be configured to make it work (the code examples should be left in, of course!). 
I'll add one.
I go back and forth on this. I think it's important to explain a lot of these things, as we often have issues filed that are resolved by just explaining oh you need the SliverOverlap* widgets etc. 
You can never have too much documentation, right? :)
I got tired of mocking Artifacts when I don't actually care about the contents. This should trivially generate unique-ish artifact paths for testing
this type was wrong and the case is bogus
@annagrin I need to remove this because it prevents regular compiler errors from showing up on the web
Rather than printing this message after a bunch of compilation failures, the new test compiler checks for a dependency before compiling and exits early. This gives a much clearer instruction on how to resolve the error too
By checking the package config we know definitely there is a missing dependency. Added instructions on how to fix
Can any of these use `testWithoutContext`?
ditto
Yes, fixed
not until these tests are re-written.
I need to understand this better. I added this to communicate compiler errors to the debugger during evaluation, so something might break there...
This is only printing trace messages, how is the debugger using printed messages?
For expression evaluation, the debugger does not need messages printed to the console, but instead is handing them specially, depending on the context (watch window, hover over, expression evaluation box, conditional compilation all need their own error handling). Not sure how the debugger is getting the error messages though, will find it out and update.  I tried the change and figured out that if we suppress the compilation messages in compile.dart :  ``` Future<CompilerOutput> _compileExpressionToJs(_CompileExpressionToJsRequest request) async {     _stdoutHandler.reset(suppressCompilerMessages: **false**, expectSources: false);  ```  then we get the desired effect - the error messages are still propagating to the debugger but the printing is gone.    
Ahh, awesome - I will make that change!
Figured out how debugger gets compilation errors:  https://github.com/flutter/flutter/blob/96711b00ce3f3addec82ebe0ee34b4c36cc3c9ba/packages/flutter_tools/lib/src/build_runner/devfs_web.dart#L85  So as long as the generator writes them to the file, the debugger should get them:  https://github.com/dart-lang/sdk/blob/ecc7a2110667284d792946775f471f4a7f409afb/pkg/frontend_server/lib/frontend_server.dart#L964  And the errors table is filled by:  https://github.com/dart-lang/sdk/blob/ecc7a2110667284d792946775f471f4a7f409afb/pkg/frontend_server/lib/frontend_server.dart#L360  This a bit too complicated, may need revisiting and simplification...
@annagrin this change is sufficient to get verbose logs in the terminal of VS Code
This works, thanks! LGTM
This line is a bug that didn't matter, since we never added error statuses. Still fixed in case this gets updated in the future
Would be nice if a lint could have caught that.
`isHint` could be a getter that returns a random value, if I extended ValidationMessage poorly. you would need to figure out the concrete type of `ValidationMessage` here. Then maybe you could prove that isHint will always return the same value for the same instance.  Seems like a fun problem :) 
Nit: Since this is only used once, maybe just inline it?
Why is this needed? Wouldn't it be null to start with?
Same thing here, wouldn't message already be null?
Would we only want the `Tooltip` if the text scale factor is greater than 1?
I dont think you need this new line
Changed to:  ```dart      final MediaQueryData mediaQueryData = MediaQuery.of(context);     return MediaQuery(       // Do not grow text in bottom navigation bar because there is no room,       // instead, properly scaled tooltips will show on long press.       data: mediaQueryData.copyWith(         textScaleFactor: math.min(1.0, mediaQueryData.textScaleFactor),       ), ```
It needs to be explicitly initialized because it's a final field, but I don't want to expose it in this constructor.
Guidance from design was to always include it, because it is useful for more than just text scale, for example when an item has no label.
Removed.
Same as above, it needs to be explicitly initialized (because it's a final field) and I don't want to expose it in this constructor.
Add `container: true` to this Semantics widget and move it back to after the `Tooltip` widget in the Stack. That should fix the issue you mentioned on Chat.  (Basically replace lines 466-513 in this PR with the content of this gist: https://gist.github.com/goderbauer/8913e43d987e76b7b89451dd2ac89089)
As explanation: It looks this is a quirk of the semantics compiler. Since the `indexLabel` was not in a container, its semantics information were implicitly merged to the highest node possible in the tree (which here happens to be the `MergeSemantics` widget). Due to this, before the force-merge triggered by the MergeSemantics widget happens, the SemanticsNode of the MergeSemantics widget already has a label of `indexLabel`. During the force-merge, the labels of the child SemanticsNodes (here: only the one of the Tooltip) are added to the end of that label. Hence, no matter how you order the children in the stack you get the incorrect merged label.  If you now make the `indexLabel` a container itself, it will own its own semantics node. The MergeSemantics widget now has two semanticsNode children and they get force-merged in the order the children have in the tree.  Hope that's somewhat clear. If not, let me know.
`container: true` can be removed here.
This worked!! Thank you for spotting that. Very tricky. 
Done.
I hadn't really thought about this before in other contexts, but is there any advantage in scaling down the text if it already fits?
nit: extra line
why are 5 seconds needed?
Maybe I'm just unfamiliar with these APIs but why do you call this in the constructor?
`markNeedsSemanticsUpdate` is what triggers `assembleSemanticsNode` to run, and as soon as this node is created, and I wanted to make sure that method gets called. I'm also loosely following the `_RenderScrollSemantics` example, which adds a listener to call `markNeedsSemanticsUpdate` in its constructor.  https://github.com/flutter/flutter/blob/025463f4632dbce15da7749d5d3883bea4e6457b/packages/flutter/lib/src/widgets/scrollable.dart#L726  It's possible that this is unnecessary. @goderbauer Do you think this call is safe to remove?
Fixed
In this particular case, I believe that there are some users who are using `textScaleFactor: 0` as a workaround to hide the labels, I do not want to break this use case. There was a period of time when `BottomNavigationBar` did not support hiding labels on the items.  
They weren't needed, changed to 2 seconds, which is what the tooltip uses (there needs to be _some_ time for the tooltip to appear).
Maybe add a quick comment here explaining why we have this widget and what it does to the future reader.
This seems unnecessary. Newly created RenderObjects will always receive a semantics update when they first render (if semantics are turned on). What breaks if you remove this?
`assembleSemanticsNode` only runs if semantics are turned on. Semantics are only turned on if an a11y service (e.g. TalkBack or VoiceOver) is running. I thought this label also needs to show if semantics are turned off? Based on that, I would expect that the tooltip is not showing a message when a11y services are turned off?
Side-note: For technical reasons, a11y are always turned on when running in a simulator. Did you try the tooltip thing on a real device without having any a11y services (outside of scaling the text) enabled? You may have to force-quit and restart the app after turning the a11y service off to delete the cached `label`.
Maybe we should have a separate constructor for this new feature. It may be difficult to debug if you forget to specify the message and suddenly a random string from the semantics tree appears. 
I am surprised that this works because the test doesn't turn on semantics. Maybe I am missing something...
Oh, wait. I think a while ago we turned on semantics by default for all tests. That's why the test is probably fine with this.
The test probably fails if you turn semantics off for it here: https://github.com/flutter/flutter/blob/812c189de8a2d09cb6f52dc1f5186b33f451f837/packages/flutter_test/lib/src/widget_tester.dart#L116
I think we should add the deprecation notice in the constructor too, [see example](https://github.com/flutter/flutter/blob/5cfb16b193886e68e51cc7256389d78a21f31bfd/packages/flutter/lib/src/material/text_theme.dart#L129).  Also it should mention after what version it was deprecated (https://github.com/flutter/flutter/wiki/Tree-hygiene#deprecation) and you might want to add a note that this is to improve text scaling support. 
Since restructuring the PR, is this still needed?
Is this because of the overlay assert you added?
Do we still need the MergeSemantics here?
This should follow the deprecation style: https://github.com/flutter/flutter/wiki/Tree-hygiene#deprecation
Also: Can you update the doc comment on this to mention that this property is deprecated and link to the one that should be used instead?
I get the following test failure from the bottom navigation tests when I try removing it:  ``` The following TestFailure object was thrown running a test:   Expected: has semantics with label: AC           Tab 1 of 3 with actions: [SemanticsAction:SemanticsAction.tap] with flags: [             SemanticsFlag:SemanticsFlag.isSelected,             SemanticsFlag:SemanticsFlag.isFocusable           ] with textDirection: TextDirection.ltr   Actual: SemanticsNode:<SemanticsNode#6(Rect.fromLTRB(0.0, 2.0, 266.7, 54.0), actions: [tap], flags: [isSelected, isFocusable], label: "AC", textDirection: ltr)>    Which: label was: AC  When the exception was thrown, this was the stack: ``` 
Oh, you'll also have to undo some of the other semantics changes we did here:  * remove MergeSemantics * make the semantics widget below (the one with `selected: selected`) a container again * Remove `container: true` from the semantics widget with `label: indexLabel`  I think that should do it and it makes the tree slightly simpler. 
Ah yes, that worked, thanks!
I simplified the tree based on goderbauer's comment: https://github.com/flutter/flutter/pull/59127/files#r450472105
Yes, exactly
Done.
Done.  Based on the breaking change guide you sent, I also created this breaking change proposal: flutter.dev/go/bottom-navigation-bar-title-deprecation, it has been open to discussion for a ~week or so now. 
@darrenaustin may already have a plan for this.
```suggestion   'This feature was deprecated after 1.19.0-4.0.pre.' ``` I think the deprecations here are just missing a period to make the analyzer happy. :)
d'oh
Nice comprehensive doc comment!
Which samples is this referring to?
Maybe add a link?
gallery in samples. they've said they'll fix it when i land this.
https://github.com/flutter/gallery/blob/74d9d92883c6ca10742c44df309f065289cf2f55/lib/demos/material/text_field_demo.dart#L225
How do I indicate that these strings have been changed and need to have their translations updated?
nit: a collection for statement that loops from 0 to `itemDatas.length` seems a better fit here? Having side effects like `itemIndex++` is a bit weird in map.
With `RTL` text direction the extra horizontal padding (5.0) is going to face inward I think. Maybe use `EdgeInsetsDirectional` instead?
Sounds like a @shihaohong or @HansMuller question? I'm interested in knowing the answer too.
nit: the cupertino localization file is not updated so this is probably not needed?
The instructions for adding the strings is a comment at the top of this file. I think there's a script that automatically does that in google3, so long as the default is modified here and in [material_en.arb](https://github.com/flutter/flutter/blob/master/packages/flutter_localizations/lib/src/l10n/material_en.arb).   We should probably update those instructions to include a guide for how to modify existing strings.
I did a quick investigation and whenever Flutter is rolled into google3, material_en.arb is the template that determines what new strings are added or if any existing strings were modified, so make sure to update those as well! 
Thanks for the help!  I just created a separate PR to add instructions for doing this based on my understanding.  More code review welcome :) https://github.com/flutter/flutter/pull/59273
Yes that is much better, thanks.  I forgot about the fanciness with for loops in an array.
I played around with this in DartPad and it seems that EdgeInsetsDirectional start is what will face inward when the text direction is RTL, so it should be correct as-is.  Let me know if I'm not thinking about this right though. https://dartpad.dartlang.org/98d77d79c6664a4f64968b899836419f
Good point.  I'm going to keep it as Paste for consistency, and because the iOS text selection menu isn't all caps either. It probably should have been Paste before this PR.
If the direction is `RTL` then in the column the first item in the list will be placed at the right edge with extra padding on its left I think?
In the dartpad if I do `crossAxisAlignment: CrossAxisAlignment.start` on the column and set the text direction to RTL for the column, then the buttons do align right.  In selection menu though, the position of the buttons isn't affected by text direction.  It also seems like when the menu is overflowing and some buttons end up in an overflow menu in a column, they are always aligned left.  Does that make sense or am I missing the case where it doesn't work?
Oh sorry I thought the buttons will be put in a text direction aware container like a `Row`. Looks like `_TextSelectionToolbarContainer` doesn't care about the text direction. It appears if I turn "force RTL" on in a native android application the menu will flip. I'll file a bug if there isn't one
Thanks!  I didn't realize the menu order flipped on native.
uber-nit: `expect(response.json['protocols'], hasLength(2));`
uber-nit: `expect(protocol['protocolName'], anyOf('VM Service, 'DDS'))`
what is the status of this TODO?
This is a very helpful comment!   I would suggest hoisting this and the attach comment into flutter_command.dart with something like:  ``` void addDdsOptions(bool verboseHelp) {   argParser.addOption(...) } ```  And then call that from run and attach.
For new code, we're trying to avoid using anything in globals. This can be restructured easily enough as:  ``` class DartDevelopmentService {   DartDevelopmentService({     this.logger,     this.launcher = defaultValue   });    final Logger logger;   final Future<dds.DartDevelopmentService> launcher; }  ```  Nit: This class doesn't do a ton but I would add a short doc comment on the purpose. 
Wasn't sure where to find whether or not we were running with ipv6, but I've figured it out.
Thank you! Disabling this can cause some very subtle issues so I wanted to make that very clear in the help message.
nit: extra indent.
nit: I believe we generally put the fields ahead of the methods.
nit: missing trailing comma.
nit: no newline after '='. (See the style guide in the wiki)
Could you link this to an issue?
This was also disable in flutter_web_runner, right?
Done, but for convenience here it is: https://github.com/flutter/flutter/issues/61259
err, resident_web_runner
slash => splash
Please add a comment above this line: ``` // This is a regression test for https://github.com/flutter/flutter/issues/58665 ```
Shouldn't we be using the Ink widget here?  https://api.flutter.dev/flutter/material/MaterialType-class.html
Ah nice
I took a look at the ink widget, and couldn't figure out how to apply it here. If i understand correctly, the Ink widget just make the splash go through the decoration of the Ink. but there is a stack on top of the material widget
You're right. I thought Ink would draw the splash on top of the Material's descendants, but that's not right. Your original approach was the right one after all, sorry about the detour.
Without this change we hit an assert in the integration tests.
this is the fix
and this
Oops, I didn't notice that I was inconsistent about this. Can you make all the `INSTALL`s lower-case to match the other function uses?
Are there any other uses of this left in parent scope?
I forget when I wrote up the bug that this was already here even in the BundleUtilities version :)
We should update the plugin template to have an empty list with this name, with a comment explaining what it's for, so that plugin authors can easily see how to add a library rather than needing to dig into the rest of the build system to discover it.
@Piinks: does this particular change looks good to you? I haven't found place where this constructor is call with null.   In NNBD a factory constructor can not return `null`. If we want to return `null` the only solution is to replace this factory constructor by a static method. 
I think this will be ok. The only use of this factory is above on line 569. :)
nit: un-indent this line by 2 spaces.
Thank you! It's updated. This indent is the default behavior of vs code flutter plugin. Should I report it somewhere or is it not actually managed by the plugin? 
Avoid `__dir__`, I used it in add-to-app version of this and people have [had issues](https://github.com/flutter/flutter/issues/54675).
Hopefully CocoaPods never removes `defined_in_file` (the path to the Podfile) but if they do, fallback to... this file.
This gives us flexibility to support bitcode (someday).
This logic will be updated to do https://github.com/flutter/flutter/issues/39659.
nit. including `generated_xcode_build_settings_path` in the message would be helpful
should we log a warning if it doesn't repond to defined_in_file?
Changed it to include the path ``` [!] Invalid `Podfile` file: /Users/m/Projects/test_ruby/ios/Flutter/Generated.xcconfig must exist. If you're running pod install manually, make sure flutter pub get is executed first. ``` and ``` [!] Invalid `Podfile` file: FLUTTER_ROOT not found in /Users/m/Projects/test_ruby/ios/Flutter/Generated.xcconfig. Try deleting Generated.xcconfig, then run flutter pub get. ```
\o/
what's the transition plan for add-to-app? Can we change this line in https://flutter.dev/docs/development/add-to-app/ios/project-setup#option-a---embed-with-cocoapods-and-the-flutter-sdk to load `File.join(ENV["FLUTTER_ROOT"], '.ios', 'Flutter', 'podhelper.rb')` or some such?  
I was sensitive about this due to https://github.com/flutter/flutter/issues/42513 but we know the location of the Podfile--it's this file. I think I'm over-engineering this a bit.  I just need to pass in this file.  We can keep the fallback to `defined_in_file` and subsequent `raise` [in the podhelper](https://github.com/flutter/flutter/pull/59044/files#diff-9a4a61b0e60143d9364139b944b2d485R43-R44).
Added this hook for future use (could have been used for the old `install! 'cocoapods', :disable_input_output_paths => true`, for example)
Currently the CocoaPods add-to-app module lays down a similar but not quite the same podhelper in the ephemeral directory, which gets recreated on a `flutter clean`.  As long as we didn't rename those methods and break existing host Podfiles (unfortunately the names don't reference iOS or the module: `install_all_flutter_pods`, `install_flutter_engine_pod`, `install_flutter_plugin_pods`) we could transition them to this bin podhelper, but I don't know what it would really buy us (other than they would get updates instantly instead on a `clean`).  I'm concerned it would make the CI story more complicated because `flutter` would need to be available on every machine, even if the entire module and podspecs and binaries were already placed in the right spot.  P.S. We wouldn't want them to need `FLUTTER_ROOT` on their path, it would have to be parsed from the Generated files the same way this one is.
ya, it should be a separate task.   What I had in mind actually may or may not work. One small ergonomic annoyance now is if someone checks out the iOS and flutter projects, it currently takes 3 steps to build again. Go to flutter, flutter pub get to make the .ios folder with podhelper.rb, then go to iOS, call pod install, then open xcode, run.  Perhaps we can save one step if the various flutter_install_* code called flutter pub get to make the underlying xcodeproj if needed etc?
That would be cool.  Want to create a new issue?
One more change to make more future proof: pass in the target instead of the build configuration.  This will give us access to the target name so in the future we can just make changes to the Flutter-specific targets (like adding a Flutter linker flag).
Nice, good catch
The cache is only for downloading artifacts (I think). Could we release the cache automatically after checking for cache updates? that way it wouldn't need to be done adhoc in each subcommand, and would be able to skip the cache for commands that don't download anything (like --version)
That makes sense.  The one-off I see is test command explicitly running [`await globals.cache.updateAll(await requiredArtifacts);`](https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/commands/test.dart#L159) which is causing it to check for updates twice.  (Introduced at https://github.com/flutter/flutter/pull/30254/files#diff-57bf7f0d5a70ab392ae3047369120c83R102).
Also `precache` probably needs it re-locked.
Remove "early" semantics.
Pre-cache still needs the cache lock.  I tested this manually and confirmed two concurrent `precache` commands wait for each other.
This is the magic line, correct?
Unless I'm totally missing something, this did a second required artifacts update check.  When I stepped through it it called `updateAll` with the same artifacts twice.
Yup that's the good stuff.
I'll add a comment.
odd...  I'm sure that is my fault
Moved `releaseLock` so it can run before `ensureReadyForPlatformSpecificTooling`.
Could you add a command test for the re-lock? somehow..
Added two new tests.  Kind of lame but I needed: ```dart   @visibleForTesting   static bool isLocked() {     return _lock != null;   } ```
nit: put spaces between `1 / _kFinalLabelScale` for readability.
nit: Remove comment here, unless it was intended to make it more clear? I don't think it should be needed.
Remove `);` at the end
It is to make it more clear and to be consistent with the other tests in this file
nit. is this guaranteed to match, even with the surrounding whitespace?
We generated this as part of the template with https://github.com/flutter/flutter/pull/4893/files#diff-fddbdff9cdb9e32ee9b9a95f74f30788R5-R8.  Xcode and CocoaPods won't add it (at least how we have the project set up now).
Can we rely on a build stamp so it invalidates on every upgrade?  Build system behavior could change without this file changing (could be a different PR).
The engine version is used as a shortcut for this: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/build_system.dart#L318  It should also include `flutter/version` though.  The goal of this input is just for local development, not to handle upgrades
@jonahwilliams  This line also causes an error when installing the service worker.  ```suggestion   return contentCache.addAll(resources); ```
thanks!
what data type is this? what's going on here?
its a JavaScript Array
ahhh, ok, I see it now!
TODO: re-add these checks with better implementation
TODO: remove once fixed
TODO: remove once fixed
Provided a default here for the google3 roll
is this supposed to be commented out?
Looks like the logic changed and this comment is no longer accurate.
Fixed
Fixed, and added test case that we default to 100 if terminalColumns is null
This was the actual bug fix, everything else is for testing
And here too
```suggestion           'The material library uses Localizations to generate messages, labels,' ```
```suggestion   /// This is parsed from the "traceEvents" data within [json] and sorted by timestamp. Anything ```
What do you mean by "time statistic results"?
end the line with a `.`.
per style guide: avoid empty prose like "note".
end sentences with `.`
I am not 100% sure I understand what this sentence is supposed to tell me...
Nit: "Assuming" -> "This routine assumes that"
We just renamed "GPU thread" to "raster thread" (https://github.com/flutter/flutter/issues/29443), so maybe change "the GPU rasterizer" to "the engine rasterizer"
This change involves `kRasterizeFrameEventName`, which is the part of the JSON item name, and part of engine interface. Are we sure we should change it here? 
Ah, I see that we forgot to rename `GPURasterizer::Draw` to `Raterizer::Draw` in the tracing events (CC @filiph ). I think it's fine to leave `kRasterizeFrameEventName` as is (since the change needs to start with the engine repo), and just remove `GPU` from this documentation. The `engine rasterizer` would be more accurate than `GPU rasterizer` because there's no longer `GPURasterizer` class in the engine. There's only `Rasterizer`.
Didn't we intentionally keep names of timeline events so as to not break people's measurement scripts?
Yes, now I remembered! You and Nathan were explicitly discussing about avoiding changing `GPURasterizer` in the tracing. Now it's also clear that if we change the `GPURasterizer` label in the engine, it will also break our framework performance tests.
Returning 0 if the list is empty may have the following problems: - It's unclear whether the 0 is caused by an empty list or that all values are 0 in the list. - It's going to add many 0-valued metrics to our benchmarks that currently don't have CPU or memory measurements (i.e., all Android tests). It will add a lot of dummy graphs to our dashboard, and may need a lot of baselining work.  Maybe we should assert the list is not empty when we're expecting CPU/memory measurements, and drop the value (not calling computePercentile) when such measurement doesn't exist.
The value is already dropped when it doesn't exist. I do a check here: https://github.com/flutter/flutter/pull/58820/files#diff-9277fbf8cff9518e455fc51bac717a7aR81 to ensure that a profile exists. I will change this to an assert though, given that this should never happen.
Nit per style guide: avoid empty prose like "note". How about"List [doubles] will be sorted"?
Nit: I believe we have the following pattern in other places: ``` eventByType[type] ?= <TimelineEvent>[]; eventByType[type].add(event); ```
Nit: `eventsByType` to suggest that it's a list?
Nit: we can use stricter `Map<String, double>` here?
Nit: throw exception or `assert` if it's unreachable?
Done
Done
Done
done
I didn't know this and I really like this.
I started by adding `userIdentifier` to `DebuggingOptions` property bag which meant that `userIdentifier` was explicitly passed around in fewer places.  However that didn't really make sense--the user isn't relevant for debugging or build, it's only relevant once you go to install or start the prebuilt app.  So I moved it into FlutterDevice.  You could theoretically deploy to multiple users on the same device, but I don't picture needing to happening often so it's not supported.  I'm all ears if you guys have a better suggestion for how to inject this into the AndroidDevice install/uninstall/start methods.
 dartdoc should have a newline between the top level comment and additional comments:  ``` /// Check if a version of the given app is already installed. /// /// Specify [userIdentifier] to check if installed for a particular user (Android only) ```
This needs more context on why someone would need to use this. Work profiles?
I agree that it doesn't really make sense for debuggingOptions. Updating the Device APIs seems like a reasonable approach - though I'm fairly certain there are overrides in google3, so you might want to double check even if FROB passed
We could also run `adb shell pm list users` for them to list possible users
I went through about 4 different versions of this help text, but none of it worked for every command I added it to.  It's too sparse though, I'll change this to make the help text different per command.  You might want to use this because you have multiple users on the device (System > Multiple Users) and only want to install to one user OR because you have [work profiles](https://developer.android.com/work/managed-profiles#testing_tips).  > For example, to find the users on a device, you would run this command: ``` $ adb shell pm list users UserInfo{0:Drew:13} running UserInfo{10:Work profile:30} running ``` > In this case, the primary user("Drew") has the user ID 0, and the work profile has the user ID 10. To run an app in the work profile, you would use a command like this: ``` $ adb shell am start --user 10 \ -n "com.example.myapp/com.example.myapp.testactivity" \ -a android.intent.action.MAIN -c android.intent.category.LAUNCHER ```
We could it for them, but I don't want to parse the output since there's no machine readable format options and this I doubt this flag will be used except by users who are already familiar with Android and `adb` (see b/142944798). ``` $ adb shell pm list users         Users:  UserInfo{0:Owner:13} running  UserInfo{10:jane:10} running ``` I don't think launching will work if the user isn't running (though install will?) and I don't want particularly want to explain all that.
Makes sense!
don't hesitate to add a big, huge help text that encompasses every possible command
In fact, rather than give each command a different flavor I would consider just adding headings to the flag:  ``` with run:  ...  with install:  ...  ```
So you run `flutter attach -h` and see the details for `flutter run` and `flutter drive` etc?
well, I would hide this particular option under verboseHelp, so -h v.   Maybe adding them all together is a bad idea, but I'd be worried about keeping the documentation up to date. Maybe a shared header + command specific details added on
How about: `'Identifier number for a user or work profile on Android only. Run "adb shell pm list users" for available identifiers.'`  What are our criteria for hiding options?  This one may be uncommonly used, but it's not like experimental or only relevant for Flutter or g3 development (like local engine flags, etc).
usually just go with your gut
> though I'm fairly certain there are overrides in google3, so you might want to double check even if FROB passed  I don't see any obvious overrides that would be impacted by this change.  @mehmetf can you double check me?  You were thinking about this awhile ago https://yaqs.corp.google.com/eng/q/4970372142465024 (internal) b/142944798
Will this break -d all with a user identifier?
Before this change `flutter drive -d all` runs on the first one it finds.  I can't find an issue complaining about that. ``` $ flutter drive -d all -t test_driver/route_test.dart Found multiple connected devices: Pixel 4           • 98281FFAZ005T6                       • android-arm64 • Android 10 (API 29) iPhone 11 Pro Max • 16AF0D86-8F62-410C-8CC2-8F70C49835AF • ios           • com.apple.CoreSimulator.SimRuntime.iOS-13-5 (simulator) Using device Pixel 4. ... ``` This `validateCommand` Android check is against the one device that's about to be used in `runCommand` [`_device = await findTargetDevice();`](https://github.com/flutter/flutter/blob/1e4d9f8502b7911f920c11d289b807c0ec7afd1b/packages/flutter_tools/lib/src/commands/drive.dart#L151). 
Never mind, @jonahwilliams pointed me in the right direction.
We override the DeviceManager. If tests pass, this should be OK to land. Feel free to update the internal bug so we can try it out internally when this lands.
Supporting CL has been submitted.
I cannot make it targeted because navigator.dart cannot depend on hero.dart or app.dart. otherwise it will be circular dependencies. The other choice is merge hero.dart and navigator.dart, but that will probably be a nasty breaking change.
nit: use a trailing commabetween the ) and put the second one on a seperateline.
Why can navigator.dart and hero.dart not import each other? They are both in widgets layer.
Maybe define an observers getter on the NavigatorState that returns the widget.observers followed by the inherited one and use that everywhere instead of `navigator.widget.observers` to avoid this duplication?
Why do we need to do this? if `didChangeDependencies` finds a different InheritedNavigatorObserver it would just update it. If it finds the same `_updateInheritedObserver` would just short circuit. 
Can we move this up to where we initialize the other observers?
nit: rename the argument to `newObserver` to avoid the confusion between `inheritedObserver` and `_ inheritedObserver`?
nit: sub -> nested
Is that acceptable? I thought that is not a good design pattern. Do we have example in our code base that does it?
This should have minimum duplication once https://github.com/flutter/flutter/pull/57605 is merged, I separate them out because i don't want to create a list or using a yield everytime the getter is called
Ah you are right the InheritedNavigatorObserver.of will get called in didChangeDependencies anyway even if it will short circuit in _updateInheritedObserver.
navigator.dart and routes.dart - within the same layer it should be fine.
I am not in love with the name, I don't think we usually put "inherited" in the name of "InheritedWidget" subclasses. But I also don't have a great suggestion for it...
nit: update this comment.
sub tree -> subtree
maybe: which is the standard way of providing a [HeroController].
Should `_updateHeroController` just call `_updateEffectiveObservers `?
Call `_updateEffectiveObservers` here?
Why not just iterator over `_effectiveObservers`?
Maybe `HeroControllerScope`? 
Why not always wrap it?
This is an optimization I feel like doing. Would you rather be safe and always wrap it?
Let's always wrap it to avoid changing the shape of the tree when this changes.
Ah yes, I forgot about changing the tree shape cause the whole subtree to rebuild...
extraneous blank line
why? it seems perfectly reasonable to use this class to provide a HeroController if you're making a widget that gets a Navigator from somewhere else.
it's not more "Standard" than this way :-)
would be clearer to have two constructors, one that requires that controller be non-null, and one that doesn't have a controller argument, with a name like `HeroControllerScope.none` or something.
we should have a test that verifies that changing the hero controller mid-way through a hero animation works.
I think we should encourage user to use observer instead if they can?
I mean until we finally refactor the hero controller to not depend on navigator observer
This is a temporary workaround for router api, eventually we want to build a more flexible system. I think we should not further improve this api?
there is nothing connected to this, so it is safe to delete
Uber nit: what about adding try/catch, so if it fails for whatever reason, it doesn't stop the test
Well, it's already within a try/catch in the calling function, but I added one around this one too.  Actually, I also changed the other try/catch blocks so that they only catch `Exception`s since otherwise they'll catch everything, including `AssertionError`, `NoSuchMethodError`, and other `Error` subclasses that represent programming errors and not regular failures. I also upgraded some throws in here to throw a `DeviceException` so that they would be caught.
nit: fix indentation:  ```suggestion       child: GridView.builder(       padding: const EdgeInsets.all(0),       gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount:2),       keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,       itemCount: focusNodes.length,       itemBuilder: (BuildContext context, int index){         return Container(           height: 50,           color: Colors.green,           child: TextField(               focusNode: focusNodes[index],               style: const TextStyle(                 fontSize: 24,                 fontWeight: FontWeight.bold,               ),             ),           );         },       ),     )); ```
same here
@goderbauer  thanks for your review. I have some doubt about format.  I have tried to format file  by  flutter format xxx.dart ,  but it doesn't meet the requirements. Could you please tell me how to check it and what's the standard? thanks
@Hixie Could you please clarify the rule of flutter format when you have a time? i have tried flutter format xxx.dart and   flutter analyze. but it seems not good.
The rules for the style of this repository are written down in https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo.  Most notably, this repository does not use automatic formatting (e.g. with dartformat or `flutter format`). This rule about trailing commas is also relevant for this particular case: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use-a-trailing-comma-for-arguments-parameters-and-list-items-but-only-if-they-each-have-their-own-line
It's kind of you. Thank you for your patience. please take a look when you have a time.
done
We need test for each constructor as well
As I see,  arguments are refer to BoxScrollView,  is it a duplicate test code for that?
we can just make sure the below boxScrollview receive the right parameter.
@liyuqian would it be easier if the command required you to pass in a destination file?  like --write-sksl-on-exit=foo.sksl.json ?
That sounds good to me. It also makes my test easier as I don't have to worry about whether the tool will create sksl_02.json or sksl_01.json. With `--write-sksl-on-exit=foo.sksl.json `, I'd expect the file to be overwritten, right?
Yup! 
Lowercase "o" on "Only" here.  Also I think you forgot a word after that. "save"?
Extra empty line.
"Finishes the current autofill context and potentially saves the user input"
"input and is ready to submit."
Duplicate "the an" here.
This feels a bit inconclusive.  Is there anything we can recommend for users to do who want multiple contexts?
Nit: I think there should be no comma at the end of this line, but it's fine either way.
InheritWidget => InheritedWidget
I think you meant to finish this sentence here.
Nit: Another comma that I feel like should be removed.
Weird line break here with a floating comma.
Maybe open an issue about this and link to it here.
Can we avoid this? we want to move away from using navigator observer-like system?
Yes I would like to avoid doing this. Is there a better way to monitor global route changes? (Or did you mean `NavigatorObserver`s should not be used in general)?
At some point we want to remove NavigatorObservers. It was a compromise to implement hero controller, and people started to use it to monitor the route history which is not what it built for. This result in people wants to add more and more functionality to this class and things started to get out of control. One other way will be creating a new route class to monitor Route.didpush, Route.didpop and such...
question: why does the function receive savedForm? I remember we discussed in the future we might want to send more parameters with save. Is it related to discussion?
Should this call shouldSave: false?
There is nothing in the lifecycle which calls "shouldSave: false", is it possible to have a scenario that we want to cancel the form?
Question: why are we adding this check in the framework, can we handle it on the iOS engine side?  The reason that I'm concerned is, platform is does not necessarily mean that this is a flutter app running as an iOS mobile app. It can also be a Flutter Web app running on iOS Safari. Since web also return TargetPlatform.iOS, in this case, this branch won't work correctly on browsers on iOS, running Flutter for Web. The code is here: https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/foundation/_platform_web.dart#L20  
The `FormState` here is just a bit of additional information that helps the developer determine what needs to be done when this particular form gets saved. The framework doesn't really send the information to the engine.
I'll check if `kIsWeb`.
Can we just do this on the iOS specific implementation in the engine? 
Having this global is odd. Why do we need it? If you want different settings, you'd just wrap your subtree in a different `AutofillContextLifecycleAction` widget.
Why is this the condition for saving? What if I have my form an an Alert box or something like that?
It's very odd to special case this. Also, why does autofill depend on the navigator?
It is less data we're sending to the engine on iOS I guess? 
Why do we need to do this filtering on the framework side? Can the iOS embedder just pick the fields that it finds relevant?
This should document what happens if called when not on Android.
```suggestion   /// input for future use if `shouldSave` is true. ```
And elsewhere in this doc since it is a parameter to the method and not a member of the surrounding context that we can link to.
assert that this is not null?
I think by doing this we would be able to reduce the size of the messages we have to send to the platform every time the focus changes. 
It does get rendered differently I think, for instance `children` and `onValueChanged` on this page: https://api.flutter.dev/flutter/cupertino/CupertinoSlidingSegmentedControl/CupertinoSlidingSegmentedControl.html. Also the LSP client I'm using is able to pick up method parameters that are in square brackets. 
It's nullable, and on dispose action is going to be a no-op when it's null.
We should document what no-op in that case means (and instead of using null, can we define a `AutofillContextAction ` for that?
See also: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#dartdoc-specific-requirements
_isInAutofillContext can never be set to false once it becomes true, is that right?
Yes. If a text field's was in the current autofill context, and then its autofill gets disabled (by setting `autofillHints` to null), the engine needs to remove it from the autofill context. It lets the engine know by sending its new `TextInputConfiguration`, instead of remain silent in which case the engine will just assume the text field is gone and it will keep the old user input (See line 1528).
I wonder why is a separate enum case preferred over `null`? I think in this case using null to stand for "no action should be taken" makes sense too. Is it because the analyzer has exhaustiveness check for enum cases?
lives => live
also have the ability to call => call
they are getting => they are
This is a rather long and informative comment. It might help to briefly summarize how a typical app will use finishAutofillContext, before going deep.  The paragraph at the end of this would serve the purpose.
A typical app can  make sure that no input field is focused but I don't think typical apps have any idea if  "any connected [TextInputClient] is disconnected".    It would helpful to illustrate the typical form case with a brief example.   If developers typically need to check if the TextInputClient is connected, we're going to have to explain how.
the default behavior can be overridden by using ...
all these => all of these
autofill context related actions will be automatically taken  => no action will be taken
Question: Since we have only one `autofill context` multiple AutofillGroups can end up in the same context right?
question: If "onDisposeAction" is called on an autofill group, and if it calls "finishAutofillContext", it will still save all the autofill values, is it correct?
Maybe we can reword this part as for example on platform X, "savefor autofill" dialog and disrupts the user's flow. Otherwise it might look like all platforms have a dialog with the same warning message, which might confuse the developer.
Can we also change this method to send "commit/cancel" information as an argument to make it similar to the other methods?
I guess it depends on what the `onDisposeAction` was. The `onDisposeAction`, if not null, is destructive. So if a finishAutofillContext call to save the user input is called after an `onDisposeAction`, that call has nothing to save because the context is destroyed at that point.
Yes
removed the assert so it's no longer a hard requirement.
Update to take a bool. Let me update the engine PR.
The definition on topmost (the ones that are closest to the root widget) is in the comments on line 54. It is not very close to this variable. In order to increase readability of the code, and make it easier to understand by developers checking this variable, let's document `topmost` here as well.
Added a comment in the code.
The formatting is slightly off here. Should be:  ```dart home: Scaffold(   appBar: AppBar(     title: const Text('Title'),     shadowColor: Colors.yellow,   ), ), ``` 
I fixed it [here](https://github.com/flutter/flutter/pull/58708/commits/788b6fca084e88ae4d3d4e901f56bbfd66d0884a)!
We should consider what this means for the copy of `DualTransitionBuilder` in the animations package once this makes it into stable. Would we be able to safely remove `DualTransitionBuilder` from the animations package and use this version instead?   Also, I don't think this'll be a problem, but I'll ask just in case since I'm not sure what will actually happen -- Will there be any conflicts/problems with having both the copy here and the copy in the animations package exist at the same time?  cc/ @goderbauer
We shouldn't import the widgets package in this file since this file is also in that same package. Instead, we should import every file that's needed independently [like this](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/heroes.dart#L7).
If we do bring the builder in here, we should bring in the tests from the animations package as well: https://github.com/flutter/packages/blob/master/packages/animations/test/dual_transition_builder_test.dart
Did you mean when the animation was _not_ completed?
It might also be valuable to describe how `isCompleted` is used for the `ScaleTransition` as well, since that isn't clearly explained.
Thanks for adding these API docs! 
nit: indentation.
Can you leave the key argument? Even though its not used it's convention to just have it on all widgets.
nit: add a key param
animation has to be non-null, presumably? add an assert?
I'll wait until we have conclusion from Goderbauer about the copy.
This also applies to the other widgets defined in this PR.
Just define the statics in the class in which they are used for cleaner encapsulation. 
I don't fully understand this. Why does the opacity jump to 0.0 when the animation is completed?
Why this? It appears that both tweens produce the same value when the animation is completed?
The container will have to be wrapped in an AnimatedBuilder since you access the animation's value directly, the container needs to rebuild every time the value changes.
Same here as above: why do we jump suddenly when the animation is dismissed?
+1
We should delete it from the animations package and use the one from the framework here. Deleting itself should be fine since the builder was never part of the public interface of the animations package. However while the DualTransitionBuilder exists in two places, I suspect there may be a conflict within the animations package as there are now two competing DualTransitionBuilder definitions. If that is the case, we should hide the framework implementation in the package until this change has made it to stable and then delete the implementation in the package (while increasing the minimal flutter version).   Can you please check whether the example app in the animation package builds correctly with this change applied to your Flutter version? If it doesn't we will have to hide this implementation in the package before this change can land.
nit: can you turn this around for easier readability: isDismissed ? kAlwaysCompleteAnimation : foo.
here and elsewhere
> Can you please check whether the example app in the animation package builds correctly with this change applied to your Flutter version? If it doesn't we will have to hide this implementation in the package before this change can land.  Got it, scheduled for tomorrow since it's already 2.A.M.
> Same here as above: why do we jump suddenly when the animation is dismissed?  I've update the explanation about why the `isCompleted` and `isDismissed` exist, can you check it out to see if it has enough information for the reason?
Done.
Done.
Using `AnimatedBuilder` to wrap the `Container` will cause the forward transition failed. (For now idk why it'll happen).
The forward builder stays in the widget tree, so the container needs to be transparent otherwise the child will be all in black.
Yes but it produce different value when animating. It require different value between the forward end and the reverse start, as the implementation before.
What do mean statics here? The animation needs access in methods...?
Should this be renamed to `_ZoomEnterTransition` for readability?
`_ExitTransition` -> `_ZoomExitTransition` ?
If we export it here it'll be public for use.
Confirmed, there're conflicts in animations package if we export it.  ![image](https://user-images.githubusercontent.com/15884415/83935217-2305f400-a7ea-11ea-9a5f-350bfdc55bca.png) 
@goderbauer Confirmed, there're conflicts in animations package if we export it.  ![image](https://user-images.githubusercontent.com/15884415/83935217-2305f400-a7ea-11ea-9a5f-350bfdc55bca.png) 
Great implement! ❤️ 
Sounds good to me
Sounds good! 
nit: newline at the end of a file
This is a layer violation. You can't import an implementation file from the widget layer directly into the material layer. The widget layer should export the transition builder so that you can just import `package:flutter/widgets.dart` here.
assert that `reverse` (and probably also `animation`) is not null.
This one is still unresolved, as far as I can tell, there is nothing right now ensuring that the Container gets rebuild when the opacity changes. 
A comment should explain why code is written the way it is, it should not paraphrase the code in words like this one is doing. In particular, this comment should explain why the animation status matters (this is still not clear to me). 
Same asserts here as above.
nit: fix indentation
Instead of `!reverse` express this positively: `reverse` to simplify things.
Oh I thought that we need to hide it from here. Sorry for that.
@goderbauer Is it good to use ```dart (reverse   ? _scaleDownTransition   : _scaleUpTransition ).animate(animation) ``` Or ```dart reverse   ? _scaleDownTransition.animate(animation)   : _scaleUpTransition.animate(animation) ```
It's really hard for a person whose native language is not English 😕. I'm wondering if this looks okay: ```dart // When the transition is running with the [reverseBuilder] in [DualTransitionBuilder], // the status of the animation will be always [AnimationStatus.completed]. // // To ensure the opacity only changed with forward animation, we need to combine // the [reverse] flag with the animation status. ```
@goderbauer 
Thanks for improving the wording here, the original I left in here was really vague. Let me try to clarify this more, you can use what you think makes the most sense from it and add parts of yours that you think is helpful as well:  ```     // The transition's scrim opacity only increases on the forward transition. In the reverse     // transition, the opacity should always be 0.0.     //     // Therefore, we need to only apply the scrim opacity animation when the transition     // is running forwards. ```  cc/ @goderbauer I think I tried `if (!reverse && animation.status == AnimationStatus.forward)` but it did not behave as I expected, but I cannot remember the exact details of the weird behavior. 
```suggestion  // @dart = 2.8  ```
```suggestion  // @dart = 2.8  ```
I'll take your wording, because the reason I've written which related to the `DualTransitionBuilder` seems unnecessary here.
the docs should also include a description of the constructor (or you can change `///` to `//` to indicate it's not camera-ready documentaion)
```dart /// Creates a [_ZoomPageTransition]. /// /// The [animation] and [secondaryAnimation] argument are required and must /// not be null. ```  Something like this?
Or we can remove these comments since the transition is a hidden one.
I think we can keep the comments. What you have proposed looks good to me
I looked into it again for the reason it has to be `if (!reverse && animation.status != AnimationStatus.completed)`. This allows an interrupted reversal of the forward transition to smoothly fade the scrim away.  Using `if (!reverse && animation.status == AnimationStatus.forward)` causes the scrim to instantly vanish if the animation was interrupted while it was transitioning forwards. This results in a disjointed experience, so it's likely better to have the scrim fade away rather than having it suddenly disappear.
So should I take further action with this comment?
I was thinking of waiting for what goderbauer thought, but I think it also makes sense to add a few sentences explaining this: ```     // The transition's scrim opacity only increases on the forward transition. In the reverse     // transition, the opacity should always be 0.0.     //     // Therefore, we need to only apply the scrim opacity animation when the transition     // is running forwards.     //     // The reason that we check that the animation's status is not `completed` instead     // of checking that it is `forward` is that this allows the interrupted reversal of the     // forward transition to smoothly fade the scrim away. This prevents a disjointed      // removal of the scrim. ```
Then I'll hold off the commit since there are already 31 commits in this PR. But he has disappeared for a week. 🤣 
The number of commits shouldn’t matter for the PR since we squash and merge (everything shows up as a single commit).
Okay then I'm going to mark this as resolved.
Was this change necessary for the fix?
Per adb specs, the `-T` has to be followed with either plain number or quoted timestamp. And it does fail for me otherwise.
This looks like you're adding the hitmap twice here and below
oh good catch, missed it during the re-sync, removed it
I would assume that this is resolving *from* web, downwards, but it seems to be resolving from web's parent (??)
Its actually from above where we look for dart source. We need to resolve down from the project directory to handle requests like lib/main.dart for source maps, so this is working as expected I think
Ahhh, makes sense. Thanks for the clarification!
We try and reserve the '=>' notation for one-liners that return a value. If you want make this a one-liner then: ```dart  void _handleDragStart(DragStartDetails details) { _startInteraction(details.globalPosition); } ```  Here and elsewhere.
This can go on the previous line
Need a comment that explains why we're including a Builder here.  Here and below.
Create const Color vars for these values, to make it easier to read the code that checks them.
```dart () { Navigator.of(context).pop(); } ``` Here and elsewhere.
Please add a comment here that explains why we expect 1 drawRect and 2 drawRRects.
I think if we can't use the => notation is makes sense to have it as it used to be. I think having the separate lines are closer how the formatter works and easier for people to read.
Done
Done.
Done
Done
Updated
This was missing from https://github.com/flutter/flutter/pull/58538.  Handle the null param.
Nit: Parameter list is getting long, add a trailing comma and reformat it
Maybe these consts should be moved to the top of the test and then used above to not duplicate?
Done!
Done!
It's not clear if "the size of the app bar when it is collapsed" is widget.collapsedHeight + [bottom.preferredSize.height] etc, or if it's just widget.collapsedHeight. It looks like you meant the latter, but maybe it should be the former?
Makes sense.  ## Collapsed height After looking more at it, I think collapsedHeight should set the collapsed height excluding any padding. It is similar to how the expandedHeight works:  ![Sliver app bar](https://user-images.githubusercontent.com/1770678/83883744-2fd00c80-a744-11ea-948c-b4e78390abee.png)  The user will have to make sure that they do not set a too small of a collapsedHeight, as that could cause overflow error for the bottom widget or hide the title. I am not sure if we need to add any assertions for this, I do not think it should be needed as it is quite obvious.  ## Opacity change I noticed also an issue with how the opacity changes when a user scrolls up, it does not correctly change the opacity for the title in my current implementation, so I will fix this too: ![no_opacity_change](https://user-images.githubusercontent.com/1770678/83883938-7887c580-a744-11ea-9218-8024364f5642.gif)  Here is how it looks like without collapsed height and the opacity changes correctly: ![without_collapsed_height](https://user-images.githubusercontent.com/1770678/83884386-167b9000-a745-11ea-8b2d-58cec2235661.gif) 
is => are  I assume that you're describing the default collapsed height here. So "the collapsed" => "the default collapsed"
This property is no longer just the size of the app bar ... It would be OK to say: Defines the height of the app bar when it is collapsed.
is set to => is
If a [bottom] widget is specified, then its ...
then the [MediaQuery] top padding, [MediauQueryData.padding.top], is added as well.
any top padding => the [MediaQuery] top padding
The `collapsedHeight` is actually ignored when `pinned` and `floating` are true and `bottom` is set. See line 1330 in `app_bart.dart`.  But I should respect it, and default it to `0.0` if `collapsedHeight` is not set. I'll do another revision for this, it will require me to update the `toolbarOpacity` calculation though.
NICE, I think this is easier to read then the original truth table.
do we not want to print any error?
Ahh good catch- I deleted too much here
ha ha, catch
Fixed
This seems odd...
perhaps it needed the real project so it could run the real doctor?
I mean the `globals.flutterUsage.isFirstRun` check part circa https://github.com/flutter/flutter/pull/3523/files#diff-1202b4fb926dd6b56d4fb16f50f6baedR50
`globals.flutterUsage.isFirstRun` is always false because it's backed by a `LogToFileAnalytics` which is a `AnalyticsMock` which hardcodes `isFirstRun` to false.
This added nothing
Only show for verbose errors, actual bugs will get logged to stderr
This was fixed several months ago by @aam 
https://github.com/flutter/flutter/issues/35924
When there is an applicationBinary then there was no native build step, so we need to show the flutter run errors as normal
Can you add a comment for when you would want to suppress errors?  Doesn't sound like something you would generally want to do.
done here: https://github.com/flutter/flutter/pull/58539/files#diff-e78651ad5bd5c46811f2b76bc465220bR375
I guess this PR is the crumb trail for the signature as to why you would want to suppress errors (so they aren't displayed twice in certain scenarios).
nit: `@visibleForTesting` 
Looking at this, is it correct that the label (and some of the other properties here) are only published when the slider is interactive? I'd assume a disabled slider should also have a label?
Yeah, I thought that was weird too, but I didn't want to change it without understanding it. @clocksmith, is there a reason for that?
nit: this is the default and could be omitted. 
Is it save to publish these actions when the slider is disabled? My intuition is that despite the disabled flag, TalkBack/VoiceOver will now announce the actions. Can you double check that with TalkBack/VoiceOver?
(see earlier comment): Since the slider is disabled I would have expected it not to have these actions. AFAIK a disabled button also doesn't publish a tap action.
Same here.
Well Talkback seems to tell you what the next increment will be, but not actually increment things, but you're right, it probably doesn't make much sense even if it doesn't do anything.
Done.
Removed.
Removed.
Did you define this one and forgot to copy it over or does it already exist ?
Did you mean `{@macro flutter.dart:ui.textHeightBehavior}`, which is what we are using as the macro in `text_painter.dart`
Thanks for the spot, I updated all the macro references to `{@macro flutter.dart:ui.textHeightBehavior}`
Forgot to remove this on the first go.
I let the tool migrate all these examples by `flutter build ios`ing them.
magic
This was the most basic Apple Swift Package I could find.  When we run the integration test it will check out this dependency from the GitHub repo.
sure hope that repo doesn't disappear...
nit. is the `.toString()` necessary?
nit. can you use a `FakePlatform` instead?
This is the example package used in the [Swift docs](https://swift.org/package-manager/#example-usage) so hopefully if they every remove it they will replace it with some other example we can easily migrate.  Fortunately it's not actually being used anywhere, so it will be extremely trivial to replace with some different package.  
No, copy paste problem.  Actually I forgot about `migrateLine`, I can make this: ```dart   @override   bool migrate() {     if (!_xcodeProjectWorkspaceData.existsSync()) {       logger.printTrace('Xcode project workspace data not found, skipping build location migration.');       return true;     }      processFileLines(_xcodeProjectWorkspaceData);     return true;   }    @override   String migrateLine(String line) {     const String legacyBuildLocation = 'location = "group:';     const String defaultBuildLocation = 'location = "self:';      return line.replaceAll(legacyBuildLocation, defaultBuildLocation);   } ```
I didn't know about `BufferLogger.test()` when I first wrote this file.  Good eye.
I spent a whole day once removing `const LocalPlatform()`'s from tests, so it instantly jumps out at me.
The addition of `frame_rasterizer_begin_times` looks good.  For the order change, considering that most text editors will show the top of a file by default, is it better to still keep the key statistics on top? Or maybe we should only write the key statistics (e.g., average, percentiles) in the summary json file, and write all timestamps in another json file?
Since the output at the end of the run is only loosely related to what is in the file, we could have the output put important information at the end, but the file contain important information at the top. Let me look into that.
Actually, I'll make the changes separately and undo the ordering in this PR.
it looks like all cells are updated. Would it be better to selectively update x% of cells?
Non-updated cells would have to go through `addRetained` and hit the same logic anyway
Changed the benchmark so it's 50% updates and 50% retaineds. The numbers are still the same (as expected), but this should catch regressions in either of the codepaths.
Why do we need the Mixin? Isn't _PageBasedCupertinoPageRoute just a subclass of CupertinoPageRoute that has an extra `page` getter?
Looks like docs are duplicated. Any chance of using a macro?
Why do we need this `page` getter? The class is private and nobody in this file seems to be using it?
Same questions about the mixin and the page getter here.
nit: indentation
The name is not great, not sure what to use instead, though.
Why the indirection via _PageBasedPageRouteBuilder? Could it just return a PageRouteBuilder?
All the override getters below are using it.
I need to override all the property getter in CupertinoPageRoute, i figure it is cleaner to separate out the logic into a mixin
PageRouteBuilder takes in builder methods and they cannot be changed through out the route lifecycle. Let's say someone update the page with same key but different builder, the route underneath will update its settings to be the new page, but it cannot update its builders to be same as the page's builders.  The _PageBasedPageRouteBuilder that builds its transition through the pages builder. That means the builders it use will be up to date when page updates. The same philosophy applies to MaterialPage and CupertinoPage  
Does that actually work, though? From what I can tell, the builder is called from `Route.buildPage`, which is only called when the route first builds (as documented). In fact, I believe its result is actually cached somewhere and reused for all subsequent builds of the route. So even if the builder changes, I would expect it to never take affect.  The tests in this PR seem to indicate that it does take effect, though. How are we clearing the cached page?
I didn't see where we cache it in our code, maybe the document is outdated? Even if the caching is true, using _PageBasedPageRouteBuilder will just make the TransitionPage.pageBuilder as responsive as thePageRouteBuilder.pageBuilder but not less.
This is the cache I was talking about:  https://github.com/flutter/flutter/blob/4d7525f05c05a6df0b29396bc9eb78c3bf1e9f89/packages/flutter/lib/src/widgets/routes.dart#L699-L703
The pages update in navigator will called changedExternalState which clear the cache
This is not good, it seems like we only want to call this when pages list actually change. Currently, it is calling whenever the navigator rebuild, and that that is wasteful
well, maybe not that wasteful, because it is just widget build and we do that all the time
Interesting. I believe there are some other properties that are not honored when they are changed after the route build for the first time. `maintainState` is one example I can think of.
I do a little search it looks like `maintainState` is the only persistent flag that doesn't change through out the route lifecycle.  MaterialPage: builder: ChangedExternalState fullScreenDialog: ChangedExternalState  CupertinoPage: builder: ChangedExternalState fullScreenDialog: ChangedExternalState title: ChangedExternalState  TransitionPage: pageBuilder: ChangedExternalState transitionsBuilder: changedInternalState transitionDuration: changedInternalState opaque: changedInternalState barrierDismissible: changedInternalState barrierColor: changedInternalState barrierLabel: changedInternalState fullscreenDialog:ChangedExternalState  for me, it seems like this is still a reasonable thing to do, what do you think?
`OverlayEntry.maintainState` is a setter, could we call it in `changedInternalState` to sync the Route's maintainState with the OverlayEntry again to make the flag take effect?
make this one private since it is only intended to be used within the class?
private?
the class itself is private. I thought we don't usually make property private if it is already under a private class?
If we would make this class public should this property be public?
I see, yes, that should be private


=============== REACHED API LIMIT AT PR 1792 =============== 2586 Pull Requests were analyzed
 There were 6320 comments

Ah I see, it only resolve when  delta_time > expectedIdlePeriod and the timer/microtask caches are empty. That is a bit weird though, shouldn't we resolve the future as soon as timer/microtask caches are empty? why do we still want to wait in this case. I was imagining this kind of logic  if (delta_time > expectedIdlePeriod || caches are empty) resolveFuturesCompleter.complete(); else continue;
so you're saying an app can't use a plugin with a higher minimum ios version?
Could we throw if ` call.arguments` isn't a `Map`?
This is from the original snackbar API.
```suggestion              testUsingContext('Version.json info is correct',(){ ```
Why is this the condition for saving? What if I have my form an an Alert box or something like that?
Added a few more context. Please let me know if that looks good.
Hitting real artifacts, failing if they did not exist
Could we also make this a unique file?
No, it will throw a tool exit if `throwOnError` is true (which it is by default)
nit: return not needed.
Done
I think it's not worth it right now, but that would be a good plan if we notice that there's a problem with the change in this PR.
```suggestion           args[1]['action'] as String,           args[1]['data'] as Map<String, dynamic>,         ); ```
nit: this seems to be equivalent to  ```suggestion       _gestureType = _getGestureType(details); ```
origin 2-space indent was OK?
nit: I couldn't find the definition of "main axes". Maybe "horizontal axis or vertical axis"?
Understood.
OK, sounds good, added a comment.
this ! should become unnecessary when you update to tip of tree
No, but it does need an ignore on dead code:  https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/painting/text_span.dart#L372  
instead of catching the exception, use:  `expect(() => .., throwsToolExit(message: ...)`
we could wrap this body in an assert to prevent people from depending on it in release builds (just have it always return false or something)
Fixed. Move the RangeSlider test case to another file.
I took a look at the ink widget, and couldn't figure out how to apply it here. If i understand correctly, the Ink widget just make the splash go through the decoration of the Ink. but there is a stack on top of the material widget
Could you use `default` to handle `constrainedAxis == null` and then just do everything in the switch statement?
This test is new.
nit: add a trailing comma to the end of this line
I think we should move this logic to our default `DeserializeFinderFactory`, and make it `@mustCallSuper`.
how much trouble do we get in if all these are non-nullable?
I don't see any risk of that but since we are cherry picking this, let's make it as simple as possible. We can always update the sdk version later. WDYT?
Can we also change this method to send "commit/cancel" information as an argument to make it similar to the other methods?
Ugh, forgot I changed this before landing last week. We originally threw a `StateError` [here](https://github.com/dart-lang/sdk/blob/master/pkg/dds/lib/src/dds_impl.dart#L32) but past me thought that wasn't a good idea and changed it.
How come this works here and not for add-to-app? Because our template build phase puts xcode_backend.sh later than where cocoapods can help us put it?
serials -> series
```suggestion          autoValidateMode: autovalidate              ? AutoValidateMode.always              : (autoValidateMode ?? AutoValidateMode.disabled), ```
Well this one is a bug I didn't notice. 
@jonahwilliams ah! it's because you didn't use a raw string!
addd -> added ?
FWIW, I would lean towards moving from `dynamic` to `Object?` everywhere rather than the other way around, but that's something we can worry about in another PR.
This `assert` doesn't take into consideration for multiple input events at the same time. This often happen for `PointerAddedEvent` and `PointerDownEvent`. 
is the code that generates this string also removed?
This is awesome. Your PR LGTM.  My only question is if there is an official documented procedure for rolling the gallery here, and if it can be updated to reference this file.
Why not use a `String` directly?
Same here.
Removed the sync call because for processes async is better, and it was only used once
@hansmuller just astutely noticed the Align-ment (😆 ) here is off. Can you fix this nit before we merge?  ```suggestion        assert(widthFactor == null || widthFactor >= 0.0),        assert(heightFactor == null || heightFactor >= 0.0), ```
Couldn't you leave `_mouseTracker.schedulePostFrameCheck()`, and just replace the body of that function with the contents of this one?  I.e., doesn't this code belong in the mouse tracker, and not the binding?
Doesn't casting it to `Object` (as opposed to `Object?`) imply the `!`?
Makes sense to me
extra space
```suggestion        autoValidateMode = autovalidate            ? AutoValidateMode.always            : (autoValidateMode ?? AutoValidateMode.disabled), ```
nit: I believe we use `*` instead of `-` throughout the code base for enumerations. 
Ah, you are right. I'll add a test for this and fix it.
nit: maybe mentioned what "handled" (or returning true) means, e.g. that the event will stop propagating and nobody else will see them?
could we add a new suite in `test/services/platform_view_test.dart` that uses the new controller?  We could start by duplicating the existing tests and covering any change in behavior between the two controllers.
haha, actually, it appeared 238 times in total, and indeed most of them called `setState`. I will fix it.
Doesn't indicate the current text insertion point? Here and elsewhere.
This change is required to make the integration test added pass
What do you mean by "time statistic results"?
Added test case for missed null android sdk case for diagnostics
done
This was not a nit at all, thanks for pointing it out :)
Seems reasonable!
Do you mind if I do the template changes and the html parsing in a separate PR? I want to keep the PRs small and easy to review.
nit: per the style guide, the order of the constructor arguments and the order of the properties should be the same.  We should make that order make sense when reading the code (e.g. routeInformationProvider and routeInformationParser should always be together).
great! I think this will be a really useful debugging feature.
```suggestion       // State for all pointers which are currently down.       //       // The `hitTestHistory` is equivalent to `GestureBinding._hitTests`, which is important for       // `_handlePointerEvent` to replicate `GestureBinding._handlePointerEvent`. ``` Explain the property so that readers can understand without referring to another file.
But you can't use _CastError in your code anyways. I'd assume if you read the doc you are wondering what error type you're supposed to catch in a try-catch - and that would be a TypeError, no?
pretty sure every time you ask that question, the answer is yes
This has been in there for .. a while now.  Basically, we try to use the $CONFIGURATION because that's probably what the user wants if they're running from Xcode (in particular, we don't want instruments tests from debug mode Dart, and we set up instruments to run in a "PROFILE" configuration by default).  But we do let a user override it if necessary.
Can we avoid referring to this (and having developers refer to it) using dart:ui?
All of the createTestCommandRunner tests hit the context due to FlutterCommand. I started refactoring things out, but I got stuck on output preferences and rolled it back a while ago
cc @goderbauer any idea if any of our (non-test) customers (e.g. google3 or fuchsia) use Draggable without data?
Or is that inferred by the tool? 
It returns null not "null", right?
I think the current one is more readable (but I removed the local var and make it a bang).
This assert is a little odd. Why do we assert after removing that there's still something in _transforms? Shouldn't we assert before?
If it's the same API as pushReplacementNamed, does it need to be different?
sorry it is a typo, i meant the remote editing value. The formatAndSetValue also called _updateRemoteEditingValueIfNeeded https://github.com/flutter/flutter/blob/9e315985d0788ee04df48559896be46225ecf2f5/packages/flutter/lib/src/widgets/editable_text.dart#L1804  This will attempt to sync the current editing value to the embedding. I was wondering if selection only change needs to be sync to the embedding as well.
Thanks for the examples!
Yeah, let's only mention the `label` here.
Done, as discussed offline with the minor tweak of returning `null` by default.
Yes if its sortable. I can add that.
How about: ```dart static bool deleteIfExists(FileSystemEntity entity, ...) { ... } ```  Then it can handle directories and links as well.
This may be nit picking, but what if the _hasInteractedByUser is set to true due to one field has change, and later on the field get reseted? I believe the form will still autovalidating in this case. This may be an ok behavior, but we should mention it in the documentation.
`--platforms=android`?
It is not the type of keyboard, but rather the mark inserted is based on the directionality of the immediately previous run of text. This ensures the whitespace is treated as part of the same directionality run instead of defaulting to the underlying direction of the field.
Also, there's an extra space on L246 but the three `=`'s are not aligned.  
If the extension method applies to any implementation of `File`, then we need test coverage of how it applies to them.
indentation
Ahh, cool I didn't know it did that :) 
I think we could still leave this as APK right? Or is this code hit for iOS as well?
Good catch. I forgot to delete L44 during refactor.
Given the time constraints and the downside of getting this wrong, this seems like a reasonable compromise in the short term. We can always circle back later if the feedback is negative
Thanks @dnfield!
seems like we could rename this to posix exception, et cetera
Done
Why does `RouteInformation` need to have an opinion at all whether and how its serializable? Isn't that up to the implementation of `RouteInformationParser` to decide how to send it over?
> pumpAndSettle is the same by the way. We recommend that people test the number of frames pumped returned by pumpAndSettle() to make sure they got the right number of frames but in reality, no one does that. It is very difficult to maintain and it can change easily by your dependencies.  pumpAndSettle really only makes sense to test your own widget, it doesn't make much sense when testing something where you don't know how many frames are going to run. In general, app logic shouldn't be triggered on frames, so when testing app logic you shouldn't need to wait for things to settle. Just pump a frame to start animations, and pump a frame with a delay sufficiently later that all the animations are done.
When would both `date != oldWidget.date` and `utils.isSameDay(date, oldWIdge.date)` both be true?
... and O(N) _for_ removing ...
Is that acceptable? I thought that is not a good design pattern. Do we have example in our code base that does it?
Done
@fkorotkov we're ready when you are :)
I wonder if the caret metrics cache should just be invalidated whenever the text painter has to relayout and its width cache misses?
This test is good. A test that you get a tool exit for the operations that `_validateReadPermissions` is also needed.
Nit: compute `frameBuildTimeMicros ` in the constructor and make `averageFrameBuildTime ` and so on as public `get` functions so it would be easy for `FrameTimingSummarizer` users to get only a subset of stats in the future.
I'm expecting throw will happen at `element(finder)`. See my added fail test case.
```suggestion   /// The background color of the heading row. ```
Most of these methods do not need to be async - this made it much easier to fix the disabled test
@blasten This can be it's own class or we can add `pointTransformer` field to the `PlatformViewController` class. Then Android could just use `PlatformViewSurface`. What are your thoughts on this? 
done
Ahh, yeah - I think I was remembering it backwards
Done
That's a really good point.  I'm trying to think of a way we could capture both of these:  - A list of small images that together add up to a lot (e.g. a list of even small images that could still be half the size they actually are). - A single large image that, while a small percentage, still adds up to a lot (e.g. a 12MP camera image rendered even at device resolution)  We could add two properties, but that seems harder to manage and reason about to me. We could also probably track the images in a static map, and then check that the whole map doesn't exceed the maximum allowable KB.
This will change everything, not just desktop; is that desired?
Thanks for pointing that out. I've updated it by removing line 78. Please let me know if it looks good!
Sorry for late response. I tried to fix, please check them out!
Woo!
Don't really care what it says since that seems like a moving target, just that it exists.
Why is this needed? Wouldn't it be null to start with?
`moveEventCount` might be clearer than `intervalCount`.
Correct. This needs be added to `index.html` like this: ```html <base href="/base/path/"> ``` I think we should also change the html template to include the `<base>` tag commented out with an explanation: ```html <!--   Uncomment the following line if you are serving your web app in a path other   than the root.    Fore more details:   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base --> <!-- <base href="/foo/"> --> ```  I like the idea of parsing it automatically from the html file. But when do we parse it?  If we do it at server startup, the user could change their index.html file while the server is running. They have to kill and start their server again (not ideal).  Should we parse it every time we receive a request? I think this might work but will lead to slower responses.  Maybe do it at build time and re-parse on hot restart? This is different from today's behavior where changes in `index.html` don't require a hot restart.
nit: can you add line breaks to the sentence to keep the number of characeters under 80 per line.
Should be required, assert non-null.
As we've discussed earlier today, this probably goes to the E2E package.
Should the whole grid be colored for focus vs just applying the color to the focused day?
It was lazy before - I think there was a misunderstanding around what `late` means. If assigning immediately it has no meaning @stereotype441 should we have a lint for this?  To restore the lazy behavior that existed before this would have to be a nullable field type, and you would have to restore the old logic.
Done.
I think OutlinedButton padding should follow ContainedButtons (16 not 8)
Done
maybe mention that restorationId can be null but this disables restoration.  or have a separate constructor for disabling restoration, and make this one require non-null.
Done
As above... It's complicated.
How about: `'Identifier number for a user or work profile on Android only. Run "adb shell pm list users" for available identifiers.'`  What are our criteria for hiding options?  This one may be uncommonly used, but it's not like experimental or only relevant for Flutter or g3 development (like local engine flags, etc).
why does the order of the keys in the output map matter?
I had state-management libraries in mind – which will have to implement a way to interact with the restoration API outside of a `State`/the widget tree.  Provider will definitely want to expose a way for users to define restorable properties, where they would define both the ID and the property from outside a `State`.  It may not be too bad, as we can use `Map<Id, Property>` instead of a tuple. I need to play around it.
I'm not sure why the SDK's not sending a `_TypeError`, as that is defined similarly:  ```dart class _TypeError extends Error implements TypeError, CastError { /* ... */ } ```
That does look wrong. Wanna send a PR to fix it?
Also, "assert" in the name makes it sound like this should only be used in asserts?
I suppose if this were accidentally removed, the devicelab tests would already be failing.
That's what I was referring in https://discord.com/channels/608014603317936148/684483384839503894/755100965811519627: > it looks like all properties (primaryColor, primaryContrastingColor, textTheme...) could be non-nullable BUT CupertinoThemeData.noDefault() makes that impossible  Basically material currently relays on the nullability of those properties to work (see https://github.com/flutter/flutter/blob/d26268bb9e6d713a73d6148da7fa75936d442741/packages/flutter/lib/src/material/theme_data.dart#L1764-L1774) by using [_NoDefaultCupertinoThemeData](https://github.com/flutter/flutter/blob/d26268bb9e6d713a73d6148da7fa75936d442741/packages/flutter/lib/src/cupertino/theme.dart) that seems to be the only place where the properties can be null.  I thought it could be possible to refactor the code to make those properties non-nullable but I haven't manage to make it work :-(  So is there something I have to do in this PR regarding this comment thread?
need to check the assetPath != path, otherwise the tool recognizes `assets: - foo.txt` as its own asset variant.
More bike-shedding: maybe EnabledAndDisabledMouseCursor?
Cleaned-up that suggestion and posted it as a PR here: https://github.com/flutter/flutter/pull/66274
Updated to add test case for org-dartlang-app URI and to expect file URIs
done
The purpose of additional time is to increase the timeout value for the test section, I think we should not overload its usage. As of the current implementation it both increases the wait time for the timer/microtask and also extends the timeout.  It also raise another question, what if there are unresolved futures that user does not care about? currently it will always fail if there are unresolved futures after the additionalTime.  How about we expose a new api, something like `tester.resolveTimerAndMicrotask()`. this api create a periodic timer just like you do here, but the sideEffectCompleter will only resolve when there are no more timercache and microtasks. In the test, the developer can decide if they want to wait for the future by calling `await tester.resolveTimerAndMicrotask()`. If they have a bad test that creating unresolved timer or microtask, it will just hang.  We don't do any waiting at the runAsync tear down, it will be developers choices to decide what they want to do.
My thinking is that those are two separate responsibilities: When I get handed a bucket, I can store all the data I want in it. It is, however, not my concern to decide how/where the data is persisted. That's the responsibility of whoever owns the bucket and provided it to me. They need to make sure that it is hooked up to a manager.  Not requiring a manager also has the advantage that we can unhook a subtree. For example, when a widget is in the way of transitioning out in an animation, we no longer need to persist its state (in the state we've already recorded that it is gone). We can then just unhook the bucket.
Update to take a bool. Let me update the engine PR.
Sadly not. `WidgetTester` calls the `handlePointerEvent` with source but `WidgetTester.binding` is of type `TestWidgetFlutterBinding`, despite its concrete type being `LiveTestWidgetsFlutterBinding`.
`{}` means named arguments, and optional if not marked as `@required`, with default value if not assigned `null`. Here I don't think they should be optional. I added all `@required`. 
This sentence isn't complete.
See snippet just below this (291-302). The comments here have removed references to kToolbarHeight, but it is still in the sample, can you update the snippet to reflect a custom value?
This seems odd...
done
Is `ShrinkWrappingViewport` need `clipBehavior`?
Maybe comment where this is coming from or force the paragraph to actually use this size.
we'll validate that it doesn't exist and fail :) 
The `collapsedHeight` is actually ignored when `pinned` and `floating` are true and `bottom` is set. See line 1330 in `app_bart.dart`.  But I should respect it, and default it to `0.0` if `collapsedHeight` is not set. I'll do another revision for this, it will require me to update the `toolbarOpacity` calculation though.
doesn't have to be here, but from looking at this code it looks like we could replace this with a mock.
same.
Yeah, I'm also worried that adding logic to retain Windows line endings would tickle the Cirrus problem.
nit: fix indentation
I think because they are doing updates to the site currently, so maybe sometimes things don't work correctly
I read your comment below. I'll change that test so it reflects the new error messages.
nit: please make sure these are sorted alphabetically
Same comment as ContainedButton's test, could put this into an inner function to avoid duplicating
This is why I put question marks at the end of all my statements, I never get this right the first try.
you can add a negative test here to say it doesn't find any mentions of 'Unable to locate Android SDK' here since we did provide a valid MockAndroidSdk to the AndroidValidator. 
project -> plugin?  > The project will not compile until you add platforms implementation.  This isn't quite true, it just isn't useful
this was a shellcheck error, not sure if this ever did what it was supposed to.
Not sure I understood this comment
use only one line of whitespace here instead of 2.
`toggleDebugBanner` should maybe be `setDebugBanner` and accept a bool arg to turn it back on, too.
```suggestion       issueCount: errorCount,       seconds: seconds,       undocumentedMembers: undocumentedMembers,       dartDocMessage: dartDocMessage,     );  ```
I'd prefer it if we reserved `=>` for one-liners that returned a value (not void). Here and elsewhere.
This worked!! Thank you for spotting that. Very tricky. 
Actually this is null on web plateform and is the cause of #62724.
Will this test pass on release branches?
This was also disable in flutter_web_runner, right?
```suggestion     // Test TextField's cursor & selection color. ```
Is the value just based on [MediaQuery.viewPadding] or is it the same as viewPadding?
Ditto.
this is used for every platform now, but most of the time it is just looking at a directory
Not sure what the "and truncates any..." part of the doc is referring to.
Cool - it's fine if it looks weird, as long as it's valid :)
This is the new check that these plugin frameworks haven't been `lipo`d to the iOS ARCHS.
I would recommend pulling this logic into a new class that is separate from the create command. in general the use of string processing here is concerning to me. The pubspec.yaml is already structured data, you should take advantage of that to add the platforms.
From other PR: using zipinfo rather than unzip could be an optimization (feel free to do it in a separate PR)
Also what do you mean by "names" here? ```suggestion     help: 'Target device id (prefixes are allowed, names are not supported).\n' ```
Renamed from other file since it only contained Android. Added test cases to prove that embedding version identification works
Can we just reuse the same method channel implementation in the <plugin_name>.dart and this web class just listen to the channel message?
I think scaleChange might be what we want here.  In _onScaleUpdate, it calls onInteractionUpdate with the direct `details.scale` value, which doesn't consider the current scale of the child.
I think so, good idea
Can you wrap a Scaffold around the transition?
I think I added that part because the focus changes were increasing a build benchmark, and I was trying to reduce the number of built items for things that were disabled.
good catch, done
Thanks for pointing out, I have fixed it.
Not related to this patch, but would it make sense to rename this to something like CallbacksAndInterceptors, or something of that sort, as this is made up of user and interceptor callbacks.
This seems an odd change. Going to switch back to being separated below.
why is this needed in WidgetTester? If needed then maybe this is find but ideally the name would just be "sample()" instead of triggerResample.
As for the name, I'm feeling `binding.sample` is confusing because binding is not the subject of `sample`...
This is reasonable but we can't reference private variables in public docs. i.e. IDEs and our API doc website won't link this snippet to anything and just looking at the variable name doesn't really inform our users of anything. We can either make this public or change how we describe it.  1. I took a look at this color, and it seems like we use 0x33000000 in a couple of places, so it would be nice to add it to https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/cupertino/colors.dart, but we should also be systematic and not make up new semantic names for these names and I couldn't find an Apple spec'ed name for this color in the apple sketch file 🤷‍♂️  ![Screen Shot 2020-09-28 at 11 39 59 AM](https://user-images.githubusercontent.com/156888/94472285-5f85a300-017f-11eb-92b0-a5da7052e5fb.png)  2. Keeping it private makes this easier since we don't have to promise to keep some semantic color correct and publicly up to date forever. Here we can just say: `When unspecified, the barrier color defaults to a light opacity black scrim based on iOS's dialog screens.`
Should this file name have stayed the same?
btw, you are not checking for the method name in the engine.
@LongCatIsLooong  Yes, you are correct. But the name of this function is ambiguous, or change the name instead.
Ah I was confused by the the name animated, and keep thinking it should be a double.
nit: Can you pick a more descriptive name here?   Alternatively, can we just merge this class with TestImageStreamCompleter in here?
This should be ok to expose, as the CaretMetrics construct is native to TextPainter.  The name "fullHeight" seems a bit ambiguous in hindsight especially since there is no API for not-full height here. We may want to consider renaming it to something like "rawHeight" here, indicating it is unprocessed and a direct result of the caret computation. The alternative is to just keep the naming as "full" for consistency.  I am leaning towards keeping it as "full" as diverging API is not good. @justinmc any opinions?
This test has no name.
consider an short name alias for typing - gen-l10n ?
Note also: maybe we should use a hyphenated name for the long form as well.
Also add a common name (as seen in the xcode gui) for this? People might not know what the CONFIGURATION setting maps to.
The name is a bit confusing, maybe siblingLength?
"resetGesture" is a strange name.
Added the type annotation but I think we need to explicitly name the inner context differently so that the developers who we target with this documentation will have an easier time seeing how this is a different context
How aboue `error_handling_io.dart` for the file name?
This name sounds like a list rather than a map (slotToChild sounds like a map)
Nit: I know you're just changing the variable name, but couldn't this be:  ```suggestion     assert(children.containsValue(child)); ```  Here and in a couple other places below.
We should explain about scaffolds being registered or provide a link to doc that explains it.
A widget that imposes additional constraints on its child.  Best to lift these one-liners from the existing API doc; don't want to explain "boxes" vs widget here.
If so, we should make this clear somewhere in the doc
Can we update the doc comment here to mention that?
I wonder if any modification invalidates the list (theoretically). Iterable says modification during iteration is generally not allowed and may throw errors, although not necessarily for List. However can we do a lazy copy, i.e. only copy when the list is first modified during the dispatch?
It can be null because the catch block doesn't throw and then the result remains null
to be defensive, maybe add an is check in case the parent is not a RenderObject.
Could combine these if statements  ```suggestion       if (focused && _focusedDay == null) { ```
single if statements should still use { } so instead of if (true) statement it would be if (true) { }
Yes that is much better, thanks.  I forgot about the fanciness with for loops in an array.
yeah, not needed - also infinite loop
Can you add a comment to explain why we need to do this check and why we use the while loop? (something about the paint extent can be zero)
If this isn't used outside make it private
This can probably be private. Also add comments
Prefer hoisting this into a private static, to avoid recompiling the regexp every time it is created
Nit: I think this can be private
This feels like a strange thing to add to flutter's public API. Looks like it is only used in one file. Can we just add it as a private thing there? Or, instead of using promote, can you just do the following in the code:  ``` num n = 42; n = n as int; n.isEven; ```
 am not sure I fully understand, `lastWordStart` seems to be private to this method?
 Unfortunately not, since I'm accessing properties from the private CustomPainter subclass, `_DialPainter`.
I don't think these should be exposed as public fields. You could instead define `_handleAnalysisStatus` and `_handleAnalysisErrors` as closures and keep these objects above in the method body:  ```  // Its OK to define methods with names in other method bodies. void handleAnalysisStatus(bool isAnalyzing) {     if (!isAnalyzing) {       analysisCompleter.complete();       subscription?.cancel();       subscription = null;     }   }  try {   subscription = server.onAnalyzing.listen((bool isAnalyzing) => handleAnalysisStatus(isAnalyzing)); ``` Alternatively you could pass analysisCompleter/error as method arguments
Is a public `onMove` property necessary for your demand?
Does it make sense for these MaterialStateProperty lerp classes to be their own public API? Perhaps down the line
This looks quite a lot like _RenderInputPadding in button.dart. In a future PR, maybe we should create a shared public widget for this.
If we would make this class public should this property be public?
I see, yes, that should be private
I've refactored `RawImage` into a public `StatefulWidget` and made the current impl private. The public impl now does not need to be special cased.
WidgetsApp doesn't use a default id.  It internally specifies an ID for the Navigator it creates. However, that's an implementation detail that's not exposed to the public.
Do these need to be public?   Though if you make them private, you'll have to update the above documentation to instead have the actual values instead of referencing these.
+1. Sorry my draft didn't have docs but all public fields of public classes should have docs.
This whole class appears to be unnecessary. After reading the example above, I thikn it can be simplified down to just have the user extend `SerializableFinder` and provide the right `DeserializeFinderFactory` that creates the expected `SerializableFinder`. See my comment below on `_createFinder`.  If we can do that, this whole class goes away and eliminates some complexity.
I'm a little inclined to keep it simple until we've seen actual abuses (like `duration * frequency` gives 1) that require us to add such complex logic. Otherwise, we risk of making many of our tests potentially hard to reason about without actually helping anything. Specifically, since we're going to use this in places where `FlutterDriver.scroll` was used, I felt just matching `FlutterDriver.scroll` input events would be good enough to not trigger any new bugs.  Additionally, the old `touchSlop` logic seems to be specifically designed for `duration == null` case and breaks a single move event into 2 move events. Using such logic to break n events into 2n events looks unnecessary and unintended (suppose the offset is really large so each event's offset is large enough to be separated).
`// This page is currently not used for frame benchmarking` might be unnecessary as there are some pages here that are only for memory benchmarking and they don't have frame benchmarking either.
We need to keep something like the previous code now that we're using a queue. I made it more efficient by stopping when the first data with time stamp greater than sample time is found. The amount of data processed here should always be low. The only time we might set last/next multiple times is when input frequency is higher than refresh rate and it would need to be extremely high for this processing to become a problem.
nit: This would be more efficient as:  ```dart if (_parent != null) {   parent._dropChild(this);   parent_ = null; } ```  right?
Good idea. Added `createRestorationManager` to parallel `createBinaryMessenger`.
Does it run in parallel with other general shard tests?
By "parallel implementation" do you mean this is a makeshift implementation and will be replaced in the future?
Is there potential for a race condition here? E.g. while we wait asynchronously for the end of the frame, somebody sets debugFastReassembleMethod to a new function, which then incorrectly gets nulled out in the next line?
According to https://api.flutter.dev/flutter/scheduler/SchedulerBinding/currentSystemFrameTimeStamp.html, `currentSystemFrameTimeStamp`:  > On most platforms, this is a more or less arbitrary value, and should generally be ignored. On Fuchsia, this corresponds to the system-provided presentation time, and can be used to ensure that animations running in different processes are synchronized.  which sounds like we should use `currentFrameTimeStamp` instead.
This still seems like a hack. Can we just use the regular mechanism of scheduling a postFrameCallback to do the update here? If necessary we can then later introduce a synchronization mechanism in the postFrameCallback to send restoration state and router information over together, e.g. the postFrameCallback of both the RestorationManager and the Router could communicate send their final information to a third party and the third party then sends it over in one go to the engine in a microtask. We can add that synchronization when we need it (i.e. when the web engine is actually going to combine these two information).
In general, I agree with you.  This PR does not make things less or more flaky. If your test relies on some condition to resolve asynchronously, then it may or may not get a chance to resolve when runAsync returns. This PR aims to make that *a little* better by trying to flush the microtask queue before returning. It makes sense but indeed, it is not a guarantee and thus it does not reduce flakes.  What it *does* do is to expose the pre-existing ugliness to developers. Now we have a ominous parameter `minFramesUntilIdle` which, if we want to, we can default to 0 so we don't wait at all (current behavior). With increased documentation and this new parameter, we are giving developers a strong signal that `runAsync` is working as intended and if they want less flakiness, they should consider changing their code.  Without this change, people are surprised by the behavior of runAsync and try to "fix" it by doing stuff like this:  ```dart runAsync(() => // some code that causes a side effect in my widgets); runAsync(() => pumpEventQueue(times: someRandomNumber)); // I found this API that's supposed to help, I guess? ```  Fiddle with `someRandomNumber` until it passes. There's no other solution to this that I am aware of.  I am trying to make this part of the API and documentation so at least developers *hopefully* understand what they are doing and why they are doing it. If they start seeing flakes, they can refer to documentation and see why it is happening.  Replace code above with:  ```dart runAsync(   () => // some code that causes a side effect in my widgets,   minFramesTillIdle: someRandomNumber, // Ah, but now I see this is a synchronization issue. ); ```  As for exposing timers and microtasks, I think that's a problem for an IDE to solve. While debugging these tests, the users should be able to see what kind of timers and futures are now "frozen" because we ended the real async zone. I have a generic bug for this that I am hoping will get some traction.   I tried to save this information and perhaps print a warning message that there are unresolved tasks and such but it is too noisy. It alerts when there's no need to alert (such as no side effect) and it doesn't alert when it needs to (e.g. some IO operation will eventually post a microtask but we have no evidence of that now).  The final thing we agree on: This problem bothers me :-). I think this PR makes things a bit more transparent (but, like you said, not any better).
- Zones.. testWidgets() has two zones, which itself is tough to grasp. runAsync within testWidgets ups that to three. Most developers don't understand zones and the side effects are bizarre and difficult to debug. - Makes it too easy to run into synchronization problems which is another thing that's difficult to debug.   Sorry for being generic. I can probably compile concrete examples for these. These are some of the difficulties I myself have run into and seen other developers struggle with.
making this async is... exciting
just make the function async and `return;`.
ah now that it's not async that works
I would suggest at least one expect in there that makes sure that the hover event occurred. Something like: ```dart   testWidgets('Input PointerHoverEvent', (WidgetTester tester) async {     PointerHoverEvent hoverEvent;     await tester.pumpWidget(MaterialApp(home: MouseRegion(child: Text('Test'), onHover: (PointerHoverEvent event){       hoverEvent = event;     },)));     await tester.pumpWidget(const MaterialApp(home: Text('Test')));     await tester.pump();     final TestGesture gesture = await tester.createGesture(         kind: PointerDeviceKind.mouse);     final Offset location = tester.getCenter(find.text('Test'));     // for mouse input without a down event, moveTo generates a hover event     await gesture.moveTo(location);     expect(hoverEvent, isNotNull);     await gesture.removePointer();   }); ```  It just makes it clearer that the test does something: without any expectations, someone (like me!) might look at the test and wonder if it is testing anything, or if the expectations were just accidentally omitted.  At the least, you could have a comment saying that the test is expected to not assert (which is probably all you can do for the first test in the file).
doesn't need to be `async`
I am not familiar with file io, why couldn't it run in fake async?  The assets loading part should be fine because we mocked the asset channel to read file synchronously https://github.com/flutter/flutter/blob/aa0382e95d3fe19b9ee4becf3fdf4017c15a149c/packages/flutter_test/lib/src/_binding_io.dart#L40  The reason I brought up fake async is that i am thinking we can move away from writing test in runAsync if we can make the fakeasync in testWidgets expose the timer and microtask.
I updated the PR. I still had to introduce some "wait time" in there because microtasks can be scheduled by any async operation "back to back". However, I feel better about this approach because it is more deterministic and easy to explain. Let me know what you think.
I think i agree with most of it, but there are some more concerns i have.  > waitForIdle: const Duration(seconds: 2),  I think we don't need the duration here. this can be a true false value, and the test will either resolve the timer/mt or just timeout the test section.  >I agree with you that there will be advanced cases where these futures should not be awaited but then we are getting into highly custom test code category. Users can then create a future that they want to await and do that. I will put all this in actionable error messages.  I think part of this is also we have some unexposed future in our built-in widget as well (for example the image decoding in Image widget or localization asset loading). unless we expose those future in the widget state, user will not be able to resolve them If they want to test the result after those async load. That is why I kinda want to have a separate api to resolve this future. However, I am ok with not provide an API too since we can use the runAsync. waitForIdle to resolve the future. It just the test code maybe a bit more complicated.  >Another reason: The interplay between the two APIs would need to be carefully covered. For instance what if this happens:  I will expect resolveTimers called without an async zone (not in the runAsync callback) will just throw an error?
"The fake async environment..."
Why is this method part of the base class if it's only relevant for _MatrixTransformPart?
@chunhtai this make sense. I created a method to auto validate only the fields that was chaged. So it currently ony validate the changed fields. Does this is a good solution? Or we must validate all the fields once one changes?
@chunhtai brought it to my attention that the build method will be called even more frequently than onChanged in my commit that I linked above 😞. Maybe we should just go back to saving _hasInteractedByUser as a bool that's calculated in _fieldDidChange.  Then open up another issues to revisit performance later.
Ahh, I missed the existing `copyWith` method - that seems more straightforward
It seems like there are a lot of ways for this method to fail, and it requires a sentinel data in the form of the comment. Is there a way this process could be simplified by ignoring comments? Is add-platforms going to be usable if it requires a very specific structure?
As a side effect, this method always generates the `GeneratedPluginRegstraint` files for iOS and Android unless the checkProject flag is true. When the plugin is not for mobile, this method still generate those files, including iOS and Android.
you are right, I deleted this method and updated the caller a bit. Please take a look see if it makes more sense.
Can we move the parsing and validation in this method by using FlutterManifest? ```dart final FlutterManifest manifest = FlutterManifest.createFromPath(pubspecPath, fileSystem: globals.fs, logger: globals.logger); ``` Then move `getPlatformsYamlMap` logic into `FlutterManifest` as something like this: ```dart   List<Map<String, dynamic>> get supportedPlatforms {     if (isPlugin) {       final YamlMap plugin = _flutterDescriptor['plugin'] as YamlMap;       if (plugin.containsKey('platforms')) {         return platforms = plugin['platforms'] as YamlMap;       }     }     return <String>[];   } ``` And put any missing type logic (if any) into `_validateMultiPlatformYaml()`.  (bonus, then androidPackage can become:) ```dart   String get androidPackage {     if (isModule) {       return _flutterDescriptor['module']['androidPackage'] as String;     }     if (supportedPlatforms.containsKey('android')) {       return supportedPlatforms['android']['package'] as String;     }     return null;   } ```
It doesn't look like this method does anything (I may be misusing Github difftool)
Can we also change this method to send "commit/cancel" information as an argument to make it similar to the other methods?
The return type of the method on result is defined as:  ```  /// Serializes this message to a JSON map.   Map<String, dynamic> toJson(); ```
Consider wrapping the logic from here to the `throwToolExit` in a helper method.
Yes. In most (all) cases, if MaterialState's resolve method returns null, that indicates that the widget should defer to the next most general default.
This is causing failures in google3 where people extend ViewportOffset.
This toString doesn't seem very consistent with Flutter. Maybe remove it or extend DiagnosticsNode to use its functionality for more standard looking toStrings.
I would name this and the enum to `FakeDevice`/`fake`. in Dart it is generally the case that classes with `Mock` in their name extend `package:mockito`'s `Mock` class
I made a class with `call` method to implement this, with single call of `Controller` construction. PTAL.
Or is this because the super class lets it be null?  Is there a big impact to changing the superclass in that case?
Ditto here - if it's all because of the super class we should look at just making the super class non-nullable as well.
Parent class value is nullable, this should be nullable too
Can you pull this parsing logic out of the the Pub class?
Please don't implement your own mocks. Either use the Mock/Fake class from mockito, or use the FakeProcessManager
nit: prefer not shadowing parameter names in the enclosing class, which can get confusing.  I don't have a great idea for a name here.  This does make me wonder if there are other cases we should be explicitly passing the isolate reference around though.
Done with the change, but let me know if `kBuildBudget` should still be a value that can be changed by customer, in which case it will need to be a member variable of the class.
I added a _Resampler helper class to the latest version of this change. It encapsulates the logic to manage multiple PointerEventResamplers and the details of how the scheduler is used to determine sampling time.
nit: rename to `_didStopCallbacks`.  For consistency, `WidgetRecorder` should also support multiple callbacks, but perhaps making this class a super-class of `WidgetRecorder` is a good way to gain both consistency and code reuse.
It's still not too clear what the difference is and why this needs to be a separate class rather than changing VelocityTracker.
this should be `event.device` + unit test
You could make this easier to test by making it a static or top level method, since it doesn't depend on anything in AnalyzeBase.
setUp so that test state doesn't leak
This test apparently doesn't rely on this value, avoid looking up potentially null home dir path
This test can't fail, perhaps you forgot to assert `details.stack` is unmangled.
Without mouse,  * During hover events, no regular hit test is done. * During down events, a regular hit test is done, so this is an extra pass, but down events happen at such a low frequency that we might not really care. * During move events, no regular hit test is done (the result of down events is reused).  Conclusion: The only "extra pass" is the ones at down events, which do not really matter.
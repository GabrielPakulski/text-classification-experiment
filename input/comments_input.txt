Sometimes a failure to delete is benign, so I'm not sure this should go here.
The change in this file switches the order of fallbacks, which confused `git`.  Now it first tries log scanning, and only if that fails, falls back to mDNS discovery.
I renamed `fallback-success` and `fallback-failure` to `log-success` and `log-failure`.  Do we care about usage data continuity?  If so, I can change the names back.
This was previously waiting and buffering for `duration` before sending the first message.  The observatory URL was discovered faster than 200 ms in my tests, so let's not wait to process it.
Not really, change away
this might deserve a const, with a doc describing where you found it.
nit: maybe describe what parts are hard-coded for testing
The events were only added to understand the severity of the issues around this that we were seeing. Please feel free to modify the events into whatever is useful for this new way of doing things, including adding new ones if needed.
This will fail if ios-deploy is missing right? should we catch the error or let it crash here and solve the problem elsewhere? i.e. startup checks
Can this not happen anymore?
Can a test only visibility annotation go here?
Is there any way to make this test and the test for 'success' more resilient to changes in output from lldb? Maybe ignore whitespace or unexpected lines between here and 'success'?
Oh, okay. The very next line after the lldb run line doesn't have to be 'success'. We'll wait until it is. Consider updating the comment above.
Does ios-deploy have anything interesting on its stderr when it exits with an error?
This change is swapping the order fallbacks.  Before it was trying mDNS and then log scanning, but now it's trying log scanning first.  The reordering confused the diff, this `ArgumentError` was just moved.
It's https://github.com/flutter/flutter/pull/66092/commits/e91e25e01ffa596f7e60c861b435a9c672a9a29e#diff-e0fb4f81676c3d33cb1796b5f126a4fdR94 now.
üëç 
Good call.
Some stuff:
https://github.com/ios-control/ios-deploy/blob/master/src/ios-deploy/ios-deploy.m#L1741
Though nothing that's probably actionable to the developer.  It's being `printTrace`d a few lines above this.
https://github.com/flutter/flutter/pull/66092/files/e91e25e01ffa596f7e60c861b435a9c672a9a29e#diff-8d108d6a887a4f5b74f7c7d77003e795R326

They seem to put actionable errors to `stdout` (see `_monitorIOSDeployFailure` parsing below, which existed before this PR).
`run` is coming from [ios-deploy](https://github.com/ios-control/ios-deploy/blob/master/src/ios-deploy/ios-deploy.m#L51), and `success` is coming from lldb.  I will make this a regex to handle whitespace differences. 
It does have to be "success" (`lldbRunCalled ` logic where it's being set to false if the next line isn't "success"), unless I have a bug in here.

Maybe I should change this to fail if the next line isn't "success" so it doesn't hang forever on something unexpected instead of special-casing "error: process launch failed" (and example of a non-success next line).
I think we already have those checks in place with the stamp/artifact download logic, since `ios-deploy` is an artifact we ship ourselves `idevicesyslog`.  Unlike the Xcode tooling where we do lots of install checks.
Ah, okay. I misread the code. My suggestion for a cleanup would be to structure this explicitly as a state machine, with an enum setting out explicitly what the states are, and a big comment explaining what/when the transitions are.

That might also make testing this code easier. I think I see below that the error paths in here could use some coverage.
Test failure modes on unexpected stdout.
Added `_monitorIOSDeployFailure` to the stderr processing in case they move how that's output.  Will add a test.
Done.
Done.
Done.
Added more comments and tests.
Added an enum, hopefully it's clearer now.
Done.
these diffs are always so hard for me to read...

So this is saying we always want to run the test for any PR, and on post-submit only on affected diffs...right?

This doesn't seem like the right logic. Should it be `&& $CIRRUS_PR == ''`, which would be only run pre-submit with a diff on the affected files?
I see, yeah I think it has to be && but I thought $CIRRUS_PR == '' meant postsubmit.
lol, yeah you're right. so `&& $CIRRUS_PR != ''`
This is why I put question marks at the end of all my statements, I never get this right the first try.
yeah, errors in those conditionals are usually difficult to spot. Updated.
FWIW the title for this test is confusing to me.  "registered plugin"?  "registered handler?"
heh, this is one reason why in my ideal test framework there's no test names. :-)

I think it refers to what happens when a method call comes in but no plugin has registered a handler for that channel.
(the name is identical to the previous test, all I did was make a copy of the test with a minor tweak)
Feel free to change that one too, it's equally confusing.
Was this here just for sanity before? Or why did we need to check for `self.skipWaiting` being a thing?
yeah, not needed - also infinite loop 
(The comment above still mentions that we're adding a hash for main.dart.js, but it seems we don't do that anymore, I think it should be updated just to not confuse future us :P)
Ah, I was understanding "remove main.dart.js bypass" wrong. This lets the service worker cache the main.dart.js again, by not overriding its name with a hash.

(I was about to ask: if we want the serviceworker to bypass main.dart.js, shouldn't we also remove it from the RESOURCES map? :P)
Fixed!
Yes, exactly - now that I realize I was COMPLETE WRONG about the default behavior of sw, everything makes more sense!

But we also bypass the worker for http requests that won't go to the cache, since I guess there is overhead for forwarding the requests
According to the documentation

> The coordinates returned in the details are viewport coordinates relative to the parent.

Is that correct?
No it's not, thanks for catching that!  I was just copying what I did for the other onInteractionUpdate, which is also wrong apparently.

I will change the code in both places so that the documentation is correct. I think that's best because the user can still convert to scene coordinates themselves using the same toScene method.
Done.  I also updated a test to make sure this is covered.
`onInteractionStart` should also use the viewport coordinate system according to the documentation? (`onInteractionStart` is called after updating the transform. Is that expected?) 

also nit: I think we can do `widget.onInteractionUpdate?.call(ScaleUpdateDetails(...))` instead?
Oh yeah that too.  I've now made sure that all of the onInteraction* calls are using the coordinates of the event (not transformed to the scene) and that they are called after the controller has been updated.  That way the user can transform them to scene coordinates if they want by using the controller, but otherwise have the viewport coordinates.  That seems like the best approach to me.   I also wrote another test confirming that you can do this.
If the developer tries to access the transform in the `onInteractionStart`, are they supposed to see the updated transform, or the pre-scroll transform? Couldn't find that in the doc.
Someone actually opened an issue for this (https://github.com/flutter/flutter/issues/63606). This PR should close that issue too now.
Good point, I updated the docs.  For start, the transformation shouldn't have changed, but for update/end, it should have changed.
This is the fix to the presubmit, It is not cleared to me which component it will focus by default when you have a TYPE_WINDOW_STATE_CHANGED.
From my observation:

- If this is the first time this screen is present, it will find the element that has the same label as the message that is sent with TYPE_WINDOW_STATE_CHANGED, and focus the NEXT element of that element. This is why it change from body to title

-  If screen has be shown before, it will remember which element was focused the last time the screen was shown, and will refocus the element after the message is announced.
nit: indentation
This should be [Router.routeInformationProvider]
fixed :)
super nit: double space
Since the regression tests link to this issue, this comment and the one in `range_slider.dart`arent' strictly necessary
Fixed.
Move the RangeSlider test case to another file.
Removed.
üëç
Is the minWidth already accounted for in the TextButton.styleFrom()?
Yes, the default minimum size for TextButton is Size(64, 36)
@blasten does this change look okay to you?  On iOS we don't want the logs to scan forever when no observatory URL is found since it needs to detect the URL wasn't found and fail.
I assume this could be for all sorts of reasons right? For instance someone tries `flutter attach` but never launched the flutter app/module etc. Make the language softer? e.g. If you previously dismissed a local network permission dialog, you can revise it here. 
This method is called for `flutter run` and `flutter drive` only, not `attach`.  But you're right, this may not be the reason the observatory isn't found.  The "Try" was to make it softer since we do that in a few places.  Like right above this we have "Try launching Xcode and selecting "Product > Run" to fix the problem:" for example.

Open to wordsmithing suggestions.
Typo duplicate "set"
minor formatting: we generally try to keep our line widths to 80 characters. See examples above (the lines without the \n at the end) for breaking up a string into concatenated multi-line string
Understood.
Technically, it doesn't set an environment variable. It just reads from this config directly in https://github.com/flutter/flutter/blob/6978832293eefa7cd3c2cc064d4698f8320f80f5/packages/flutter_tools/lib/src/android/android_studio.dart#L159. I think you can just remove the `String envKey` argument too since we don't need it anymore. 
I did try removing that, but it caused some tests to fail. Specifically this test: https://github.com/flutter/flutter/blob/7f3c9b6bdab5a38cfa9eb4ba5aa5d7c5378282f3/packages/flutter_tools/test/general.shard/android/android_workflow_test.dart#L334
I read your comment below. I'll change that test so it reflects the new error messages.
I don't think `flutter config --android-sdk` helps finding the Android SDK, at least based on how the tool is written now.  Just suggesting `flutter config --android-sdk` is probably enough. 

https://github.com/flutter/flutter/blob/d3515f5fb6342e76cb8b99b9874605179a0d0592/packages/flutter_tools/lib/src/android/android_sdk.dart#L71
you can add a negative test here to say it doesn't find any mentions of 'Unable to locate Android SDK' here since we did provide a valid MockAndroidSdk to the AndroidValidator. 
Added below. Can you let me know if it looks good?
Thanks for pointing that out. I've updated it by removing line 78. Please let me know if it looks good!
Let's default this to `Clip.hardEdge` now to avoid breaking changes. We can change the default and go through the lengthy breaking change process later.
ditto.
ditto.
ditto
ditto
ditto
ditto
ditto
ditto
remember to change documentation too when the default is changed to `Clip.hardEdge`.
ditto
ditto
ditto
nit: space after `if` and before `(`.
Done :D
I think the context should just be required here to be non-null.
according to the assert location `context` could be null with null `resolvable`. I will run the tests to check if context can be non-null.
Updated a test to make context non nullable.
Why is this better?
To prevent null to be used. The `CupertinoDynamicColor.resolve` user now know that the context is mandatory to call this function. Calling it with null resolvable looks quite uncommon and using a non-null value required the context to be non-null.
I see, the second `CupertinoDynamicColor.resolve()` argument can no longer be null. But the first (Color) parameter can, so this test survives. 
Exactly :)
Looking at this again, isn't it guaranteed that this will always return a non-null value? primaryColor should always be non-null in the default theme?

Same for many of the getters below that reference the default.
Same explanation as https://github.com/flutter/flutter/pull/66024#discussion_r490767475
uber nit
```suggestion
class MockDartDevelopmentService extends Mock implements DartDevelopmentService {}

```
If children is empty (seen in the example app posted in the bug and in the test case, this throws an exception)
```suggestion
        // flutter root and pub must be lazily-loaded to avoid initialization
```
This new version is pretty dense. Why do you need to destructure `...` the output of `.map()` here, I would assume that the `.map()` is returning a `List<Future<bool>>` already?
I had to do this because `FutureOr<bool>` is not a `Future<bool>`, so I can't pass it to Future.wait. I should just change to type signature to skip the FutureOr, then I can simplify this
Done
Ahh, that makes sense. Is `Future<bool>` a sub-type of `FutureOr<bool>`?
Xcode change this whitespace, let it.
Match https://github.com/flutter/flutter/blob/2e67bf2e32391af4fe38cb292c99e77d14b53584/dev/benchmarks/platform_views_layout/ios/Runner.xcodeproj/project.pbxproj#L319
Match https://github.com/flutter/flutter/blob/2e67bf2e32391af4fe38cb292c99e77d14b53584/dev/benchmarks/platform_views_layout_hybrid_composition/ios/Runner.xcodeproj/project.pbxproj#L319
`skipWaiting` doesn't seem to be supported in Safari: https://caniuse.com/?search=skipWaiting
there is no mechanism to force update (automatically or via user interaction) without skip waiting.

Should we disable service workers on safari?
This does work on safari desktop it seems, but it is not sufficient on iOS
I'm guessing it's less of a concern on mobile since on mobile you typically don't have multiple tabs of the same app active at the same time?
ü§∑‚Äç‚ôÇÔ∏è 
just remove `../project-name ` entirely, here and below
also remove trailing space
ok! , i will do it
This will be automatically called by the controller's notifier.
This is tricky, good call testing this case.
I think it should stay as "Change", as I understand it.  I think it meant like: "is selection the only change"
I'm not sure why the selection wasn't checked here in the first place.  This seems to make more sense.
Could you create an actual issue for this and link to it here?  I just want to make sure this has the chance to get looked at, in case it is a problem.  It doesn't make sense to me that the engine should notify twice for the numeric keyboard.
This PR really reminds me of this issue, which also deals with the asynchronous communication between the engine and framework: https://github.com/flutter/flutter/issues/61282

My solution there wasn't anything like this PR, but I think using this flag `_updateEditingValueInProgress` could maybe help us handle problems like that.
The track at #65811 
Done.
Do we still need this, with the changes made in line 1650 through 1656 (i.e., the additional case handling when `_value == value` )?
@LongCatIsLooong 
Yes, you are correct. But the name of this function is ambiguous, or change the name instead.
It appears the method is only used here. You can get rid of it and use the expression instead (and maybe leave a comment that says if the change is selection only)
Good idea.
Done.
Thanks!
Can you flip a boolean value here to mark that the onChanged callback was called, then add an expectation after the `enterText` call to verify that the callback was called?
Good point, thank you, now updated.
Why were these imported in the first place? Is it needed for the references in the doc comments? If so, why aren't the new button classes needed to be imported?
I don't know why the were imported before. The analyzer reported that the were not needed and the docs  tests succeeded, so I'm assuming that similar imports are needed anymore.
Is this a change in defaults, or was the previous comment incorrect?
The previous comment was incorrect.
Nice test
TY!
Please add a comment at the top of this test:
```dart
/// Regression test for https://github.com/flutter/flutter/issues/65657
```
It looked like firstRenderObject shouldn't be needed here because there's only one.
Might be slightly simpler (here and below) without saving a ref to the renderobject. Also the "equals" isn't needed.
```dart
final Finder rail = find.byType(NavigationRail);
expect(tester.getSize(rail).width, 72)
```
@a14n, could this be `String this.data` so that you can't pass nulls to the default constructor (i.e. `Text(null)` should be an error) ?
Sure! Thanks for the review :) A lint could make sense to catch similar issue.
Done. I also changed `Text.rich` textSpan parameter.
Filed dart-lang/linter#2237
nit: remove commented code
Done!
let's pin mockito to 4.1.1 since we're planning on removing it entirely anyway (right? cc @jonahwilliams)
(I'm assuming it's the cause of all these new dependencies.)
let's not encourage that second path if we don't need it... requiring that this approach only be used by entirely separable code seems like a good place to start.
mockito still exists in one test, the one that uses private APIs. Once it is removed from there it will be gone from `package:flutter`, but still used elsewhere in the SDK
you don't actually use args, it seems
"extends Object" is redundant
should it end with `_test.json`?
Are we not planning on removing it from everywhere?
The one test is the one I'm removing in this PR, I think.
We definitely don't have time to do that for the flutter_tool. I'm not sure about the other packages though.
But is it OK to pin it to 4.1.1 for `flutter_tool`?
Good point.  Removed.
Yeah, I know, but there were some weird analysis problems with non-nullable code that it was fixing.  It appears to not be needed now though, so maybe it was a bug in the analyzer that got fixed.
Good idea.  Done.
We're not going to migrate to NNBD in the tool for quite a while, so it should be safe for now
Right. Removed. (I would if there was a nullsafety version.)
nit: double space
Fixed.
question: what is `oldwidget`?
it is the original widget before the update
do we need to do similar things for obscure and disabled?
Should this be `if (!attacted) return` ?
I remember I ran into situation when user update widget when the input connection is attached to another textfield and cause a crash
I don't want to jump the gun and implement something that nobody asked for ("if it aint broke dont fix it") lol. That said, after this PRÿå it becomes super easy to add obscure, disabled, etc when they are needed.
That's a good point. I just followed what the other methods are doing.

I think this should remain as is, and the code in `EditableText.didUpdateWidget` should check before calling `updateConfig`. I'll fix it.
This is a stateful widget, which means the `state` instance remains alive even if you build `EditableText` multiple times. So when you do:
```dart
Widget build(BuildContext context) {
  return EditableText(
    readOnly: true,
    ...
  );
}
```
^ this `EditableText` instance becomes the new value for `widget`, and the `EditableText` instance from the previous build is available in `oldWidget`.
Is `minScale` the max scale allowed?

if `_boundaryRect.size` is `(10, 10)` and the viewport's size is `(100, 200)`, then `minScale` is going to be 20 right? Anything above 20 is going to make the child exceed the size of the viewport in both dimensions?
This minScale is the minimum scale allowed, but maybe my comment in the code above this is confusing.

The boundary is defined as being positioned on the child, and it scales with the child.  In your example of a 10,10 boundary, let's say that the child is also of size 10,10.  So here's your example with an orange child and a yellow viewport:

| scale | 1.0 | 10.0 | 20.0 |
| -- | -- | -- | -- |
|           | <img width="151" alt="Screen Shot 2020-09-10 at 9 37 20 AM" src="https://user-images.githubusercontent.com/389558/92764802-9d926280-f349-11ea-8ca2-85fde7e1627d.png"> | <img width="173" alt="Screen Shot 2020-09-10 at 9 37 02 AM" src="https://user-images.githubusercontent.com/389558/92766646-41304280-f34b-11ea-879e-682a18e82b9d.png"> | <img width="196" alt="Screen Shot 2020-09-10 at 9 37 40 AM" src="https://user-images.githubusercontent.com/389558/92765015-cfa3c480-f349-11ea-9fae-363d0987785e.png"> |

The purpose of this minScale is to prevent the viewport from exposing anything beyond the boundary. In other words, in this example it's trying to cover up all the yellow using the orange child.  It is not trying to prevent the child from growing beyond the size of the viewport, that's fine.
Ah I see. Thanks for the explanation! In that case would it be possible to move the logic in the if clause to before clamping? Then the function would be roughly
```dart
    final double currentScale = _transformationController.value.getMaxScaleOnAxis();
    final double totalScale = math.max(currentScale * scale, math.max(_viewport.width / _boundaryRect.width, _viewport.height / _boundaryRect.height));  
    final double clampedTotalScale = totalScale.clamp(widget.minScale, widget.maxScale);
    final double clampedScale = clampedTotalScale / currentScale;
    return matrix.clone()..scale(clampedScale);
```
Yes that looks much better, thanks!
Does this mean that we can't use e.g. spacebar as an input?
yes - though this matches the restrictions that the resident runner has. This could be changed to strip off a trailing newline line if length > 1 instead? I'm not sure that would buy us that much
Maybe worth adding this as a comment, though I'm not sure this would be the best spot?

The spacebar is pretty big on keyboards, so it might be convenient to use for something someday.
No need for this extra newline here.
I think the analyzer will complain about not following Flutter's code style unless you do it this way:

```dart
widget.onInteractionStart(
  ScaleStartDetails(focalPoint: focalPointSceneScaled),
);
```
What do you think about `horizontalScale` and `verticalScale`?

Maybe the best thing to do is to leave them null as you have already done.  When doing pinch-to-scale, horizontalScale and verticalScale are independent of scale and seem to be related to the angle of the two contact points on the screen.  This is probably irrelevant when scaling with the mouse wheel.

Or, we could set them to scale, or set them to 1.0.
Change this to `0.0` just to make it clear that it's a double.
I think scaleChange might be what we want here.  In _onScaleUpdate, it calls onInteractionUpdate with the direct `details.scale` value, which doesn't consider the current scale of the child.
So for every mouse wheel event, we call all 3 callbacks: Start, Update, and End.  I guess that makes sense.  I don't think it's possible to group calls to _receivedPointerSignal.
```suggestion
    testWidgets('Scale with mouse returns onInteraction properties', (WidgetTester tester) async {
```
```suggestion
      expect(afterScaling, equals(currentScale));
      expect(currentVelocity, equals(noMovement));
```
Could you also expect that currentScale is not null and not 1.0?  I worry that this feature could break but the test would still pass if currentScale were 1.0 or null.
Maybe add a `calledStart` boolean and set it to true in here, then expect it to be true later?  Just to get onInteractionStart some test coverage, even though it doesn't do much.
Extra newline.
I'm not sure about this one because it seems that in the normal pinch zooming it seems to display the currentScale instead of the scaleChange, could you do a crosscheck on this just to make sure. Also the ScaleChange value seems to be fixed at approximately 1.3 for zoom in and 0.89 for zoom out  per tick of scroll( as in when you can feel it scroll once). so I'm not sure which would be the better choice. I'm giving my opinion on the decision but do update me on which one you think should be used  for better consistency and/or change!
I think it's better to leave it at 1 because I agree it being irrelevant when scaling with mousewheel.
I also have a follow up question regarding the flutter_build check, it seems there are times when it was fine and times it is not, is this a normal thing?
I think you'll have to add those parameters here too then, otherwise they're null:

```dart
  horizontalScale: 1.0,
  verticalScale: 1.0,
```
Regarding the 1.3/0.89 thing, is your InteractiveViewer wrapped in a GestureDetector somewhere?  There is a known issue about that which I still need to fix: https://github.com/flutter/flutter/issues/58636

Regarding the current scale vs. scaleChange, it does seem to be passing the change in scale based on my experiment:

```dart
InteractiveViewer
  onInteractionUpdate: (ScaleChangeDetails details) {
    print('onInteractionUpdate ${details.scale}');
  },
  ...
)
```

Logs:
```
(Zooming in:)
flutter: onInteractionUpdate 1.0051666615057695
flutter: onInteractionUpdate 1.0103338151812797
...
flutter: onInteractionUpdate 2.4213762341047356
(Stopping and zooming out:)
flutter: onInteractionUpdate 0.9978297973338419
flutter: onInteractionUpdate 0.995660468727219
...
```

~~Lastly, about the flutter_build check.  Yes, our test infrastructure is quite flakey unfortunately.  If the error message doesn't seem related to your PR, then it's probably an infrastructure problem and just needs to be re-run.~~ Sorry, I misread this at first.  Specifically the flutter-build check is referring to the current status of Flutter's master build, which does usually go red a few times per day.  It happens whenever someone merges a PR that breaks a test.  The only thing to do is to wait for it to go green.
the 1.3/0.89 I think is becaused a scroll tick is always constant value, so probably why the scaleChange value is constant. But since your tests are proven scaleChange, then I will be using that for the details.scale!
unfortunately adding a new named parameter here breaks some internal customers. Can we reland this with either an optional named parameter, or just a new named constructor for it?
I think we no longer have `iphonexs` in the devicelab. We probably should just use `mac/ios`.
Let's also add a `flaky: true` here just to be cautious.
Done
This is the part that should fix the post-commit failure from https://github.com/flutter/flutter/pull/64674.
Run `pod install` (assuming the fingerprint says it's needed) when there's a Podfile even if there aren't Flutter plugins.
@xster What do you think about this?  Looks like the `project.isModule` caveat was added back in #21276.
nit. Maybe a comment to explain why we have to `pod install` even if it doesn't have plugins?
Good idea, done.
I wish that original line could be DeMorgan rewritten üòÇ

That isModule part is definitely weird. I can see the argument for just generally not running pod install when there's only a user Podfile without plugin. Since at that point, it doesn't have much to do with Flutter's build pipeline. When a user changes his own Podfile, the user should run pod install themselves. Our customers did complain back in beta days about pod install always running for no changes and being slow. 

I can't think of why isModule + has Podfile means pod instead has to run. Removing isModule from this consideration altogether seems reasonable. "'Cause if you like it, then you shoulda put a test on it" 
I reverted this, and instead added a Flutter plugin to the integration test so the tool runs `pod install` for us and I don't need to call it manually.
```suggestion
  /// How each line of text in the Text widget should be aligned horizontally.
```
ummm this is reasonable. Thanks for catching this
Add more context to this comment. e.g. `Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on` in this and the next file.
Leave the final line break here and in the next file.
Thanks for review! Could you please check again?
This widget can be `const` I think?
```suggestion
/// When the user scrolls past [refreshTriggerPullDistance],
```
nit: Probably better to briefly describe what the sample code does instead of reiterating the docs. 

Maybe something like  "this sample shows the default ios pull to refresh indicator for 1 second and adds a new item to the top of the list view"?
That makes sense. There is not enough explanation for the example. I will apply a new comment for the example code.
I agree. :)
Thank you!!
I'd just inline your function in here to make it easier to read. 
Since it's a cupertino example, I'd just use CupertinoApp and CupertinoPageScaffold here. (I also suspect this doesn't build if you just import cupertino.dart above)
align these indents.
> (I also suspect this doesn't build if you just import cupertino.dart above)

I referred to this example.
https://api.flutter.dev/flutter/cupertino/CupertinoContextMenu-class.html
The doc on `TextPainter` says "The newline, if any, is included in the range". However this doesn't seem to be the case... or I missunderstand this statement.

I couldn't find any tests for `TextPainter.getLineBoundary` to see if this is expected.
Oh, interesting. So the web tests failed here with:

```
07:30 +485 ~12 -1: /b/s/w/ir/k/flutter/packages/flutter/test/rendering/paragraph_test.dart: getLineBoundary control test [E]                                                                           
  Expected: 'I polished up that handle so carefullee'
    Actual: 'I polished up that handle so carefullee\n'
              ''
     Which: is different. Both strings start the same, but the actual value also has the following trailing characters: \n
```

Which sounds like implementation for the web platform is more aligned with the doc... ?

Running this test locally on macOS works fine.

I'm probably going to need help determining which behavior is the correct one and whether I should be looking at the TextPainter implementation to fix this inconsistency.
Extra newline here.
required => require
Or maybe this? "Accessing this value does not cause the layout to be updated."
Any of these docs comments that were copied from text_painter.dart should use a macro instead.

Here's an example of how to do that:

https://github.com/flutter/flutter/blob/0bb1e573fce0a32c28d1bd3caf26e53405604f48/packages/flutter/lib/src/painting/text_painter.dart#L335-L337

https://github.com/flutter/flutter/blob/0bb1e573fce0a32c28d1bd3caf26e53405604f48/packages/flutter/lib/src/rendering/paragraph.dart#L269
I would agree with you, something seems not right there.  Let's see if @GaryQian knows what the behavior should be.

There are some tests in the web part of the engine for this, and they include the newline: https://github.com/flutter/engine/blob/09a5bf7acf44dbb22d68830f5a51ebe822d5e659/lib/web_ui/test/paragraph_test.dart#L926
If you have a workaround for preferredLineHeight, I would prefer that we hold off on exposing this as official API. The current implementation of this value is sketchy at best and is something I want to eventually rework.

Some problems with this value is that it assumes an alphabetic space as the character to get metrics from. This causes some issues with ideographic text such as Chinese or even Arabic in some fonts. The current implementation also does not account for the differences in first line vs second+ line height, so could produce values that are not useful beyond the first line.

For now, I suggest continuing to use your workaround instead of adding this API that may have to be broken in the future.
tight -> strut

Can you change this in the original docs in TextPainter as well? This doc is no longer accurate.
Going off of the macro comment by Justin, change this in the original doc, and then macro it here.
The primary reason this is not exposed is API bloat, since once we add it, it cannot be removed. We should try our best to explore reasonable alternatives before resorting to adding additional API.

In this case, getLineBoundary exposes a few of the text position APIs based on metrics, which we want to eventually move away from to contain more bitdepth.

I think you may be able to workaround this by calling getBoxesForSelection, once with a collapsed selection to get the rect that bounds the current position, and again with a wide selection that encompasses a few lines. Then, you can take the right most and left most boundaries of the boxes that share the same y offset as the first call. Then pass those boundaries to getPositionForOffset.

That should get you something that may work for your purposes. If the resulting code is really complicated, confusing, or unreliable, we can proceed with exposing this.
This should be ok to expose, as the CaretMetrics construct is native to TextPainter.

The name "fullHeight" seems a bit ambiguous in hindsight especially since there is no API for not-full height here. We may want to consider renaming it to something like "rawHeight" here, indicating it is unprocessed and a direct result of the caret computation. The alternative is to just keep the naming as "full" for consistency.

I am leaning towards keeping it as "full" as diverging API is not good. @justinmc any opinions?
Let me know if you are able to get a workaround working!
This may indeed be a bug, I think the newline makes sense here, especially since the docs indicate that it was meant to be included. It isn't your responsibility to fix that though, so you may want to just mark it with a comment and a `TODO: blahblah` to indicate that the result here may be due to a bug. Then, you can duplicate the test and make one of them skip web while having the other skip android+ios. We should file a bug on this.
Makes sense, thanks! I can keep my workaround for now and remove this method from here.
Updated and added a macro in TextPainter. I haven't included the last line referencing `[layout]` of TextPainter as it seemed specific to the painter class itself (even though RenderParagraph has a similar requirement).

Let me know if you'd like that line to be included in the template, I'll update.

Also changed `[position]` to use backticks, as it seems more inline with the style guide around method parameters.
Thanks for the examples!
Removed this method per @GaryQian 's recommendation.
Per @Hixie suggestion I updated this test to be more strict in comparing expected value.
Yep it does seem to work pretty well. Thanks for the suggestion! Since each RenderParagraph in Zefyr represents a single paragraph of text (meaning text between two newlines) here is what I ended up with:

https://github.com/memspace/zefyr/blob/78a5ac11542d39a45cc11cb904416dec0c443da7/packages/zefyr/lib/src/rendering/editable_text_line.dart#L294-L309

```dart
  @override
  TextRange getLineBoundary(TextPosition position) {
    // getOffsetForCaret returns top-left corner of the caret. To find all
    // selection boxes on the same line we shift caret offset by 0.5 of
    // preferredLineHeight so that it's in the middle of the line and filter out
    // boxes which do not include this offset on the Y axis.
    final caret = getOffsetForCaret(position);
    final lineDy = caret.translate(0.0, 0.5 * preferredLineHeight(position)).dy;
    final boxes = getBoxesForSelection(
        TextSelection(baseOffset: 0, extentOffset: node.length - 1));
    final lineBoxes = boxes
        .where((element) => element.top < lineDy && element.bottom > lineDy)
        .toList(growable: false);
    final start = getPositionForOffset(Offset(lineBoxes.first.left, lineDy));
    final end = getPositionForOffset(Offset(lineBoxes.last.right, lineDy));
    return TextRange(start: start.offset, end: end.offset);
  }
```

I'm checking at the vertical middle of the line because I've noticed that emojis, for instance, have larger selection boxes (and they also mess with the line height they are at):
![image](https://user-images.githubusercontent.com/441756/92557187-7db34f80-f220-11ea-89ee-5cc55227e273.png)

Overall it's actually pretty concise and I'm happy with this approach. So I removed `getLineBoundary` from this PR.

It now only exposes `getFullHeightForCaret`.
Oh yeah, one more thing before submitting, caretPrototype here does not do anything useful as in getFullHeightForCaret, it only contributes width, which is then ignored. You should just remove the parameter and pass a zero rect instead in the method body.
Updated.
Is there anything else that refers to "full height" in the codebase?  Not that I could think of or find with a quick search.

If it's really just this method, maybe we should nip it in the bud and switch to "rawHeight" while we have the chance?  If I'm wrong then it definitely makes sense to be consistent and use "fullHeight".
This check is new and was not in https://github.com/flutter/flutter/pull/64988.  If the user rearranged their build scripts manually, error and tell them how to fix it.
<img width="483" alt="Screen Shot 2020-09-02 at 5 16 38 PM" src="https://user-images.githubusercontent.com/682784/92049734-15580000-ed40-11ea-9300-1e1440836a82.png">
This test is new.
This is new and tests https://github.com/flutter/flutter/pull/65124
Well I get this error but the build script "Thin Binary" is after "Copy Bundle Resources"
<img width="213" alt="Bildschirmfoto 2020-09-09 um 11 29 50" src="https://user-images.githubusercontent.com/6883178/92581291-c7874e80-f28f-11ea-885b-66ce9cf3bfb1.png">
@bennibau can you file a new issue and @ mention me?  I want to see what's going on in your case.

Please include the output of `flutter doctor -v` and the full exported Xcode run report.
View > Navigator > Reports > Export... 
<img width="350" alt="Screen Shot 2020-09-10 at 1 41 57 PM" src="https://user-images.githubusercontent.com/682784/92802492-66cd4400-f36b-11ea-8715-89cd92dc6df3.png">

Also, a screenshot with those build phases expanded.
This test has no name.
WE DON'T HAVE FUN HERE.
I seriously considered leaving the original or having it say "funny and fully" or something but...
Ah yes, test names. One of the other features I'd just remove entirely if I were to create a new test framework. :-)

Fixed
Does the web go through the text input client instead of raw keyboard event?
This also attempt to sync the remove editing value in the embedding side, I think we should still need to do that if it is a selection change? cc @gspencergoog .
should we also verify the handle does not show up?
Yes. All keyboard interactions with the text field are handled by the browser and we only receive the result of the change. e.g. If the user clicks "shift+right arrow", we receive an event from the browser telling us that selection has changed, so we read the new selection state from the input field and we send it to Flutter through the text input client.
how do we verify it? can we add a screenshot test here?
Something like this should be sufficient https://github.com/flutter/flutter/blob/d3fd62c8433ab9bf4e6b7312096cea1ab98b543f/packages/flutter/test/material/text_field_test.dart#L1032
The thing is, `EditableText` doesn't show the handles on its own. Instead, it takes a `showSelectionHandles` property. This test is only making sure that `EditableText` reports the change correctly. The rest is on `SelectableText` and `material/TextField` to take the selection change and pass the correct value for `showSelectionHandles` (which they already do, and they have tests for that).
Maybe I'll add a test that includes the entire interaction between `EditableText` and `material/TextField`?
I think you can just use textfield/selectabletext to test directly, after all, we care about they do not show the handle but not how editabletext ineract with textfield to make that happen. 
Thanks for the suggestions! I wrote a test for `selectable_text` and `material/text_field` to make sure they don't show handles under these circumstances.

@chunhtai do you think I should remove the `editable_text` test that I had initially?
What is a "remove editing value"? Shouldn't it send a `TextEditingValue` with an empty `text` in that case? And that would fail the `_isSelectionOnlyChange` check.
@chunhtai can you explain what you mean again?  I'm not sure I understand exactly what you're referring to.
sorry it is a typo, i meant the remote editing value. The formatAndSetValue also called _updateRemoteEditingValueIfNeeded
https://github.com/flutter/flutter/blob/9e315985d0788ee04df48559896be46225ecf2f5/packages/flutter/lib/src/widgets/editable_text.dart#L1804

This will attempt to sync the current editing value to the embedding. I was wondering if selection only change needs to be sync to the embedding as well.
I think we can keep it
Yes, it does, because otherwise the next editing operation won't operate on the same selection in both places.
After receiving a new value from embedding, if it's a selection-only change, we won't be formatting the text. Which means that `_value` and `_receivedRemoteTextEditingValue` are certainly the same. Is there something I'm missing?
If I understand correctly, the only reason we may want to update remote editing value is when the text formatting causes changes in the editing value, so we send it to the embedding to avoid getting out-of-sync.
I took a look at the code in engine https://github.com/flutter/engine/blob/f7c7b41f0a0c72163d749321d070880fcac6402d/shell/platform/android/io/flutter/plugin/editing/TextInputPlugin.java#L577
It looks like we care about the selection value. I was under the impression that the engine should sync its own editing value before sending the updateEditingValue to the framework, but i couldn't find the code that does that. So It seems like we do need to call _updateRemoteEditingValueIfNeeded somewhere even if it is a selection only change? 
The `TextEditingValue` includes the current selection.  So a "selection only" change does cause a change to `_value` or `_receivedRemoteTextEditingValue`, which then needs to be synced.
Maybe we're all in agreement here that it needs to be synced? I somehow feel like we're all saying the same thing...
ah I see, the updateEditingState is sent with the value inside the embedding, so it is already the same. yes, we don't need to sync it in this case.
Ok, let me try to clarify a bit. I think we are using the word "sync" which has many meanings in this context.

On the framework side, we keep two variables:
- `_value`: The current editing value on the framework side.
- `_receivedRemoteTextEditingValue`: This is what the framework thinks is the current editing value on the engine side.

Whenever the editing value changes in the engine, it sends an `updateEditingValue` message to the framework. The framework then sets `_receivedRemoteTextEditingValue` to the new value received from the engine (this is one meaning of "sync"). Then the framework tries to format the text of the new editing value received from the engine. If the formatting causes changes to the editing value (i.e. `_value` != `_receivedRemoteTextEditingValue`) then the framework sends the new (formatted) `_value` to the engine via `_updateRemoteEditingValueIfNeeded` (another meaning of "sync").

In the case of this PR, a selection-only change means there'll be no formatting changes, hence `_value` and `_receivedRemoteTextEditingValue` are guaranteed to be the same. So there's no need to call `_updateRemoteEditingValueIfNeeded` to "sync" the editing value back to the engine.
Thanks for the clarification. Makes sense now. LGTM.
Keep the information that it is safe to call this during build?
seems like we could rename this to posix exception, et cetera
on Linux/macOS
` || platform.isMacOS`?
oops, messed up my merge
nit. is there either POSIX documentation for these, or macos specific docs?
done
This is the actual change.  The rest of the PR updates the benchmark Xcode projects.
This was what caused the devicelab errors on #64988 post-submit.  `xcode_backend.sh` without any args was building, thinning, and embedding.  However, at this point the generated Info.plist that we will need to edit for https://github.com/flutter/flutter/pull/64988 doesn't exist, so it was failing.
Wow!
ultra nit / optional: "Consider source controlling your project before regenerating to inspect the difference."
if you parse the result and compare a dart map, the test will be resilient to changes in formatting.
Done.
can we document this some way to avoid future me "optimizing" this code back to the previous state?
nit: does this fit on one line?
done! hopefully the test will help too
Optional cleanup: Pull the debug banner toggle out into a helper function.
Does this change the help text for release mode?
Yes, the screenshot help was missing despite the fact that it should be supported. I added a test case for this.
fixed
done
`toggleDebugBanner` should maybe be `setDebugBanner` and accept a bool arg to turn it back on, too.
Sorry, I'm confused. It's supported in profile but not in release, right? Is `supportsServiceProtocol` what we were using to distinguish those cases?
its supported in profile and release, because it involves talking to a device daemon (ios-deploy/adb) and not the service protocol.
actually idevicescreenshot, not ios-deploy
where you saying that `canRun` is not reliable on Windows?
canRun just checks if the result of https://github.com/google/process.dart/blob/cce751da2076b8345d2f17b9db5cc6fc04f60e69/lib/src/interface/common.dart#L51 is null. I'm not actually sure what it will do in this case.
This variable should no longer be necessary. Remove to simplify code.
Combine `kNonDraggingListHeight` and `kDraggingListHeight` to simplify code.
Shall we add a message to the error? 
Shall we add a message to the error here as well? Also a comment on why we add this method. (Sorry the serviceClient also doesn't have it, but I thought it might be useful in the future to the readers of this code)
There are a few things we need to do here.
(1) This only works for desktop web (mobile web has another method which is very similar to this)
(2) If `flt-semantics-placeholder` which lives on the engine changes, this will break. It would be very hard to understand for the engine-developers. It is best to add a documentation and also a link to that code.

Btw, a question we can also click on this button by calling the following right?
```
webDriver.execute(
          'document.querySelector(\'flt-semantics-placeholder\').click();',
          <String>[]);
```
Question: Looks like we are also switching the way we are accessing the driver object (fromExistingSession vs constructor)? Is there a specific reason for it (anything failing with a11y or screendriver)?

The async version of fromExistingSession returns a WebDriver instance which will **NOT** have the same capabilities (in fact, it would be empty) as the original one where the capabilities plays an important role for screendriver.
Discussed offline. Will follow existing pattern and do not add message to UnimplementedError.
See the comment below.
Updated accordingly. Well create an issue for Mobile Web (in fact, it works on Android-Chrome).
Great, thanks for adding this test!
Even though selectionColor and cursorColor will not be deprecated (yet), their API docs should explain what the deprecation warning will, and the docs should warn about the upcoming deprecation.
Nit: Is there any way this could be a constant?  Just thinking that it's not intuitive where this value comes from by looking at the test (I see it hard coded in material/text_field.dart).

Don't worry about this if it's not a quick and obvious improvement, I know it's not really this PR's responsibility!
I think this has to be the same as `Color(ColorScheme.light().primary.value)`. Only pointing that out because I wish we wouldn't use ThemeData.fallback(), since it needlessly obscures ThemeData.light().
Why has this test and the next one been hollowed out?
Good point. Done.
I just switched everything to color constants for the default values so this is no longer an issue.
Before we had two tests for defaults: one with opt-in turned off and one for opt-in turn on. With this PR there is only one default (the opt-in) case, so this replaced both with just the opt-in case.
do this in the initializer and it can be final
nit: add a brief doc comment and link to the correct documentation?
there are some helpers like `stringArg`, `stringsArg`, et cetera that avoid the casting
consider not catching all file system exceptions: some of these might be programming errors in the tool.
consider an short name alias for typing - gen-l10n ?
Note also: maybe we should use a hyphenated name for the long form as well.
I've converted any `FileSystemException`s I threw in the tool into `L10nException`s and then removed the code catching file system exceptions
`return child.getDistanceToActualBaseline(baseline);` ?
Can you modify the test to just call the getDistanceToBaseline on renderobject of LayoutBuilder and see if it returns the right value when it has child? 
I was afraid that changing how baseline is calculated may have adverse effects. That's why I only called `getDiatanceToActualBasline` to pass the baseline to child.

Should I override how the baseline is computed by returning it?
I decided to only pass the baseline to child because of this [issue I faced](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772)
If I guessed right, I won't be able to call getDistanceToBaseline in the test after getting the LayoutBuilder RenderBox since it's only allowed to call when performing layout. 
I have edited the test to check that getDistanceToActualBaseline is actually caching the baseline for computation as we have done for other widgets like Chip and ListTile.
I did test it out, and returning the child's actual baseline do have an effect on how the child is laid out on y coordinate when a Baseline is present. Wouldn't that make it a breaking change?
let me take a step back, May I know what is the use case of this change? It seems weird that we call getDiatanceToActualBasline of the child if we don't want to use the result. That will be a weird side affect.
If you check out [the comment](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772) which describes the blockage for the PR. Hexie suggested providing Ink widget a private RenderObject. So instead of providing a private RenderObject, I suggested that what if we implement the baseline logic for LayoutBuilder instead of rewriting the most of the code for the Ink widget. The [comments on the PR](https://github.com/flutter/flutter/pull/63887#issuecomment-675278772) descibes the usecase and why I ended up doing this.
Ah So this is for a failing test. I think we should return the child, otherwise according to the test it will no longer baseline the list title correctly.
But I do agree with you that there is no point if we are not returning the child's baseline since then Baseline won't be able to properly define the y coordinate for a child. I'm just concern that doing so may be a breaking change.
I think this is more programmatically correct, so i think it is ok if this is a breaking change.
So, is the PR good to go without a breaking change design doc or we should handle it with a flag property? I can write a design doc for it, if needed.
We only consider it a breaking change when it break contributed tests https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes

So you should make the change first to see if it does break tests
I have already made the changes to return the child's baseline, and it's not breaking any test. 
This is not a good test for this change, can we try to build a real child and verify its position does take the child.getDistanceToActualBaseline into account?
I have updated the test. Let me know if it's not good. I'll try to improve.
Moved these failures to where they are detected, instead of the end of the test.
This works, but is there a more idiomatic way to return a string from a bash function?
Unrelated to this change, but I noticed the quotes were missing.
This is a new xcode_backend entrypoint.  At the least, we can tell add-to-app customers to call this in a new build script phase.
Check out the screenshot in the description.  We can probably remove the second "Flutter".  Maybe also "connect"?
> Allow Flutter tools on your computer to debug your application. This prompt will not appear on release builds.
This section is new.
Don't really care what it says since that seems like a moving target, just that it exists.
This was moved from `general.shard`, it's not a hermetic test.
These were disabled in https://github.com/flutter/flutter/issues/35707, but as an integration test they should get a precache, so I fixed them up and reenabled.
This one is new, the behavior changed #57688 but the `installWithoutRelease ` test was being skipped so it didn't fail.
I might be misreading this a bit, isn't this ultimately the same plist as https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/targets/ios.dart#L341 ?
https://stackoverflow.com/questions/17336915/return-value-in-a-bash-function probably
I think I would rather not add this for add-to-app.

Those customers should be sophisticated enough to read an error log and know which plist(s) to update.

This is likely to get things wrong for some customer and we'll get requests to change it or a specific CI system or wahtever.
oh lol, TIL. So there's an actual built-in tool to turn plists to things like json so it can be more easily consumed by things like dart?
oh cool, is this a whole new feature (that confused matt forever) bundled here? :D
Also add a common name (as seen in the xcode gui) for this? People might not know what the CONFIGURATION setting maps to.
Also add a gui description if possible (I assume people can go into the build settings tab, add a new row, expand the configurations and type in something in xcode).
How come this works here and not for add-to-app? Because our template build phase puts xcode_backend.sh later than where cocoapods can help us put it?
Display an error message otherwise?
On the second connect. I'd maybe leave it. Otherwise people might think I'm just flutter running and then maybe taking a screenshot or something. I'm not technically "debugging", why doesn't it work?

On the second Flutter, don't have a strong opinion. To be specific, we're not really debugging their (objective-c) application. This is strictly dart/observatory/flutter stuff.
What about .frameworks? Will those cases never work unless users type in something manually in their real checked-in info.plist?
This has been in there for .. a while now.

Basically, we try to use the $CONFIGURATION because that's probably what the user wants if they're running from Xcode (in particular, we don't want instruments tests from debug mode Dart, and we set up instruments to run in a "PROFILE" configuration by default).

But we do let a user override it if necessary.
It's not the same file, that's the project's `ios/Runner/Info.plist` (build setting `INFOPLIST_FILE`), and that's checked into source code, and where [the docs](https://flutter.dev/docs/deployment/ios#updating-the-apps-name) tell users to update some fields before they submit to the app store.  

This PR is editing the Xcode-generated Info.plist that gets embedded into the `Runner.app`.
After Xcode compiles everything and it embeds resources (storyboards, images, etc), it creates a `Runner.app/Info.plist`, which is a combination what's in the user's Info.plist in Xcode, plus a bunch of other Xcode-generated keys and metadata
<img width="1032" alt="Screen Shot 2020-09-01 at 12 05 55 AM" src="https://user-images.githubusercontent.com/682784/91813044-eb3efa80-ebe6-11ea-93da-b3033cf9622b.png">

By editing this final generated Info.plist, we don't need to update the user's checked in Info.plist, update the template, or have a complicated migration where we set different Info.plists depending on configuration, which would cause flavor-users a bunch of pain.  We know the user needs this service in debug and profile when copied to the device, and it also means it won't slip into the release version that gets submitted to the App Store.
> Those customers should be sophisticated enough to read an error log and know which plist(s) to update.

How would they see an error message from the VM if they can't attach?  **Edit: oh right, they would see it in Xcode.**
It definitely requires some Xcode-foo to know you can edit the Info.plist per configuration.  You need to know how to expand the build setting, which people seem confused by.  
<img width="862" alt="Screen Shot 2020-09-01 at 12 16 17 AM" src="https://user-images.githubusercontent.com/682784/91814041-66ed7700-ebe8-11ea-93c1-912feed22d9e.png">
Or they can do something like `Info-${CONFIGURATION}.plist`
We'll have to update the docs, for sure.

>  Will those cases never work unless users type in something manually in their real checked-in info.plist?

Right, they would need to edit their plist.

At least in the CocoaPods case they can add the build phase I suggested in https://github.com/flutter/flutter/issues/63893#issuecomment-684126922
Actually, looking again, https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/targets/ios.dart#L341 is a different third `Info.plist`. It's the one that gets embedded in the `App.framework`.
Yeah this logic and error messaging was just moved into a common function so I could use it in two places.
This was all just moved.
> Because our template build phase puts xcode_backend.sh later than where cocoapods can help us put it?

Bingo.  I put some more details in https://github.com/flutter/flutter/issues/63893#issuecomment-684126922.
If the developer sets their own NSLocalNetworkUsageDescription because their app is doing their own local networking we don't override it.
that's ok. I just meant if that's the case, we should print something in the console to indicate that you'll get a popup in debug and we can't set the message in it but it's for flutter tools to connect.
Yup, it's being used for other plist parsing, see https://github.com/flutter/flutter/blob/80619f100ffefec82528be1b92a76ad22807e459/packages/flutter_tools/lib/src/ios/plist_parser.dart#L53  Except the json part doesn't totally work... https://github.com/flutter/flutter/issues/62160
oh lol, sad
Does it matter which Plist these permissions are added to, or could it be done to the flutter framework plist itself?
Can we call this dartObservatoryBonjourServiceFound?  or take in `_dartobservatory._tcp` as a parameter?  From the callsite it just looks like we are throwing if any bonjour service is found.
Is this throwing an error if a user legitimately has their own mdns service for their release build?  We want to make sure to support that.
This is an integration test, it doesn't have any mDNS service set.  The `xcode_build` script handles that case, it detects if the `NSBounjourServices` key is set, and adds it to the list.
It needs to be on the app bundle, so `Runner.app/Info.plist`.  A framework can't set app-level permission requests or entitlements.  Otherwise this problem would be a whole lot simpler.
understood. 
we should go have Matt write this down in https://flutter.dev/docs/deployment/flavors :D
CONFIGURATION is an env var provided by Xcode. It's available in the build settings if you dig into them. There's no special GUI name.

By default anXcode project has Debug and Release. We added profile to our default template when this was added.
Oh hey, this was another bug we needed to fix
I can't find the original issue, but we did not correctly run pub when building for macos
https://github.com/flutter/flutter/issues/46236
Nice.
Is 'digest parsing' something we no longer need to test, or is this handled elsewhere?
Hoping to start optimizing that analyzer üòâ 
We don't need it anymore because we are no longer retrieving digests. :)
Before this change, we had to look up all of the digests and then figure out which one we needed in order to get the right image. With the new endpoint, we can just ask for the exact image we need. 
Doesn't have to be in this PR, but should this be moved to the integration shard?
I wasn't sure. It is definitely touching the real filesystem, but it is also more of an analysis check - I could see wanting it to remain fast.
would it be possible to allow the entire `//test/integration.shard/` dir?
we could - this sort of enforces using the existing test_utils, which could be helpful if we do want to change the file system in the future
oh yeah, makes sense
Does it run in parallel with other general shard tests?
yes ... hopefully those aren't also writing to the filesytem...hmm
we should probably just move this?
i vote move them just to be safe and rule out the potential flaking.
done!
How about a test in forbidden_imports_test.dart that checks that this file isn't imported outside of the integration.shard subdir?
let's leave iPadOS out or add a caveat since we never invested much in tablet specific UI (which has not many but some noticeable differences)
Why not making `tallky[key]` as `double` to get more precision?
I'm keeping the same datatypes as before to avoid breakage.  With how big these numbers are 1/3 of a number is inconsequential.
I could also use a content hash, but technically it needs to be the content hash of the _entire_ bundle in order to be correct. Use a large random number is a pretty close approximation, because it will only change when at least one aspect of the build has changed (causing this logic to rerun)
I think `nextInt` [accepts up to 1 << 32](https://api.dart.dev/stable/2.9.1/dart-math/Random/nextInt.html), so you could go as high as: `4294967296`. (Not sure it'd make a big difference)
since it is embedded as a string we could go bigger, 4294967296 sounds like a nice number though!
There are a few more of these actually: https://github.com/flutter/flutter/pull/65693/files
If its not too much trouble could you apply them in this PR?
Sure, I'll add them! Thanks for looking at this PR
Nit: Consider turning this into a macro if you haven't already. I think it's repeated 4 times, if I'm not missing a slight change.
avoid creating new list with sublist(0)
avoid creating more than a single list or any extra iterables
avoid creating extra list
avoid creating extra iterables
The name is a bit confusing, maybe siblingLength?
is this necessary?
A more specific type is generally better, in this case it is a private API so there should be no concerns.
done
`_attempt` could return `null` on success, and the exception object on an error. Then here you can rethrow the most recent error. Then at the callsite, you can catch `IOException`, or something more narrow, since it doesn't look like the text `'Failed to download...'` is used there. The caller also presumably already knows what the url is.
done?
Ehhhh. Okay, sorry. Maybe that wasn't the best suggestion. If there's some way to avoid catching `Exception` here that would be good, though, since it's only the `IOExceptions` that probably indicate a network issue on the end-user's side.
Where did the `throwTooleExit` go?
Maybe these should all rethrow, `fetchUrl` can do a `try {} catch on IOException {}` with a `continue` in the `catch` if there are still attempts left? `doesRemoteFileExist` would also need a `try {} catch {}`, too, then I guess.
The problem with this approach is it'll fail if there's _two_ `ReorderableListView`s with items that have the same local keys. I think the solution is that `_GlobalObjectValueKey` should have two values, one is the key we're proxying to, and the other is the _ReorderableListContentState to which they belong. We can probably rename it to `_ReorderableListChildGlobalKey` or something, with arguments `final Key subkey` and `final _ReorderableListContentState state` or something like that, to make it clearer what is going on.
@Hixie 
That's a great idea! Thanks for your comment. I will apply it immediately.
you don't need to make this generic, since you don't use the T in the implementation
Thank you! I updated the code.
@Hixie Add `_ReorderableListContentState` as a value of the key can not solve the situation where multiple items use the same local key, they have the same `_ReorderableListContentState`, which will lead to Multiple widgets used the same GlobalKey, such as:
```
  @override
  Widget build(BuildContext context) {
    return ReorderableListView(
      children: <Widget>[ InnerTest(key: ValueKey(0)), InnerTest(key: ValueKey(0)) ],
      onReorder: (_, __) {},
    );
  }
```
The reason why there is no problem here is its wrong implementation of `int get hashCode => identityHashCode(subKey);`

Probably we could add the index into the values together to solve this problem.

I think we should add this to the unit test case.
```
    If [operator ==] is overridden to use the object state instead,
    the hash code must also be changed to represent that state.
```
In other words, Hash codes must be the same for objects that are equal to each other according to [operator ==]
Comments whit `//` .
I don't know much about the hash in the key. Would you explain with an example?
Also see
```
/**
   * The equality operator.
   *
   * The default behavior for all [Object]s is to return true if and
   * only if `this` and [other] are the same object.
   *
   * Override this method to specify a different equality relation on
   * a class. The overriding method must still be an equivalence relation.
   * That is, it must be:
   *
   *  * Total: It must return a boolean for all arguments. It should never throw
   *    or return `null`.
   *
   *  * Reflexive: For all objects `o`, `o == o` must be true.
   *
   *  * Symmetric: For all objects `o1` and `o2`, `o1 == o2` and `o2 == o1` must
   *    either both be true, or both be false.
   *
   *  * Transitive: For all objects `o1`, `o2`, and `o3`, if `o1 == o2` and
   *    `o2 == o3` are true, then `o1 == o3` must be true.
   *
   * The method should also be consistent over time,
   * so whether two objects are equal should only change
   * if at least one of the objects was modified.
   *
   * If a subclass overrides the equality operator it should override
   * the [hashCode] method as well to maintain consistency.
   */
  external bool operator ==(Object other);

  /**
   * The hash code for this object.
   *
   * A hash code is a single integer which represents the state of the object
   * that affects [operator ==] comparisons.
   *
   * All objects have hash codes.
   * The default hash code represents only the identity of the object,
   * the same way as the default [operator ==] implementation only considers objects
   * equal if they are identical (see [identityHashCode]).
   *
   * If [operator ==] is overridden to use the object state instead,
   * the hash code must also be changed to represent that state.
   *
   * Hash codes must be the same for objects that are equal to each other
   * according to [operator ==].
   * The hash code of an object should only change if the object changes
   * in a way that affects equality.
   * There are no further requirements for the hash codes.
   * They need not be consistent between executions of the same program
   * and there are no distribution guarantees.
   *
   * Objects that are not equal are allowed to have the same hash code,
   * it is even technically allowed that all instances have the same hash code,
   * but if clashes happen too often, it may reduce the efficiency of hash-based
   * data structures like [HashSet] or [HashMap].
   *
   * If a subclass overrides [hashCode], it should override the
   * [operator ==] operator as well to maintain consistency.
   */
  external int get hashCode;
```
How about this way?

```Dart
@override
int get hashCode => hashValues(subKey.hashCode, identityHashCode(state));
```
Thank you very much üëç 
The new hash seems to work fine :)
```dart
@override
int get hashCode => hashValues(subKey, state, index);
```
Do we need an index? ValueKey already has a value for the index.
See https://github.com/flutter/flutter/pull/64855#discussion_r484312001
@xu-baolin Two children can never have the same key, so the current behavior is correct
See: https://api.flutter.dev/flutter/foundation/Key-class.html

"Keys must be unique amongst the Elements with the same parent."
I see, thank you. 
@PixelToast However, this change not an equivalent modification, and change the behavior of fault tolerance.
Can we consider producing globalkey only through state and indexÔºåso that we don't have to force developers to provide the widget with a key.
@xu-baolin No problem!

This PR is for fixing a specific bug and not extending functionality though, you are welcome to open a new issue to discuss any changes to functionality that would be nice to have.
@xu-baolin @haeseoklee 
This repo uses the triple slash for documentation comments, see the style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use-for-public-quality-private-documentation
@xu-baolin @PixelToast 
It looks better to modify it with ```//```. Thank you for your guidance.
Is this the same test as previous one?
Yes. One is for''vertical mode" and the other is for "horizontal mode"
I see, but then you will need to set scrollDirection to vertical in this test, right?
That's right. I'll apply it right away. üëç 
check a few more non-specified things like FLUTTER_FRAMEWORK_DIR is also pointing to reasonable places etc?
can you also add an "advanced" usage that synergizes with xcode more? Something like --flavor. 
`--flavor` does not change any of the generated config, it just controls which scheme we tell xcodebuild to use.
true dat. How about --local-engine?
we'll validate that it doesn't exist and fail :) 
as in you're going to assert users don't flutter build ios --config-only with --local-engine? Should we? If this is a flutter build ios --config-only command rather a flutter build ipa command, the intent is broader now no? We can't tell what the user wants to do and flutter build ios --config-only --local-engine can be a valid intent (e.g. this new path is now probably going to become the easiest way to flutter build ios --config-only --local-engine, then launch xcode and put a breakpoint on the engine code).
no, the tool will fail to locate the local engine because it does not exist.
ah got it. I misunderstood.
done-ish
```suggestion
  /// This method sends the given event to [dispatchEvent] based on
```
Instead of saying "down event" and "signal event" this could link to the events directly, right? e.g. [PointerDownEvent] and [PointerSignalEvent].
Same for the others.
... Event events...

maybe just say "for [PointerHoverEvent]s, [PointerAddedEvent]s, or [PointerRemovedEvent]s.
"resetGesture" is a strange name. 
Why is this reset necessary when the instance just got created?
commented out code
how does this assert that the down event is cancelled?
commented out code
Since this is only needed for the LiveTestWidgetsFlutterBinding could it just live there as a private?
Presumably, we would want to keep this override to ensure that only `TestBindingEventSource.test` reach this method?
I changed it to `resetGestureBinding`.
I've added the following comment, is it clearer?
```dart
    // The test target, _TestPostRouteCancel, shows on the home route how many
    // [PointerCancelEvent] it has received. Initially it will show "Home 0".
    // After the route is popped, it should show "Home 1", meaning it received
    // one [PointerCancelEvent].
```
It's something I've thought for a long time, and I don't think this design is either sufficient or necessary to achieve what it seems to.
Redefining `TestWidgetsFlutterBinding.dispatchEvent` provides a way to diverge the behavior of `dispatchEvent` based on event source, although the new behavior is only implemented by its subclass `LiveTestWidgetsFlutterBinding`. How it behaves based on the source is shown as follows:
```
// TestWidgetsFlutterBinding binding;
binding.dispatchEvent(event, result)  // AssertionError
binding.dispatchEvent(event, result, source: TestBindingEventSource.test)  // Test behavior
(binding as GestureBinding).dispatchEvent(event, result)  // Original behavior
```
But this is why the assertion is unnecessary: If some class calls `dispatchEvent` without adding `source`, the class must be unaware of `TestWidgetsFlutterBinding`, which means it will always call the method as `GestureBinding.dispatchEvent`. This assertion protects no one.

And why shouldn't any class aware of `TestWidgetsFlutterBinding` be allowed call the device version? The `LiveTestWidgetsFlutterBinding.dispatchEvent` even defines its own way of handling device-sourced events. The only `dispatchEvent` that does not accept device-sourced events is `TestWidgetsFlutterBinding`'s, which itself does not even redefine test-sourced events. If we really want to diverge by the source, we better do it in `LiveTestWidgetsFlutterBinding` (which does not need it either, since it _allows_ device-sourced events).

What's worse, it forces a test in `gesture_binding_resample_event_on_widget_test.dart`  to [shadow the argument](https://github.com/flutter/flutter/pull/64846/files#diff-57f04f566394a5e6943f53570d727bddL29).

Since the assertion is not needed, and the divergence is already implemented by `handlePointerEvent`, _and_ it brings trouble, I can really think of no reason to keep this assertion.
I think the intentions of the test would be a little clearer if the app would more clearly say what the "0" means. You could for example have an additional text widget that says "PointerCancelEvents: 0". The test would then be self-explanatory and you wouldn't even need the comment above.
Looks like this property (and the logic for setting/retrieving it) can be moved into the `LiveTestWidgetsFlutterBinding` class since it is only needed there?
Sadly not. `WidgetTester` calls the `handlePointerEvent` with source but `WidgetTester.binding` is of type `TestWidgetFlutterBinding`, despite its concrete type being `LiveTestWidgetsFlutterBinding`.
@zanderso What do you think of this hard deprecation?  I doubt this is commonly used.  I didn't want to silently drop it.  I could make it more complicated and print this warning, but then try to pass the deprecated `timeout` down into `deviceDiscoveryTimeout`.
This has the side effect of repopulating the `devices` cache, with the `timeout` duration.  We decided to do this in https://github.com/flutter/flutter/pull/51678#discussion_r387157291 to avoid google3 breakages.
Plumbing it to `deviceDiscovertyTimeout` sounds like the right way to deprecate this. It can then be entirely removed after the stable branch cut.
Is this the same logic as in the engine?
Yes. With the refactor to using a function for fuchsia_ctl, it was easier to diff the two files and see that this was missing.
Ordering shouldn't matter here
We actually want the analytics now that each re-entrant build corresponds to a single flutter invocation
I tried to collapse most of the logic for creating the xcodebuild command using if/for elements - it should be easier to read for the most part...
Logic is the same, just un-nested the else on old L398
below
below
`BuildContext context`
"In this example, the context used is the one from the `Builder`, which is a child of the `FrogColor` widget, so this works:"
In this example, the context used is the one from the `MyOtherPage` widget, which is an ancestor of the `FrogColor` widget, so this does not work:
for clarity let's put a header like "## The \`.of\` method convention" or "Implementing \`.of\` methods" above the paragraph that starts "The convention...", and then a similar header above your new text e.g. "## Calling `\.of\` methods" or some such.
Added the type annotation but I think we need to explicitly name the inner context differently so that the developers who we target with this documentation will have an easier time seeing how this is a different context
done
done
done
"bellow" here should be "below"
oh i also meant to remove "DON'T" (and "DO" above). The writing style for the API docs try to avoid telling people what to do, they just give information and let the reader decide what to do with it.
 ü§¶‚Äç‚ôÇÔ∏è oh, that's right
removed
removed the comments entirely as we now have similar text before each snippet
It looks like we only need one of L43 and L44? 
And there's also a copy of `watchPerformance` in `macrobenchmarks`. 
2s is not a very short time (vs ~10s sampling time), maybe we should also increase the timeout settings in `macrobenchmarks`. 
This sounds potentially flaky. Is there any way to improve coordination with the engine to avoid magic delays like this?
Good catch. I forgot to delete L44 during refactor.
Yes, it's flaky in terms of benchmark numbers (still have a chance to be bimodal and measuring the wrong thing), but not in terms of success/failure. It will be a net gain compared to our old version as the old ones have a higher chance of measuring the wrong thing.

We shall definitely have a more proper fix to solve this reliably. Created https://github.com/flutter/flutter/issues/64808 to track that.

If the intention here is to wait for another 2 seconds, then I think you will need a fresh instance of `Future`.
Good catch. Fixed.
so `exit $LASTEXITCODE` is setting `%ERRORLEVEL%`?
Yes, by default when you run powershell with -Command, all non-zero exit codes are translated into `1`.  This LASTEXITCODE trick allows me to set the exit code to the value from the command, which I set to 2 specifically for the case where the version is incorrect.
Could you add a comment, just because I know I won't remember that? Otherwise, LGTM.
Added more details and combined the two comments
I _think_ this only exits you out of the subroutine and then actually not sure what it executes next (would it retry the subroutine again? That wouldn't make much sense since this error is unreoverable.). I would have expected this to set `exit_code` and then jump to `: final_exit`?
Might be worthwhile to leave a comment here why this is two (e.g. link it to the batch file)
/B is subroutine only - you can test this locally by removing the condition for the pwsh version detection, but it will immediately exit.
done
I wonder why we do the 'final_exit' dance below then... But if you tried this and it works: LGTM
Nit: line 33-37 can be simplified as `imageIndex = (imageIndex + 1) % 6`.
I wonder if more memory info (e.g., peak memory, average, percentile, etc.) from `DevToolsMemoryTest` (see, e.g., [this example][1]) or Timeline (see, e.g., [profiling_summarizer][2] and https://github.com/flutter/engine/pull/18516) would be helpful here? The DevTools works for Android and the Timeline works for iOS.

[1]: https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/complex_layout_scroll_perf__devtools_memory.dart

[2]: https://github.com/flutter/flutter/blob/master/packages/flutter_driver/lib/src/driver/profiling_summarizer.dart#L79
Done
commented out code?
unless you need the `null`, this can be `observatoryUri.complete()`
Done
Done
I am a bit worrying about removing this assert. If you take a look at line 529, the getMinChildIndexForScrollOffset should return child index whose scroll offset is <= scrollOffset

It feels like a user error to me.
after taking a look at the code again it seems fine to remove it. Let me think about it further if there is any corner case
This does not feel right, the paintExtent should be accurate represnt what is available on the screen.
I think the issue may be sliver grid is calculating paint extent incorrectly. It finds the delta of leadingScrollOffset and trailingScrollOffset. There is no problem with trailingScrollOffset, but it assume the leadingScrollOffset is always the scroll offset of firstchild. but that may not be true because it can be place arbitrary on screen.

Do you have the repro for the hittest issue?
I think this is ok
I think this is ok actually. The test I added includes the `hitTest` repro.

In the test case, there are 2 containers in the grid, one on top of the other, each with a height of 100. So the `paintExtent` is 200 when they are laid out, that seems right.

Checking `geometry.hitTest` here does not consider _where_ they are actually painted, even though it is being compared to the mainAxisPosition of the gesture here. In the test case the `leadingScrollOffset` is 300, the `paintExtent`/`hitTest` would have to be 500 to pass `hitTest` as it is, and that wouldn't be correct.

`SliverGeometry.hitTest` cannot exceed the `paintExtent`, and defaults to be the `paintExtent`, so it is 200 as well. This does not correlate with the actual position of the children, but is the correct representation of what has been painted.

It works when we know the children are placed at the top of the grid, but this is not allowing arbitrary placement. So the `hitTest` and `paintExtent` are correct, the question is, "have I hit within the area of the `SliverGrid` where it _may_ have painted a child?" - since we don't know yet where the grid children are positioned. I think the `maxPaintExtent` is a good representation of the area where a child may be painted. Once it passes this check, the children are `hitTest`, and this is where it reconciles the positioning of the children. WDYT?
I thought of a better way to explain - the size of something does not necessary indicate its position.
I think the current way of calculating the paint extent is not correct. according to the doc
```
The amount of currently visible visual space that was taken by the sliver
to render the subset of the sliver that covers all or part of the
[SliverConstraints.remainingPaintExtent] in the current viewport.
```
I attached a picture to demonstrate my thought.
![Untitled drawing (2)](https://user-images.githubusercontent.com/47866232/92029976-3823ed80-ed1b-11ea-81c9-e7d48c93a6b2.jpg)


 
Interesting! I did not know the space should be included in the paintExtent. Let me try this and see how it comes out. :)
@chunhtai I think you are right, this should be the better way to fix the hitTest result. üôÇ 
is the abs necessary? is it possible for the scroll offset to be come negative? even if it does we should still use the negative value to calculate the paint extent right?
A negative scrollOffset happens when you over scroll at the top. When I was checking this yesterday there was a case where a negative scroll offset resulted in an incorrect paintExtent. Like in our example, instead of 500, when the scrollOffset was -10, it incorrectly calculated a paintExtent of 490. Checking now, it isn't reproducing, so maybe we do not need it.
I took at calculatePaintOffset, if the scrollOffset is a negative number it should still correctly calculate the delta between from and to. I think we should remove the the abs if we cannot be reproduce it.
sgtm!
```suggestion
      from: math.min(constraints.scrollOffset, leadingScrollOffset),
```
How aboue `error_handling_io.dart` for the file name?
What's the relationship between these `ignore`s and `https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/general.shard/forbidden_imports_test.dart` ?
Oh I see, this file was added as an exception but that changed when I renamed it
If you mirror the way the `ErrorHandlingFileSystem` is set up:

https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/globals.dart#L66

then tests that inject their own `ProcessManager` should also get wrapped in the `ErrorHandlingProcessManager`.
That seems like the opposite of what I want - if a test specifies a regular process manager it should get a regular process manager. This would match the behavior of the non-context tests
If we have tests with a mock process manager where the mock process manager throws a `ProcessException` with one of the errors now caught by the `ErrorHandlingProcessManager`, those tests are now testing something that can't actually happen.
that's true for context injected tests, but I don't think that we should require all of the context free tests to use the error handling filesystem/process manager.

testing cases that can't happen is definitely not idea - we should be able to handle this in code review by pointing out when something is redundant with the error_handling_io lib.

I'm more worried about tests which build up a large amount of injected interfaces being hard to understand for new contributors. Why does this process exception become a tool exit here, but not here? Or what instance am I actually using.
They do not look the same, I will either not mention the video or make them look similar.
This is the new check that these plugin frameworks haven't been `lipo`d to the iOS ARCHS.
This wasn't actually building for the simulator (it's missing `--simulator`) even with the `-d` flag. `flutter build ios` with a watch companion doesn't actually work.  Anyway the next thing this does is run on the simulator, which does work.
This adds a framework to the watch extension.  Previous this failed because `xcode_backend` `lipo`d all `.framework`s, even the ones in the watch extension with a different expected architecture.
Bitcode should be off for Runner.
Adding (any) plugin is what kicks the tool into running `pod install`, which we need to embed the watch framework.
This is the actual fix.
Instead of `find`ing and thinning all `*.framework`s in `Runner.app`, it now only does so in the `Runner.app/Frameworks` directory.
Add a comment for what this is? It came from a pod?
never mind, the answer's here. Still good to comment in the other file. 
Why should bitcode be off? Bitcode is a requirement when you have a watch extension.
Because this is an integration test that will never be submitted to the App Store and I didn't want to track down [issues related to the pods building before the correct bitcode-embedded version of Flutter gets copied around](https://github.com/flutter/flutter/issues/39356#issuecomment-618138976).  I'll set it back to `YES` and see if this particular integration test triggers that case.
might be worth making this `final` as a further check that the callback only runs once
ObjectKey.value should probably be nullable
we should probably use oldElement throughout here (or not at all, but i see the benefit of avoiding the `!`s)
why do we need a `!` here?
oh because [] can return null, i see.
this should be non-nullable
we should make this one non-nullable and make its getter generate a pretty FlutterError for the case where it's null, saying something like "This widget has been unmounted, so the State no longer has a context (and should be considered defunct). Consider canceling any active work during "dispose" or using the "mounted" getter to determine if the State is still active."
we might get better diagnostics if we make _widget `late` rather than nullable
should be non-nullable
child should be non-nullable and required
child should be required, non-nullable
this can be late and the method can be non-nullable; this can throw in release builds, it's debug-only
`aspect` has to be nullable, no? I'm surprised this didn't either require "required" or "?".
can we make this non-null for consistency with AbstractNode?
all builders should return non-nullable Widgets
also context on builders should always be non-nullable
this should be non-nullable
state and _state should be non-nullable
please do me a favour and remove the "Notice that" here... :-)
we need to remove this cast (and not replace it with a copy). how we do that...
the real solution is a dart feature to cast the list cheaply. But in the meantime, let's make a private Element subclass that we create a single instance of and use that as our placeholder, and just before we return let's verify that the list doesn't contain any of them.
It would conflict with `AutomaticKeepAliveClientMixin.build` :

```dart
  @mustCallSuper
  @override
  Widget? build(BuildContext context) {
    if (wantKeepAlive && _keepAliveHandle == null)
      _ensureKeepAlive();
    return null;
  }
```
this field is compared to null at some place, so it can't be late.
Some null may be here accros all children.
Some null may be here accros all children.
Some null may be here accros all children.
I was also surprised with that some times ago. IIRC this is allowed because the method is abstract? But that looks actually quite strange. /cc @leafpetersen 
Yes, see the 9th bullet in this section: https://github.com/dart-lang/language/blob/master/accepted/future-releases/nnbd/feature-specification.md#errors-and-warnings , landed [here](https://github.com/dart-lang/language/pull/733).
we need to change `AutomaticKeepAliveClientMixin.build`, something like this should do (untested):

```diff
diff --git a/packages/flutter/lib/src/widgets/automatic_keep_alive.dart b/packages/flutter/lib/src/widgets/automatic_keep_alive.dart
index b2ae057b3f..9b6e11d5f9 100644
--- a/packages/flutter/lib/src/widgets/automatic_keep_alive.dart
+++ b/packages/flutter/lib/src/widgets/automatic_keep_alive.dart
@@ -330,8 +330,7 @@ class KeepAliveHandle extends ChangeNotifier {
 /// with [State] subclasses.
 ///
 /// Subclasses must implement [wantKeepAlive], and their [build] methods must
-/// call `super.build` (the return value will always return null, and should be
-/// ignored).
+/// call `super.build` (though the return value should be ignored).
 ///
 /// Then, whenever [wantKeepAlive]'s value changes (or might change), the
 /// subclass should call [updateKeepAlive].
@@ -397,6 +396,17 @@ mixin AutomaticKeepAliveClientMixin<T extends StatefulWidget> on State<T> {
   Widget build(BuildContext context) {
     if (wantKeepAlive && _keepAliveHandle == null)
       _ensureKeepAlive();
-    return null;
+    return const _NullWidget();
+  }
+}
+
+class _NullWidget extends StatelessWidget {
+  const _NullWidget();
+  @override
+  Widget build(BuildContext context) {
+    throw FlutterError(
+      'Widgets that mix AutomaticKeepAliveClientMixin into their State must '
+      'call super.build() but must ignore the return value of the superclass.'
+    );
   }   
 }  
```
ah, i see, yeah. We should probably refactor that a bit but let's do that in a separate PR.
not sure what this means. ProxyWidget should never have a null child.
Weird, what's the reasoning?
this should be non-nullable and places where we create `IndexedSlot<Element>` should be `IndexedSlot<Element?>`.
we have to avoid this cast
you can use the same trick mentioned earlier with a `class _NullElement extends Element` with a static instance.
this ! should become unnecessary when you update to tip of tree
this one too
this should be non-nullable
for all builders, BuildContext should not be nullable
in all files we should avoid double-blank lines
The routes parameter should have a non-nullable argument type here (unlike the property)
same with navigationObservers
these two should have non-nullable types in the parameter list as well as being required
do we really use null as a key in this map?
should probably be non-nullable
as discussed elsewhere, we should return _NullWidget() or something here
parameter here should be non-nullable
add a `decoration != null` here to avoid the null deref below
can this just be late?
late would avoid this `!`
this should probably be non-nullable
this too
and this
shouldn't this be non-nullable? i guess this is the source of the `?`s I commented on above...
if we can get rid of the nullability above this one would go too
can we make this non-nullable? (_position would still need to be nullable, and updatePosition would need to be updated to refer to _position instead in some places)
how much trouble do we get in if all these are non-nullable?
these should probably be non-nullable too
i think we should try making these getters non-nullable (and maybe even the fields, though they'd have to be late). it might require removing some asserts.
this should be non-nullable unless there's a really good reason it has to be nullable...
use _pixels here not pixels, in case pixels is overriden; but, in theory, this should simplify back to the old code
in this case it might be possible to use List.generate.
Done
Done
Done
Done
Done.

Doing this change the test _Destination hero scrolls out of view mid-flight_ in `packages/flutter/test/widgets/heroes_test.dart` was failing. I fixed it with  https://github.com/flutter/flutter/pull/64672/commits/0cfceff260ce8ca98e0e4861c4ee28fbd4a43999#diff-b33b1120961b2c010e3388ede5bdf04aR493-R495. Not really sure if the fix is correct, could you take a look please?
There was `DefaultTextStyle.fallback` that was explicitly using null child. Please review https://github.com/flutter/flutter/pull/64672/commits/3750f394117651f6cb2593bbb5eb66112f3da708#diff-879a73856784f585a1665c1ace514899 and let me know if this looks good to you.
Done
Done
Done
Done. I've done some refactoring to avoid testing if depth is null. Changes have been done in https://github.com/flutter/flutter/pull/64672/commits/c0e5d54a217727487197e04802ada46c3cb882ab.
Done
Done
Done
Done
Done
Done
AFAICT `pixels` is still nullable in master. I don't understand your comment.
Done
In `SilverMultiBoxAdaptorElement` there's the following case that can return null:

```
int? get childCount => widget.delegate.estimatedChildCount;
```

What should we do in this case?
Done
Done
`Local.countryCode` (used as key of the map) is nullable
Done
Done
no because child is nullable
Done
Done
but current cannot be late
Get ride of `?` means make data required in the constructor. Some tests create Draggable without data. Should we required data to create Draggable?
Done
Trying to make it non-nullable I face test failures:

```
When the exception was thrown, this was the stack:
#2      new _CastError._create (dart:core-patch/errors_patch.dart:110:27)
#3      ScrollPosition.minScrollExtent (package:flutter/src/widgets/scroll_position.dart:139:49)
#4      ScrollMetrics.copyWith (package:flutter/src/widgets/scroll_metrics.dart:51:48)
#5      ScrollPosition.recommendDeferredLoading (package:flutter/src/widgets/scroll_position.dart:861:7)
#6      Scrollable.recommendDeferredLoadingForContext (package:flutter/src/widgets/scrollable.dart:296:28)
#7      ScrollAwareImageProvider.resolveStreamForKey (package:flutter/src/widgets/scroll_aware_image_provider.dart:98:20)
```
There are some specific handling when pixels is null. (Search `pixels == null`)
I replaces `pixels` with `_pixels` but I cannot go back to old code because `_pixels` is nullable.
Those are all about the initial value. At a minimum let's make `pixels` non-nullable and add a `hasPixels` getter that returns whether `_pixels` is non-null. The `pixels` getter itself is almost always assumed to return non-null.
yeah if we must make _pixels nullable then fair enough.
looks like it's the same thing about delayed setup of the initial value, though this one seems harder to deal with so let's just let it be nullable for now i guess.
cc @goderbauer any idea if any of our (non-test) customers (e.g. google3 or fuchsia) use Draggable without data?
I think that can be `widget.delegate.estimatedChildCount!` because childCount is only used when we're past the point where we're unable to render a child and estimatedChildCount is guaranteed to be non-null at that point.
ViewportOffset.pixels is non-nullable on master as far as I can tell.
yeah looks good
yeah that seems reasonable.
Seems reasonable!
humm... It looks like my cherry-pick of the widget migration made ViewportOffset.pixels nullable... I will take a look :-/
Just changing the return type to non-nullable and using `widget.delegate.estimatedChildCount!` causes several test failures.
Shouldn't dimensions be non-nullable? (it asserts that it is non-null below).
This seems pretty useless if the file is null (line and column mean nothing without a file).  I know there's a check for null in the `toString`, but I think this should be non-nullable.
Can you add a message to the `Error`?

Maybe this should be an `UnimplementedError` instead?
This doesn't really tell the user what to do about it.

Could you give more context? Like "...because no child widget was given" or something?
I think this can be `late`, and then the getter below can return a non-nullable value.
Done
`hasPixels` getter added.
Done
Done
hmm, let me look into this. I'll grab your branch and investigate once I'm done with perf and relanding #63146.
Like `pixels` there are place where null can happen. I introduced an `hasViewportDimension` but like `hasPixels` I'm not sure those names are good API compared to just check for nullability. As a user I would say that I should wrap every `.viewportDimension` into a block garded by `hasViewportDimension`.
See da6feed457
Another issue with non-nullable field is that `ScrollMetrics.copyWith` method doesn't work anymore if one of `has*` is false.
I was using the same pattern for `minScrollExtent` and `maxScrollExtent` and faced this copyWith issue.
Trying to make them non-nullable I faced several issue (in test) and even with an `bool get has*` method there's still the `ScrollMetrics.copyWith` issue that can not be solved.
I found a workaround for `ScrollMetrics.copyWith`. Let me know if the `has*` pattern looks good to you.
See ed04e18fdc
This method is inherited from `InlineSpan`. In `WidgetSpan` `dimensions` is required but in `TextSpan` `dimensions` can be nullable. So it's not possible to make the parameter required only in this branch.
Done
Changed to UnimplementedError
```
  /// A const-constructable default text style that provides fallback values.
  ///
  /// Returned from [of] when the given [BuildContext] doesn't have an enclosing default text style.
  ///
  /// This constructor creates a [DefaultTextStyle] with an invalid [child], which
  /// means the constructed value cannot be incorporated into the tree.
  const DefaultTextStyle.fallback({ Key? key })
```

I don't know what to add. Do you have a suggestion?
It cannot be late because it can be set to null:
```
  @override
  void didUpdateWidget(Shortcuts oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.manager != oldWidget.manager) {
      if (widget.manager != null) {
        _internalManager?.dispose();
        _internalManager = null;
      } else {
        _internalManager ??= ShortcutManager();
      }
    }
    manager!.shortcuts = widget.shortcuts;
  }
```
How about this:
```
A DefaultTextStyle constructed with DefaultTextStyle.fallback cannot be incorporated into the widget tree, it is meant only to provide a fallback value returned by DefaultTextStyle.of() when no enclosing default text style is present in a BuildContext.
```
OK, makes sense.
It's way better than my poor english would have suggested :) thanks!
OK, I see. Can we mark the `manager` getter as non-nullable and return `widget.manager ?? _internalManager!` from it?  The `manager` getter shouldn't ever return null when accessed, since one or the other of `_internalManager` and `widget.manager` should always be non-null.
Can we keep hasPixels to ScrollPosition rather than putting it on VIewportOffset itself?
Done
`pixels` is currently used in `VIewportOffset.debugFillDescription` and we should guard its usage to avoid LazyInitializationError. That why I added `VIewportOffset.hasPixels`.
Alternativelly we could move this `description.add('offset: ${pixels.toStringAsFixed(1)}');` to every child having the concret implementation of `double get pixels`.

```diff
diff --git a/packages/flutter/lib/src/rendering/viewport_offset.dart b/packages/flutter/lib/src/rendering/viewport_offset.dart
index 3e986f8640..435cbfb182 100644
--- a/packages/flutter/lib/src/rendering/viewport_offset.dart
+++ b/packages/flutter/lib/src/rendering/viewport_offset.dart
@@ -94,9 +94,6 @@ abstract class ViewportOffset extends ChangeNotifier {
   /// the value changes due to [correctBy]).
   double get pixels;
 
-  /// Whether [pixels] property is available.
-  bool get hasPixels;
-
   /// Called when the viewport's extents are established.
   ///
   /// The argument is the dimension of the [RenderViewport] in the main axis
@@ -247,11 +244,7 @@ abstract class ViewportOffset extends ChangeNotifier {
   /// If you override this, make sure to start your method with a call to
   /// `super.debugFillDescription(description)`.
   @mustCallSuper
-  void debugFillDescription(List<String> description) {
-    if (hasPixels) {
-      description.add('offset: ${pixels.toStringAsFixed(1)}');
-    }
-  }
+  void debugFillDescription(List<String> description) { }
 }
 
 class _FixedViewportOffset extends ViewportOffset {
@@ -263,9 +256,6 @@ class _FixedViewportOffset extends ViewportOffset {
   @override
   double get pixels => _pixels;
 
-  @override
-  bool get hasPixels => true;
-
   @override
   bool applyViewportDimension(double viewportDimension) => true;
 
@@ -294,4 +284,10 @@ class _FixedViewportOffset extends ViewportOffset {
 
   @override
   bool get allowImplicitScrolling => false;
+
+  @override
+  void debugFillDescription(List<String> description) {
+    super.debugFillDescription(description);
+    description.add('offset: ${pixels.toStringAsFixed(1)}');
+  }
 }
diff --git a/packages/flutter/lib/src/widgets/scroll_position.dart b/packages/flutter/lib/src/widgets/scroll_position.dart
index 2537333b73..25864e3cea 100644
--- a/packages/flutter/lib/src/widgets/scroll_position.dart
+++ b/packages/flutter/lib/src/widgets/scroll_position.dart
@@ -901,6 +901,8 @@ abstract class ScrollPosition extends ViewportOffset with ScrollMetrics {
     if (debugLabel != null)
       description.add(debugLabel!);
     super.debugFillDescription(description);
+    if (hasPixels)
+      description.add('offset: ${pixels.toStringAsFixed(1)}');
     description.add('range: ${_minScrollExtent?.toStringAsFixed(1)}..${_maxScrollExtent?.toStringAsFixed(1)}');
     description.add('viewport: ${_viewportDimension?.toStringAsFixed(1)}');
   }
diff --git a/packages/flutter/test/rendering/slivers_block_test.dart b/packages/flutter/test/rendering/slivers_block_test.dart
index cdb61b8add..05bb823a61 100644
--- a/packages/flutter/test/rendering/slivers_block_test.dart
+++ b/packages/flutter/test/rendering/slivers_block_test.dart
@@ -79,9 +79,6 @@ class ViewportOffsetSpy extends ViewportOffset {
   @override
   double get pixels => _pixels;
 
-  @override
-  bool get hasPixels => true;
-
   bool corrected = false;
 
   @override
```

WDYT?
Ok, use this commit, it should solve our problems:
https://github.com/flutter/flutter/commit/00f5d1ce9897b2d353fb69df5cfccc62ebeb78db
(disclaimer: i'm still running all the tests so there's the possibility something other than the tests that failed before will now fail, but in theory the new code is just a slightly more efficient version of the old code so we should be good...)
I cherry-picked your commit. Thanks!
any idea what the cause of this one is? Is this something we'll run into again when we update the tests, or is the null check happening in widgets code?
~~ok let's leave all those as nullable then~~
that looks good except i would just call it "hasScrollExtents" rather than having both, since they should always be set together
viewportDimension should get set at the same time as the scroll extents iirc, can we use the same getter for all three?
or hasDimensions since viewportDimensions could maybe also be part of it
Interesting trade-off. I think you were probably right the first time, ViewportOffset.hasPixels makes sense since I guess we're saying in the fillDescription that it is legitimate that it can sometimes be null.
never mind, i have a fix for this one in another PR
https://github.com/flutter/flutter/pull/65135 - makes the error message better, and changes the specific test here to not worry about the exact error message in the first place, since that's not what it's about.
```suggestion
    for (FocusNode node in ancestors) {
      if (node is FocusScopeNode)
        return node;
    }
    return null;
```
@a14n well in any case aspect here should be nullable
this can be non-nullable, since the assert before ensures that a directionality is available
```suggestion
    final double iconOpacity = iconTheme.opacity ?? 1.0;
```
looks like this one should be non-nullable, maybe just default to false?
this can be non-nullable, it's only ever called with `this` as the argument value
this should be non-nullable; you can remove the body of the `dispose` method.
(for all of these) "Whether _the_ [foo] property is available"
seems like this should be non-nullable?
ancestor should be non-null
ancestor should be non-null
Done
As there are 2 methods (`applyViewportDimension` and `applyContentDimensions`) it seems legit to have 2 get `has*`. 

IMHO if we'd like to have a single `hasDimensions` we should try to have a single  `applyDimensions` instead of the 2 `apply*` above. But regarding test failures I faced (trying to have a single `haveDimensions`) it seems to have cases where scrollExtents and viewportDimension are not all null or all non-null.

BTW should we use `hasContentDimensions` instead of `hasScrollExtents` to have the same naming as `apply*`?
Done
Done
Done
Done
Done
Done
Done
Done
This change leads to several failure in tests (that I'm not sure how to fix).
k, i'll look into it
Sure, hasContentDimensions and hasViewportDimensions works for me.
I changed `hasScrollExtents` to `hasContentDimensions`
Quick scan in google3 seems to indicate that Draggable is never used without data. Not sure about fuchsia...
Does this have to be late? It's assigned in both branches. Should not be needed.
Right! And moreover it could be made final.

It would be great to have an hint to detect unnecessary `late` like this one.
Actually `final` is not yet accepted by CFE (unlike analyzer)

I just remove `late`.
The request to hint/lint unncessary late is tracked at dart-lang/linter#2205
This `extends Object` change is failing many google3 tests where generic types are omitted. Example code: https://gist.github.com/goderbauer/244c5f19f69bb36d4a136d176ad189c4
This is causing failures in google3 where people extend ViewportOffset. 
Self-nit: remove this flag / TODO
@godofredoc do you know if fuchsia_ctl needs the flags to be ordered this way? It makes it hard to read to have the command mixed in with the flags.
Yes, -d is an option for the core command and the ones after "ssh" applies only to the ssh command.
Here and below: Very minor nit, source files should [end with a linefeed](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline). That said, that's probably more pedantic than anything -- I'm 99% certain that the entire Dart toolchain consistently handles this just fine without it. But not a bad idea anyway.
Added missing null checks
Added missing null checks, just in case ...
unskipped test that failed without addition of "just in case" null checks above.
Added test case for missed null android sdk case for diagnostics
There is already code in the FlutterProject class to parse all of this information, why are you repeating the process yourself?
didn't know . I m using it now in the new commit 
Please don't reformat the files
i will revert
I don't think this is the way to do it. If you want to insert it into the html, it should be as markup. Otherwise a JSON asset file seems like a reasonable way to go
in one comment ditman suggested to inject it in a script tag .so i tried to do that.
if that's not okay , i will revert to the previous way . 
if you inject it into a script tag you will need to use a javascript API to read it. Whereas you can use package:http JSON parse to read the version info in a json asset
Could you avoid duplicating this logic twice?
This isn't really ever testing that the contents are correct. Perhaps a unit test of your helper method to confirm it contains the correct details?
here and elsewhere: newline at EOF
is this getting added to the output dependencies? Also, you need a test that this rule is doing the right thing
yes. it is getting added to the output dependancies.
Rather than in utils, why not make this a method on `FlutterProject` itself?
here at elsewhere, add a newline at EOF
You can remove the `foo.txt` setup/assertion from this test, since it isn't what is being tested
add a newline between this test case and the previous one
can you put this space back?
Create the flutter manifest once, then pass it into the flutter project. You also should use a `MemoryFileSystem.test` instead of the globals.fs, like:


```
final MemoryFileSystem fileSystem = MemoryFileSystem.test();
final FlutterManifest manifest = FlutterManfiest.createFromString('''
... content goes here
''');
final FlutterProject flutterProject = FlutterProject(fileSystem.current, manifest, logger: BufferLogger.test());


```
Thanks for adding that test, this is fine now
please add this space back
spaces after `,`
prefer 2 space indent
please revert this change
space above and give this a doc comment describing what it does
newline at EOF
```suggestion
    
    expect(environment.outputDir.childFile('version.json'),exists);
```
```suggestion
      
      testUsingContext('Version.json info is correct',(){
```
formatting please
`...containing the [appName], [version], and [buildNumber]`
```suggestion

      testUsingContext('Version.json info is correct', (){
```
```suggestion
        final FlutterManifest manifest = FlutterManifest.createFromString('''
    name: test
    version: 1.0.0+3
    ''', logger: BufferLogger.test());
```
```suggestion
```
```suggestion
    expect(environment.outputDir.childFile('version.json'), exists);
```
If the .. will be less.., so switch them.
Fixed.
I remove the gap between the inactive track and active track, also see #64534 
nit: that
It may change the previous behaviour if `parentData` is null. I guest it can not be null?
Duplicated line
if you're painting then you must have parentData, yeah.
Why is this still specified as an annotation? 
because this file is still opted-out (in widgets)
IIRC the reason these were added is that dart2js could not optimize the function otherwise. If that is still the case I would expect  it to show up on the web size benchmarks
This function makes me sad
Ah, that makes sense! Thanks.
we haven't migrated widgets/ yet. This is just making sure we make the right call when we get to it.
yeah...
Based on the history, @dnfield added the original `if (kReleaseMode) return` logic, then @ferhatb added the `assert()` around the body. This removes the if condition and leaves the assert so that the method can be non-nullable. I think it was ferhat's change that improved size, and this keeps that logic. Let's keep an eye on the numbers though, certainly...
Ahh, yeah - I think I was remembering it backwards
The problem with making this an assert is that profile mode will no longer show as much helpful information. But I guess we don't have any tests covering that and no one is complaining about it so oh well.
My general opinion on this is release and profile should be as close to identical as possible except for the minimum required to actually enable collecting metrics.
Why make this a JS expression? It will effectively compile to `if (true)` and `if (false)`. If put the if outside the string interpolation we could just not emit the `else` branches.
nit: I'd probably write this as:

```javascript
if (!response) {
  throw error;
}
return response;
```
 So that the "normal" flow is outside the branch.
Would be good to spend a sentence for each option on explaining the use-case. For example: "online-only is useful if you don't want any local caching but still support adding/installing the app on the home screen as a PWA."
Can't this just be in the SizeAnalyzer class?
ya, I might be missing something but at a glance, it seems like everything you need is already in analyzeAotSnapshot. 
Done!
ultra nit: since we're doing construction injection now and this file is new, should all these be private?
the second `)` should at a new line
replace with: Slider track paints correctly when the shape is rectangular
trailing comma here
NICE. This is all much more obvious.
Can this just be:
```
bool get canListDevices => _androidSdk?.adbPath != null;
```
ditto
Are there any other uses of `which`?
We use this in coverage to look for lcov, and to look for Java if the android studio Java is missing
Completely unused
Ignore exceptions thrown when trying to delete the file.
Will permissions errors on this operation be handled by the ErrorHandlingFileSystem?
Ignoring exceptions here too is probably a good idea.
```dart
if (d.listSync().isNotEmpty) {
  break;
}
try {
  d.deleteSync();
} catch FileSystemException {
  ...
}
```
How about counting down instead of up?
```dart
int retries = 2;
while (retries > 0) {
...
retries -= 1;
}
```
Then maybe you get something a bit easier:
```dart
while (true) {
...
  } on ProcessException {
    retries -= 1;
    if (retries == 0) {
      rethrow;
    }
    ...
}
```
The decrement should go before the `if (retries == 0)` I think.
woops!
Updated the error handling filesystem to wrap Directory.createSync
Up to you, but I'm wondering if it makes sense to pull this out under `base/`
I think at this point it is too tied to the cache API. I think it might make sense to consider combining this with the `Net` class in the future, at which point it will be more coherent and `base/` will make more sense IMO
This is the fix, it turns out the isolate runnable event was coming from the compute isolate, and removing it caused the test to hang. Instead we can use the point where we start registering package:flutter service extensions as an indication that the hot restart is complete
I think intent of this code was to wait for IsolateRunnable corresponding to the main isolate. Are we not seeing main isolate IsolateRunnable event, only see one for the compute isolate?
Yes, this starts listening too late to pick up the main isolate runnable. I think this is OK to switch to the extension event, because it more accurately measures when we could reasonably perform another hot reload ( though If I see a large change in the benchmarks I can investigate)
This is rather unfortunate. I think we do want to ensure we subscribe to the vm service events before we restart isolate. At a minimum let's add a comment/todo explaining why we are listening for ServiceExtensionAdded instead of IsolateRunnable.
Done
`.single` instead of `removeLast()` to capture that there's only been one call?
I don't think thats how verify works, the verification result is created once.
I guess we could clear the state between each test run
I believe single is a property and not a method.
darn my attempts to edit via github UI
As you've already added the SkSL version for gallery, I wonder if it's easy to add the SkSL version for cubic_bezier_perf in this PR so we can have 1 less TODO. It will our tech debt :D
Done. Tested against my Xiaomi MIX2 and seems normal. 
does this fail when you don't include the change to sliver_grid.dart?
@Hixie Yes, it will throw exception in master branch:

```
Running "flutter pub get" in flutter...                             1.8s
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY RENDERING LIBRARY ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following assertion was thrown during performLayout():
'package:flutter/src/rendering/sliver_grid.dart': Failed assertion: line 163 pos 15:
'childMainAxisExtent != null && childMainAxisExtent >= 0': is not true.

Either the assertion indicates an error in the framework itself, or we should provide substantially
more information in this error message to help you determine and fix the underlying cause.
In either case, please report this assertion by filing a bug on GitHub:
  https://github.com/flutter/flutter/issues/new?template=BUG.md

When the exception was thrown, this was the stack:
#2      new SliverGridRegularTileLayout (package:flutter/src/rendering/sliver_grid.dart:163:15)
#3      SliverGridDelegateWithFixedCrossAxisCount.getLayout (package:flutter/src/rendering/sliver_grid.dart:335:12)
#4      RenderSliverGrid.performLayout (package:flutter/src/rendering/sliver_grid.dart:529:51)
#5      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#6      RenderViewportBase.layoutChildSequence (package:flutter/src/rendering/viewport.dart:486:13)
#7      RenderViewport._attemptLayout (package:flutter/src/rendering/viewport.dart:1491:12)
#8      RenderViewport.performLayout (package:flutter/src/rendering/viewport.dart:1400:20)
#9      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#10     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#11     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#12     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#13     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#14     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#15     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#16     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#17     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#18     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#19     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#20     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#21     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#22     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#23     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#24     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#25     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#26     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#27     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#28     RenderConstrainedBox.performLayout (package:flutter/src/rendering/proxy_box.dart:270:13)
#29     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#30     RenderPositionedBox.performLayout (package:flutter/src/rendering/shifted_box.dart:396:13)
#31     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#32     RenderView.performLayout (package:flutter/src/rendering/view.dart:169:13)
#33     RenderObject._layoutWithoutResize (package:flutter/src/rendering/object.dart:1645:7)
#34     PipelineOwner.flushLayout (package:flutter/src/rendering/object.dart:896:18)
#35     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1091:23)
#36     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5)
#37     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15)
#38     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9)
#39     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9)
#42     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#43     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27)
#44     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22)
#47     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#48     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27)
#49     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20)
#50     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29)
<asynchronous suspension>
#51     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#52     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19)
<asynchronous suspension>
#55     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14)
#56     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24)
#57     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54)
#62     withClock (package:clock/src/default.dart:48:10)
#63     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22)
#68     FakeAsync.run (package:fake_async/fake_async.dart:178:7)
#69     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15)
#70     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24)
#71     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19)
<asynchronous suspension>
#72     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#77     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13)
#78     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15)
#83     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5)
#84     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17)
<asynchronous suspension>
#85     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart)
#90     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9)
#91     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15)
#92     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7)
#99     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11)
#100    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11)
#101    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16)
#106    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5)
#107    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7)
#125    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12)
#126    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31)
#130    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11)
#164    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21)
#172    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23)
#173    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46)
#183    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41)
#192    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33)
#193    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14)
(elided 117 frames from class _AssertionError, dart:async, and package:stack_trace)

The following RenderObject was being processed when the exception was fired: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT:
  creator: SliverGrid ‚Üê Viewport ‚Üê IgnorePointer-[GlobalKey#b5d38] ‚Üê Semantics ‚Üê _PointerListener ‚Üê
    Listener ‚Üê _GestureSemantics ‚Üê
    RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ‚Üê _PointerListener ‚Üê Listener
    ‚Üê _ScrollableScope ‚Üê _ScrollSemantics-[GlobalKey#1b0e4] ‚Üê ‚ãØ
  parentData: paintOffset=Offset(0.0, 0.0) (can use size)
  constraints: SliverConstraints(AxisDirection.down, GrowthDirection.forward, ScrollDirection.idle,
    scrollOffset: 0.0, remainingPaintExtent: 4.0, crossAxisExtent: 4.0, crossAxisDirection:
    AxisDirection.right, viewportMainAxisExtent: 4.0, remainingCacheExtent: 254.0, cacheOrigin: 0.0)
  geometry: null
  no children current live
This RenderObject has no descendants.
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY RENDERING LIBRARY ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following NoSuchMethodError was thrown during performLayout():
The method 'debugAssertIsValid' was called on null.
Receiver: null
Tried calling: debugAssertIsValid()

When the exception was thrown, this was the stack:
#0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5)
#1      RenderViewportBase.layoutChildSequence (package:flutter/src/rendering/viewport.dart:502:34)
#2      RenderViewport._attemptLayout (package:flutter/src/rendering/viewport.dart:1491:12)
#3      RenderViewport.performLayout (package:flutter/src/rendering/viewport.dart:1400:20)
#4      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#5      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#6      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#7      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#8      RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#9      RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#10     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#11     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#12     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#13     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#14     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#15     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#16     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#17     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#18     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#19     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#20     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#21     RenderProxyBoxMixin.performLayout (package:flutter/src/rendering/proxy_box.dart:115:13)
#22     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#23     RenderConstrainedBox.performLayout (package:flutter/src/rendering/proxy_box.dart:270:13)
#24     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#25     RenderPositionedBox.performLayout (package:flutter/src/rendering/shifted_box.dart:396:13)
#26     RenderObject.layout (package:flutter/src/rendering/object.dart:1788:7)
#27     RenderView.performLayout (package:flutter/src/rendering/view.dart:169:13)
#28     RenderObject._layoutWithoutResize (package:flutter/src/rendering/object.dart:1645:7)
#29     PipelineOwner.flushLayout (package:flutter/src/rendering/object.dart:896:18)
#30     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1091:23)
#31     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5)
#32     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15)
#33     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9)
#34     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9)
#37     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#38     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27)
#39     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22)
#42     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#43     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27)
#44     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20)
#45     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29)
<asynchronous suspension>
#46     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#47     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19)
<asynchronous suspension>
#50     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14)
#51     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24)
#52     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54)
#57     withClock (package:clock/src/default.dart:48:10)
#58     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22)
#63     FakeAsync.run (package:fake_async/fake_async.dart:178:7)
#64     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15)
#65     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24)
#66     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19)
<asynchronous suspension>
#67     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#72     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13)
#73     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15)
#78     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5)
#79     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17)
<asynchronous suspension>
#80     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart)
#85     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9)
#86     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15)
#87     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7)
#94     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11)
#95     LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11)
#96     RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16)
#101    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5)
#102    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7)
#120    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12)
#121    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31)
#125    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11)
#159    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21)
#167    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23)
#168    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46)
#178    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41)
#187    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33)
#188    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14)
(elided 115 frames from dart:async and package:stack_trace)

The following RenderObject was being processed when the exception was fired: RenderViewport#ac634 NEEDS-LAYOUT NEEDS-PAINT NEEDS-COMPOSITING-BITS-UPDATE:
  needs compositing
  creator: Viewport ‚Üê IgnorePointer-[GlobalKey#b5d38] ‚Üê Semantics ‚Üê _PointerListener ‚Üê Listener ‚Üê
    _GestureSemantics ‚Üê RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ‚Üê
    _PointerListener ‚Üê Listener ‚Üê _ScrollableScope ‚Üê _ScrollSemantics-[GlobalKey#1b0e4] ‚Üê
    RepaintBoundary ‚Üê ‚ãØ
  parentData: <none> (can use size)
  constraints: BoxConstraints(w=4.0, h=4.0)
  size: Size(4.0, 4.0)
  axisDirection: down
  crossAxisDirection: right
  offset: ScrollPositionWithSingleContext#2038a(offset: 0.0, range: null..null, viewport: 4.0,
    ScrollableState, AlwaysScrollableScrollPhysics -> ClampingScrollPhysics ->
    RangeMaintainingScrollPhysics, IdleScrollActivity#1bdef, ScrollDirection.idle)
  anchor: 0.0
This RenderObject had the following child:
    center child: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY RENDERING LIBRARY ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following NoSuchMethodError was thrown during paint():
The getter 'visible' was called on null.
Receiver: null
Tried calling: visible

When the exception was thrown, this was the stack:
#0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5)
#1      RenderViewportBase._paintContents (package:flutter/src/rendering/viewport.dart:620:26)
#2      RenderViewportBase.paint (package:flutter/src/rendering/viewport.dart:614:7)
#3      RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#4      PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11)
#5      PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5)
#6      PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7)
#7      PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7)
#8      RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#9      RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#10     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#11     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#12     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#13     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#14     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#15     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#16     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#17     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#18     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#19     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#20     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#21     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#22     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#23     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#24     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#25     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#26     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#27     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#28     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11)
#29     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5)
#30     PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7)
#31     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7)
#32     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#33     RenderCustomPaint.paint (package:flutter/src/rendering/custom_paint.dart:578:11)
#34     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#35     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#36     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#37     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#38     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11)
#39     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5)
#40     PaintingContext._compositeChild (package:flutter/src/rendering/object.dart:208:7)
#41     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:189:7)
#42     RenderProxyBoxMixin.paint (package:flutter/src/rendering/proxy_box.dart:133:15)
#43     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#44     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#45     RenderShiftedBox.paint (package:flutter/src/rendering/shifted_box.dart:72:15)
#46     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#47     PaintingContext.paintChild (package:flutter/src/rendering/object.dart:191:13)
#48     RenderView.paint (package:flutter/src/rendering/view.dart:215:15)
#49     RenderObject._paintWithContext (package:flutter/src/rendering/object.dart:2323:7)
#50     PaintingContext._repaintCompositedChild (package:flutter/src/rendering/object.dart:142:11)
#51     PaintingContext.repaintCompositedChild (package:flutter/src/rendering/object.dart:102:5)
#52     PipelineOwner.flushPaint (package:flutter/src/rendering/object.dart:989:29)
#53     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1095:27)
#54     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5)
#55     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15)
#56     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9)
#57     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9)
#60     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#61     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27)
#62     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22)
#65     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#66     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27)
#67     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20)
#68     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29)
<asynchronous suspension>
#69     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#70     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19)
<asynchronous suspension>
#73     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14)
#74     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24)
#75     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54)
#80     withClock (package:clock/src/default.dart:48:10)
#81     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22)
#86     FakeAsync.run (package:fake_async/fake_async.dart:178:7)
#87     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15)
#88     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24)
#89     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19)
<asynchronous suspension>
#90     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#95     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13)
#96     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15)
#101    Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5)
#102    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17)
<asynchronous suspension>
#103    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart)
#108    Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9)
#109    Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15)
#110    Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7)
#117    Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11)
#118    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11)
#119    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16)
#124    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5)
#125    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7)
#143    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12)
#144    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31)
#148    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11)
#182    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21)
#190    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23)
#191    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46)
#201    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41)
#210    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33)
#211    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14)
(elided 115 frames from dart:async and package:stack_trace)

The following RenderObject was being processed when the exception was fired: RenderViewport#ac634:
  needs compositing
  creator: Viewport ‚Üê IgnorePointer-[GlobalKey#b5d38] ‚Üê Semantics ‚Üê _PointerListener ‚Üê Listener ‚Üê
    _GestureSemantics ‚Üê RawGestureDetector-[LabeledGlobalKey<RawGestureDetectorState>#35828] ‚Üê
    _PointerListener ‚Üê Listener ‚Üê _ScrollableScope ‚Üê _ScrollSemantics-[GlobalKey#1b0e4] ‚Üê
    RepaintBoundary ‚Üê ‚ãØ
  parentData: <none> (can use size)
  constraints: BoxConstraints(w=4.0, h=4.0)
  layer: OffsetLayer#114a6 DETACHED
  size: Size(4.0, 4.0)
  axisDirection: down
  crossAxisDirection: right
  offset: ScrollPositionWithSingleContext#2038a(offset: 0.0, range: null..null, viewport: 4.0,
    ScrollableState, AlwaysScrollableScrollPhysics -> ClampingScrollPhysics ->
    RangeMaintainingScrollPhysics, IdleScrollActivity#1bdef, ScrollDirection.idle)
  anchor: 0.0
This RenderObject had the following child:
    center child: RenderSliverGrid#5eb0d relayoutBoundary=up1 NEEDS-PAINT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY SCHEDULER LIBRARY ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following NoSuchMethodError was thrown during a scheduler callback:
The getter 'visible' was called on null.
Receiver: null
Tried calling: visible

When the exception was thrown, this was the stack:
#0      Object.noSuchMethod (dart:core-patch/object_patch.dart:51:5)
#1      RenderViewportBase.visitChildrenForSemantics.<anonymous closure> (package:flutter/src/rendering/viewport.dart:216:57)
#2      WhereIterator.moveNext (dart:_internal/iterable.dart:442:13)
#3      Iterable.forEach (dart:core/iterable.dart:283:23)
#4      RenderViewportBase.visitChildrenForSemantics (package:flutter/src/rendering/viewport.dart:217:10)
#5      RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#6      RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#7      RenderIgnorePointer.visitChildrenForSemantics (package:flutter/src/rendering/proxy_box.dart:3121:14)
#8      RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#9      RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#10     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#11     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#12     RenderSemanticsAnnotations.visitChildrenForSemantics (package:flutter/src/rendering/proxy_box.dart:4450:11)
#13     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#14     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#15     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#16     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#17     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#18     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#19     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#20     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#21     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#22     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#23     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#24     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#25     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#26     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#27     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#28     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#29     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#30     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#31     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#32     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#33     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#34     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#35     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#36     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#37     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#38     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#39     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#40     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#41     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#42     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#43     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#44     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#45     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#46     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#47     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#48     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#49     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#50     RenderObject._getSemanticsForParent.<anonymous closure> (package:flutter/src/rendering/object.dart:2678:61)
#51     RenderObjectWithChildMixin.visitChildren (package:flutter/src/rendering/object.dart:3049:14)
#52     RenderObject.visitChildrenForSemantics (package:flutter/src/rendering/object.dart:2761:5)
#53     RenderObject._getSemanticsForParent (package:flutter/src/rendering/object.dart:2673:5)
#54     RenderObject._updateSemantics (package:flutter/src/rendering/object.dart:2637:41)
#55     PipelineOwner.flushSemantics (package:flutter/src/rendering/object.dart:1092:16)
#56     AutomatedTestWidgetsFlutterBinding.drawFrame (package:flutter_test/src/binding.dart:1100:31)
#57     RendererBinding._handlePersistentFrameCallback (package:flutter/src/rendering/binding.dart:298:5)
#58     SchedulerBinding._invokeFrameCallback (package:flutter/src/scheduler/binding.dart:1117:15)
#59     SchedulerBinding.handleDrawFrame (package:flutter/src/scheduler/binding.dart:1055:9)
#60     AutomatedTestWidgetsFlutterBinding.pump.<anonymous closure> (package:flutter_test/src/binding.dart:961:9)
#63     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#64     AutomatedTestWidgetsFlutterBinding.pump (package:flutter_test/src/binding.dart:948:27)
#65     WidgetTester.pumpWidget.<anonymous closure> (package:flutter_test/src/widget_tester.dart:524:22)
#68     TestAsyncUtils.guard (package:flutter_test/src/test_async_utils.dart:72:41)
#69     WidgetTester.pumpWidget (package:flutter_test/src/widget_tester.dart:521:27)
#70     main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:314:20)
#71     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29)
<asynchronous suspension>
#72     testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#73     TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19)
<asynchronous suspension>
#76     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14)
#77     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24)
#78     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54)
#83     withClock (package:clock/src/default.dart:48:10)
#84     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22)
#89     FakeAsync.run (package:fake_async/fake_async.dart:178:7)
#90     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15)
#91     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24)
#92     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19)
<asynchronous suspension>
#93     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#98     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13)
#99     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15)
#104    Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5)
#105    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17)
<asynchronous suspension>
#106    Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart)
#111    Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9)
#112    Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15)
#113    Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7)
#120    Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11)
#121    LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11)
#122    RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16)
#127    RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5)
#128    RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7)
#146    _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12)
#147    new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31)
#151    CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11)
#185    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21)
#193    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23)
#194    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46)
#204    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41)
#213    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33)
#214    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14)
(elided 115 frames from dart:async and package:stack_trace)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following TestFailure object was thrown running a test:
  Expected: null
  Actual: 'Multiple exceptions (4) were detected during the running of the current test, and at
least one was unexpected.'

When the exception was thrown, this was the stack:
#4      main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart:345:7)
<asynchronous suspension>
#5      main.<anonymous closure> (file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart)
#6      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:146:29)
<asynchronous suspension>
#7      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#8      TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:784:19)
<asynchronous suspension>
#11     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:764:14)
#12     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1173:24)
#13     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:178:54)
#18     withClock (package:clock/src/default.dart:48:10)
#19     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:178:22)
#24     FakeAsync.run (package:fake_async/fake_async.dart:178:7)
#25     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1170:15)
#26     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:138:24)
#27     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:175:19)
<asynchronous suspension>
#28     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#33     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:173:13)
#34     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:231:15)
#39     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:228:5)
#40     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:383:17)
<asynchronous suspension>
#41     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart)
#46     Invoker._onRun.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:370:9)
#47     Invoker._guardIfGuarded (package:test_api/src/backend/invoker.dart:415:15)
#48     Invoker._onRun.<anonymous closure> (package:test_api/src/backend/invoker.dart:369:7)
#55     Invoker._onRun (package:test_api/src/backend/invoker.dart:368:11)
#56     LiveTestController.run (package:test_api/src/backend/live_test_controller.dart:153:11)
#57     RemoteListener._runLiveTest.<anonymous closure> (package:test_api/src/remote_listener.dart:256:16)
#62     RemoteListener._runLiveTest (package:test_api/src/remote_listener.dart:255:5)
#63     RemoteListener._serializeTest.<anonymous closure> (package:test_api/src/remote_listener.dart:208:7)
#81     _GuaranteeSink.add (package:stream_channel/src/guarantee_channel.dart:125:12)
#82     new _MultiChannel.<anonymous closure> (package:stream_channel/src/multi_channel.dart:159:31)
#86     CastStreamSubscription._onData (dart:_internal/async_cast.dart:85:11)
#120    new _WebSocketImpl._fromSocket.<anonymous closure> (dart:_http/websocket_impl.dart:1145:21)
#128    _WebSocketProtocolTransformer._messageFrameEnd (dart:_http/websocket_impl.dart:338:23)
#129    _WebSocketProtocolTransformer.add (dart:_http/websocket_impl.dart:232:46)
#139    _Socket._onData (dart:io-patch/socket_patch.dart:2044:41)
#148    new _RawSocket.<anonymous closure> (dart:io-patch/socket_patch.dart:1580:33)
#149    _NativeSocket.issueReadEvent.issue (dart:io-patch/socket_patch.dart:1076:14)
(elided 111 frames from dart:async and package:stack_trace)

This was caught by the test expectation on the following line:
  file:///Users/gaoge/Develop/flutter/packages/flutter/test/widgets/slivers_test.dart line 345
The test description was:
  SliverGrid negative usableCrossAxisExtent
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Test failed. See exception logs above.
The test description was: SliverGrid negative usableCrossAxisExtent

‚úñ SliverGrid negative usableCrossAxisExtent
Exited (1)
```
`kTertiaryButton`? Should probably be primary, no?
Can you add some more information here about when this will fire? e.g. after the down even of the second tap? May also be helpful to put this in relation to onTapDown (presumably, that one will fire for the first tap down - does it also fire for the second down?)
Good catch - fixed.
Done.
Why is this `binding.pump` instead of `tester.bump` as line 97 and 104?
Nit: I guess `binding.samplingOffset` here should be `const Duration(microseconds: -5500)`? I might be clearer to create a constant and use it in line 93, 100, 106, and 114.
Nit: `now` seems to be a little confusing. `currentTestFrameTime` might be a little more clear?
This is a nit. I changed it to `tester.pump`
Done
Using `binding.samplingOffset` is in David's version. I changed it to `kSamplingOffset`, but I don't get why this is better. 
I think it's a little better because
1. if the binding somehow gets the `samplingOffset` wrong, the `kSamplingOffset` version of `expect` would catch that while the `binding.sampleOffset` version of `expect` won't.
2. David's original version uses `GestureBinding.instance.samplingOffset` which would match the `GestureBinding.instance.samplingOffset = kSamplingOffset` in a simple text search. In the new version, `binding` isn't immediately obvious to be the same as `GestureBinding.instance` (but I believe they're the same).
```suggestion
  String get flutterChooseOne => 'Please choose one (To quit, press "q/Q"):';
```
Instead of exiting, use `throwToolExit('')`
I would also add 'Q'
Can you add a test case for q/Q?
leave the message blank. exitCode 0 is the default so it isn't necessary either.
Are you sure? `throwToolExit('')` exitCode will be `null`
we don't need to tell the user why we exited if they asked to exit
```
expect(e.exitCode, 0);
expect(e.message, contains('exit from choose'));
```

with clear test message may help
The old test was a little more strict (`called(1)`)?
Took another pass
```suggestion
      matchesGoldenFile('container.clipBehaviour.with.shadow.png'),
```
The library name does not need to be included. It is handled manually. :)
perhaps add a comment regarding "50 * 1024" number?
Done
```suggestion
  /// By default, the background color is transparent unless selected. Selected rows have
```
```suggestion
  /// The background color for the data rows.
```
I think you could use a macro here to include much more detail about decorations
Is it actually translucent, as in you can see behind the data table? Otherwise, use a different term
```suggestion
  /// The effective background color can be made to depend on the [MaterialState] state, i.e. if the
```
I think this means it's over the inkwell but below the text, is that correct? Could tweak to clarify
same here, I think there might be a useful macro
```suggestion
  /// The background color of the heading row.
```
```suggestion
  /// The effective color can be made to depend on the [MaterialState] state, i.e. if the
```
Is it possible to press a heading row?
nit: stay consistent for all properties, either 'This value defaults to' or ' By default, ...'
```suggestion
  /// The padding between the header text and the sort icon.
```
Could this be showBottomBorder instead?
This doesn't feel super useful, was it an ask?
nit: may be more readable in 3 lines
Will this icon still be visible by default in dark mode?
remind me why we add these?
ensure the order in `data_table.dart` matches the order for DataTable theme properties
macrofy all of these and use the macros in the `data_table.dart` to avoid  disadvantages of documenting twice
nit: same order as parameters
nit: same order as parameters
maybe you should add the missing missing DiagnosticsProperties
To avoid nullable problems internally afaik
Yeah Im curious about the need for being able to customize this one
```suggestion
  /// By default, a divider is not shown at the bottom to allow for a border
```
Do these need to be public? 

Though if you make them private, you'll have to update the above documentation to instead have the actual values instead of referencing these.
`dataTableTheme` should never be null since it gets initialized in the `ThemeData` constructor. You can remove the `?` here and everywhere else.

```suggestion
      ?? themeData.dataTableTheme.horizontalMargin
```
Nit: Use your full GH username for the todo
```suggestion
class DataTableThemeData with Diagnosticable {
```
Looks like this line is repeated 3 times
This line is repeated from above
```suggestion
              letterSpacing: 0.0, // Will overflow if letter spacing is larger than 0.0.
```
Why are all the `first`s necessary? What changed to cause these to be needed?
Why is this needed?
Extra new line not needed
I looked at BoxDecoration and the Ink widget, neither of them has any templates, and they are not more specific about documentation the decoration parameter, so I'll leave this out.
That is correct
I could not find a useful macro or template for TextStyle. I think by going to TextStyle directly they can find useful enough information.
Yes if its sortable. I can add that.
I will remove this one parameter, I thought initially I would need it for internal usages but probably not needed.
Good catch
It is due to the change to how the padding is added to the sort icon. Now that I remove that option, I can revert this change actually.
To keep the test the same I could either update the variables that we `expect` or set the style to be the same as before.

Seems like it's confusing to just add the textStyle so I'll go ahead and update the values instead.
I think that is out of the scope of this pr
Done!
Yes, let me add a screenshot to the description
Looks good! Only issue is I think the macros include the "Defaults by" but the DataTableThemeDate properties should be null by default
True I will change the templates a bit to exclude this. I think for `headingRowColor` and `dataRowColor` I can exclude this part. For headingRowColor it is null and not used by default anyways and for dataRowColor the default should be updated in https://github.com/flutter/flutter/issues/64314 to be the primary color.
It would help to explain that the default values for each property are defined by DataTable itself.
`two [DataTableThemeData] objects` or `two [DataTableThemeData]s`.
two space indent here and below
Using composite values like BoxDecoration can be problematic in components and themes however, in this case, since the default is `no decoration` it should work out nicely. Is it possible that apps will want to change a table's border, depending on its focused (other?) state. If this was a `MaterialStateProperty<BoxDecoration>` it would be a little clumsier to specify simple value, but more flexible:
```dart
decoration: MaterialStateProperty<BoxDecoration>.all(myDecoration)
```
Glad to see this TODO here. When it's done, the API doc for rowColor etc should explain exactly what color scheme colors are being used.
NICE
Why isn't this part of the theme?
Done!
Done!
I think in this case we will not need to have different box decorations depending on the state. The focus or selected state will only be handled by the different rows and the whole DataTable never really has any (`MaterialState`) state.
Good point, I added dividerThickness to the theme now.
Done!
Documentation should be a complete sentence that starts with a capital letter and ends with a period. This line also doesn't really tell me much about what this parameter is or how to use it.

I'm also a bit suspicious about having a `Map<String, FinderConfig>` here - it may be better to have this as type.
Similar nit. What does it mean to register a Flutter Driver Finder? Why would I want to do that? This should probably include some example code.

Also, make sure that it is a complete sentence that ends with a period.
This doesn't add anything - why would I want to create this? Are the parameters required? What happens if I pass null?

It seems like the parameters should have asserts that they're not null.
Is it from that or from the factory passed somewhere?
nit: Indentation

Please use a complete sentence that starts with a capital letter.
Same comment about using a map here.
It seems strange that we're passing in a factory here.

I think what we'd want instead is to have these finders be provided by a default factory, and let new implementations re-implement them if desired (or just use the default one before adding its own).
remove extra newline
I think rather than having this be a typedef for a function that takes a map, it might be better to just have a class that can be implemented or extended, for which we provide a default implementation.

That way it will be a bit clearer about who to pass this to and what precisely it needs to implement.

We could move all the existing implementation into its own class that serves as a default, and still let callers pass in their own implementations that add or remove functionality.

WDYT?
I have added example
Sample code should be real, runnable code.
This doc still needs to start as a proper English sentence with a capitalized first word that ends with a period. E.g. "The `finders` parameter are used to add custom finders beyond the ones found in (whatever we end up naming the class)".

The sample below is a good start, but it doesn't really show me how to use the `finders` parameter.
nit: extra spaces between `with` and `Deserialize`.
```suggestion
        } else {
```
```suggestion
class FlutterDriverExtension with DeserializeFinderFactory {
```
Also, up to you, but you could just drop the `else` entirely here since you're returning in your if.
We should probably write a test that actually implements new logic here and makes sure it works.

Also, please add a new line at EOF.
```suggestion
class TestDeserialize with DeserializeFinderFactory{

}

```
I mixed it with Mock by referring to other codes
Will such an example understand how to use
```suggestion
/// A factory for deserializing [Finder]s.
```
```suggestion
/// The `finders` parameter are used to add custom finders, as in the following example.
```
Looking at the sample code, this appears to be unused. The actual deserialization code is in `DeserializeFinderFactory` right?
I think we should move this logic to our default `DeserializeFinderFactory`, and make it `@mustCallSuper`.
This whole class appears to be unnecessary. After reading the example above, I thikn it can be simplified down to just have the user extend `SerializableFinder` and provide the right `DeserializeFinderFactory` that creates the expected `SerializableFinder`. See my comment below on `_createFinder`.

If we can do that, this whole class goes away and eliminates some complexity.
But createFinder cannot be put together with SerializableFinder, otherwise it will easily lead to indirect reference to "dart:ui"", and reference to "dart:ui" in the test code will cause it to fail to run
The main purpose of using DeserializeFinderFactory here is to decouple from "dart:ui", so I think it should not be added
DeserializeFinderFactory will be used in some multiple searchers, such as Ancestor and Descendant
Ahh ok, that makes sense.
I mean specifically this method here. Where is this used?
Called by CommandWithTarget
https://github.com/flutter/flutter/blob/bae44ef34971cd7549118300d6e82a0cc6c33bea/packages/flutter_driver/lib/src/common/find.dart#L50-L52
https://github.com/flutter/flutter/blob/bae44ef34971cd7549118300d6e82a0cc6c33bea/packages/flutter_driver/lib/src/common/find.dart#L410-L422
Please add an example of what should be done here, and perhaps a comment explaining when you can leave this empty.
Please expand this.

I think I'm seeing it now, but I'm worried that future me will forget this again - and if I were reading the example to figure things out I'd have no idea what goes in here.
```suggestion
///   const Some(this.title);
```
should this be called mainExtend instead of max? (not sure what max is referring too....)
nit: maybe call this throwOnInteractions?
actually, this is kinda strange, isn't the intention of `verifyNoMoreInteractions` to insure that only expected invocations have happened so far? It's not really making any statements about the future, right?

Could we better express this as something like `expect(mockHelper.invocations, hasLength(<whatever>))`?
Same elsewhere.
Ahh right, I got this mixed up with something else. In that case, yeah checking the length would be the right way to do it
I'm not very satisfied with this part because it's almost duplicating `E2EPerfTest` except for what class it inherits. But I don't know if there's better way of implementing diamond inheritance. 
@liyuqian I moved it to a named constructor. PTAL. 
Nit: `timelineFileName = null` seems unnecessary?
Nit: maybe just call it `_kDefaultScoreKeys` as they're used both for e2e and non-e2e tests?
`timelineFileName` is a `final` and has to be initialized for the style guide reason. 
it's not default key for driver-based tests. what about `_kCommonScoreKeys`?
`_kCommonScoreKeys` sounds good.
This name sounds like a list rather than a map (slotToChild sounds like a map)
Why is this `children` here but `slottedChildren` in the cupertino file above?
Nit: I know you're just changing the variable name, but couldn't this be:

```suggestion
    assert(children.containsValue(child));
```

Here and in a couple other places below.
I'll update it back.
In the Cupertino file above, the element contains both an indexed list of children and a map of what it was referring to as "slotted children", so I made the map name match what it was referred to in the comments.  However, it sounds like it's more confusing, so I'll rename all occurrences back to `slotToChild`
Yep - I'll update them all.  I'm not used to having a `containsValue()` function on a map üôÇ 
This probably isn't the right place for it, maybe in events.dart
unsure if stylus should be treated like mouse or touch, probably the latter to be safe.
nit: revert this?
Unsure whether styles is more a mouse or touch device...
yeah, I have no idea really. The only stylus I've ever used was the one that came with the Nintendo DS. In that case, it was more of a precision assist for the existing touch screen. I could imagine for a stylus like that it would not be disambiguated from a touch event.
lol, I see you asked the same question above...
fixed
Should we be using the word "Mouse" in these?  I think something like "kPrecisePointerHitSlop" is more correct, since it wouldn't have to be a mouse (trackpads would have this set too, for instance). We use "precise" as terminology elsewhere (but we also use mouse some places too).
And people often use stylii in place of mice when they use it on a drawing surface. I think of stylii as being much more precise than touch, so I'd go with the more precise slop on them.
nit: it'd be nice if the variable was called `event` instead of just `ev`.
Can we rename `ev` to `event` here (and below) too?
Renamed to follow the precisePointer pattern
Done
done
Good to know!
nit: "The"
Done. Thanks!
I think the better order would be: stable VS, stable BT, pre-release VS, pre-release BT.
The combinatorics are getting a bit much for duplicating code at this point. I think a nested loop with the outer controlling whether or not to check for prerelease and the inner controlling the `requiredWorkload` would make it easier to understand what is the same and what is different in each check.
This block of four is used so often it would be good to just make a helper at this point called something like `setNoViableToolchainInstallation` that does all four.
Does this test actually need anything after the initial `setMockCompatibleVisualStudioInstallation` call? The `setMockPrereleaseVisualStudioInstallation` may have just been copypasta.

In general I would only expect a test to need to mock up to the first successful result.
Not at the moment, all mock after the first successful result are removed and duplicated code are refactored per your suggestions. please take a look at the latest commit.
Since you added a Dartpad example, you can remove the video.
Move the `const` to the `Padding` widget, since it can be const too.
@chunhtai Hi, Probably we can not modify the value of `confirmationNotification.paintOffset` here, just add this offset to the `_leadingController._paintOffsetScrollPixels` above.
Otherwise, The function of `OverscrollIndicatorNotification` will be affected, I add a test case `CustomScrollView overscroll indicator works if there is sliver before center and modify glow position` below.
Can you separate this into a different test?
same here
I thought we are verifying the paint offset is correctly applied, what does the scroll direction do here?
Sorry for the comment is not clear, I will fix it.
Line 375 set the `paintOffset` 50.0, `[OverscrollIndicatorNotification.paintOffset]` can special the indicator offset, also see https://api.flutter.dev/flutter/widgets/OverscrollIndicatorNotification/paintOffset.html
So in this test case, the indicator should paint at 50.0 from its edge.
Done.
Done.
comment is a bit confusing
same here
Fixed.
Fixed.
Looks like these two could be `late final`?
`late final`?
late final?
isn't it also `int/*!*/`?
Or is that inferred by the tool? 
Presumably, `_IntrinsicDimensionsCacheEntry` would also be `/*!*/` ?
inferred
somehow it got that right
this was a shellcheck error, not sure if this ever did what it was supposed to.
`-gt` is correct.
I decided to make this required since we don't handle null in the switch below.
yay definite assignment analysis
This test uses too much mockito
The local comparator is used in a non-ci environment, so neither of these would be correct. ü§î 
WDUT about `ContinuousIntegrationEnvironment.none` ?
SGTM. The switch statements will want it to be accounted for, it'll just be a pass through then. :) Thanks!
This should say how it influences the overflow property.
What is "word base" or "alphabet base"? I think we'd need to explain this a little better.
same here.
Sorry for late response. I tried to fix, please check them out!
Here and below
```suggestion
  /// the glyph causing overflow, and those that follow, will not be rendered.
```
This seems to just be a duplication of the sentence in line 164? Remove one of them?
Thanks for the advice. I will do that.
If this is not nullable, then almost every test in rendering/reattach_test.dart fails
This is surprising... running this test locally to take a closer look.
Instead of doing this, we should just default `explicitChildNodes` to false here: 

https://github.com/flutter/flutter/blob/606abc915fb85e6896c85e19c1cf3fa4f526745a/packages/flutter/lib/src/rendering/proxy_box.dart#L3624-L3628

Just like we do for the `excludeSemantics` flag. Not defaulting it to false seems like an oversight. 
done!
Couldn't you leave `_mouseTracker.schedulePostFrameCheck()`, and just replace the body of that function with the contents of this one?

I.e., doesn't this code belong in the mouse tracker, and not the binding?
I think the idea is that `MouseTracker` does not schedule for itself. Instead it provides a method that should be scheduled, and the binding schedule things, just like how the binding subscribes to the pointer router. In this way, `MouseTracker` only provides 2 methods that is called outside, and is agnostic by whom, when, and how often they are called.
OK, makes sense.
It would be a little safer to factor this into _initWidgetState() 
Also `debugCheckHasDirectionality`? Here and below
```suggestion
///
/// This class provides APIs for showing drawers and bottom sheets.	
///	
/// To display a persistent bottom sheet, obtain the	
/// [ScaffoldState] for the current [BuildContext] via [Scaffold.of] and use the	
/// [ScaffoldState.showBottomSheet] function.	
///
```
```suggestion
/// To display a snack bar, obtain the [ScaffoldMessengerState] for the current
```
```suggestion
  ///       title: 'Flutter Code Sample for ScaffoldMessenger.of.',
```
```suggestion
  ///         appBar: AppBar(title: Text('ScaffoldMessenger.of Example')),
```
```suggestion
/// This class provides APIs for showing drawers and bottom sheets.
///
/// To display a persistent bottom sheet, obtain the
/// [ScaffoldState] for the current [BuildContext] via [Scaffold.of] and use the
/// [ScaffoldState.showBottomSheet] function.
```
```suggestion
```
```suggestion
```
```suggestion
```
Do we still want to say that snackbars are typically shown with ScaffoldState.showSnackBar?
Scaffold feature events?
This isn't necessary.
Saying that it's called within the build method sounds a little like it produces a widget.  Maybe say that it's called in response to a user gesture or an application state change? 
Looks like dev/snippets/config/templates/stateless_widget_scaffold_center.tmpl would simplify this example
I think we need to admit why this case is needed (sometimes snackbars are produced by code that doesn't have ready access to a valid BuildContext) and provide an example.

I think we need a nullOK parameter
We should explain about scaffolds being registered or provide a link to doc that explains it.
Slightly better (IMHO) as:
```dart
if (_accessibleNavigation == true
    && !mediaQuery.accessibleNavigation
    && _snackBarTimer != null
    && !_snackBarTimer.isActive) {
  hideCurrentSnackBar(reason: SnackBarClosedReason.timeout);
}
```
If accessibleNavigation goes false, do we need to shorten existing timeouts (restore them to their normal values)?
Do we want to verify that scaffolds only get unregistered once?
Distributes or shows (displays)?
I could be missing something but ... looks like this could be 

```
  final ScaffoldFeatureController<SnackBar, SnackBarClosedReason> controller = ScaffoldFeatureController<SnackBar, SnackBarClosedReason>._(
       ...
  )
```
This name is a little confusing because it's not the status of the (a) snackbar that's changing. Just _handleStatusChanged would be OK
Assuming that this triggers the animation's status callback, comment as much here.
Why isn't _accessibleNavigation valid here?
to dismiss the snackbar?
I'd prefer it if we reserved `=>` for one-liners that returned a value (not void). Here and elsewhere.
Could specify alignment: Alignment.center on the Container instead
We use `const Text()` elsewhere
maybe factor out a debugHasScaffoldMessenger(), like debugHasScaffold().
As noted earlier: should we be doing some automatic adjustment of snackbar durations when accessibleNavigation is true?
Indentation and maybe use Container.alignment
This looks slick. But what happens if you write
```dart
Theme(
  data: ThemeData(snackBarTheme: mySnackBarTheme),
  child: ... showSnackBar(mySnackBar),
)
```
We may need to explain this limitation.
Oops! Thanks!
Ah thanks, updated
Nice!
Whoops. Leftover. At one point I tried to follow the same conventions as ScaffoldState, but that was a much larger break and migration.
Can you explain more?
I don't think so, this is existing API that I relocated from ScaffoldState to here. The existing tests regarding accessibleNavigation & SnackBars pass. Is there a case we aren't covering?
How do you mean?
The assertion below, `assert(_snackBars.first == controller);` would be referencing `controller` before it is declared in that case.
This is from the original snackbar API.
AFAIK, because it may have changed during the course of the timer counting down. This is another artifact of the original snackbar api.
Should I put this explanation in the Hero documentation?
#64832 verifies SnackBars are matching expected a11y behavior.
That wouldn't really warn anyone about this case (unless they do a lot of recreational reading). On the other hand, this (Hero) issue doesn't come up that often, which is why it's not called out in the Hero docs. Hopefully it will not come up often due to snackbar heroics either.
The reader may not understand what you mean by _registered_ scaffold.
Should we `assert(_scaffolds.remove(scaffold))` here?
OK, I see.
Should we be checking the _MinuteTextField as well?
Good point, yeah we might as well
Seems like this code isn't correct, since TextSpan is not documented as accepting null children
supertype is nullable anyway
is the code that generates this string also removed?
looks like the point of this test was to check that our null checking gave a pretty error message. What's the error message now? Is it still pretty?
No, but it does need an ignore on dead code:
 https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/painting/text_span.dart#L372

It depends:

1. weak-mode, no null assertions - same error message
2. weak-mode, null assertions - null assertion error when constructing the TextSpan. Depending on the context that might be easy to read or ugly
3. strong-mode, static error can't be hit.
This was set twice
copy-paste strikes again
This should probably handle badly formatted output without crashing
```suggestion
    void fail() {
```
```suggestion
    }
```
Semi-colon was required as it's a local variable declaration, but I changed it to a local function instead to avoid confusion.
Shouldn't this be ios_content_validation_test?
+1
No, the enabled devicelab tests are `android_defines_test`, `flavors_test` and `ios_content_validation_test` in the manifest.yaml, the first two were enabled before this change. Sorry for the confusion. This change also removed `flutter_gallery_ios__compile` as it takes longer to run.
Any reason why we don't run each test by itself? can we also consolidate the configs in fewer files, seems like now we need to update three places. 
The devicelab `manifest.yaml` contains ~140 devicelab tests and is still being used in Cocoon backend and agent. Merging it with `try_builers.json` would require much larger changes. 

After this change, to enable / disable a test we only need to change the `manifest.yaml`.
I'm missing context, how will the tests run in their own builders? 
Please see [this example build](https://chromium-swarm.appspot.com/task?id=4e1771414675dc10), the devicelab recipe will checkout the repo, read manifest.yaml then run the tests marked with on_luci=true.
I think we are going in different directions, in one hand we are moving tasks to provide more targeted signals and this PR is putting merging together multiple signals(multiple tests as a single task). Please add a TODO to split to one test per task.
Filed https://github.com/flutter/flutter/issues/64057 to track.
Does this comment need an update?
This comment is still accurate, but it's specific to the SSH port forwarder. Merged it with the comment in _SshPortForwarder.start.
Have Windows hostonly been migrated?  I see https://ci.chromium.org/p/flutter/builders/prod/Windows%20hostonly_devicelab_tests but it's failing.
I don't see hostonly_devicelab_tests for macOS on any builder, am I missing it?
we want this to ONLY run on post-submit?
This was an error, back to ||
This was an error, back to ||
Reverted to use ||
Some of this code could probably be deduplicated between here, TextField, CupertinoTextField, and TextSelectionGestureDetectorBuilder, but I think I'll have to fix https://github.com/flutter/flutter/issues/64190 first.  I'll make sure I clean up any deduplication when I fix that issue.
Same with onSingleLongTapStart below.
I believe there is now no way to make Select All appear for a SelectableText on iOS, so I've removed this test.
I don't know why this test was passing in the first place, but it started failing when I made this change, despite the behavior it describes being broken either way.  I've created the issue https://github.com/flutter/flutter/issues/64059 to deal with fixing it and unskipping it.
That seems consistent with native iOS in my experimentation.
How do we differentiate between precision devices? the mouse and stylus should not make a selection right?
I just double check it seems like selectable text is correct, but there will be different for long press on textfield when it has keyboard focus vs when it does not
Hmm I'm not sure but that would make sense. @gspencergoog Didn't you have a keyboard and mouse setup for an Android device?  Is there different behavior for longpressing with the mouse vs. a finger?
@chunhtai Are you talking about https://github.com/flutter/flutter/issues/64190 specifically or this PR?
I meant we probably can't merge those methods for selectableText and TextField/CupertinoTextField because they have different behavior when long pressed in native iOS
```
SelectableText -> always select the word
Textfield -> If keyboard focused, then move collapsed cursor to the word boundary and shows selectAll
                -> if keyboard not focused, select the word
```

for macOS at least, the mouse long press does not select the word
That continues to work even after this change.  The behavior on all 3 platforms is shown in https://github.com/flutter/flutter/pull/63994#issuecomment-676748652.
Would https://api.dart.dev/stable/2.9.1/dart-core/String/trimRight.html work?
In the event the message contents itself has trailing whitespace, we should still retain that
It shouldn't be necessary to call setState() here, rebuilding the frame should be enough. 
These comments are helpful. Wordsmithing: Tap the checkbox when tristate is disabled.
Yes, you are correct, it's redundant. I will fix it, thanks:)
Done.
Done.
This all looks fine however this particular callback occurs about 200 times in the tests and the StateSetter parameter is always called `setState`. Probably best to bow to convention and do the same here.
haha, actually, it appeared 238 times in total, and indeed most of them called `setState`. I will fix it.
Done. :)
What do you mean by 'save' here?
Ah, it's supposing that users are filling some forms in `Stepper` which needs to be saved.
```suggestion
  /// change the text of the continue or cancel button as per which step are users at.
```
How about updating like this? Would it be better?
That sounds good to me! Thank you!
```suggestion
  /// change the text of the continue or cancel button depending on which step users are at.
```
Applied. Thanks for your review! :)
Can you wrap a Scaffold around the transition?
Maybe better: "On the web it is used as the page title, which shows up in the browser's list of open tabs."
@goderbauer  Done :smile: 
Remove
Should this be moved, too?
Moved to an AndroidSDK method
Removed locating the android sdk, because if it wasn't found before it won't be found again
No - because if we fail to find the android SDK we inject this interface as null, and the intention of this code is to provide a method of looking up adb without the android SDK.


Now, I think we should eventually remove both of those behaviors, but it was too breaking of a change to do at once.
Fixed! my bad
Nit: having negative timestamp looks strange. Can we change `buildStart` from `0` to some positive numbers so `vsyncStarts` can still be nonnegative?
Done. 
This didn't need to be a local
Maybe: "See https://flutter.dev/docs/development/tools/sdk/releases for previous releases of flutter"
Thank you for the feedback! Your version is better. Will use it instead of the initially chosen one. 
```suggestion
          'for previous releases of Flutter.');
```
```suggestion
            'for previous releases of Flutter.\n\n'
```
Will it be more helpful for the developer if we used a descriptive URL parameter name? E.g. "revision", "version", "cache_key"?
good idea, will use `revision`
A reasonable follow up to this PR would be to add an automatic migration using the tooling that @jmagman already wrote, but its not something I have time for right now
Would love to combine more logic, iOS and macOS building should look almost the same.
I'm guessing it doesn't matter if it gets "tripped" twice in a row?
This makes sense for now.
A better solution for both platforms would be to craft one-line error messages (not like the `=======================` errors we have now) and echo prefixed with "error " or "warning ".  This will show up as a real Xcode error instead of just a failure of a script exiting with nonzero, as discussed in chat one time.

![unnamed](https://user-images.githubusercontent.com/682784/90298236-41b9e400-de46-11ea-8324-aa6d0b36934d.png)
![unnamed-1](https://user-images.githubusercontent.com/682784/90298237-42527a80-de46-11ea-8375-8e8afa8bfbbb.png)
except that's supposed to say "This is an error message" and I'm too lazy to recreate this.
No, just as long as it gets modified at least once
Is this something we need to do for our `printError` calls? That is not that most difficult thing to add...
We are way too chatty with out `printError` calls to just prepend `error `.  For example, I believe every dart compilation failure line is a separate `printError`, including the `  _^_ ` whatever ASCII annotation line that points to the column of the printed line, so there would be like 5 Xcode errors for every dart compilation error, when there should just be one.  I may be misremembering though.

I have a branch for this I never finished, for iOS:
logger.dart
```dart
class XcodeScriptPhaseStdoutLogger extends StdoutLogger {
  XcodeScriptPhaseStdoutLogger({
    @required AnsiTerminal terminal,
    @required Stdio stdio,
    @required TimeoutConfiguration timeoutConfiguration,
    StopwatchFactory stopwatchFactory = const StopwatchFactory(),
  }) : super(
    terminal: terminal,
    stdio: stdio,
    outputPreferences: OutputPreferences(
      wrapText: false,
      showColor: false,
    ),
    timeoutConfiguration: timeoutConfiguration,
    stopwatchFactory: stopwatchFactory,
  );

  @override
  void printError(
      String message, {
        StackTrace stackTrace,
        bool emphasis,
        TerminalColor color,
        int indent,
        int hangingIndent,
        bool wrap,
      }) {
    String xcodeMessage = message;
    if (message.contains('Error:')) { // <-- "Error:" was the best indicator I had for a dart issue.
      xcodeMessage = 'error: $message'; 
    } // <-- Probably need more cases here.

    super.printError(
      xcodeMessage,
      stackTrace: stackTrace,
      emphasis: false,
      color: color,
      indent: indent,
      hangingIndent:
      hangingIndent,
      wrap: wrap
    );
  }
}
```
xcode_backend.sh
```sh
  RunCompileCommand "${FLUTTER_ROOT}/bin/flutter"                                \
    ${verbose_flag}                                                       \
    ${flutter_engine_flag}                                                \
    ${local_engine_flag}                                                  \
    assemble                                                              \
    --output="${derived_dir}/"                                            \
    ${performance_measurement_option}                                     \
    --logging-style=xcode-build-phase                                     \
...
```
assemble.dart
```dart
    argParser.addOption(
      'logging-style',
      hide: true,
      allowed: <String>['xcode-build-phase'],
      help: 'Format logging.',
    );
```

On the right track?
Yeah that seems like a good place to start, though I would leave out the message introspection and instead configure it via the calls to printError
Hopefully no one ever adds `set -e` to the top like https://github.com/flutter/flutter/pull/50664.
Isn't the reason that we were doing this here was that if we fix it to not need the tripwire, we need to update the project with the input/output files? It seems like this sets us up to accidentally change the script later while forgetting that we need to fix all the projects in the wild.
I forget, is there something blocking us from merging this into the Dart script we're using for Windows and Linux? It would be nice to go in that direction instead of adding even more logic to the shell script version.
I'm confused here; IIRC you recently turned `trace` on for Windows and Linux to fix missing Dart failure output. Why do we want it for Windows and Linux but not macOS?
No, its do-able with some light refactoring besides the tripwire. If we can resolve that its 5 mins of work
trace only prints stderr by default, and forwards stdout to our verbose logging (hidden by default). with -quiet, xcode writes errors to stdout so we need to surface them.

> Why do we want it for Windows and Linux but not macOS?

Everything is doing something different with error logs üïµÔ∏è‚Äç‚ôÇÔ∏è 
The project input/output files are correct and can work 100% of the time, if you are building through flutter. When building through the xcode UI, changing configurations does not lead to any sort of change in files on disk - so Xcode thinks that our task can be skipped.

I have no idea how to fix this.
> The project input/output files are correct

Right, but we took them out of the Xcode project when adding the tripwire. A fixed build flow that uses the input/output files and doesn't need a tripwire requires adding those back to the project. There's no world where we can fix the need for the tripwire without changing people's existing projects, so I don't see why we would want to move the tripwire creation from the project to the script.


> changing configurations does not lead to any sort of change in files on disk - so Xcode thinks that our task can be skipped.
> 
> I have no idea how to fix this.

I thought we had a potential solution for this now, inspired by @jmagman's iOS work with App.framework: have three different copies of the framework in ephemeral, rather than just one (e.g., ephemeral/debug/..., ephemeral/profile/..., ephemeral/release/...) and control the linking ourselves with linker flags, including a configuration-variable-based linker search directory.
Couldn't we combine scripts, and have the tripwire logic based on OS (if we really need the tripwire here rather than in the project, which per my other comment I'm still not convinced of)
Oh, I see. Could we use the new stdout error regex logic I added for MSBuild here, so the logic is more unified?
different locations for debug/profile/release artifacts would definitely help. I can't say for sure if it would solve the issue completely 
with `-quiet` there shouldn't be any need, since only task stderr should be surfaced
> Couldn't we combine scripts, and have the tripwire logic based on OS

We could for new projects, with some backwards compat for macos_assemble (unless we add the project migration support, but like I said I don't really have time for that this week)
I was just thinking converting `macos_assemble.sh` into a thin `tool_backend.dart` wrapper, not doing an actual migration at this point. Just so we're not adding more bash logic and continuing to maintain bash complexity, when we already have a Dart version that's more testable and more maintainable basically ready to swap in.
But there are other differences in the code flow. For instance, won't your current approach mean that errors are printed in the normal color on macOS, rather than red on every other platform? And any code, future or current, that hooks into the logger mechanism to know what the errors are won't see the macOS error output as errors.

Whereas if you pass `.*` as an error regex (along with using `-quiet`) then macOS errors will use the same path through the logger as errors on other platforms.
Anyway, that part was a tangent. Going back to my main concern: what is the goal for moving this logic out of the project? This PR seems unrelated to the tripwire, and AFAIK nothing has changed since we made a deliberate decision to put the tripwire logic on this side of the divide (per my comment above).
Ahh, cool I didn't know it did that :) 
I think (now I need to double check, because I could have mixed it up) that ending with `&& touch` was causing failures of the actual script to be suppressed. I bet there is some sort of bash-fu to fix it..
Oh, I see. I missed that there wasn't anything else in macos_assemble.sh before, and thought the error exit you added there was to fix that problem.

Yeah, the current Xcode script is definitely wrong, because it's just two statements. Changing the `\n` to ` && ` should be the easy fix there.
I think it's worth commenting why this is done (i.e., the interaction with `-quiet`) since it's non-obvious without context.
Done
```suggestion
/// Creates a grid of mouse regions, then continuously hovers over them.
```
Is there a constant line ending somewhere we can use?  I don't see one.
Does it pass if we expect `depsIndex != -1`?  I know that's not how it works now, but it seems more strictly correct.
I don't know if it matters that we aren't maintaining the line endings, probably not.
Good call. Changed to expect().
Yeah, I'm also worried that adding logic to retain Windows line endings would tickle the Cirrus problem.
you don't ever need `equals`
Nit: if the class is called `DevToolsServerAddress` it seems weird that it contains `bool success`.

How about returning null on failure instead of an explicit field?
That's true, I can make this a little simpler overall without the success/failure. I might add a failure message later on but I don't think it's needed now.
Are we sure other engines also does not need such a feature? @justinmc @LongCatIsLooong 

If they need it, even if we don't use it now, we can change the wording.
In other engines, we handle everything on the framework side for read-only fields (e.g. keyboard arrows/shortcuts, clipboard, context menu, etc). I tried it, it works fine. And since no one complained about it, I'm assuming read-only fields (and SelectableText) works fine on mobile platforms.

In any case, thanks for adding mobile people so we can confirm üòÑ 
typo: "virtualk"
nit: no need for "etc" when providing an example
Should the last three use-cases use the `SelectableText` infrastructure in the case of read-only input?
nit: "use" implies that a connection is established but may or may not be used. However, it seems we never establish a connection when this is `false`. Suggestions: `shouldConnect`, `shouldCreateInputConnection`.
We treat skips as technical debt. Can the test body be changed so that we simply expect different behavior on different platforms? If not, let's leave a comment explaining why this test is web-only.

/cc @Piinks for more guidance.
True! If the test can be expected to work across platforms that would be ideal.
If it's skipped because of an outstanding issue, there should be a comment with the issue link beside it.
If it is being skipped because of platform specific behavior, you could execute the test conditionally based on the platform, or leave a comment saying why the test is skipped without plans to resolve it.
I agree with @mdebbar.  I'll try to keep an eye out for use cases that might need this as we go forward though.
It's the other way around. The `SelectableText` widget is the one using read-only field infrastructure :)
As we discussed yesterday offline, we can add an assert to line 462 with a message "readonly fields cannot autofill".
Done.
This column only has one child, why do we need the column here? Presumably, it can be removed?
I think this is more clear, but let me know if it doesn't seem accurate.

```suggestion
    // There's no need to format when starting to compose or when continuing
    // an existing composition.
```
IIRC `TextRange.isValid` does the same:
```suggestion
    final bool isValueComposing = value?.composing?.isValid ?? false;
```
ditto the using `TextRange.isValid` comment.
If the problem is with that specific formatter, can we apply the fix to the formatter instead?
Done it, the fix is now land on the specific formatter.
Ah so we previously missed the case where the composing finishes without actual text change. Nice catch!
nit: I think it would be easier to understand if the second expression reads something like `!isComposing && isPreviouslyComposing`
Using `isComposingRangeValid` is a bit too strong. It's mainly used for out of range check. To check whether `newValue` contains composing text, I think `newValue.composing.isValid` is preferred. Yeah I'm sorry the name is a bit confusing.
Also applies to the changes below.
I think the behavior change is worth documenting. We should probably add a "#Multistage text input" section or "#Composing Text" section somewhere in this class for visibility, and document the fact that the [maxLength] constraint is going to be temporarily lifted when the user starts composing, and when the composing finishes, the text may get truncated so it does not exceed [maxLength].
Also, ideally we shouldn't allow the user to start composing when they've already reached the length limit. 
> Also, ideally we shouldn't allow the user to start composing when they've already reached the length limit.

Strongly agreed with this one! I'll add it.
> `!isComposing && isPreviouslyComposing`

Conditions are really a science.
I've removed this comment, it seems useless.
```suggestion
    // Return the new value when the old value has not reached the max
    // limit or the old value is composing too.
```
I didn't realize NNBD had been turned on here already üëç 
This could be automated if we had a way to filter issues filed from this template. We could create a label like "infra: ticket" or add [Infra Ticket] to the issue title.
nit: The triage process should be its own paragraph
This template covers every new infra issue, not only the ticket queue. And adding "Infra Ticket Queue" project doesn't take more effort than adding a label or customized title.
Which process do you refer? This paragraph is for customers who want to file a ticket to the infra ticket queue.
If this is public on our site, I bet a lot of people won't know what we mean by "infrastructure" without more context.  Maybe instead of "to the infrastructure", "about Flutter's CI infrastructure"?
Ahh I see. I was under the impression this template was being used only for infra tickets. I would clarify what the difference is between infra ticket issues and normal infra issues.
Sounds good, reworded.
nit: can the line below this one be simplified just like you did in the constructor?
done
Remove? Uncomment?
How do we still have these just `test`s?
testbed experiments that didn't pan out.
Fixed!
Might want to update this comment to mention `isReplacing` instead.
Why the extra pump?
Remove debug print?
```suggestion
  testWidgets('widgets move scopes during restore', (WidgetTester tester) async {
```
Why did the one above move to after the pump, and this one didn't?
Moved both to after.
Removed. It is not necessary. Must be left over from debugging something.
nit: It's unlikely, but the "is true for one frame after" could be misconstrued as "is true for one of the frames after" (i.e. not just the immediately following frame, but one of any of the following frames).

Maybe say "is true for the frame after" instead? Here and above.
trivial nit: please be consistent about whether a space appears after `switch` (space preferred)
per our style guide, please call the argument "value"
it's trivial, but ideally this line would be after the early return
trivial nit: no need for these blank lines
Small change but;
```diff
+ return fit == BoxFit.scaleDown;
-   switch (fit) {
-      case BoxFit.scaleDown:
-        return true;
-      default:
-        return false;
-    }
-  }
```
switch cases are generally preferred over comparison in the repo, but so is the default case tbh

https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-using-if-chains-or--or--with-enum-values
nit: separate this out in two bullets, one for each of the `debugProfile...` flags
Can you please also update the documentation of these two flags to include a link back to this new flag?
Done
With my pleasure:)
Is there a use for retaining constraints on neither axis?  
Could you use `default` to handle `constrainedAxis == null` and then just do everything in the switch statement?
Nit: Not sure if you wrote this or copied it but just an apostrophe:

```suggestion
  /// passes to its child. If the child overflows the parent's constraints, a
```

If this is going to cause a CLA problem then make the change manually haha.
Were these being clipped before?
for science!
Don't think there's one in the framework or material or cupertino. But this PR does not change `RenderUnconstrainedBox`'s API or functionality.
per the style guide default should be avoided: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-using-if-chains-or--or--with-enum-values
Yes, 55 is the minimum height iirc
Ah got it, that makes sense.
Alone on an Infinite Canvas with No Constraints will be the name of my breakout studio album.
It wasn't clear that "normalized" in this context means "satisfies BoxConstraints.isNormalized". Maybe leave the qualifier out here and document that we're going to assert isNormalized elsewhere?
"some of its intrinsic sizing ..."? This widget doesn't necessarily know what the child's intrinsic sizing rules are?

Maybe just say: here's an example. 

Ideally, you'd provide a rule of thumb about when to use this widget.
Maybe this is a little clearer? 
This snippet guarantees that the child [Card]'s height will be at least as tall as its intrinsic height. Unlike an [UnconstrainedBox], the child will be taller if the parent's max height is constrained. If the parent's max height is constrained to be less than the Card's intrinsic height then a warning will be given in debug mode.
Probably don't need this reference (plus "the type constraints of constraints" is a typo), since the API  includes BoxConstraints.
A widget that imposes additional constraints on its child.

Best to lift these one-liners from the existing API doc; don't want to explain "boxes" vs widget here.
Should itemize the asserts we apply to parameters, and parameter default values, here. 

I'm assuming (didn't read ahead) that child can be null.
Shouldn't this explain that it's for cases where the parent isn't the same size as the child?
Why don't we use Directionality.of(context) if the textDirection parameter is null?
If would be a little more helpful to explain that the we're transforming the parent's constraints and then using them to constrain the child's size.
will be or must be?

AFAICT we don't normalize incoming constraints. Is this really necessary? 
NICE
Makes sense. Removing the `normalize()` call from `performLayout`.
It does. Copied the docs from unconstrainedbox and didn't check.
Are you sure if it's only when they appear in the same route, or should it be global unique?
Not need global unique, but should be equal between rebuilding. 
If you like you can give them the same key, it works well. Because the identifier is a key chain
Actually, "in the same route" is not precise enough, isn't it?
```suggestion
/// within the widget's closest ancestor [PageStorage] (such as within the same route), if you want to save all of their positions,
```
Also "if you want to save all of their positions" should be "if you want to save all of their positions independently" followed by "unique [PageStorageKey]s". Otherwise, their positions ARE stored, but overridden by each other.
NICE suggesting.
Done.
Not sure what I should be writing here, and what paths are required. the APK code size analysis seems to hardcode a path to arm64-v8a - I assume that should actually be the path to whatever aot output we find?
What does the command to generate the code size analysis look like now? does it still use a --analyze-size flag?
I think we could still leave this as APK right? Or is this code hit for iOS as well?
what about apk-analysis.json files? Additionally, if we are storing the apk-analysis.json files, why do we need to also store the v8 snapshots? An apk-analysis file will contain the v8 snapshot information
can you add a TODO here to add the precompiler trace option https://github.com/flutter/flutter/issues/63676, here and elsewhere
this is used for every platform now, but most of the time it is just looking at a directory
See question above on the format.
Yes
I'm not quite sure of the format of the apk-analysis file, seems like:

1. It needs to contain the snapshot, the path to libflutter.so, and some snapshot type key - right?

Should probably be called something else for the other platforms: apk-analysis.arm64.json, ios-analysis.json, et cetera
The apk-analysis.json file currently contains the unzipped APK data, processed into a json format that DevTools uses to parse AOT snapshot trees. At the libapp.so node (defaulting to only one ABI currently), we swap in processed v8 snapshot data. The ending result is that the apk-analysis.json file contains a tree structure of the apk where the AOT snapshot has been embedded into the default libapp.so node.

The "type" key, is do differentiate apk-analysis files from v8 snapshot files when inputting them into DevTools. I think if would be fine if the value of "type" was the target platform ("android", "ios", "macos", "linux", "windows")
Keep track of the path to the aot file path instead of hard-coding a specific arch
I just added it everywhere, easy enough
oh cool, I like this solution. But can we also edit the help for the --analyze-size flag then to say you need to also specify this? Otherwise, all users will always run `flutter build apk --analyze-size` one time and always get a warning to re-run it a second time.
oh I thought you called it codeSizeDirectory just for the AOT. If you're gonna have this flag for everything, perhaps outputSizeDirectory? Since there's more than just code that you're breaking down.
I'm somewhat surprised this logic isn't extracted from the function below since it more or less does the same thing. Shouldn't the next one essentially just call unzip then call this?
what's this second file?
Maybe not the case but I somewhat expected this to be a configurable variable somewhere
If so, we should make this clear somewhere in the doc
What happens if users do `flutter build ios --debug --analyse-size` here and on other platforms?
this is probably fine to start
ditto here
ditto here
(probably all handled in the same place, but) ditto here
We check that here: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/runner/flutter_command.dart#L691
precompiler trace file, its used for something :) @kenzieschmoll 
yeah good point, I think I could give this another go.
Yeah, will update the analyze-size flag
Added to the flag documentation
@kenzieschmoll is it go/dart-devtools-aot-code-size-attribution?
Can you help us fix the (new) line 107 for windows as well?
Does this mean only Android is putting out a zipped file. All the other platforms are just directories? That's neat. 
not sure what you mean?
You already did in ab1c196
Yeah, while iOS and macOS would eventually end up in a zip archive the tool itself doesn't build this - its done through xcode. The .app is pretty close, modulo some compression, but I think it is really more like an android appbundle in that Apple applies more thinning/compression before downloading.

For windows and linux there is no real "distribution" format yet, so the directory is the next best thing.
You didn't reply to this one :)
what about `android`?
what are your thoughts on giving this a more descriptive name? e.g. `android-code-size-analysis.json`, `windows-code-size-analysis.json`? It may be more intuitive for users to understand what is being "analyzed"
Here and in https://github.com/flutter/flutter/pull/63610#discussion_r471855924, I'd suggest s/code/output. Since it's not just code that we're analyzing. There's assets etc as well.
`android-output-size-analysis` or `android-size-analysis` sgtm. I think the important part is "size" to distinguish from other analyzable metrics (memory, perf, etc.)
actually, from an offline discussion `aab`and `apk`. Can you update the comment to reflect the possible options?
do we need to add more tests for windows, macos, and linux?
We don't yet have CI for the desktop targets :( 
I think 10 is probably fine (it's more or less a screenful) since lower sized packages are a diminishing return as we show them. There's always DevTools :)
commented code
Can you add some code comments for what this does?
> I think 10 is probably fine (it's more or less a screenful) since lower sized packages are a diminishing return as we show them. There's always DevTools :)

showing 10 is pointless, it will be almost identical for every single flutter using package. At this point we have removed 95 % of the useful console output, we might as well skip it all together.
Done
fixed
discussed on main thread
Nit: I think `final String driverFile;` looks safer than `String driverFile`. Can you do the following?
```
final String testDriver = driverFile ?? (semanticsEnabled...)
```
`with hybrid of host-driven and self-driven` seems to be hard to understand. How about `where the animations are self-driven on device without host interventions, but the timeline events are still sent to host to be processed.`.
Is it Ok to make this `controller` a local variable inside `_handleMessages` which gets constructed during each function call? The constructor itself looks very simple so I don't expect call it multiple times to have a negative impact.
It seems to me that we should do the following instead?
```
if (hybrid) {
  await driver.requestData('profileDemos');
} else {
  await runDemos(kProfiledDemos, driver);
}
```
ditto.
Done.
Done.
Done.
Done
I made a class with `call` method to implement this, with single call of `Controller` construction. PTAL. 
This is wrong and needs to be reverted
this seems suspicious too
Reverted
Also reverted.
Can you add back the comment describing the colors? Thanks.
@goderbauer 
Thank you for your information. 
Note: I'm not 100% sure this is the right approach.  Is it possible for the user to provide their own implementation of `AssetBundle.load`?  If not, maybe it would be better to change the type of `data` to a `ByteData` (removing the `?` on line 666) and just remove this check.

Actually, that might be a reasonable approach anyhow, even if it is user-overridable, since the user will still get an exception when `data` gets dereferenced on line 682; the only difference will be that the exception will be marginally less comprehensible, and the key won't be evicted from the image cache.  But maybe that's ok.

Anyhow, I'm open to suggestions.
yes `?` could be removed. But for now I would keep the `if (data==null)` for now.
I think we can probably just drop this. If the method is not supposed to return null, we can assume it's handled by throwing an exception.

I'm not quite clear though on when weak checking would be used. Could you explain a bit more about how that would happen?
@dnfield 
Weak checking is when the user's app contains some files that are opted in to null safety (e.g. flutter) and others that aren't (e.g. their app and packages).  It does all the static checks for null safety, but the type system is fundamentally unsound at the boundary between opted in and opted out code.  For example, if you invoke an abstract method in an opted-in class that has a return type of `int`, that's supposed to guarantee that you'll never receive `null` as a result.  But if the concrete implementation of that abstract method is in opted-out code, it could return `null` without causing a compile time errors.  That's the sense in which it's unsound: your opted-in code can have a variable of type non-nullable `int` that contains a `null` value.  Effectively, non-nullable types can't be completely trusted if there is some opted-out code somewhere in the program.  Once the entire program has been migrated to null safety, the unsoundness goes away and `int`s are really `int`s.

Because of this, we have code in Flutter that looks to be dead code, but we want to keep it around until most users have upgraded their apps to null safety, so that we can continue reporting useful exceptions to them if they pass `null` to us where they shouldn't.  The type system thinks that code is dead but the reality is it's not, so we have to add the `// ignore:` comment.  The reason I'm having to make this CL now is because fixing a bug in the analyzer that was preventing some of the "supposedly dead" code from being recognized.

Does that help?  If not, I'm happy to discuss over VC.
Ahhh ok that makes sense.  Yeah we should leave this then.
nit: trailing comma
nit: trailing comma
In the previous change, the Expand child was on the subsequent line. It's a little easier to read that way.
It seems a little like overkill to factor out _HourTextField and _MinuteTextField, but OK.
Done
Done
Done
yeah I would have preferred not to, but it made it easier to properly test this.
Instead of commenting this out, the test should be skipped with the `skip` argument: https://master-api.flutter.dev/flutter/flutter_test/testWidgets.html

There also should be a comment with a TODO indicating when to re-enable this test.
Same here.
shall this be added back to framwork_config.star in `infra` repo?
```suggestion
$text = "# Ensure File`n`$ServiceURL https://chrome-infra-packages.appspot.com`n`n# Skia Gold Client goldctl`nskia/tools/goldctl/`${platform} git_revision:b57f561ad4ad624bd399b8b7b500aa1955276d41"
```
Drive by suggestion: add docs that the revision refers to the chrome infra/infra repo, e.g. https://chromium.googlesource.com/infra/infra/+/b57f561ad4ad624bd399b8b7b500aa1955276d41
Previous node has ... 'previous' button
In theory, you could do all of this checking in just one slightly more complicated version of this test.
Well, sure, but doesn't that violate the principle of "one behavior => one test"?
Thanks, fixed.
OK, I modified the tests to test all of the behaviors in separate tests (so they fail separately), but using a new `TestVariant` subclass so that I don't duplicate code when doing so. Let me know what you think.
NICE
I feel like this is an analyzer error if it's not indented, but if I'm wrong then no worries.
No, it won't fail the analyzer, but it does need to be indented for readabililty. Done.
The change from an if to an assert here and below was just something I noticed while I was working on this. It's not related to the fix.
You mean the scale can still be 0 when there're more than 1 pointers? That sounds like a bug?
nit: this seems to be equivalent to 
```suggestion
      _gestureType = _getGestureType(details);
```
nit: if `details.scale` is not 1.0 this gesture would have been reinterpreted to scale or rotate I think?
nit: can this be moved to around line 819 (inside the `switch` clause)?
Off-topic: I haven't tried it, but the heuristic here feels like a bit of a hit or miss? These values can have subtle changes even if the user tries to keep their fingers still. And once it's recognized as scale or rotate it can't be reinterpreted to something else.
Yes, for the first 1 or 2 calls to onScaleUpdate.  I interpreted it as meaning that the two pointers are exactly the same distance apart as when the gesture started for a tiny period of time.  In that case, maybe it's not a bug, even though it is kind of inconvenient.

Also when I wrote zero I meant zero change in scale.  The scale is actually `1.0`.  I've updated the comment to be clear about that.
Much simpler, thanks.
I thought the same thing at first, but I remembered that this is for the case where scale is disabled.  I'll add a comment about that actually.
Good catch, I should have done that originally.
Yeah there is probably a better way to do this.  Currently rotate is hardcoded to disabled, so it won't affect anyone, but it did work alright when I was using it.  The fact that it can't be reinterpreted is on purpose (at least at perceptible time scales) to avoid small amounts of scale rotation when actually just trying to do the opposite gesture.  Google Maps does the same thing.
It doesn't look like `ErrorHandlingFile` overrides `openSync()`.
This test is good. A test that you get a tool exit for the operations that `_validateReadPermissions` is also needed.
Ahh, yeah I did not run my integration test with this change after switching to the error handling file system. I could modify this so that it skips the random access file.
```suggestion
  /// Attempt to find the length from the file to ensure that read permissions are correct.
```
done
Include this above with the other constants starting on line 83.
done
Not sure the implementation of `hash2()`, but this seems worse?
The hashcode itself is kind of pointless anyway - since it is hashing the lengths of the checksum/properties.
that's true
Wonder what else is using it.
The possibilities are limitless 
I'm not familiar with this code, should we printError here, or is this expected to run into `YamlExceptions`s?
At this point we're still discovering plugins - I think it should definitely be non-fatal, but I'm not really sure how actionable an error parsing the yaml would be. I will add it to the trace so it gets surfaced somehow
Yeah, trace makes more sense actually
Why do we still need `?` after `key.keyLabel` here?
Ok I see you've explained it in the PR description. But how come it doesn't trigger lint error?
You're right, I don't need the `?`.  Not sure why there's no linter error.
We shouldn't track this in two places.  Can you update the `create.dart` usage (which populates the `.iml` template) to `kAndroidSdkMinVersion` and delete this?

Also, I wonder why the ide templates aren't using that, they hardcode the SDK version instead of using `{{androidSdkVersion}}`:
https://github.com/flutter/flutter/search?q=%22Android+API+25+Platform%22&unscoped_q=%22Android+API+25+Platform%22

Can you update those manually to 29?  I created https://github.com/flutter/flutter/issues/63522 to change these to use the template context.
@fkorotkov we're ready when you are :)
sure. Done. 

re: the ide template stuff, ya it's a bit unclean. I think it was a template to unpack IntelliJ projects for the Flutter SDK itself rather than a Flutter project so it doesn't have the same templates. Still worth cleaning up. 
what do you mean? üòÖ seems the image is working for you ü§î
ah ya LG. You were just mentioning on chat previously whether we needed 30. Awesome, thanks!
oh, right. I was asking in the context of using 30 in the `catalina-xcode-12.0-flutter`. I'll upgrade it once this PR merged or it doesn't matter and I can bump it any time?
You just meant creating a new catalina-xcode-12.0-flutter rather than moving all our current tests to catalina-xcode-12.0-flutter right? if so then ya, any time is good.
So the question here is do you want Android 30 as part of this PR #63252? cc @jmagman 
If I understand your question, it's 2 separate things. This is Android 30 for Linux and Windows, that one is Xcode 12 for macOS. We can do them separately. 
style nit: avoid "note that", see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-empty-prose
Also, it is unclear to me what you actually mean by this comment. Like any widget you'll have to rebuild the widget if you want to change any properties. 
Sorry for late reply. I tried to modify docs as you said. Hope this one would be better
```suggestion
  /// It is usually more efficient to create children on demand using
  /// [ListView.builder] because it will create the widget children lazily as necessary.
```
This is surprising, shape is never null, so this should always return non-null.
null can be returned with BoxShape.rectangle and a null borderRadius.
Nit: a new line.
The formatter removes the line at the end.
Covers basis of specifying true or false options, or using default (null) option
Let's check the right padding as well since it is part of the change.
same for sliver one
Let's keep this so I can figure it out next time, too.
This is the default and could be omitted.
Update https://github.com/flutter/flutter/blob/master/dev/snippets/config/templates/README.md to mention this new template?
I believe OutlineButton is outdated, and should be replaced with a OutlinedButton (note the extra "d").

/cc @HansMuller 
For completeness, the RestorableInt needs to be disposed in `dispose`. See also https://github.com/flutter/flutter/pull/63497.
Yes, please use OutlinedButton
...
i've filed https://github.com/flutter/flutter/issues/63510
removed
Nit: remove this new line to pass the license check.
Done. 
a fly by comment, shouldn't we assert in this case to indicate whoever simulating the keys event are doing it wrong?
Do you mean this should crash in debug mode but pass in release mode? I kind of get the intention, but still why would anyone release a piece of code that crashes in debug mode?
The reason is that unless they press the key that causes the problem during their testing, they won't know that it crashes in debug mode.

And I don't think an invalid key sequence should crash the app in release mode: it can be ignored if it gets that far.
Sounds good :) 
Maybe you can add this to the comment. Your explanation is pretty helpful.
OK, sounds good, added a comment.
Maybe comment where this is coming from or force the paragraph to actually use this size.
Why not just renderWrap.add(RenderParagraph(...))?
nit: lineHeight?
same.
Is making a list and `join`ing too clunky?
Is there a test that's just `--null_assertions` without a `--foo`?
Very difficult for my sleepy brain ü§£ 
I just wanted you to know that I understand the fence post problem
I added a unit test that tests various flag combinations in computeDartVmFlags
fixed
Maybe `'Perform additional null checks...`
This one is removed due to duplicate of the assert in `dragFrom`. 
I think assert the value that's going to be used is more meaningful than assert the global constant. 
The line breaking here looks strange.
Nit: consider reusing the documentations from `FlutterDriver` such as
```
[duration] specifies the length of the action. 

The move events are generated at a given [frequency] in Hz (or events per second). It defaults to 60Hz.

If [duration] is null, input events are assumed to happen at once, and [frequency] is ignored.

See also [LiveTestWidgetsFlutterBindingFramePolicy.benchmarkLive] for more accurate time control.
```
The `touchSlop` logic seems to be much more sophisticated than the `scroll` logic in `flutter_driver`, and it could generate more input events than `duration * frequency`. Shall we just create a separate `drag` function that doesn't have `touchSlop`, but use `duration` and `frequency` to decide how many events to be generated?
`touchSlop` comes in as a bug fix in #26438. I'm feeling it sophisticated too but I don't have good enough reason to change it. I'm expecting in the duration-frequency version, because `offset/(duration * frequency)` is very small (if the frequency and duration is reasonable), it will always go to single event for each individual input. However if a user is abusing these numbers (like duration * frequency gives 1), I don't want to trigger that bug, so I'm using this as a fall back. 
Done
As for driver, I feel it's just we are being lucky not having gone into that bug. 
Double checked  #26438, without this `touchSlop` the widgets that are having issue is the cupertino style switcher. I guess scrolling is not when there's problem. In `flutter_driver`, there isn't a `drag` but always scrolling. My understanding is `flutter_driver` has not reached the stage of being able to do all operations and no one has used `flutter_driver` to test dragging a cupertino switch. However, changing the timed version to `scroll` doesn't sounds good to me because the operation is not always scrolling either (like the one in `macrobenchmarks/picture_cache` which is using `scroll` in `flutter_driver` and causing confusion). 
I'm a little inclined to keep it simple until we've seen actual abuses (like `duration * frequency` gives 1) that require us to add such complex logic. Otherwise, we risk of making many of our tests potentially hard to reason about without actually helping anything. Specifically, since we're going to use this in places where `FlutterDriver.scroll` was used, I felt just matching `FlutterDriver.scroll` input events would be good enough to not trigger any new bugs.

Additionally, the old `touchSlop` logic seems to be specifically designed for `duration == null` case and breaks a single move event into 2 move events. Using such logic to break n events into 2n events looks unnecessary and unintended (suppose the offset is really large so each event's offset is large enough to be separated).
So I moved the timed part to `timedDrag` and `timedDragFrom`. PTAL
I also added a unit test for `timedDrag`. One more thing that's worth mentioning (already in a comment), the PointerUpEvent and its corresponding PointerData doesn't provide `button` field. 
We can restore all the changes here as `_separateDragOffset` is not going to be used by anyone else
There's no widget given so "the middle of the widget" seems to be an irrelevant documentation.
`[drag]` -> `[dragFrom]`? I suggest putting the identical comments in a template, so it's clear what can be shared and what cannot.
`slowDrag` -> `timedDrag`
Done.
Done.
Removed. 
Done. 
There's nothing wrong with this but personally, I'd write:
```dart
final List<_ColumnBuilder> pickerBuilders = Directionality.of(context) == TextDirection.rtl
  ? <_ColumnBuilder>[_buildMinutePicker, _buildHourPicker]
  : <_ColumnBuilder>[_buildHourPicker, _buildMinutePicker];

```
Yeah I agree, this is cleaner
Is this pump necessary even with the duration pump on the next line?

Same question for the material text field test.
The name of this file is missing an underscore, should be "text_field_restoration_test".
Good catch. Fixed.
We need one pump to start the animation. And another (with a duration) to finish it.
Nit: use `[offset], [speed], [frameInterval]` so the IDE/doc can cross reference with the argument declarations?
I don't think `[...]` can reference arguments. In all other docs `[...]` is only used for methods, functions, classes, consts, etc, but not arguments of a method. e.g. https://github.com/flutter/flutter/blob/master/packages/flutter_test/lib/src/controller.dart#L44 
plus, in api.flutter.dev, we don't have an independent page for an argument. 
this seems wrong, it should just have the path contents
possibly an issue with projectDir
You shouldn't need to manipulate the path string like this - what problem is this solving?
This was a mistake I made. In the commit, I accidentally removed the `dir` in `project-dir` so the test failed and I couldn't understand why at the time. I'll remove this line in a subsequent commit. Thanks for the catch!
Maybe better: "An immutable style describing how to format and paint text."
This comment and name are pretty vague; there are different things that it could refer to (e.g., I would have guessed without having seen the implementation that it was the exterior bounds). How about `GetClientArea`? (I don't think we need `Window` in the name of a method on a window object; it's implied.)
OK, will rename to GetClientArea
qarni
Fixed in more recent commit
```suggestion
/// await expectLater(tester, meetsGuideline(textContrastGuideline));
```
This sucks.
The plugin linter tests are going to hit this problem with Xcode 12, too.
\cc @cyanglaz 
I'm not familiar with the syntax. Does "canFail" make the analyzer pass even hitting this problem?
Yes, it's running this check but not failing the test if the linter fails.  Flutter is missing an ARM simulator slice, so will fail on Xcode 12.
This would probably benefit from a little more detail. What does it mean to have "structured errors"?
Dartdoc cannot resolve these references: https://cirrus-ci.com/task/6118617987153920?command=main#L135

You probably have to capitalize the "w" in Window to resolve.
Hmmm, I'm not sure the capital is working either.  Maybe these don't need to be actual element references?

Something like:

     /// Ensures callbacks for `window.onBeginFrame` and `window.onDrawFrame`
Right.  Will update.
(I'll give this a whirl.)
Can you make those hyperlinks?
would be good to point to things like FlutterError and so on where we have more detail
capital letter should work...
this comment is a bit confusing, can you explain more?
This should explain how it uses it
this should also add why people would want to look at this
missing ':'.
This should talk a little bit more details
This should also include why we want to look at this
same here and everywhere
Tried to clean it up a bit, let me know what you think of the new version. It was meant to mirror the super method's documentation: [RenderObject.describeSemanticsConfiguration](https://api.flutter.dev/flutter/rendering/RenderObject/describeSemanticsConfiguration.html).
nit: indent 
indent
indent
It seems like only two classes(RenderViewportBase, SingleChildScrollView) are using this in their show on screen. Let's list two of them separately here
indent
It maybe a little bit inaccurate, we do not override this method often, it just so happens that we uses this method for those occasion.
Just to be clear, should the indent on the second line match the position of the `[` on the first line, or be indented even further?
it should match the position of `[`
nit, let's remove the `as described above.` It seems to not add much information
Is `ShrinkWrappingViewport` need `clipBehavior`?
`ShrinkWrappingViewport` seems to already have `clipBehavior`: https://github.com/flutter/flutter/blob/77b4505c8014330fba2f2706c658a64bc5d1891b/packages/flutter/lib/src/widgets/viewport.dart#L313
I mean line 314. This function has two return branches, :)
Ah yes, nice catch! Fixed now.
I like it! This is what I was trying to do but it is a much simpler way of tracking it.
Maybe we should update the docs on `RangeMaintainingScrollPhysics` indicate that there are more cases where the range is not maintained. 
Nice fixed! 
We can not use the `oldPosition ` above, for example, the `_PagePosition.applyViewportDimension` will correct the pixels due to resizing from zero, and it will cause `RangeMaintainingScrollPhysics.adjustPositionForNewDimensions` mistake. I am currently fix this bug (#65015 ). 
This should be 
```
if ((oldPosition.pixels < oldPosition.minScrollExtent) ||
        (oldPosition.pixels > oldPosition.maxScrollExtent))
```
right?
`If the current velocity is non-zero`
oops. will fix in the reland.
oh wow, how did that not get caught by the tests, yikes
I'll leave this as-is in my reland and will let you follow up in #65015 (i'll review that shortly, sorry i missed that until now)
fixing it doesn't cause any test failures even! what on earth.
fix in https://github.com/flutter/flutter/pull/65135
remove the "not"? As in it used to throw and now it doesn't anymore?
oops yeah
just make the function async and `return;`.
then you can just await here
making this async is... exciting
though... why do you not return the same future as the other call to doSerialization?
Or throw? Seems weird to do nothing when called redundantly, and return a future that completes before the earlier "real" call...
took me a while to understand these two sentences. How about:

A change in restoration data is usually accompanied by scheduling a frame (because the restoration data is modified inside a [State.setState] call, because it is usually something that affects the interface). Restoration data is automatically flushed to the engine at the end of a frame. As a result, it is uncommon to need to call this method directly.
`However,`
`frame, this`
sent
for -> of
"final to be persisted scroll offset" is dubious, not sure what you mean
sent
how can we guarantee this?
even if it didn't change?
RestorableValue only calls didUpdateValue if old and new value are different.
Reworded.
It just ensures that you don't call flushData from a RestorationBucket's `finalize` method (which is called during serialization).
ah now that it's not async that works
`childRect.left > size.width` should be `childRect.right > size.width`.

It's probably clearer to just write the function as
```
  bool _shouldClipAtPaintOffset(Offset paintOffset) {
    assert(child != null);
    return  paintOffset.dx < 0 ||
            paintOffset.dy < 0 ||
            paintOffset.dx + child.size.width > size.width ||
            paintOffset.dy + child.size.height > size.height;
  }
```

It would be nice if you can also add another unit test that fails `childRect.left > size.width` but passes `childRect.right > size.width` :)
fixed, NICE code review, and clean code.
I will add a unit test too, It seems too easy to make mistakes here ^.^
Done.
@liyuqian I think this is the trouble. Somehow `flutter update-packages --force-upgrade` is downgrading this package. I posted a question in discord. 
Maybe I am misreading this, but won't you wind up with primary for both foreground and background color if we aren't in dark and enabled?

Should the foreground be `colorScheme.onPrimary`?
Yes! Good catch. I will add a test to verify this stuff.
nit: align the `:` with the `?` for clarity
Good point.  Looks like this is moot now, since @a14n made the type of `handler` nullable.  I've reverted this part of the PR.
This is awesome. Your PR LGTM.

My only question is if there is an official documented procedure for rolling the gallery here, and if it can be updated to reference this file.
I don't know. I'm asking right now.
+1, interested in how this works as gallery changes - don't we want master to test against the newest gallery?  this seems more reasonable for branches than master (but I may be misunderstanding)
If we always ask `flutter/flutter:master` to clone `flutter/gallery:master`, an error in Gallery might cause Flutter's build to fail. These tests always uses latest `flutter/flutter:master`.
I think the best way is to use a commit hash instead of a branch, and set up a process to roll it regularly. (But this is a future task.)
@christopherfujino @pcsosinski 

There isn't a process to roll the gallery version yet. It would be a good idea to add this process, some time in the future.
The message we show when anything here is missing was written with the assumption that installing GTK-dev libraries would install everything in the list as a dependency, so doesn't list the individual libraries. Do we need to revisit that string? E.g., on Fedora is it relatively easy to get into a state where of the things on this list only `blkid` is missing?
In the particular case of `blkid`, if you don't explicitly grab it's location from pkg-config, it is implicitly assumed to be installed in the system root (see the linked bug).

This is not a problem if you manually install your GTK development packages locally (as instructed in that message), but it is a problem with the `flutter-snap` for example.

It's not good enough just to have `libblkid` available in the snap. Without the project explicitly asking pkg-config where it is, the linker makes guesses (as mentioned above).

I don't think it hurts to have `flutter doctor` check for this library in addition to the others, but if you think it unnecessary, we can take it off the list.
In short, the message **doesn't** need to be updated, nor does this library need to be on this checklist.

Really, the only necessary changes in this PR are the `pkg_check_modules()` and `target_link_libraries()` additions in `flutter/CMakeLists.txt`.
I'm fine with adding it to the list since it is in fact a dependency, I just wanted to be sure we didn't also need updated instructions. Thanks for the explanation; I understand now why we don't.
For my understanding: why this change?
This prevent usage of nullable type as type parameter and T is treated as non-nullable.
Why is this nullable when we assert that it is not null?
Ditto
Shouldn't this be `required TextDireciton textDirection`?
Ditto
We assert this isn't null. If we have to make it required that's probably better than making it nullable.
Or is this because the super class lets it be null?  Is there a big impact to changing the superclass in that case?
Ditto here - if it's all because of the super class we should look at just making the super class non-nullable as well.
More of a question: is `FlutterError.onError?(....)` allowed?
No but you can use `FlutterError.onError?.call(....)`
The overriden method documents that textDirection can be null
https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L470-L479
Same here
https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L449-L458
Same here
https://github.com/flutter/flutter/blob/bdadd7f4e88b35c976bb3160a5c312fa4bbe09c4/packages/flutter/lib/src/painting/borders.dart#L483-L487
Ahh ok. That makes sense.
After trying to make direction non-nullable there are several failure in tests. null is actually possible as argument for `BorderRadius.resolve`. So I'll revert the last commit.
Parent class value is nullable, this should be nullable too
I wasn't sure what to do with these. The key event data requires these are non-null
syncCall cannot be null,  though it doesn't effect this test
Null is frequently used to check if these are set in tests (here and elsewhere)
late doesn't work here with the override in flutter_test. I can't really explain it, because it doesn't make sense to me
You can just remove the entire line.  I think I just put in the nulls to highlight that for the test they weren't being specified. A comment would have been better.
Hmm, maybe the signatures got updated? Last I checked it had to be non-null, but this PR is a week or so old now
Analyzer is complaining about this one.
nit: maybe rename for clarity to `RecordedCanvasCall` and rename the subclass to `RecordedRotateCall`, etc?
I'm a little confused. Will this path appear in a user's app?
not at all
this was a test in the flutter repo that we checked in a .packages file for, there was an exception in our gitignore
Oh I'm sorry, it's been so long since I coded I forgot how to read a diff...
:P 
```suggestion
      only_if: "changesInclude('.cirrus.yml', 'dev/**', 'packages/flutter/**', 'packages/flutter_test/**', 'packages/flutter_drive/**', 'packages/flutter_localizations/**', 'bin/**') || $CIRRUS_PR == ''"
```
Can we only add the link to stackoverflow? Too many choices may make it difficult to to chose one.
Maybe: Ask your questions about how to achieve a particular effect in Flutter or get help with using a particular API. 
sounds good to me, I've included both Reddit and SO following this [comment](https://github.com/flutter/flutter/issues/61094#issuecomment-668777210)
Sure thing
Note these newly created plugins will not be able to be used by Flutter apps with a minimum of 8.0 (compilation time error), so that's all apps currently in the wild now.

I really wish there wasn't an error for this, or at least I wish it was suppressible.

I'm willing to be convinced we shouldn't increase the plugin minimum requirement for a few stable cycles until more apps have upgraded to 9.0...
so you're saying an app can't use a plugin with a higher minimum ios version?
Yes. I'm going to revert the plugin min version bump, it seems like we need to talk about that separately.
This is not used for published plugins, it's generated for app and modules that need to import plugins.
SGTM
Per the gold team, the current refactor they are doing will make `master` -> `master_str` (where we are now) -> `master`
Can we instead check to see if `master` is available, and if not use `master_str`? That would reduce churn and eliminate breakage for us in the interim.
SGTM. Can we encourage them to avoid the term "master" entirely?
I think it is based off our own branch naming convention. @LeandroLovisolo is that correct?
```suggestion
      "master_str": {
```
To satisfy the analyzer:
```suggestion
Future<void> testWithOutput(String name, Future<void> body(), String expectedOutput) async {
```
nit: Indent the other lines so that they're aligned with the first line
Thanks, fixed üôÇ
nit: remove extra whitespace before first line in test body.
use only one line of whitespace here instead of 2.
remove whitespace at the end of the test block.
We don't have a tool specific template, but https://github.com/flutter/flutter/issues/new?assignees=&labels=&template=BUG.md&title= might be a better link
I considered that but I thought it would make the error message sufficiently uglier as to outweigh the benefit.
This change is making the test slightly less precise (the `.called(1)`) is missing. instead of just having a `didCopy` boolean, can we have a `copyCount` integer?
Done
Just to double-check: No other pubspec file changed as a result of running `flutter update-packages --force-upgrade`? 
yes, since this was a dev_dependency it doesn't affect the version solving of any other package
```suggestion
  /// This is why the default value is false. Most of the time, when you change the
```
```suggestion
  /// expectation and re-use the old widget.
```
Is it necessary to have a list of BoxShadows here? Or can we just pass an empty list?
I guess it should not create a problem if we pass an empty list, since the method checks if there are boxShadows in the list to paint, or else it's skipped.
Let's do that and maybe add a comment that since there's an elevation of 0 equates to no shadows, it's just an empty List<BoxShadow> so future readers don't get confused
nit: already returns a bool, so no need to use an equality here:
```suggestion
    assert(!kElevationToShadow.containsKey(widget.elevation),
```
I would avoid using the full set of values here. Maybe do a pointer to api.flutter.dev/flutter/material/kElevationToShadow-constant.html instead, since the problem with this would be any change to the values in kElevationToShadow might cause this to accidentally be off. For example, if we add an elevation value for 48 and forget to update this assert message, it'll be incorrect.


```suggestion
      'Invalid value for elevation. See the kElevationToShadow '
      'constant for possible elevation values.'
```
Makes sense, I'll do the changes.
nits:
Can we explain more?
Like what's "Native stacktrace", where does user get dart stack trance, etc.
nits:
use // for TODOs
could you also link this TODO to an issue to track?
I don't think this has to be dynamic? Just `String?`.
nit: remove extra blank line
Done
nit: indentation. 
nit: indentation
This is intended. The cookbook article talks about floating bar, so I added it as a sub-node to the SliverAppBar list item. If that's too confusing or if we try to stay away from nested lists in API docs, I can correct this (and the other instance below).
I would prefer not nesting these to keep them simpler.
1 line?
Outlined for M2?
maxLines has to be null for the `expands` logic to work, so we limit to 2 characters
yep that is expected
Minor nit:

```suggestion
  testWidgets('DataTable sort indicator orientation', (WidgetTester tester) async {
```

The 'test' here is redundant, as they are all tests üòÑ .
dart -> Dart
Good catch. Will do flutter -> Flutter as well. Thanks!
```suggestion
    'This feature was deprecated after v1.21.0-1.0.pre.'
```

Is this suggestion exactly what you tried before, and it still didn't work?  What if you try 1.20.0-7.1.pre?
Instead of deprecating just the iOS13 value, should you deprecate this parameter now?  That way in the future we only need one follow up PR to remove this parameter.  Otherwise you need one to deprecate this and a second later one to remove it.
Sure, the parameter should be deprecated now to make user use default value.
I think it's still valuable to keep this test around.  Just leave off `iOSVersionStyle` so it defaults to iOS14?
The original tests are now default to iOS14 so we nolonger need these iOS14 tests.
But should we add some tests for iOS13 style?
Oh I see.  No I think it's fine since iOS13 will be removed in the future.

Alright this looks good and should be merged when our build is green.  Thanks for following up with this work!
remove -> removed
I've ran "flutter format" to format this file. 
The flutter framework does not use use formatter, see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#formatting. Can you please undo the unrelated format changes?
Done. 
```suggestion
          args[1]['action'] as String,
          args[1]['data'] as Map<String, dynamic>,
        );
```
FYI @LongCatIsLooong, small autofill change.
Not sure I understand what this is for. Is this for autocomplete text fields?
Ah nvm I see it's for https://developer.android.com/reference/android/view/inputmethod/InputConnection?hl=uk#performPrivateCommand(java.lang.String,%20android.os.Bundle)
This test probably belongs to another file in the same directory: "text_input_test.dart" 
Adding the performPrivateCommand() in here because we introduced an abstract function performPrivateCommand in TextInputClient. This is used for resolving the compilation error. 
Dartdoc is complaining that there's no template for this macro: https://cirrus-ci.com/task/5126735421243392?command=main#L119
Called when the result of an app private command is received?
Added template in editable_text.dart
Done.
Was this a debug message, or intentional? If intentional why go to `stderr`?
That was just a debug print.  Removed, thanks for seeing it.
'.json' -> 'json'. Right now the output file name looks like `flutter_size_01..json`
Could we also make this a unique file?
perhaps we should store an output file for each platform - see https://github.com/flutter/flutter/issues/61629
can we generate a snapshot for each platform (see https://github.com/flutter/flutter/issues/61629)? we can write a follow up CL to consume all the generated snapshot files in SizeAnalyzer. Or do we actually need to generate different ABIs with the `flutter build apk` `--target-platform` flag?
Though I'm fine with getting this change in, and adding support for multiple platforms later if that ends up being a CUJ.
What do you mean by platform here - android/ios? or arm/arm-64/x86_64

Given the command UX we started with, I suspect only one platform at a time makes sense.
If we need to do multiple platforms, we'll need to create multiple BuildInfos anyway
Sure, how do you want me to surface that info to devtools? Or does it rely on the user dropping it into the UI?
It would rely on the user dropping it into the UI. I just meant using `globals.fsUtils.getUniqueFile();` to create the file if that clarifies!
I mean arm/arm-64/x86_64. One platform at a time sgtm
Done
Done
I think we could do this as a follow up, but it would require more plumbing.
Why do we allow `null` for direction?
It looks like subclasses are asserting that this is non-null?
When is the imageCache ever expected to be null?

/cc @dnfield 
Same question about the image cache here.

@dnfield (unrelated to this PR): Why do we expose the image cache twice: as part of the binding and as a global? Should one of them be deprecated?
I looked at the usage of `ImageSizeInfo` and was surprised that we allow `null` for these values.
How can this become null? The constructor asserts that it is non-null.
I think this should not be null
Ditto
No but it gets created by a virtual method. Can we make it late?
That predates my work.  @jonahwilliams might know.  I would be fine with deprecating the global.
I don't quite remember. It might have been global before we moved it into a binding
Did some digging, looks like it was moved into the binding in https://github.com/flutter/flutter/pull/13409 and the global was kept. I'll prepare a PR to deprecate the global similarly to how we deprecated the global `defaultBinaryMessenger`.
It is nullable because null can be used via gradient.dart `Shader createShader(Rect rect, { TextDirection? textDirection })` or with ImageConfiguration that accepts null `textDirection`.
I made it nullable because L117 there's `imageCache?.clear();`. I will change it to late non-nullable
This change makes the following test fails:

```dart
  test('PaintingBinding with memory pressure before initInstances', () {
    // Observed in devicelab: the device sends a memory pressure event to us
    // after PaintingBinding has been created but before initInstances called,
    // meaning the imageCache member is still null.
    final PaintingBinding binding = TestPaintingBinding();
    expect(binding.imageCache, null);
    binding.handleMemoryPressure();
    expect(binding.imageCache, null);
    binding.initInstances();
    expect(binding.imageCache, isNotNull);
    expect(binding.imageCache.currentSize, 0);
  });
```

I guess I can remove it?
Ahh I remember now.  This caused flakes sometimes because the memory pressure would get processed before finishing binding initialization on rare occasions.  I guess we have to leave it as nullable.
Please don't remove this test, this was a real failure. @dnfield I think re-ordered some of the initialization but I don't think it is solved.

Specifically, we can have a queued up message for us when initializing the binding, which might be a low memory event. I believe that gets forwarded immediately, but due to the binding order will run before the image cache is initialized. That doesn't mean that the image cache needs to be nullable, since this state isn't generally observable - but you do need to track whether it has been initialized somewhere.
Something like:
```dart
late ImageCache imageCache;
bool _imageCacheSetup = false;

```
ok, after reading more carefully the comment I understood that it was not a good idea to remove it :)
@jonahwilliams I'm not sure to follow. Do you expect a change in this PR or are you just talking about a future change that could happen?
So I have to make a "breaking change" with:

```diff
-  const ImageSizeInfo({this.source, this.displaySize, this.imageSize});
+  const ImageSizeInfo({this.source, this.displaySize, required this.imageSize});
```

Is it ok for you?
This type was very recently added and only used for debugging purposes.  It should be fine.
Actually there are several tests failures with this change and I'm not confortable how to change them. Could you made this change after this PR is merged?
That's fine
Sorry I made a mistake. The failures appear with `ImageInfo` where some tests return null image
The tests fail with the following diff:

```diff
--- a/packages/flutter/lib/src/painting/image_cache.dart
+++ b/packages/flutter/lib/src/painting/image_cache.dart
@@ -389,7 +389,7 @@ class ImageCache {
     _PendingImage? untrackedPendingImage;
     void listener(ImageInfo? info, bool syncCall) {
       // Images that fail to load don't contribute to cache size.
-      final int imageSize = info == null || info.image == null ? 0 : info.image.height * info.image.width * 4;
+      final int imageSize = info == null ? 0 : info.image.height * info.image.width * 4;
 
       final _CachedImage image = _CachedImage(result!, imageSize);
```
changed
nullable is fine for now
no longer necessary right?
ditto
nit: `shaderWarmUp?.execute();` might be more efficient
why do we need this? We just checked that value isn't null in this block
ditto
This should not be nullalble - the ctor asserts it's not null. We should remove the != null from hasListeners
We have to wait for #61042 to be fixed before removing null asserts on parameters.
because `value` is a getter/field a null check doesn't promote it to non-nullable.
`_codec` is not directly initialized in the constructor (it is in a `future.then()` so some code could has access before the callback is executed).
I can make the field `late` but we could face LazyInitializationError if `addListener` is call before the async initialisation is done.

WDYT?
Ohh I see.  Yes that makes sense, this should just be nullable 
Ooh, nice. I will need to remember this one for some of the other tests I have were I manually reset these.
Do you also set `tester.binding.window.platformBrightnessTestValue = Brightness.dark;` to null?
Yes I should, done
Does this need to be clamped like it was before?
it gets clamped after the `switch`.
Ah I see, thanks.
One possible way to avoid this (tiny) breaking change is adding a new API `Future<void> settleAnimations()` to `WidgetController`. In it, `LiveWidgetController` can just wait for `!binding.hasScheduledFrame` without `pump` while `WidgetTester` simply calls `pumpAndSettle`. How do you think about that? We could also discuss it with Dan or Ian and see what they prefer.
Throwing an exception when there's no back button still seems to be desired. As `expectSync` may not be available from `WidgetController`, maybe we can use something else (e.g., [FlutterError]). That way, we can probably still preserve the `fails when there are no back buttons` test with a small modification.

[FlutterError]: https://api.flutter.dev/flutter/foundation/FlutterError-class.html
It sounds a good work around. The bad part is for `WidgetController` these two methods sound duplicate. I'm not sure which is better and I agree to discuss further. 
I wonder if it really is desired/consistent with other APIs. By removing the `pageBack` method, IDE reminds me that the `matcher.dart` is no longer needed: basically this method is the only method `expect`ing the existence of a finder, while all other methods are assuming a finder exists, and rely on when really evaluating a finder to raise an error. 
If we're going to do this breaking change, I felt a named parameter map `[duration], {timeout, phase}` is better than a positional one such as `[duration, timeout, phase]`. It should be compatible with most `pumpAndSettle` calls with just 0 or 1 positional argument, and will force `timeout, phase` to be spelled out if used.
nit: please make sure these are sorted alphabetically
We should remove this timeout feature, per https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#never-check-if-a-port-is-available-before-using-it-never-add-timeouts-and-other-race-conditions

Maybe just make the default null and assert that it is null in this version, and mark it deprecated in the superclass and the other implementation? Or maybe remove it entirely? Could be another PR to do that... I'd rather we didn't add more code that supported it though.
iirc you can make `guard` take an `int` and then just return `count` from the body.
if we're changing the API anyway, then definitely just drop timeout entirely.
is it a breaking change?
this whole method is a bit dubious to be honest (we really shouldn't be depending on material or cupertino in flutter_test). It's all just convenience methods. So once we have them anyway, why not also make sure there's a back button.

That said, whether we throw a FlutterError or a TestError (or whatever expectSync fires) doesn't seem to matter that much. This is a test framework, so expectSync is not unreasonable IMHO.
as it is you're still going to through when you try to tap a the button and there isn't one
It doesn't break our current test cases because the optional argument is not used in the flutter/flutter repo. @Hixie 
this implementation needs a test
Done. 
It is tested in `'Test pumpAndSettle on LiveWidgetController'` from `packages/flutter_test/test/live_widget_controller_test.dart`
Done. 
Removing timeout is a real breaking change, tested here: https://github.com/flutter/flutter/blob/67e9b2945ec6b09d4c1719a9aa81578e95cd6071/packages/flutter_test/test/widget_tester_test.dart#L473-L478 @Hixie 
Removed timeout. 
We should do a while loop on `indexOf(firstChild) > 0)` and only return on line 185 if firstChildScrollOffset < -precisionErrorTolerance, other wise we should continue downward to finish the layout.

If we set it to null here and return on line 185, the rendering binding will think the layout is finished and proceed to painting. 
lets add a expect(tester.takeException(), isNull)
For example this may cause a problem if the children after the firstChild change their size in this perform layout.
Ah, I think I see what you mean now. I'll update. Thanks!
This does not look right, the `earliestScrollOffset` is at the beginning of the first child already, we want to take `earliestScrollOffset` and minus the paint extent of child before the first child. I think one thing that is confusing of the original code is that line 177 ` earliestUsefulChild = insertAndLayoutLeadingChild(childConstraints, parentUsesSize: true);` will actually update the firstChild. So the firstChild in line 173 and line 179 are actually different.
Can you add a comment to explain why we need to do this check and why we use the while loop? (something about the paint extent can be zero)
Sure!
We could also change the sdk version, though it doesn't matter too much since it's shipped with Flutter.
If you want to do that, it would become `>=2.9.0`
I don't see any risk of that but since we are cherry picking this, let's make it as simple as possible. We can always update the sdk version later. WDYT?
I don't have a preference.
Oops, looks like I forgot to remove a TODO, do you think you could remove it as part of this PR? Looks like the formatting of that test is a bit off too.
Will this result in any visual diff from the ButtonBar?
Sure, done.
I don't think so. I've already done some image diffs before and after this PR, to check. Still need to check the test repo ofcourse.
Add this in `main()` under `LoggingProcessManager loggingProcessManager;
done
Sorry, I also meant because `logger = BufferLogger.test()` is in setUp, match the pattern of `LoggingProcessManager` and just declare it here.
```suggestion
  BufferLogger logger;
```
done
Yeah I did that and forgot the remove the other constructor call. Fixed in a new commit.
Is this needed for the docs fixes?
Yeah, the docs reference stuff from there, it wasn't part of the public API though and no docs were generated for it.
Alternatively, we could change the docs to not reference this. Let me check that this should actually be part of the public API...
You're right, just exporting this for the docs is strange since it isn't really part of the public API. I instead changed the location where it was referenced to not link it.
SGTM
√ºber nit: It appears these are organized alphabetically except for this one. ü§ì 
ü§¶  I will fix this in a follow-up PR (I want to submit this ASAP to avoid new warnings from sneaking in and pushing another commit would restart all the bots...)
As promised: https://github.com/flutter/flutter/pull/62611
Nit: add `flaky: true` to the new task.
Done. 
please use consistent indenting on all lines
nice catch
/cc @dkwingsmt or @gspencergoog Is it expected that the label can be null? If so, can we add something to the docs here to explain what that means?
/cc @LongCatIsLooong When is this expected to be null? Can we add that to the documentation here?
Should this be `late` to keep the laziness of the original code?
It's not supposed to be null but I might have omitted `currentEditingValue` in some of the tests.
Static variables and top level variables are already lazy in Dart so I think `static late final` is the same as `static final`.
@leafpetersen or @lrhn is it correct? 

If yes the analyzer could perhaps have an hint to prefer `static final` over `static late final`
By making `currentEditingValue` required and non-nullable tests on packages/flutter are OK.

I made it nullable because in the constructor it was not `@required` and not asserted as not null.

I'll make the change to have non-nullable type.
null seems to be possible regarding https://github.com/flutter/flutter/blob/7ec2d360bce51f010554be8d80572af4748a4a95/dev/tools/gen_keycodes/lib/keyboard_keys_code_gen.dart#L61-L73
Yes, null is possible, since it's possible that we don't have the key label data for a key.
Can we update the doc comment here to mention that?
This is odd. Returning null from here is always a bug, it means we missed a case in the switch. This should really be non-nullable (unless null is a legal value for affinity).
The `?? TextAffinity.downstream` is strange since `_toTextAffinity` effectively can't return null (see comment above).
This surprises me, why is null allowed here? (according to the doc it only sends string representation of enum values.)
Maybe `encoded['selectionAffinity']` can actually be null?
This is strange again. If `message` is non-nullable, then this method should never return null - it would be a bug if it does.
Done
Changed to non-nullable
Because `StringCodec` implements `MessageCodec<String?>` and its decode/encode methods accepts/returns null.
Changed
No idea :-( Let's run tests and see...
Thanks to CI (https://cirrus-ci.com/task/5831088616505344?command=main#L38) we have an answer:

```
00:00 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                  
00:01 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                  
00:02 +0: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart                                                                                                  
00:02 +0 -1: loading /private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart [E]                                                                                           
  Failed to load "/private/tmp/flutter sdk/dev/automated_tests/test_smoke_test/timeout_pass_test.dart": Invalid argument(s): AppLifecycleState null not supported.
  package:flutter/src/services/binding.dart 207:5     ServicesBinding._parseAppLifecycleMessage
  package:flutter/src/services/binding.dart 185:38    ServicesBinding.readInitialLifecycleStateFromNativeWindow
  package:flutter/src/services/binding.dart 35:5      ServicesBinding.initInstances
  package:flutter/src/gestures/binding.dart 65:11     GestureBinding.initInstances
  package:flutter/src/semantics/binding.dart 24:11    SemanticsBinding.initInstances
  package:flutter/src/rendering/binding.dart 32:11    RendererBinding.initInstances
  package:flutter/src/painting/binding.dart 23:11     PaintingBinding.initInstances
  package:flutter/src/widgets/binding.dart 257:11     WidgetsBinding.initInstances
  package:flutter_test/src/binding.dart 318:11        TestWidgetsFlutterBinding.initInstances
  package:flutter_test/src/binding.dart 914:11        AutomatedTestWidgetsFlutterBinding.initInstances
```
Looking at this code again, I think the idea is that if `encoded['selectionAffinity']` is null, this should default to `TextAffinity.downstream`.
`static late final` with an initializer is the same as `static final` (and also when non-final).  Without an initializer they are different.  +1 for a hint/lint.  cc @bwilkerson 
Actually this is null on web plateform and is the cause of #62724.
"the appropriate elevation for app bars." is really just noise. We could delete it.
Appbar => AppBar
primary => [primary]
nit: 2 space indent
"at the same time" seems confusing, this all properties are applied at instantiation time.  Maybe "along with"?
You're removing this because the reader can find this out by clicking through to `[AlignmentGeometry]` (and then transitively through to `[AlignmentDirectional]`)?
s/an/a/
`[SemanticsProperties.label]` ?
`[SemanticsProperties.label]` ?
It's probably worth adding docs to the class docs of `NavigatorState` that says you can get a reference to the class by calling `Navigator.of`
I actually didn't mean to remove this. Putting an updated version back in.
why does the order of the keys in the output map matter?
add some dart doc describing what this class is for
add dart doc describing what this method does. Add a note saying that `aotSizeJson` can be from instruction sizes or v8 snapshot (if that is correct)
make this documentation more specific. This method seems like it is specific to the lib/ directory in an APK. note that here
use string concatenation `'$totalPath/'`
This needs a copyright header too
this should be an exact version, then run `flutter update-packages --force-upgrade` to update the checksums
make these two named and required parameters
for the consts here, I would hoist them out of main at put them at the top level
this issue is marked as fixed, is this still necessary
nit: if _currentNode_ does not have any children 
i'm surprised that we are checking that `className.isNotEmpty` and checking that `libraryUri != null`. I would expect these two checks to be the same. Why are we checking for null on one and empty on the other?
Neither ancestors nor siblings are used in the test, so they currently have 0 coverage
what are we grouping by 2 for? perhaps put 2 in a const that describes what the number represents
does `childWithPathAsName.addValue(pathsToSize[paths]);` need to be called before `currentNode.addChild(childWithPathAsName);` so that the `childWithPathAsName's` value is summed into `currentNode's` value when calling `addChild`?
why 10? put in a const with a descriptive name
same comment here. why 4?
make these required named parameters
rename to addAotSizeDataToApkAnalysis
It's to make sure that the type field isn't just hidden at the bottom of the json because of the giant AOT data. I'm not sure when the user would need to check the type manually by opening up the json, but I was thinking it'd be better to make the type field more visible.
Done
Done
Done
Done
Done
Done
Done
Done
Done
`childWithPathAsName`'s value should already have been added to currentNode on the previous iteration of the loop.
Removed since those are not used (the entire `SymbolNode` code was copied from here: https://github.com/flutter/flutter/issues/51594#issuecomment-639823612)
Removed
Done
+1. Sorry my draft didn't have docs but all public fields of public classes should have docs. 
Using required named parameters will be clearer than positional parameters here.
From other PR: if this function now does 2 things, reflect it in the name.
From other PR: using zipinfo rather than unzip could be an optimization (feel free to do it in a separate PR)
add some code comments here
If this isn't used outside make it private
add code comments here for what this is doing
add code comment here. e.g. we picked this specific file to match and print the aot content because it's likely the most popular architecture and other architecture sizes should be similar so it's not worth repeating
I'd somehow via the names make it clearer that _printLibDetails prints a tree and _printEntitySize prints a line
This can probably be private. Also add comments
ah is this why those parameters were in the constructor? There is already a dependency injection mechanism. See other tests using `testUsingContext`. Then you can remove those construction params. 
Done
Done
Done
Done
Done
I think snapshots for all three platforms will be included in a follow-up CL. Should I still add the comment?
Done
Removed
Added a TODO
Done
Done
@jonahwilliams helped me put in those constructors explaining we might not want to use the `global` keyword. Would removing the construction params force us to use the `global` keyword?
Yes, new code should not use the global zone injection - it makes testing the code very brittle as we've found that new contributors frequently do not understand which interfaces need to be overriden.
2020
2020
new line at end of file
confusingly it should be 2014
This needs a bug assigned to it
this should be a printError and not a regular print
Prefer hoisting this into a private static, to avoid recompiling the regexp every time it is created
formatting is off a bit here, indent the required params by 2 spaces
Done
Done
Done
@peterdjlee 
So the new consensus is to do constructor injection through the entire graph? Is there a tracking bug to migrate existing code?
you need a newline here to make analysis pass
https://github.com/flutter/flutter/issues/47161 , but I haven't done a good job of keeping it updated
Do these need to be relative imports to fix the analyze bot?
Looks like other files have relative imports! Changed to relative imports.
FYI, as far as I know we do not document requiring zipinfo to be installed, so switching may not be straightforward
both zipinfo and unzip are built-in on macOS and neither are built-in on Ubuntu so we're more or less in the same position either way. 
No, we're not in the same state - we require unzip and warn if it is not installed and do no such thing for zipinfo
ah I see, SG, let's leave it then. This makes it simpler. 
This is conflicting with the doc comment above it.
Fixed
'[SemanticProperties.label]'?
Nit: `s/used, if/used. If/`
(and elsewhere in this file)
`* The time picker widget ([showTimePicker])` ?
Typo of the old code `Scrpllable` -> `Scrollable`.
Done. 
Nit: `See also [dragUntilVisible].`
Done. 
LOL. What exactly does a "Customer Clipper" do?  Doesn't sound like something we'd want to implement. :-)
Haha! 
Maybe we should make a little `join_paths` helper function for this file that does what `path.join` does, so we can keep the simpler inline logic (and don't need to duplicate it more times if we need to add more paths)?
Done
I believe this is supposed to be "**In** its build,..."
We usually reference the Widget (and not its State).
dito
Can you wrap this call in an assert so it gets optimized out in release builds?

Also, the method name should start with `_debug`, maybe _debugVerifyInsertPosition.
nit: formatting is off here.
While there's less duplication, the code is actually a lot harder to read now than it was before with the if/else branches. I think I'd prefer the old style.
and I will wrap this into another assert so that we don't spend time call into another method in production code.
same here
instead of doing if else can you merge this two by doing newEntries?.contains
we will also need to update the error text to be more generic if we merge this too check.
Could you leave a comment linking this path with the useSyntheticPackage setting in the flutter tool?
nit: if you have a return here you don't need the else below.
There is one small missing feature: you could check that generate is true and if not warn that the sources won't be importable. 
I just [added the feature](https://github.com/flutter/flutter/pull/62395/files#diff-d27c3ed6f283118c1a9719f24ec8a4f5R42) and [a test](https://github.com/flutter/flutter/pull/62395/files#diff-e3ab382c96a655e902c9ff5ba96fa840R71). PTAL
Use `var proj = FlutterProject.fromDirectory(environment.projectDir); flutterProject.manifest.generateSyntheticPackage` instead of parsing the pubspec yourself.
nit, just return the result:

```
return buildSystem.build(
...
)
```
Can you pull this parsing logic out of the the Pub class?
?
what is this change fixing?
nit: remove comment, doesn't really need describing
instead of catching the exception, use:

`expect(() => .., throwsToolExit(message: ...)`
It doesn't fix anything, but I thought that it was a little clearer to me to just be explicit since `fromDirectory()` is simply the same thing as `globals.projectFactory.fromDirectory()`.
you could drastically reduce the nesting here by re-arranging the code a bit:

```dart
if (!exists) {
  return;
}

if (condition that causes type error) {
  ...
  throwToolExit(..);
} 
```
i.e. check for errors first, and early return/throw
ahh, right
`expect(() => ..., throwsA(isA<Exception>())`
you should also check that the logger error text contains some part of the message you added
Please don't implement your own mocks. Either use the Mock/Fake class from mockito, or use the FakeProcessManager
`return await` does not really do anything, you can return the future directly
Is there an existing function which already handles this? If not, should I move this somewhere more centralized?
This code looks correct to me, I am curious though why we want to & with the offset.zero at the first place @goderbauer 
I think we forgot to change this when the code was moved in https://github.com/flutter/flutter/pull/13983 a loong time ago!
I don't think this is needed very often. Usually you only care about their relative position to the parent. Having that just here seems fine.
Nit: Demo code should either consistently use or omit the `.0` on doubles
To follow Material Dialogs, should we put the OK button last/left?
```suggestion
  /// centered within the available space.
```

maybe?
If this is null, then it uses the inherited text direction right? Probably worth mentioning that in the documentation.
To match the other lines
```suggestion
    properties.add(DoubleProperty('overflowSpacing', overflowSpacing, defaultValue: 0));
```
The above setters follow the pattern of returning early if its the same, should this one too?
The above setters follow the pattern of returning early if its the same, should this one too?
Nit:
```suggestion
    final bool isRtl = textDirection == TextDirection.rtl;
```
```suggestion
      RenderBox nextChild() => rtl ? childBefore(child) : childAfter(child);
```
Nit/Suggestion:
```suggestion
  testWidgets('Empty OverflowBar', (WidgetTester tester) async {
```
Nit: Should probably be consistent with keeping/omitting the `.0` for doubles.
Nit: Unnecessary new line
üëç
üëç

üëç


üëç


üëç


üëç


üëç
I had it this way originally but I suffer from a personal loathing for logically capitalizing acronyms, so `rtl`.
üëç
üëç
üëç
I find that omitting the `.0` makes code easier to read however it was necessary to introduce one in these expressions so that they eval to doubles instead of ints. I realize that it's inconsistent but I've tried to be consistent about that.
I wonder if we should make this default match the material spec for button spacing? Or is that assuming too much? It would just be nice to just wrap an array of buttons with an `OverflowBar` with no params and have it match the old `ButtonBar` layout by default.
For a dialog you'd also need to end-align the OverflowBar and somewhere you need to ensure that the OverflowBar can be scrolled into view.

Using 0 for the spacing seemed appropriate for the widgets library since it's probably the wrong place to have an opinion about spacing.
Ah, I missed that it was part of the widgets library üòÑ. Totally makes sense for it to be there and that the default should be 0.
nit: double space
... will be still be ... ?
I believe `children` of an `MultiChildRenderObjectWidget` also cannot be null. Mention that in the docs and add an assert?
Is this calculation correct? I'd assumed that if width is big enough everything gets layed out in a row and then the hight would not be the sum of the children heights, no?
Yes, you are correct, this method is incorrect. The min intrinsic height should be: if the sum of child intrinsic widths fit, then the max child height, otherwise the sum of the child heights.
I've fixed this however I still need to add some tests for min/max intrinsic height.
It shouldn't be necessary to qualify Brightness with `ui.`. 
The extra level of indirection provided by `ThemeData.fallback()` doesn't provide much value. Maybe just use ThemeData.light() here. It's a little clearer.
This API doc should really incorporate a `[MediaQueryData.highContrast]` link somewhere.
This would be a good place to reiterate the link to the spec that we're matching. Here and below.
Fixed
Done
Done
Added a comment with a link but there is no published high contrast spec yet. These links can be updated once there is.
use a typedef here.
Probably just `VoidCallback`?
This probably deserves a comment explaining why we have this wrapper object instead of just using the `listener` directly.
Wondering if this would be even faster with a regular for loop. (The code would definitely be prettier without the casting).
Why's entry nullable?
What if `entry.listener()` calls `removeListener` for itself? Wouldn't that set `entry.next` to null and the iteration would end early? 
(If we don't have a test for this scenario, we should add one)
It is required by LinkedList. We cannot do `LinkedList<VoidCallback>`.

We could change `LinkedList<_ListenerEntry>` by `DoubleLinkedQueue<VoidCallback>` maybe?
`entry.next` may be `null` when reaching the end of the list. We need it to be nullable for the `entry = entry.next`
Ah, I see. I didn't look at the interface for LinkedList. Never mind. 
Makes sense. 
Good catch

I should add tests for `addListener(() { notifier.notifyListeners() })` too
... and O(N) _for_ removing ...
nit: the comma should be part of the previous line.
nit: let's call this localListeners again to avoid confusion.
nit, the " " (space) should be moved to the previous line.
nit - typo "immediately"
Could we avoid this copy by getting the next entry before we invoke the current entry's listener?
I wonder if any modification invalidates the list (theoretically). Iterable says modification during iteration is generally not allowed and may throw errors, although not necessarily for List. However can we do a lazy copy, i.e. only copy when the list is first modified during the dispatch?
@dnfield That would break the behavior of "listeners added during notifyListeners are not called immediately"

We could keep track of the last listener before the iteration to work around that. But the complexity is that removeListener can be called at any given time. So the "last listener" may change over time
lets move the check `parent._debugLifecycleState ==  _ElementLifecycle.defunct` to the first before we check attached
Done.
Can we do this one in a separate PR to make a potential revert easier? This one is a little more risky and may break things (see animations package).
ack - will update it tomorrow morning
Done
It's not clear to me what this additional doc is supposed to tell me. What is the context? (That context should also be added to the doc comment).
nit: I find the phrasing of this slightly confusing/misleding - e.g. where is the cache?

Perhaps something like this:

```
Loading an image from a file creates an in memory copy of the file, which is retained
in the [ImageCache]. The underlying file is not monitored for changes. If it does change, 
the application should evict the entry rom the [ImageCache].
```

We should add similar documentation on `FileImage` in the painting binding.
We should also explain _how_ to evict the image - which is a little difficult to do with an [Image.file] constructed widget, and so we should probably explain that if you expect the underlying data to chagne you should directly work with a `FileImage` provider so it can more easily be evicted on changes.
I think it would make sense to just explain in the docs above this they the provider does not monitor the file for changes and to call the [evict] method if the underlying image data changes.
Updated, thanks :)
I'd put the creation of the cache in `populate_script` of the cache instruction since cache might fail to be downloaded or have some other issue.
please add more context about what this flag does, and why it would need to be passed
there is an android unit test for passing debugging options, that should be expanded to cover this flag
there is also an iOS unit test for flag passing, please update
Added a few more context. Please let me know if that looks good.
Done.
Done.
How about something like

'''
Removes all existing persistent caches. This allows reproducing shader compilation jank that
normally only happens the first time an app is run, or for reliable testing of compilation jank fixes (e.g. shader warm-up).
'''
Nit: `tabbar` -> `tabBar`
Done
Doesn't this eliminate most of the files?
What about something like this instead? (and do use r'' strings).

```suggestion
final RegExp _pattern = RegExp(r'(<code[^<>]*>)(?!.*?<code[^<>]*>).*?({@[^}\n]*}).*?(<\/code>)');
```

And why do you have the `?` after the `}`? are macros expected to not be terminated? I mean sure, if someone is misspelling them, they can also not terminate them, but that seems unlikely.
Given this sort of error, do we want to just search for all words beginning with "@" outside of code blocks? Or is that too many false positives?
It eliminates class-level and library-level files. The majority of files are documentation for properties, which are getting checked. My hope is that we can get this fixed soon-ish on the dartdoc side.
Added `r`.

Since it is essentially free, I do want to catch the error where a macro is not terminated (or has been terminated with a `)` instead of a `}` etc).

I don't fully understand the regex suggestion. Wouldn't that match things inside a code tag?
Unfortunately, that has too many false positives. If that becomes a common source of error, we could also match on something like `(@foo}` and report an error for those.
Yes, I wasn't thinking about the regex in the right way: my suggestion would only match inside of a code block.  Please ignore it. :-)
Yeah, I figured. OK.
nit: Can you expand the doc comment above to include that this will return null if there's not enough data to fit a curve?
This one is surprising. I expected this to be non-nullable.
Why's `+=` no good anymore?
I am surprised that the return type can be null here. 
Why the `?` when the next line is a non-null check?
Oh, do getter and setter need to have the exact same type?
done
Not sure why I made it nullable :-/ Changed
I should have made `_pendingDragOffset` nullable at some point and change it again later. Updated.
It can be null because the catch block doesn't throw and then the result remains null
>do getter and setter need to have the exact same type?

Almost. The rule is that setter can accept the return of getter. See https://github.com/dart-lang/language/issues/331
This one can go back to `+=` as well then?
Fixed. Thanks!
nit: remove `catch(_)`
Done.
nit: don't use "we"

Can this be tested somehow?
I'm not sure if it's worth testing here since it's tested in the SDK, but DDS will throw an exception if another client is already connected to the VM service.
I suppose if this were accidentally removed, the devicelab tests would already be failing.
Yeah, the last time I tried to land this after I stopped swallowing the exception I found this issue. The iOS devicelab tests were very unhappy so it'd be hard to miss.
any reason not to remove on release builds too? It would probably be easier to test this if you removed the header on each request, see the existing devfs_web_test.dart
Probably not many people will use flutter run to serve their production app, but it is not recommended to remove it as this header is used to avoid click-jacking attacks. 

I don't think is possible to remove a default header in a request. When creating a response you can add a map of headers but don't see how to remove one. Also, I can't override it as the opposite(eg X-Frame-Options: ALWAYS) doesn't exist.

`shelf.Response.ok(_kDefaultIndex, headers: headers);`
> Probably not many people will use flutter run to serve their production app, but it is not recommended to remove it as this header is used to avoid click-jacking attacks.

But flutter run is still a debug mode essentially, its not a full app server. If it isn't safe for release mode it isn't safe for debug or profile mode.

Yeah, I'll admit I'm not familiar with the shelf APIs. This approach sounds fine as long as you test that the header isn't present somehow
```suggestion
      // Allow rendering in a iframe.
```
Not sure why we were specifying `color: Colors.white` before; it's OK to leave the parameter out now? Here and below.
I think so. I just checked this in dartpad and it looks fine without the white color for `RaisedButton`:

https://dartpad.dev/5c0e3ff90da4da543a2d850d1690f259

Not sure why it was specified in first place.
Glad to hear that it wasn't needed.
We should handle null here - I imagine we'd want to throw if it's null, but not throw like this.
If we timed out here, shouldn't we throw?
nit: avoid abbreviation - perhaps just call this `delta`?.

We should also document that delta is assumed to be in the `AxisDirection` of the scrollable.
This sentence isn't complete.
until `finder` is visible?

And I think the `and` should be an `or`.
The last clause here is awkward.

Maybe `but the caller must specify the scrollable that builds child specified by finder`?
Should have tests that test how this fails (e.g. what exceptions are thrown) on failure conditions.
I'm expecting throw will happen at `element(finder)`. See my added fail test case.
Done
Done.
Done. 
This sentence should have been deleted after I added timeout. 
Done
I added doc on throw. 
Not sure which `null` you mean but I added some `assert`. Let me know if I misunderstood it. 
Wouldn't the user want to know that the throw happened here because the timeout was hit? If we let element(finder) throw for us, it doesn't necessarily mean we timed out.
Ahh, maybe we should rename timeout to something like `maxScrolls`?
Changed `timeout` to `maxScrolls`. 
If `element` throws, The only way to exit the `while` loop is to trigger timeout. I agree `maxScrolls` should be more reasonable name here. 
We should assert that widget(scrollable) does not return null before using it.
`assert(scrollable.evaluate().isNotEmpty);` should do the job. And according to `WidgetController.widget` implementation  (https://api.flutter.dev/flutter/flutter_test/WidgetController/widget.html) this will not give `null` if there isn't such a widget but throw, which happens at `.single` (https://api.flutter.dev/flutter/dart-core/Iterable/single.html)
The finder isn't necessarily of that type
And if your concern is `Element.widget`, `assert(widget != null)` is in its constructor. 
> The finder isn't necessarily of that type

If the type is wrong, it won't give `null` either. Then what I should do is `assert(finder.evaluate().single.widget is Scrollable)`. But if I should do this, shouldn't that happen in `WidgetController.widget`?
Now that I had a look at other APIs, non of them are doing `assert(finder != null)` or `assert(finder.evaluate().isNotEmpty)` (e.g. `WidgetController.getSize`). Probably I shouldn't do this either. @dnfield what do you think?
removed those assert. 
The cases when we do assert != null is when getting renderObject from element, which makes sense because along widget->element->renderObject, we can have prior exists without latter, but not vice versa
Ahh ok, I see now. This would throw a cast error if it was the wrong type of widget already, not return null.
nit: instead of "we", document the part of the tool that is waiting normal.
Done.
```suggestion
    runApp(MaterialApp(home: Center(child: CountButton())));
```
Maybe
```suggestion
  /// Called to indicate that there should be a new frame after an optional delay.
```

And add in the doc
```
  /// The frame is pumped after a delay of [duration] if [duration] is not null,
  /// or immediately otherwise.
```
we should probably make it clear that the time that is advanced is the FakeAsync clock when you're using this in `flutter test`, and the real clock in live environments.
Similar things are already in the xxxTestBinding.pump. I added a sentence in `WidgetTester` for this but I don't think it should be in `WidgetController` because `WidgetController` does not necessarily come with a test binding and there isn't the context about FakeAsync because controller is assuming the binding to be general. 
I believe Android/iOS are not supposed to play a sound when you accidentally tap the undismissable barrier. Does this change that?
No, this doesn't change that, because Android/iOS don't have an API to play a system sound, so on those platforms, this platform channel message will be a no-op.
Can you document here what platforms support this?
Okay, let's add some documentation to `SystemSoundType.alert` that describes the behavior on the platforms to make this clear. 
I'd suggest investigating whether it makes sense to pass an `onError` callback to this `listen()`. If there is an error added to a `discoverer` stream, you probably don't want it to propagate asynchronously to the containing zone.
`discoverer.devices` is a `Future<List<Device>>`, I'm making it into a stream with `.asStream()`.  Are there cases there could be errors on that stream?  Streams give me heartburn.
I just realized this doesn't need to be a stream at all.
The edge case Zach mentioned is a bit more obvious when streams aren't used. In this case, after  `Future.any` completes the first future, the second future may still complete w/error. That would cause an unhandled exception to be thrown into the zone.

You could simulate this a similar 2 discoverer setup where one throws an error after another turn.
Done, added test for this as well.
I think this is almost the behavior we want, thought it's not quite the same as before. Previously if a discoverer crashed, we would surface that and go straight to crash logging. Especially if we don't match an exact device, knowing that some discovery has crashed is probably important, but I don't think that it should stop users from running on unrelated devices.

Unsure what the right solution is.
Maybe if there is any error, and the target device isn't found, print an error directing the user to `flutter devices` or `flutter doctor --verbose`.
I was happy with the old crashing behavior so we'd at least see it, but I'm still missing something related to why it matters if it's unhandled and thrown into the zone.

> That would cause an unhandled exception to be thrown into the zone.
I was actually wrong about this. Future.any will explicitly discard errors thrown by future's other than the first. I think what you have here is good
Great! Once this is proved to work, let's add ios and ios32 versions of this in another PR as those are currently flaky.
As we've discussed earlier today, this probably goes to the E2E package.
As discussed offline earlier, this `FrameTimingSummarizer` could either go to a standalone Dart package in `flutter/packages`, or we can put it into the SDK side by side with `FrameTiming`. For those who are monitoring Flutter's performance on real user devices, I think this class would be used hand-in-hand with `FrameTiming`. @Hixie : do you have any preference where we should put `FrameTimingSummarizer`? (We have to put it somewhere so many of our perf tests can depend on it instead of duplicating it multiple times.)
Can we use a `WidgetController` here instead of a more specific subclass `WidgetTester`?
A lot of the following code is very similar to `runDemo` in https://github.com/flutter/flutter/blob/master/dev/integration_tests/flutter_gallery/test_driver/transitions_perf_test.dart.

As we plan to preserve both Flutter driver timeline perf tests and e2e FrameTiming perf tests for a while (partially because timeline still has a lot more information that `FrameTiming` doesn't), it's probably better to use a single piece of code in both places. Maybe now is a good opportunity to let `FlutterDriver` implements `WidgetController` so we can share the code?

This would guarantee that driver tests and e2e tests are measuring similar animations, and avoid the risk that someone changes one test and forget to update another.
Yes, let's do this before landing the duplicate code into the repo :)
According to our discussion earlier today, it seems that we're not planning to measure transition duration in the e2e test. If so, why do we still do this Firebase specific work as only e2e tests can run on Firebase?
This piece is shared with the original flutter_driver based transition_perf test. I just moved it into an `if` so in the e2e it doesn't go through this by not providing a transition_duration file name. I don't know why it talks about firebase.
It's hard. `WidgetController` has everything depending on a binding (it can be a test binding or a real binding), but `FlutterDriver` doesn't have a binding. And the finder in `WidgetController` and that in `FlutterDriver` don't share base class. 
So to do that, the path in my opinion would be to write a mixin separating the controlling part (not the setting up part) of `WidgetController` and share this with `FlutterDriver`, and similarly for both finders. Even with that, there are some APIs doing the same thing but are named differently, meaning the result will be a breaking change. If we still consider abandon `flutter_driver` for driving the test, I don't think it will be worth it. 
Two things: `pumpAndSettle` and `pageBack`: 
- `pumpAndSettle` can be replaced by `pump` for a duration, and with policy not being `fullyLive` (which is fine because we don't need accurate control of time but want to wait the frame). The issue is, wait for settling in flutter driver I believe is part of adb (or its equivalence of iOS debugger), while here we are forced to estimate the time, resulting in potentially extra frames, meaning the metric may not be a faithful equivalence of the original driver test; 
- `pageBack` can be implemented separately or promote to `WidgetController`. To promote, I need to delete this line: https://github.com/flutter/flutter/blob/30aef0a3b9611763f8e60985e7cca9cb30c1ea6a/packages/flutter_test/lib/src/widget_tester.dart#L1072 because `WidgetController` doesn't have a test context and doesn't have this expect stuff. Justification for this is `WidgetController` is not `expect` one widget for other finders in the API, so is other places for `WidgetTester`. I'm not sure if I should.  
I think our conclusion is both this and the summarizer can first go to a separate package in a personal repo, and then to flutter/packages. 
Or alternatively, make `pumpAndSettle` an abstract method in `WidgetController` and implement it in `LiveWidgetController`. The tricky part is that there's a `EnginePhase phase` optional order/un-named argument in `pumpAndSettle` in the middle of `duration` and `timeout`. `duration` and `timeout` should be part of the API but `phase` only makes sense for `WidgetTester`. This will be a breaking change but luckily ALL `pumpAndSettle` calls in the repo doesn't use this argument. 
A demo of the change #62640 
Oh, sorry that I remembered wrong. I had a second thought that `watchPerformance` might go to E2E because it seems to be just for reporting with the E2E binding. Either way should work and the difference seems to be either letting E2E depend on your new package, or letting your new package depend on E2E.
Just to add more info: along side with `FrameTiming` means it will be in the flutter/engine repo. 
Hmm... your concerns seems to be very legitimate. In that case, for Flutter driver timeline perf tests, can we just control the test inside `transitions_perf.dart` which is running on device instead of `transitions_perf_test.dart`? Then it seems that the host side `transitions_perf_test.dart` only needs to send a signal to device to start the control sequence (and the host will start capturing the timeline tracing events). The device-side code in `transitions_perf.dart` should be shareable with the E2E test?
Ah, I didn't realize this code was already there before your PR. It seems to be added by @yjbanov 4 years ago https://github.com/flutter/flutter/blame/30aef0a3b9611763f8e60985e7cca9cb30c1ea6a/dev/devicelab/lib/tasks/gallery.dart#L47.

Yegor: do you still remember why we're doing this as I'm pretty sure we're not using Firebase test lab until very recently? What could happen today if we remove it (the gallery transition test is still not running on Firebase yet)?
Haven't tried but sounds do-able. If that's the case the issue I mentioned above about using `WidgetController` and thus #62640 becomes necessary, and the measured result may be different with the original flutter_driver ones because it's almost a new test (a host-driven and self-driven hybrid test). Will try after #62640 lands . 
Done.
Done.
Done. This part I think I missed in our previous discussion. I also moved it to the new package `end_perf` but I think it might be better to e2e, replacing current `e2e_driver`. 
Why are we removing `kDebugWarning` here?
Done with the newly merged `pumpAndSettle`. 
https://github.com/flutter/flutter/pull/62064/commits/3e83f94d0c67a46bcb653966bd49cd208b6b2ea7 is an implementation of making `flutter drive` test share the driving code with the e2e test (making it a hybrid of host-driven and self-driven). 
I now removed this extra work, but I'll wait to see if there's anything breaking that we didn't realize. 
This diff looks strange.

Maybe remove `flutter_gallery_instrumentation_test` in a separate PR to make it cleaner?
If we plan to use this file both in e2e and flutter_driver-timeline tests, maybe we should rename this file?
It was moved to e2e_perf (watchPerformance). Now I will need to find a new place for it. 
Nope, this file is not reused as a whole. For the reused version `run_demos` function will be in a separate file. 
Somehow during rebase it goes in. It's removed now. 
Nit: add a TODO here with a Github issue to remove this file once it made into e2e.
Do you already have a plan on how to avoid this message?

From here, it's unclear how severe this warning is, and how it might be fixed. If there's no immediate plan to fix this, having more details here or in a Github issue may help a lot in the future.
Done
Ahh I should have removed it long before. This is due to the early version of `e2e_driver` doesn't expose timeout API. After the `timeout` is set to a good value this warning is no longer there. 
This has been around forever, but it'd be really nice if we could suppress the non-JSON text like this when `--machine` is in the args üòÑ
It should be safe to write this to stderr too, right? I was looking at this a while back but that change ended being hard to land due to integration tests asserting stderr was empty
Hmmm, not sure.. I think there are probably many places that assume stderr is for errors. I think PowerShell may also (or at least used to?) print stderr in scary colors.. some common tool like Git was always causing my grief because it wrote some status messages to stderr and made it look like it'd crashed üòû
ack
If we're disallowing color changes in the logo widget, why allow them here?
No good reason. I'll remove it from here as well.
```suggestion
    // Test TextField's cursor & selection color.
```
```suggestion
    // Test the selection handle color.
```
```suggestion
    // Test TextField's cursor & selection color.
```
```suggestion
    // Test the selection handle color.
```
```suggestion
  testWidgets('ThemeDate.textSelectionTheme will be used if provided', (WidgetTester tester) async {
```
```suggestion
    // Test TextField's cursor & selection color.
```
```suggestion
    // Test the selection handle color.
```
```suggestion
    // Test TextField's cursor color.
```
```suggestion
    // Test SelectableText's cursor color.
```
```suggestion
    // Test the selection handle color.
```
```suggestion
    // Test TextField's cursor & selection color.
```
Please add the diagram that you have on the PR to the docs: that makes it super clear what you're talking about.
We seem to be on a nice trajectory here :-). How about : The color of the cursor. Here and elsewhere and in general.  For example: The color of the TextField's selection handles, instead of "The color used to paint the selection handles on the text field".
Doesn't indicate the current text insertion point? Here and elsewhere.
that defines the configuration for the rendering of text selection => that defines the appearance of text selection
This works because the TextField doesn't actually use TextSelectionTheme directly right? Otherwise we'd have to include a Builder.
NICE
`TextField` looks up the current theme with `TextSelectionTheme.of(context)` in the build method, so it should work fine here.
```suggestion
  /// found, then this method will return null instead of throwing.
```
You might add a comment that you can detect whether or not the action is available (found, and not disabled) using `Actions.find` with its `nullOk` set to true.
Done
Done
This is a bug fix. Previous runs with `--profile` is fine so this `assert` isn't a critical check. And the original version neglect the fact that old events will fade.  
`usually considerred` -> `usually be considered`
`location` -> `startLocation` might be clearer.

Nit: It may be helpful to document that `Offset center, Offset totalMove` means dragging from `center - totalMove / 2` to `center + totalMove /2`. Alternatively, it may be more intuitive to take `Offset fromLocation, Offset toLocation` and just drag from `fromLocation` to `toLocation`.
`moveEventCount` might be clearer than `intervalCount`.
The integer milliseconds observed from devices look suspicious to me... Did we lose the precision somewhere in the engine? Even with 60hz input, 16ms or 17ms seem to be sufficiently different from 16.67ms which could make resampling be ~4% off?
Also document that the jerk here is not `$ d^3 x / dt^3 $ as typically defined in physics. Your explanation in the PR description should be helpful here.

Ideally, the `jerk` and `jank` should be documented in the signature of this function as these are the return of this function.
My very early work of recording gestures shows that, all touch screen event has timestamp of milliseconds precision. For mouse input in desktop and web Flutter the event timestamp is microsecond. I think you can still find those datas in our 1:1 docs. 
I think that's from the OS level, not the engine. 
Done
Done
Done
Done.
Nit: filename `scroll_smooth_measure.dart` sounds a little strange. Maybe `measure_scroll_smoothness.dart`?
It would be interesting to also add a 59hz-input-60hz-display case that simulates the Fuchsia usage. I think we can do 2 cases in this single test by extending your `TestVariant`?
Are the following lines in the gradle file needed to make the test run, or are they just added to keep this gradle file up to date with other gradle files generated by `flutter create` with a newer Flutter version?

If these are specific to this test, it might be nice to document why they're needed as it doesn't look to be obvious.
How's this `40E3` picked?
This paragraph above is a little hard to read... Maybe the following is better
```
/// For smoothness it filters out the frames that either are delayed for too long, 
/// or are too slow to build. Those frames are counted in `dropped_frame_count`.
```
`go/tq-smooth-scrolling` is internal so delete it.
"Smoothness (`abs_jerk`) is measured by  the absolute value of ...",
"Its average (`average_abs_jerk`) is calculated for the overall smoothness",
"frames with `abs_jerk` larger than 0.5 is counted to `janky_count`".

Let's also refactor the code to rename `jerk` to `absJerk` to make it consistent with the documentation and report keys.
"not using" -> "using"
It's copied from what's in `flutter create` and is necessary to load e2e plugins. Without this I will get: 
```
Plugin project :e2e not found. Please update settings.gradle.           
/Users/minglyu/flutter/dev/benchmarks/complex_layout/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java:4: error: package dev.flutter.plugins.e2e does not exist
import dev.flutter.plugins.e2e.E2EPlugin;                               
                              ^                                         
/Users/minglyu/flutter/dev/benchmarks/complex_layout/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java:14: error: cannot find symbol
    E2EPlugin.registerWith(registry.registrarFor("dev.flutter.plugins.e2e.E2EPlugin"));
    ^                                                                   
  symbol:   variable E2EPlugin                                          
  location: class GeneratedPluginRegistrant                             
2 errors                                                                
                                                                        
FAILURE: Build failed with an exception.                                
                                                                        
* What went wrong:                                                      
Execution failed for task ':app:compileDebugJavaWithJavac'.             
> Compilation failed; see the compiler error output for details.        
                                                                        
* Try:                                                                  
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
                                                                        
* Get more help at https://help.gradle.org                              
                                                                        
BUILD FAILED in 27s   
```

I didn't add comments because it's just updating this to newer version, and newer test cases in `dev/benchmarks` are already the newer version. 
Moved it to overall comments about the return value. 
Done. 
Done.
Done. 
I tried 35 and 45 and find the result qualitatively same. I'm expecting it to be a few frame interval. With single frame like 16 or 17ms the result has significant fluctuation in my early test. 
My apology! I tested it again on iOS and also android devices and lost that pattern. I can't find why in the beginning of my project I found that pattern. I'm removing to integer millisecond part.
Please use https://master-api.flutter.dev/flutter/foundation/mapEquals.html from the foundation library instead of importing package:collection
Okay thanks for telling. :)
Nit: There should be a line break here.
Style nit, here and below:
```suggestion
    const Map<int, MaterialColor> sampleMap = <int, MaterialColor>{
      0: Colors.lightBlue,
      1: Colors.deepOrange,
      2: Colors.blueGrey,
    };
```
Done!
okay :)
nit: space after `if`
nit: indent by 2 everywhere
This example uses a [LayoutBuilder] to build a different widget depending on the available width.
Optional suggestion: This will make the sample an interactive dartpad, which means you can resize the window and actually see this in action! :)

```suggestion
/// {@tool dartpad --template=stateless_widget_material}
```
If you choose dartpad:
```suggestion
/// This example uses a [LayoutBuilder] to build a different widget depending on the available width. Resize the
/// DartPad window to see [LayoutBuilder] in action! 
```
The analyzer is failing due to a trailing whitespace here.
I forgot to mention, making this a dartpad means we can remove this boilerplate.
```suggestion
```
```suggestion
```
Here's a dartpad example: https://github.com/flutter/flutter/blob/e64fe11542238376fdfbf351d81e22d08296da45/packages/flutter/lib/src/widgets/basic.dart#L4563 :)
In the other NNBD PRs this annotation was completely removed once a file was migrated. Why keep it here?
Oops, sorry. It was old code I didn't change.
Just checking - 'iff' as in 'if and only if', or typo?
Yeah I meant "if and only if".
As a recursive void method, the name `getViewHierarchy` seems confusing. How about `updateViewHierarchyString`?
Line at the end of file
Done.
Done.
Add a TODO to add the test back, and (nit) since we do need a rewrite, this is probably ok to just remove, but may also consider using `}, skip: true);`
added a TODO
Don't you want to have some expectations after this line?  Or is it just that you expect it to not crash? At the least, you might want to verify that the `Text` actually received a hover event (in which case, you probably want to surround it with a `MouseRegion`).
I'm just expecting it not to crash (or rather, not to trigger the assert in the original version before the PR, since that one can actually run on profile mode). The `location` can be anything in the app for the test purposes but it's just `moveTo` has to have a location. 
But let me know if you think I should catch the event. @gspencergoog 
I would suggest at least one expect in there that makes sure that the hover event occurred. Something like:
```dart
  testWidgets('Input PointerHoverEvent', (WidgetTester tester) async {
    PointerHoverEvent hoverEvent;
    await tester.pumpWidget(MaterialApp(home: MouseRegion(child: Text('Test'), onHover: (PointerHoverEvent event){
      hoverEvent = event;
    },)));
    await tester.pumpWidget(const MaterialApp(home: Text('Test')));
    await tester.pump();
    final TestGesture gesture = await tester.createGesture(
        kind: PointerDeviceKind.mouse);
    final Offset location = tester.getCenter(find.text('Test'));
    // for mouse input without a down event, moveTo generates a hover event
    await gesture.moveTo(location);
    expect(hoverEvent, isNotNull);
    await gesture.removePointer();
  });
```

It just makes it clearer that the test does something: without any expectations, someone (like me!) might look at the test and wonder if it is testing anything, or if the expectations were just accidentally omitted.

At the least, you could have a comment saying that the test is expected to not assert (which is probably all you can do for the first test in the file).
Done with a little different. 
`initCommand` doesn't need to be a function, you can re-use the same List<String> in both spreads.
I don't think this one is really carrying its weight
since this isn't a function any more I would name it something like "sharedArgs"
How about sharedCommandOptions?
Sounds good!
could you leave this on the same line?
By having `_handleViewNeedsPaint` inside the `if else if` branch, it seems that `_handleViewNeedsPaint` won't be called for hover events now but it was called before this change? I wonder if that's intended, and whether hover should trigger some painting.
It's intended, because 
1. the original version, if I neglect the problematic `assert` sentence and considered it an `if`, basically doesn't draw hover event;
2. If we are to draw hover event and scroll event, I would think a better practice is to have a separate list/map for that and keep the original one just for down event, because it's more meaningful to plot them in a different way.  
To paint hover event, would probably better to be a TODO, if we decide to paint it. 
To clarify, `paint` method for this class is only painting `_pointers` data. So if all events are down-move-up, than it always needs paint. But for other events, it originally should violate the assert, and nothing will be added to `_pointers`, so it's a fake (literally, not in the test sense) `_handleViewNeedsPaint`.
Discussed with @CareF offline. This `_handleViewNeedsPaint` only triggers repaint of the `_pointers` positions which do not include non-down (e.g., hover) pointers. So we don't have to call it if it's not down or already tracked in `_pointers`. The repaint of the test app should be driven by `super.dispatchEvent` and that should be the place where the test app responds to hover repaint.
nit: prefer not shadowing parameter names in the enclosing class, which can get confusing.  I don't have a great idea for a name here.

This does make me wonder if there are other cases we should be explicitly passing the isolate reference around though.
Is there a reason we're not just setting the outter `isoalte` to `isolateRef.load()` here?

Should we be asserting `isolate == isolateRef.load()` somehow?
Ahh I see, this could be other isolates the application uses that also started paused, right?
Analyzer wants a type annotation on this array.  
nit:
```suggestion
  /// Input that always occupies at least 2 lines and has an infinite max.
```
Fixed in new commit
Don't forget CupertinoTextField!

```suggestion
  /// These apply equally to `TextField`, `TextFormField`, `CupertinoTextField`,
  /// and `EditableText`.
```
I think this could be confusing because the horizontal limit isn't exactly *specified* (it's the width constraint). Also, you don't have to hit the horizontal limit when newline characters are used.  Maybe just say "Expands vertically as needed."?

```suggestion
  /// Expands vertically as needed.
```
Just formatting the lines here:

```suggestion
  ///
  /// If the value is set, it must be greater than zero. If the value is greater
  /// than 1, [maxLines] should also be set to either null or greater than
  /// this value.
```
Done :)
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
Nit: This can all go on one line
If this fails, I assume we're OK with the default exception handler's report?
Yeah. I don't think it can be improved.
`To do set` -> ` To set`?

Nit: `a normal test` -> `a normal unit test`, and add `{}` to the `if` in the sample code?
I think our API doc should start with a short paragraph with a sentence. The old doc does not seem to follow that convention. Maybe we shall fix it too. CC @Hixie @goderbauer 
> Nit: `a normal test` -> `a normal unit test`

I think it's not necessarily a unit test. This is more often used for integration and performance test. 
Done other than the above. 
Added a new sentence. 
Yes, if you have the chance please change the first paragraph to a one-sentence summary.
@CareF : your `git push` probably failed as Github still shows your commit 6 days ago as the last commit.
> @CareF : your `git push` probably failed as Github still shows your commit 6 days ago as the last commit.

My bad! I pushed again. @liyuqian 
Nit: `triggered` -> `[pump]ed`?
Nit: is `ignores [scheduleFrame] requests from the framework` more accurate than `prevents the framework from requesting any frames from the engine itself.`?
Nit: `pump` -> `[pump]`
Nit: `new frame` -> `artificially [pump]ed frame`?
`and for requesting` -> `and requesting`?
I'm not sure I should use `pump` here because it's not only from pump but also from animation. I'll leave this to @sfshaza2 for language advice. 
`prevents the framework from requesting any frames from the engine itself.` is the original version in `LiveTestWidgetsFlutterBinding.framePolicy` doc I moved from. I agree the new version but will leave this conversation un-resolved for visibility. 
`new frame` is the original version. But I agree this is more clear. Also leave it open for visibility. 
means => results in 
which might => and might
If you know your test file wouldn't be => If you know that your test won't be.....
set it to => set the policy to
persistently in that particular test file => in that particular file.
By "a normal test" do you mean one that won't call pump extra times?
Maybe:
```
To set a policy that won't cause the test to pump extra frames,
add the following to the `main()` function, before calling
[testWidgets]: 
```
The major difference with what? fadePointers?
```
The major difference between [fadePointers] and [benchmarkLive] is that the latter ignores...
```
OR
```
The major difference between this policy and [benchmarkLive] is that the latter ignores...
```
Perhaps:
```
This allows all frame requests from the engine to be serviced (including frame
requests that are artificially triggered), but...
```

I wouldn't use pumped instead of triggered.
=>
```
Therefore, animations won't run in this mode because the framework
generates an animation by requesting new frames.
```
I'm having trouble unpacking this sentence:
```
Compared to [fullyLive] this policy ignores the frame requests from [pump]
of the test code so that the frame scheduling respects the situation of
that for the real environment, and avoids waiting for the artificially
[pump]ed frame frame when driving the test in methods like
[WidgetTester.handlePointerEventRecord] or [WidgetTester.fling].
```

??? Perhaps the following?

```
Compared to [fullyLive], this policy ignores frame requests from [pump] 
so that frame scheduling mimics that of the real environment,
and avoids waiting for an artificially[pump]ed frame.
(For example, when driving the test in methods like
[WidgetTester.handlePointerEventRecord] or [WidgetTester.fling].)
```
=>
```
This policy differs from [benchmark] in that it can be used for capturing
animation frames requested by the framework.
```
I like the new sentence, but the sentence after that. Oy. 

Original sentence:
```
  /// Whether to have [pump] with a duration only pump a single frame
  /// (as would happen in a normal test environment using
  /// [AutomatedTestWidgetsFlutterBinding]), or whether to instead
  /// pump every frame that the system requests during any
  /// asynchronous pause in the test (as would normally happen when
  /// running an application with [WidgetsFlutterBinding]).
```

Clearer sentence:

```
  /// Whether [pump] (with a duration) pumps a single frame
  /// (as would happen in a normal test environment using
  /// [AutomatedTestWidgetsFlutterBinding]), or
  /// pumps every frame that the system requests during an
  /// asynchronous pause (as would normally happen when
  /// running an application with [WidgetsFlutterBinding]) ...
```

Then what? The original sentence needs a final clause. Whether it's one pump or many... what then?
I didn't write this but I think normal here just mean the test is like what we typically write a test, not the kind of test with tricky hack. 
I'll keep the original version because `artificially triggered` is from test file, not the engine. 
Done
Done
Done with the second. 
Done
Modified to your version. 
I changed the sentence to "The policy decides ..." to make it complete. I can't think of a clause. 
This is where the actual widget cache logic will go. Once this PR lands, the only thing that needs to be done is to wire it up, pending some agreements about the parser APIs
analyzer started flagging these for some reason
TIL about `&=`
should this be `printError()`?
this method is pretty massive, not a nit, just an observation
In this case, its okay for this method to fail - the tool can fallback to the regular re-assemble and still do a hot reload. I'd like to leave this as a trace to be a bit more conservative
Yeah, historically it was really hard to change because we didn't have good test coverage. And the last time I changed it significantly I accidentally broke hot reload for some people :( 
nit: small doc comment describing what it does
doesn't need to be `async`
@jonahwilliams another option is to remove this from the high level context, and instead make it required to initialize `XCDevice` since that's the only place it's used.
https://github.com/flutter/flutter/blob/859fce9010895ce5bcdb913a8373b5b1a194a1fb/packages/flutter_tools/lib/src/context_runner.dart#L250-L257

would become:
```dart
 XCDevice: () => XCDevice( 
   processManager: globals.processManager, 
   logger: globals.logger, 
   artifacts: globals.artifacts, 
   cache: globals.cache, 
   platform: globals.platform, 
   xcode: globals.xcode, 
   iproxy: IProxy(
     iproxyPath: globals.artifacts.getArtifactPath(
       Artifact.iproxy,
       platform: TargetPlatform.ios,
     ),
     logger: globals.logger,
     processManager: globals.processManager,
     dyLdLibEntry: globals.cache.dyLdLibEntry,
   ), 
```

This would make
https://github.com/flutter/flutter/pull/61762/files#diff-ebc648b2067d73f2af30539f5d3a59faR503
become:
```dart
iProxy: _iproxy,
```
IMO Leaving/Removing from the context injection isn't really that important. As long as we're not introducing more globals into classes that have already been cleaned up, I have a separate plan to remove the context w/o breaking g3
`XCDevice` is close to being cleaned up, I already did this exercise with https://github.com/flutter/flutter/pull/53203 (which was further pushed down in https://github.com/flutter/flutter/pull/53307,  we can't do in this case since g3 wants to override). 
I've just convinced myself, I'm going to do this pattern from the beginning.
Are these changes here related to the fix, or just cleaning up something? I assume scope can no longer be null when it might have before?
Actually, I made those changes thinking that these couldn't ever be null, because the `rootScope` can't be null, but if the `_manager` is null, it still could be.  I reverted these.
nit: remove empty line
nit: remove empty line.
I had this name wrong in the last PR. Fixed it here.
üëç
Good catch adding these missing properties!
You should be able to use a pumpAndSettle here and below instead of the multiple pumps and durations, if you haven't tried it already.
I could only replace one, I think it has to do with the cursor blinking and the timing needing to be right
Strange, is the `pump` without a duration needed as well?  And what if you combine the two with durations into one with `Duration(seconds: 1)`?

There are [other tests](https://github.com/flutter/flutter/blob/f98a00c7506a0a4a3a53372e574a048a884ca03b/packages/flutter/test/material/text_field_test.dart#L1664-L1666) that do this sort of thing, though not testing the cursor size.

Anyway I think the main thing is to just make sure it's clear to someone else reading this code why the pumps are there, so maybe just add a comment.
It wasn't, I simplified this test and others doing the same thing, and added a comment
```suggestion
/// app. When using [SliverAppBar.flexibleSpace], the [SliverAppBar.expandedHeight]
/// must be large enough to accommodate the [SliverAppBar.flexibleSpace] widget.
/// 
/// Furthermore is included functionality for stretch behavior. When
/// [SliverAppBar.stretch] is true, and your [ScrollPhysics] allow for
```
We can simplify this a bit, and let's actually move it to the 'flexibleSpace' of the `SliverAppBar` class where it is relevant.
The `AppBar` does not have an `expandedHeight`.
```suggestion
  /// When using [SliverAppBar.flexibleSpace], the [SliverAppBar.expandedHeight]
  /// must be large enough to accommodate the [SliverAppBar.flexibleSpace] widget.
  ///
```
Sure @Piinks I will make the required changes.
All the daemon commands are exclusively machine mode, so defaulting to true instead might make more sense here
formatting is kind of weird. Would get on one line or use 2-space indent
Add a comment to explain here. Probably link to the comment that proposed the workaround.
+1
done
qq: how does this ensure that pointer id doesn't reach the limit? As pointed out in https://github.com/flutter/flutter/issues/61421#issuecomment-659715358
The `MotionEvent` pointer ID limit is an internal Android implementation detail that AFAICT isn't documented anywhere.

This patch ensures that the pointer ID value will be less than the number of active pointers.  The version of Android that I looked at apparently accepts pointer IDs in the range 0 through 31.  So realistically this patch will keep the pointer ID values within a safe range given that a user is unlikely to have >32 pointers active simultaneously.

Given that it isn't a defined part of Android's API I didn't want to try to hardcode a limit here.  But we could enforce a maximum number of active pointers on the framework side if this is a concern.

```suggestion
  /// Defaults to [AutovalidateMode.disabled] if `autovalidate` is false which
```
Turns out this is a breaking change. The public field is removed, not deprecated.

This affects (at least) [flutter_form_builder](https://pub.dev/packages/flutter_form_builder).
https://github.com/danvick/flutter_form_builder/issues/465

Ideally, should (with appropriate deprecated tag) put something like
```dart
bool get autovalidate => autovalidateMode != AutovalidateMode.disabled;
```
@pedromassango oops did we miss this one?
Hmm. Just checked `form.dart` file and I don't see any reference for `final bool autovalidate`. We did removed this intentionally in favour of AutovalidateMode property.

Maybe this is referencing a old commit file?!
> bool get autovalidate => autovalidateMode != AutovalidateMode.disabled;

This is interesting and would prevent the breaking changes ü§î 
@chunhtai do you think this we should put it back?
@skyeskie
What are the use cases of using this Widget's property?
I think we should put this one back, but we should do
```
autovalidateMode = autovalidateMode ?? autovalidate ? AutovalidateMode.always : AutovalidateMode.disabled
```
Same as what we do for other formfield
Alright, I will send a PR to put it back ASAP
`FormField` has the exact same issue (below, 363-368)

@pedromassango
I personally don't use this, but just ran across when `flutter_form_builder` refused to compile, specifically when it tries to access `autovalidate` on `FormField` in its `FormBuilderCustomField` class [here](https://github.com/danvick/flutter_form_builder/blob/2d5f61b3863b058b9b6213aac25f6b62b65bd44e/lib/src/form_builder_custom_field.dart#L96).
The PR is: https://github.com/flutter/flutter/pull/66267

@chunhtai I think we should add it back on formField widget too, right?
`FakePlaatform` has a typoo
Thaanks!
Nit: `run_app.dart` may be better?
Done
`-t test_driver/run_app.dart`
`cubic_bezier_perf` is not just for the SkSL shader wram-up. As you noticed before, `cubic_bezier_perf__timeline_summary` is a normal driver test without SkSL, and only `cubic_bezier_perf_sksl_warmup__timeline_summary` involves SkSL.

Therefore, I think one should still be able to use `flutter drive -t test_driver/run_app.dart --driver cubic_bezier_perf_test.dart` to run the non-SkSL test locally.

I wonder if `cubic_bezier_perf_sksl_warmup__timeline_summary` had any troubles if you did the change above?
> I wonder if `cubic_bezier_perf_sksl_warmup__timeline_summary` had any troubles if you did the change above?

It runs as expected, but it may make difference in therms of the performance metrics. Locally I don't see significant difference except for `worst_frame_rasterizer_time_millis`, but that one is usually flaky. 

I still added the change but let me know if I should revert it. 
Done
It's fine to change `createCubicBezierPerfTest` as is now. You may need to also update `createCubicBezierPerfSkSLWarmupTest` and make sure that `cubic_bezier_perf_sksl_warmup__timeline_summary` devicelab tasks run successfully locally.

For this README file, I don't think you have to give a special treatment to `cubic_bezier_perf`. You should be able to just include it as a normal `[test_name]`.

Finally, what `worst_frame_rasterizer_time_millis` difference numbers are you seeing? Is it for `cubic_bezier_perf__timeline_summary` or `cubic_bezier_perf_sksl_warmup__timeline_summary`?
> Finally, what `worst_frame_rasterizer_time_millis` difference numbers are you seeing? Is it for `cubic_bezier_perf__timeline_summary` or `cubic_bezier_perf_sksl_warmup__timeline_summary`?

40ms for using run_app and 12 ms for using the warmup version. 
I don't see anything for `createCubicBezierPerfSkSLWarmupTest` that needs updating. 
Oh, you didn't remove `cubic_bezier_perf.dart`. I think you can remove it and just let `createCubicBezierPerfSkSLWarmupTest` use `run_app.dart` too.

In terms of the performance difference, 40ms/12ms might be within the [noise range][traces]. Do you have detailed numbers, like is it within the range of 80ms-120ms for the non-warm-up version?

[traces]: https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3Dworst_frame_rasterizer_time_millis%26test%3Dcubic_bezier_perf__timeline_summary%26test%3Dcubic_bezier_perf_sksl_warmup__timeline_summary
I should have mentioned, my numbers are tested on Pixel4 rather than Moto G4. Moto is always flaky on my local side due to #59263. And the difference I mean both using `PerfTest` (or equivalently `flutter drive`) but with `run_app.dart` or `cubic_bezier_perf.dart` (this includes some codes for warm up). Test takes quite some time. I'll test a couple more times before updates.
Update: run 4 times for using `run_app.dart` and `cubic_bezier_perf.dart` for `createCubicBezierPerfTest` on MotoG4. No significant difference is observed, but `worst_frame_rasterizer_time_millis` looks slightly better for `cubic_bezier_perf.dart` (89.064, 83.331, 94.123, 83.505 vs 97.895, 87.275, 100.392, 106.045). 
Line 31-35 could be removed as we'd still prefer `flutter drive --profile -t test_driver/run_app.dart --driver cubic_bezier_perf_test.dart` . I also created https://github.com/flutter/flutter/issues/61757 to track the removal of `cubic_bezier_perf.dart`.
Done. 
This is definitely something we could clean up to0, by just checking in a handwritten package config.
(not now)
```suggestion
        expect(result.messages.first.message, contains(mockDevice.id));
```
I believe the message types have equality defined, so you could do:

```dart
expect(result.messages, [
  ValidationMessage(...),
  ValidationMessage(...),
]);
```

This will probably give a better error if the length changes
nit: remove else and un-nest return
by convention property names should typically lower case. So perhaps
'router', 'route', and 'event' instead of PointerRouter, PointerRoute, and PointerEvent.
similarly, renderObject instead of `RenderObject`.
for this one you should give the property a lower priority level as you don't want it to actually show up as that will make the error confusing to read. I think `level: DiagnosticsLevel.debug` is what you want. https://api.flutter.dev/flutter/foundation/DiagnosticLevel-class.html
Could these two be `late final`?
Actually, it looks like completer could just be final and initialized right here instead of in the constructor?
Indeed!
I would expect this one to always return a non-null value. At the time when you can read it, `_lifecycleState` has always been initialized.
Since you changed it above: Change this one also to the new function syntax?
Changing this line to:

```
AppLifecycleState get lifecycleState => _lifecycleState!;
```

causes a lot of failures in tests. For instance:

```
Null check operator used on a null value
  package:flutter/src/scheduler/binding.dart 340:58   SchedulerBinding.lifecycleState
  package:flutter/src/services/binding.dart 180:9     ServicesBinding.readInitialLifecycleStateFromNativeWindow
  package:flutter/src/services/binding.dart 34:5      ServicesBinding.initInstances
  package:flutter/src/gestures/binding.dart 66:11     GestureBinding.initInstances
  package:flutter/src/semantics/binding.dart 24:11    SemanticsBinding.initInstances
  package:flutter/src/rendering/binding.dart 32:11    RendererBinding.initInstances
  package:flutter/src/painting/binding.dart 23:11     PaintingBinding.initInstances
  package:flutter/src/widgets/binding.dart 257:11     WidgetsBinding.initInstances
  package:flutter_test/src/binding.dart 302:11        TestWidgetsFlutterBinding.initInstances
  package:flutter_test/src/binding.dart 898:11        AutomatedTestWidgetsFlutterBinding.initInstances
  package:flutter/src/foundation/binding.dart 57:5    new BindingBase
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding&PaintingBinding
  package:flutter_test/src/binding.dart               new _TestWidgetsFlutterBinding&BindingBase&SchedulerBinding&ServicesBinding&GestureBinding&SemanticsBinding&RendererBinding&PaintingBinding&WidgetsBinding
  package:flutter_test/src/binding.dart               new TestWidgetsFlutterBinding
  package:flutter_test/src/binding.dart               new AutomatedTestWidgetsFlutterBinding
  package:flutter_test/src/_binding_io.dart 25:7      ensureInitialized
  package:flutter_test/src/binding.dart 298:100       TestWidgetsFlutterBinding.ensureInitialized
  package:flutter_test/src/widget_tester.dart 123:71  testWidgets
  material/tabbed_scrollview_warp_test.dart 79:3      main
  package:flutter_goldens/flutter_goldens.dart 43:17  main
  dart:async                                          _completeOnAsyncReturn
  package:flutter_goldens/flutter_goldens.dart        FlutterLocalFileComparator.fromDefaultComparator
  dart:async                                          _completeOnAsyncReturn
  package:flutter_goldens_client/skia_client.dart     SkiaGoldClient.getExpectations
  dart:async                                          _completeOnAsyncReturn
  package:flutter_goldens_client/skia_client.dart     SkiaGoldClient.getExpectations.<fn>
```
Done
Thanks for fixing the string `four` to `three`. However, can you leave these all as `1.`'s, so that they can be re-ordered, new ones added or existing ones removed without needing to edit each number?
Okay I will change them to `1.` again @christopherfujino 
Grammatically I think the original was correct, there is a single description, and it should be both "clear" and "concise".

```suggestion
     concise description of what the problem is.
```
I can't visually see the diff on this one...what was the change?
I think the original was correct. Consider the (simplified) version: "It's powered by the same graphics library that underpins Chrome and Android". Now with modifiers to "graphics library", "powered by the same hardware-accelerated Skia 2D graphics library that underpins Chrome and Android." Alternatively, this sentence could be re-written "It's powered by the same hardware-accelerated 2D graphics library that underpins Chome and Android: [Skia]."
It is the final space, highlight both and you will be able to see it üëÄ

It is my markdown linter, says it is best practices. if you think it is not necessary I will remove it as soon as possible
Yes, I totally agree with you üëç
As development is in the present tense, I think the original was preferable.

```suggestion
during development of the framework. The tools in this directory
```
what's the diff here?
this is actually referring to "layer performance", so I believe the original is preferable.

```suggestion
  low-level engine primitives, such as layer, picture, and semantics performance.
```
The clip art library is not "the public domain", it is either "public domain", or more explicitly "in the public domain".

```suggestion
Which is public domain.
```
I would agree but try reading it like this:

This directory contains tools and resources that the Flutter team uses during the development of the framework.

The verb `uses` is present so I think it is correct. It symbolizes present tense

Try highlighting both together. The extra space after the period is removed.
Ah okay, tbh I was confused here so I will change it.
Okay üëç, "in the public domain" is more descriptive
Probably `"the"` is more accurate here.

```suggestion
Running the devicelab will do things to your environment.
```
This is actual log output, please don't reformat.
Yea You are so right üëç
Okay üëç
Okay üëç
It's testing "that" certain apps can be still be built. Original was correct.

```suggestion
This project is meant to test that apps using the current `android/settings.gradle`
```
Please keep these as `1.`'s, so they can be re-ordered/deleted new ones inserted.
Please keep the numbers as `1.`'s, so they can be re-ordered, deleted, or inserted.
original was correct
```suggestion
output, which dartdoc places back into the documentation. Any options given to
```
I think this line is too long (we prefer 80 column lines)
This line now looks too long (prefer 80 column lines)
what's the diff here?
also looks like you added a comma, not sure github diffing algorithm didn't pick it up, this LGTM
Ah okay I thought it was a copy\paste mistake
Ah okay I thought it was a copy\paste mistake
I prefer the original, but don't have a strong preference, you can leave your version if you like :)
LGTM. again, weird the diffing algorithm didn't highlight (it usually highlights trailing whitespace changes).
I have removed the last space
Okay will change it
OKay will do it
Updated It! 
Great! üëç
Okay thanks üòäüëç
I think because they are doing updates to the site currently, so maybe sometimes things don't work correctly
I don't get it. that is is for singular and apps is plural. correct me If I am wrong
The original was correct here. It is not a list of 3 items, but referring to the Android platform, where there are two components built: the Android component and the Flutter component.
Okay I will change it now
you are correct, in that "that" is for singular, however, in this sentence "that" does not refer to the "apps", but to the fact of whether or not those apps can be built.
Ah okay
Your PR here is adding this text which I don't see on master, maybe this got deleted in a recent change and when merging back in master you accidentally restored it?
I guess but what I didi isn‚Äôt fetch all new things and see what was changed so I changed nothing but I will make sure
When there's a merge conflict you have to manually look through all the changes and decide which makes sense to keep. [This change](https://github.com/flutter/flutter/commit/7bef51acc979ee467c02a7503a8990a6edbb0ae3) removed the this README text, so with your merge conflict you need to also remove it.
Fixing the issue where a wrong platform view surface is used.
Had to add this to ensure the driver tests are running.
Did you mean to check `verboseExceptions` somewhere?
You're right, the `throwOnError` check here is redundant, since we already know it's true from the check on 453. This should be `if (verboseExceptions) {`. Fixed and added another unit test.
this matcher was never used
I forced non-const constructors here because I'm not sure if `operator ==` is called on equal const objects. Am I wrong?
Nit: `s/tester.//`
Done
MaterialApp has a build-in navigator. Can you just use that one instead of adding another one to simplify this a little? (same for the test below)
You'd also end up with less modal barriers making the expect below a little more sensible :)  
Done
This looks like a good solution. One thing though, is that if the user has a typo in this env variable (or if it the remote is down), we should explicitly show the override value in any error message. If you check line 654 of this file, we throw an error if a command we run does not return a 0 exit code. Even though this error includes the complete command that failed, unfortunately, if `FLUTTER_GIT_URL` env variable is wrong, we won't hit an error until line 257, which tries to run the command `git fetch $_versionCheckRemote $branch`, which doesn't include the upstream URL in it. Probably the better version would be to add a `catch` around 262, and IF we have an explicit `FLUTTER_GIT_URL` override set in the environment, `globals.printError('Warning: the Flutter git upstream was overriden by the environment variable FLUTTER_GIT_URL = ${globals.platform.environment['FLUTTER_GIT_URL']}');` (something like that, I didn't test it).

Also, this change should have unit tests in the file: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/general.shard/version_test.dart. Using the `testUsingContext()` function, you can provide a `FakePlatform` and `ProcessManager` overrides (if you search the codebase for `FakePlatform`, you'll find a lot of examples) where you set the environment variable and then expect that you are getting the correct git commands to the `mockProcessManager`, specifically the one setting the upstream.

Let me know if you you run into any obstacles!
Unfortunately this isn't really testable since it can't be changed after the first time it's set.  I wrote a unit test for this that passed on its own, but failed when run with the entire test suite because it always returned `https://github.com/flutter/flutter.git` because a previous test had initialized it.

How about:
```dart
String get _flutterGit => globals.platform.environment['FLUTTER_GIT_URL'] ??
    'https://github.com/flutter/flutter.git';
```
Good catch
I have finished print warning and unit test. But test running failed unexpected. Sorry for troubling but I have a problem now.
nit: Missing a space between `catch` and `(`
```suggestion
    } on VersionCheckError catch (error) {
```
This change is temporary for demo purposes only. After flutter/plugins#2873 is landed this will be updaged.
I'm not completely sure why this `internalRun` needs to be rewritten... what lines of code should I focus on reading?
L439 ~ 446, the metric key list. This E2E version cannot get vsync related metrics. 
Other than that, I'm expecting E2E tests to share `testDriver` file and to have different timeline file name (L393, L394). It may also make sense to change the name of the result file from `**.timeline_summary.json` since it's of different format and not timeline. 
Mentioning this, I think '--trace-startup' is no longer needed. I'll delay the update to keep the above line numbers valid. 
nit: prefer "linux/android" when possible.
Done
To minimize duplicate code, maybe we can let `internalRun` take options like `bool reportsVsyncMetrics = true, bool needsTraceStartup = true`, and then just use `internalRun(reportsVsyncMetrics: false, needsTraceStartup: false)` in the e2e test?
Nit: `FrameTimingSummarizer` seems to be a more informative name.
This file probably also belongs to `test_driver` as this is unlikely to be used as a unit test. BTW, I guess we'll update `WidgetTester` to `WidgetController` in this file?
This file probably belongs to `test_driver` as this is unlikely to be used as a unit test. 
When this PR is out of draft, we should try to minimize duplicate code as it's hard to maintain.
I'm not expecting to use that demo very soon but if you think I should, maybe I'd better change this PR back to draft as that demo is far from use-able. 
And the reason I'm putting it in `test/` rather than `test_driver` is that E2E recommends so (https://pub.dev/packages/e2e#test-locations), and the test file (`cull_opacity_perf_e2e.dart`) should be able to run using `flutter test`. 
Same reason above. https://github.com/flutter/flutter/pull/61509#discussion_r456103995
If you mean re-use the warning string from `packages/flutter_driver/lib/src/driver/vmservice_driver.dart`, that one is private and need an extra line break to align the warning message. 
Done
And although it's out of draft, I'm still thinking it as experimental and expecting to see how it will go with device lab. If it's going on well, I think it will worth discussing if `FrameTimingSummarizer` and `watchPerformance` should go to e2e, `flutter_test` or stays with test codes.
Changing from `WidgetTester` to `WidgetController` for `driverOps` and `setupOps` for now, but this specific case it's not used. 
As [`FrameTiming`] is in the SDK, I wonder if we can also put `FrameTimingSummarizer ` in the SDK just in case that developers also want to monitor their app performance in the wild (e.g., https://github.com/flutter/flutter/issues/37437). What do you think, @Hixie ?

[`FrameTiming`]: https://api.flutter.dev/flutter/dart-ui/FrameTiming-class.html
Nit: call this `macroPerfTestE2E` to reduce confusion between this and the driver version of `macroPerfTest`.
@CareF : in terms of the warning message, I think we could have an extra line break in both cases, and just move this to a public const inside some file in `macrobenchmarks` so both e2e and driver tests can import?
As we're no longer using `flutter_driver`, I wonder if `benchmarkOps` would be a better name than `driverOps`? Now I also feel that `Ops` was a lazy naming that I created earlier. I hope we could also have a better name for that :)
We can now use `benchmarkLive` here?
Nit: compute `frameBuildTimeMicros ` in the constructor and make `averageFrameBuildTime ` and so on as public `get` functions so it would be easy for `FrameTimingSummarizer` users to get only a subset of stats in the future.
Nit: I feel it's safer to use a simple O(n) scanning algorithm here than a cleverer O(log n) binary search. We don't have unit test coverage for this function so it might be easy for someone to break this in the future without noticing it.
@CareF : how do you think about the last comment about reducing duplicate code?
Is it true that we don't need this file if flutter/plugins#2859 landed? Since this PR doesn't need Timeline, I wonder if we only need a part of flutter/plugins#2859 without the Timeline support.
My bad. This comment was added here for my first trial version. Now this file is a little different with flutter/plugins#2859 but the larger idea is similar. 
`flutter_driver` cannot import things from `macrobenchmarks` because the latter is not a published package and is not a dependency of `flutter_driver`.  There's another similar thing in https://github.com/flutter/flutter/blob/07caa0fbfe5186cc8a11902cc46377cebd592088/packages/flutter_test/lib/src/widget_tester.dart#L324-L334 . I think it might be better to put in `flutter_test`, if we have to. 
I interpret `driver` here as the operation to *drive* the test, rather than from `flutter_driver`. What about call them `driverCallback` and `setupCallback`. And maybe i should also `typedef` the callback. 
Then `kBuildBudget` would have to be a getter (or a const) so user won't expect to change it to change the related result. 
Done
Done
Done
Done with the change, but let me know if `kBuildBudget` should still be a value that can be changed by customer, in which case it will need to be a member variable of the class. 
Done. A little sad when I finally find small algos are useful somewhere but it turns out not a good practice :(
Removed the comment. See new comment in flutter/plugins#2859
I had a slightly different design but still reduce the duplicate. Let me know if that looks good. 
And these three are not exactly the same. One is `flutter run`, one is `flutter drive` (and I just noticed a nit, the one in `vmservice_driver.dart` should have an additional `-t` (#61922) and E2E should be both (just updated this)
I realized I shouldn't do this because `data` is incremental. 
So it seems that I'll have to do the same as the `TimelineSummary` where multiple list generation and sort on the same object is performed... Or I'll have to make a cache system (I don't think I should...). Currently I reverted that moving to constructor change. Let me think about the trade-off. 
Let's file an issue and put a TODO here to use https://github.com/flutter/flutter/wiki/Engine-specific-Service-Protocol-extensions#get-the-display-refresh-rate-_fluttergetdisplayrefreshrate instead of the hard-coded 16ms. If you have time to kill, you can resolve it later.
Ah, I forgot that the other one is in `flutter_driver`. Yes, let's reuse the `flutter_test` one if possible since this E2E test would depend on `flutter_test` anyway?
It says milliseconds in the comment but I believe it's in microseconds.

Nit: `p90FrameBuildTimeMicroseconds`? `p90` seems to be clearer than `percentileXYZ90` and it's nice to put unit microseconds in the name.

Take a step back, I feel that the best solution might be to directly return a `Duration` here, and only do `inMicroseconds / 1E3` in the final JSON construction. This would remove all unit issues, and open the possibility of using nanoseconds if one has to. I think this should be easy to do as `Duration` supports all common operators such as `<, +`.

Same applies to all other similar functions.
I feel sorry too... Here's how I think you might be able to add it back in the future:

Writing that algorithm is a good, what feels unsafe is to make it as an private little function without any unit tests. In the future, if `FrameTimingSummarizer` turns out to be something that we want to add to our API, then we can invest a lot more time in it to improve its ergonomics and efficiency. At that time, we shall certainly make the algorithm as efficient as possible, and add many unit tests to guarantee its correctness. (Right now we're just trying to unblock our critical path asap.)
As you pointed out in https://github.com/flutter/flutter/pull/61509#discussion_r457753936, most people who use this function probably don't expect the `List<FrameTiming>` to be mutating in their first thought.

I'd suggest to let your `watcher` record a `List<FrameTiming>`, and give that final list to `FrameTimingSummarizer` after that list is fully recorded.

You can then extract the build and raster duration and sort in the constructor. I feel it's probably still cleaner to call `_findPercentile` in each getter so you don't have to introduce a lot of class member fields.
Done with modification to `flutter_test`
Done with refactoring `FrameTimingSummarizer` using factory constructor. 
The internal data of `Duration` is `int` in microseconds. 
And it doesn't have a `operator /` method. The only one is `operator ~/ (int)`. Difference is within microseconds which I assume is fine. 
Done with #61958 
(moved to factory constructor)
Nit: when a function has a lot of arguments, Flutter usually put them under `{}` so it would be like the following
```
const FrameTimingSummarizer._({
  this.frameBuildTime,
  ...
});

// Use it with argument name provided to reduce confusion
FrameTimingSummarizer._(
  ...,
  averageFrameBuildTime: frameBuildTime.reduce(add) ~/ data.length,
  ...,
);
```
Nit: as we're moving away from `flutter_driver`, I wonder if `ControlCallback` is a better name than `DriveCallback` as the callback takes a `WidgetController`. CC @dnfield for suggestion too as I imagine that we'll use this in all future e2e performance tests.
`than` -> `then`
`{}` means named arguments, and optional if not marked as `@required`, with default value if not assigned `null`. Here I don't think they should be optional. I added all `@required`. 
Done
Done.
Could we eliminate the ButtonBar here? 
We can, but then we would lose some of the padding around the buttons that the `ButtonBar` provides. Might trip up some golden tests.
I think you can get the same effect with
```dart
Container(
  alignment: Alignment.center,
  padding: EdgeInsets.symmetric(horizontal: 8),
  constraints: const BoxConstraints(minHeight: 52.0),
  child: Row(
    mainAxisAlignment: MainAxisAlignment.end,
    children: <Widget>[
      TextButton(
        onPressed: _handleCancel,
        child: Text(widget.cancelText ?? localizations.cancelButtonLabel),
      ),
      const SizedBox(width: 8),
      TextButton(
        onPressed: _handleOk,
        child: Text(widget.confirmText ?? localizations.okButtonLabel),
      ),
    ],
  ),
)
```
There's special behavior in ButtonBar that puts the buttons in a column if they don't fit in a row (good for i18n cases or custom button text), so I'd say we keep the button bar until we have a good replacement for that
Is that really an issue with the time picker? Can the picker become narrow enough to require making a column out of the OK/Cancel buttons while otherwise remaining usable?
I think it may be possible in other locales (german perhaps?)
OK, with me to leave this as-is for the moment. I'm going to write a row-unless-theres-no-room-then-a-column that we can replace ButtonBar with. Until then, this is good.
update-packages fetches all of the packages of all of our dependencies, which is massively bloating the zip size
cc @gspencergoog any reason not to do this?
One of the main reasons we created the downloadable archives in the first place was to enable people (mainly in China) to work offline by downloading an archive (on a machine with a connection), putting it on a USB stick, unpacking it on another machine, and being able to run.

If we don't fetch packages, that won't work anymore. If we don't think that is a scenario we care about then that's fine.

We also thought that the out of box experience of unpacking it and building an example was improved because you didn't need to immediately wait for pub to run: it just built (but that's a fairly small thing).
we already fetch all of the dependencies for the flutter tool, and anything needed to run a flutter template. Pulling in all of our dependencies, the zip size has gradually increased to 848 MB
Rather than excluding by git, could we just exclude everything from the `dev/` folder specifically?

That way, if we move to distributing the gallery some other way (e.g. by pub somehow?) this won't break.
I floated that idea and the concern was that it could break the offline workflow. Lacking good integration tests this is a minimal fix to reduce the size
Want to put this one at the end of the list after the platforms? I thought for a second you edited this accidentally.
Woo!
Woo!
Woo again!
Done!
Would it be possible/useful to make this one of those interactive dartpad examples? The users could hover over the button and see the color change for themselves.
Additionally, it might be useful to show hovered or focused: blue, pressed: green, default: red in this interactive example so users can see the different states in their browser. 
I've made the examples interactive. 

I didn't change this example as you've suggested because I wanted developers to see the `states.any(interactiveStates.contains)` idiom.

This should be inside the `if (parent is RenderObject)` check
This assert can fail if the parent visits multiple children - it can be removed.
Maybe call this `isVisitedByParent`?  Otherwise it may be confusing to read since the child _is_ a child of its parent.
Nit: `s/,/;/`
Nit: Remove new line
Nit: I think this can be private
Should percent be used here? If so, what about localization?
Will these be reversed for RTL?
This matches what `Slider` currently does. If they are to be localized, that would have to be a separate PR
Good catch, I'll reverse them for RTL
assert that children is empty since the method ignores it?
I'd recommend writing the test with `tester.getSemantics` and `matchesSemantics` (example: https://github.com/flutter/flutter/pull/60329/files). That makes the test a little less brittle (we don't have to update the test when semantics above the Slider change.
This means, the accessibility focus rect (that green rect that Talkback draws) will always cover the first half of the slider for the first thump and the second half of the slider for the second thump - no matter the thumb position, right? Is that the expected behavior for a range slider? I would have expected the semantics nodes to be around the thumbs...
Correct, the thinking was that splitting the area in two makes the widget more accessible due to the larger targets (`Slider`'s semantic node is around the whole slider, for instance). It also helps when the two thumbs are on top of one another
Cool, I'll look into that. It feels more resilient
Can you update the documentation of this property to include what the default value is?
Done
nit:

```suggestion
/// Here is an example of a basic [OutlineButton].
```
nit: should it be: ... which computes the smallest width ... ?
same.
The magic is here.
_debugFastReassembleMethod might need to become public in the future, in case I can't evaluate in the scope of the binding library and still use whatever type.
nit: maybe better: "debugFastReassembleMethod must be set to use fastReassemble."?
Maybe add a little more documentation here? E.g. it appears that this has to be set every time before  fastReassemble is invoked?
Define a typedef for the function type.
Would also be good to document what `cb` needs to do.
Is there potential for a race condition here? E.g. while we wait asynchronously for the end of the frame, somebody sets debugFastReassembleMethod to a new function, which then incorrectly gets nulled out in the next line?
Isn't `_` reserved for "ignored" params per style giude?
I'm not sure how best to document this. Unlike other APIs, no one should ever set this themselves (and if it is set it will get blown away)
Good idea, I should grab this callback in a local at the start
I'm being overly defensive because there is a chance that a user creates a widget which matches the parameter name, and `_` seems like the least-likely collision
I could name it like _param_flutter_please_dont_collide_123223232 - that seems less likely
The documentation wouldn't be for people writing a Flutter app, but for people working on the framework or the tool when looking at this again in the future :P 
Done
Updated, PTAL
Done
Done
For the test it doesn't really matter, so I named it `x`
Move this up to right after you've assigned it to fastReassemblePredicate?
Done
Will this test pass on release branches?
Yes - because we need to create arguments before we know what the current flutter version is, all of the features are always displayed
If test is just intended to catch inadvertent changes to the scrollbar's appearance, then `777, 3, 20, 297` etc is OK. If there's simple explanation for the values, it would help to include a comment about that.
All magic numbers removed.
Beautiful!
is also => are also
The previous explanation seemed more complete to me, because it explained why.
Can you also add "macOS: [not available]" (and iOS) or something, so that it's clear that it isn't available on macOS/iOS? Or at least a statement that it isn't supported on systems that aren't listed. What happens if I specify `SystemMouseCursor.wait` on a system that doesn't support it?
I added the following comment
```
/// If the platform that the application is running on is not listed for a cursor,
/// using this cursor falls back to [basic].
```
(Thought I did, thanks for pointing out).
Should we instead fix `FocusableActionDetector` to not remove the `Actions` and `Shortcuts` widgets when disabled, and instead just empty out their maps? There is some performance cost to building them, but if they cause churn in the tree, that could be offset by not causing it anymore.
It would break some tests because that introduces a 1 frame delay to descendant `Focus`'s semantics (`isFocusable`) . Currently since we change the shape of the tree, a new `Focus` widget gets inflated so there's no delay (line 1090):

https://github.com/flutter/flutter/blob/4195ad4ef605851be64e649ec2d292645d7425f7/packages/flutter/lib/src/widgets/actions.dart#L1081-L1103
(Is this expected?)
Well, I would think that anything that cares about the focus changing shouldn't care about the 1 frame delay, since focus changes already happen in a microtask, so that already happens often.  And semantics shouldn't care about a 1 frame delay either.
I think I added that part because the focus changes were increasing a build benchmark, and I was trying to reduce the number of built items for things that were disabled.
If a switch is disabled then `isFocusable` should be removed from its semantics flags in the same frame, no? 
The focus itself won't actually be removed until the microtask runs, so if the semantics removes it immediately, it might actually be early (and wrong until the task runs).
Updated. But it still seems confusing to me that when the UI is disabled the semantics is telling us the component is focusable.
Yes, ideally it would be resolved immediately, but it causes too much of a performance hit to update focus while the tree is rebuilt, and would mean that sometimes (during the build) two things could have focus at the same time, or that nothing has focus, which complicates a lot of logic.
Would it be possible to update the focus tree after we finalize the layout (instead of in a post-frame callback)? 
It would help to explain how this differs from benchmark and fullyLive, and when I'd want to use this instead of one of those.
nit: space between `duration ??`.

Why are we awaiting a delay of the duration before stting a timer for the duration again below? Won't that mean we get double the duration expected?
`benchmark` is actually very different: it's ignoring all animations. But yeah I should update the docs, and restructure the two parts from https://api.flutter.dev/flutter/flutter_test/LiveTestWidgetsFlutterBindingFramePolicy-class.html and
https://api.flutter.dev/flutter/flutter_test/LiveTestWidgetsFlutterBinding/framePolicy.html . But before that I still would like to hear if the general idea is reasonable. 
It's an early return. When the policy is `benchmarkLive`, the below part is not executed. 
What's the number here for other flags, on host unit tests and on device?
Ahh sorry, I missed the scope of the return here.
This won't work. Tests might be executed in random order, and the code "on top of them" isn't guaranteed to run inside the test itself.

You either have to set the frame policy in the test and have that just work, or create separate test files for different policies.

You _might_ get this working if you use `group`s.
All other flags don't response to frame requests from the engine, including the benchmark, and they basically don't track animation unless manually pump-ed. So these numbers are not relevant for other flags. 
As for the number on host and on device, that's the issue why I'm getting flaky result. The number here comes from my local test on my macbook, and it seems on Cirrus they get different number, varying from 60+- ~90+-. Is there better place to test these number?
To reduce the number of new files introduced, can we put this under `macrobenchmarks/test`, and create a new page in `macrobenchmarks` for the purpose of `simple_scroll`?
It would be nice to put your local results in the PR description to set the expectation of those two different flags.
I don't feel comfortable doing that because it's technically not a performance benchmark but more like a test to check the functioning of a feature. But if you insist I'll make the change. 
Done. 
The reporting of metrics like `average_delay_fullyLive_millis` and `average_delay_benchmarkLive_millis` makes me feel that this is more or less a performance test. It's testing the performance of the input events simulation which justifies `benchmarkLive` (i.e., everything would still run if we don't have `benchmarkLive`, but the simulation performance would be bad and inaccurate). Such performance metrics also prevent future accidents that suddenly make our simulation much less accurate.
Done. 
`// This page is currently not used for frame benchmarking` might be unnecessary as there are some pages here that are only for memory benchmarking and they don't have frame benchmarking either.
Nit: Flutter repo prefers `n += 1` than `n++`. I can discuss the reasons in our next meeting if you're interested.
By doing so I'm avoiding extra operation to select the page. It might be a good idea to do the same for other pages with E2E test version, or to put this together with the util code in #61509 
This file is modified from https://github.com/flutter/plugins/blob/master/packages/e2e/lib/e2e_driver.dart
This looks strange. Does `handlePointerEventRecord` mostly return all negative delays? Shall we use `abs` just in case of positive delays? We might need to add some documentations to `handlePointerEventRecord` to describe the meaning of positive and negative delays, and set the expectation if most of them are negative or positive.
`Ignore any request from pump but respect other requests to schedule a frame.`
Yes mostly negative. It's positive only when `Future.delayed` complete earlier than the set time. My local test shows it's 0~3 out of 200+ events with tiny positive values < 100us (**micro**seconds). I don't think I should use `abs` because this list is only shown in debug mode and `abs` makes less use of the info. But it does make sense to change the behavior of `handlePointerEventRecord` for the major result being positive since we are calling it delay, and add docs to that. 
Update about the number. When putting this on a more complex environment, sometimes (not sure when, it differs from run to run) the fluctuation becomes larger, and positives can go as much as ~10% and up to 500us. Still tiny compare to frame interval though.  
nit: space before {
The first if branch below also assigns 0.0 to extra. Remove that?
nit: space before {
nit: remove extra blank line
Do you need this? Wouldn't the test fail by itself if it throws an error?
does a warping => "warps" from one tab to another, non-adjacent tab, with an animation. 

On the face of it, it's not clear why this route might have been disposed as a consequence of the warp. The test appears to set up a situation where the old Navigator will have been disposed - not its route. Can you explain this scenario in a little more detail?
Minor nit, but it might be nice to make sure that each of the settings overrides the other (i.e. provide all three shadow colors to verify that the widget setting overrides the other two if they are all specified).
OK, I've added some tests like that.
I think this could be said a little more briefly:

If [sortColumnIndex] is non-null, then the table will be sorted by the values in the specified column. The boolean [sortAscending] flag controls the sort order.
Sure @HansMuller I will change it.
```suggestion
  /// Defines the background color of `ListTile` when [selected] is false.
```
nit:
```suggestion
      ),
```
nit: indentations and trailing commas
```suggestion
      MaterialApp(
        home: Material(
          child: Center(
            child: StatefulBuilder(
              builder: (BuildContext context, StateSetter setState) {
                return ListTile(
                  selected: isSelected,
                  onTap: () {
                    setState(()=> isSelected = !isSelected);
                  },
                  title: const Text('Title'),
                );
              },
            ),
          ),
        ),
      ),
```
I feel like it doesn't make sense to put these checks here as the method name says "_validateLegacyYaml", but the code is actually validating the new format.

What do you think about fixing it in the `validatePluginYaml`? We have something like:

```dart
if (usesNewPluginFormat) {
  if (yaml['platforms'] != null && yaml['platforms'] is! YamlMap) {
    const String errorMessage = 'flutter.plugin.platforms should be a map with the platform name as the key';
    return <String>[errorMessage];
  }
  return _validateMultiPlatformYaml(yaml['platforms'] as YamlMap);
} else {
  return _validateLegacyYaml(yaml);
}
```

We can make it as:

```dart
if (usesNewPluginFormat) {
  if (yaml['platforms'] != null && yaml['platforms'] is! YamlMap) {
    const String errorMessage = 'flutter.plugin.platforms should be a map with the platform name as the key';
    return <String>[errorMessage];
  }
  return _validateMultiPlatformYaml(yaml['platforms'] as YamlMap);
} else if (usesOldPluginFormat) {
  return _validateLegacyYaml(yaml);
} else {
  return <String>['The flutter.plugin.platforms key in the `pubspec.yaml` is not found. '
                              'An instruction to format the `pubspec.yaml` can be found here: ' 
                              'https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin'];
}
```
This is great! Thanks :) 
Yeah, put the check inside the method `_validateLegacyYaml` is weird.
I will modify it later, thanks for the suggestion : ) !
Thanks! Feel free to @ me when it's ready to be reviewed again :)
What about: 
```
Cannot find the `flutter.plugin.platforms` key in the `pubspec.yaml` file.
```

We want to push users to use the new format.
We don't need the "See:" here.
OK.
oops
```suggestion
  ///
  /// If `textDirection` is [TextDirection.rtl], then the direction in which
  /// text flows starts from right to left. Otherwise, if `textDirection` is
  /// [TextDirection.ltr], then the direction in which text flows starts from
  /// left to right.
  ///
```

The test is failing due to trailing spaces.
Will fix it.....Thank you..
Although this is a correct statement about `textDirection` in general, it's not really help for understanding how the `Row` lays out its children.  If you rephrased the point (in terms of the row's children) and explained the implications of the start and end parameters, that would help.

#58019 was really a request to enhance the `Row` _class_ API doc, by mentioning the support for RTL layout a little earlier. 
Sure. @HansMuller 
This link is broken. I don't think this asset actually exists in https://github.com/flutter/assets-for-api-docs?
@Piinks  Yes it is but I have also created PR for that too, [#115](https://github.com/flutter/assets-for-api-docs/pull/115)
```suggestion
/// The [textDirection] property controls the direction that children are rendered in.
/// [TextDirection.ltr] is the default [textDirection] of [Row] children, so the first
/// child is rendered at the `start` of the [Row], to the left, with subsequent children
/// following to the right. If you want to order children in the opposite
/// direction (right to left), then [textDirection] can be set to
/// [TextDirection.rtl]. This is shown in the example below.
```
```suggestion
  /// If [textDirection] is [TextDirection.rtl], then the direction in which
```
```suggestion
  /// text flows starts from right to left. Otherwise, if [textDirection] is
```
Good idea!  How about totally removing the suggestion to re-install the SDK manager.
```suggestion
      'Android license status unknown.\n'
      'Run `flutter doctor --android-licenses` to accept the SDK licenses.\n'
      'See ${_androidSdkInstallUrl(platform)} for more details.';
```
Thank you very much for supporting my idea! this suggestion has been committed! @jmagman 
what is `defined_in_file`? is this a pod magic function?
nvm, I grepped the codebase and found y our other comments about it
maybe flutter_parse_dependencies_file_for_ios_plugin? to make it more explicit
is this intentional?
add a code comment or reference issue for when this can happen?
No, I meant to revert this.  Good catch!
I don't think it can ever happen AFAIK, I think I just wanted a way to surface Something Bad Happened and stopping instead of copying from a nonexistent directory in https://github.com/flutter/flutter/pull/59044/files#diff-76053fa099530bf75a339336cccbc2efR23.
I copied the comments to this file.
```suggestion
      // State for all pointers which are currently down.
      //
      // The `hitTestHistory` is equivalent to `GestureBinding._hitTests`, which is important for
      // `_handlePointerEvent` to replicate `GestureBinding._handlePointerEvent`.
```
Explain the property so that readers can understand without referring to another file.
Can you comment when this will happen?
Isn't it the same as `timeDiff` so that it's basically the same as L714?
By "parallel implementation" do you mean this is a makeshift implementation and will be replaced in the future?
Put executions into a `test` body. Code outside of `test` can only prepare stateless data and utility functions.
When something along the way is expensive and causes miss of a frame. My experiments using #60796 + e2e usually have 2 or 3 packet out of like about 200 that falls here on a MotoG4 with the complex_layout test case and a set of input simulating scrolling, which looks like doing GC or something. 
No because `Future.delay` doesn't promise exact delay time. 
I mean the implementation is almost the same, but due to there is not a subclass relation I have two copy form there. 
I tried but failed. `runApp` inside a test body will result in `await SchedulerBinding.instance.endOfFrame;` to never complete. 
Just call `tester.pump` right?
This reference also make sense since the implementation is copied from `GestureBinding`. I'll have both. 
I think I misunderstood the question for the above reply. Ideally L714 should give a negative value but this should give zero (and is indeed zero in #60796 's unit test where it's using a fake async), but since `Future.delay` is not exact, there will be a little extra delay. 
@dnfield there isn't and shouldn't be a tester because getting a `WidgetTester` will introduce its own controller, making the `LiveWidgetController`'s signal directed to the wrong place. This is also one of my failed version before this PR.
Sorry I made a mistake. Previous unending await is caused by another reason. 
Ahhhh ok.  In that case you can just manually drive the binding. But I'm surprised putting this in a test body makes a difference, especially since you're not using testWidgets.
I see. Can you add a comment saying "Recalaulate time diff because (...)"?
@dnfield Sorry the difference I thought it was is caused by some other things. 
Ok then I suggest changing it to
```suggestion
  // This function is identical to [GestureBinding._handlePointerEvent] to replicate 
  // the behavior of real cases.
```
(or something appropriate.)

The "parallel implementation" is a jargon that refers to what I mentioned in the first comment.
Done.
nice!
'was deprecated after 24 hours of its debut '
Shouldn't this be `ElevatedButtonThemeData`?
Yes, you're correct, thanks for pointing that out.
I think the characters issues was getting triggered by this code I removed @justinmc . Normally we don't need to invalidate the packages when a dependency changes because the pubspec must have changed, but the flutter sdk is special and needs a bit of help.

I think we missed it because so much else triggers a pub get that in most cases you won't notice
I don't really like this, in theory adding a yaml wouldn't re-trigger pub get,  that would have to be done automatically
Ah nice, thanks for following up on that!  The [issue](https://github.com/flutter/flutter/issues/59645) is still getting the occasional comment from someone experiencing the build problem, so hopefully this PR will clear that up.
Why the move to an assert?
I'd be concerned about an update or bug in this list breaking the tool if our test coverage isn't good. Moving to an assert lowers the risk.

On the other hand, its entirely unrelated to this PR, so I should remove it anyway
`savePackageConfig` is a utility function written in terms of public APIs:

https://github.com/dart-lang/package_config/blob/9c586d04bd26fef01215fd10e7ab96a3050cfa64/lib/src/package_config_io.dart#L131

Maybe the tool should do this more manually to avoid the possibly brittle filesystem type check.
Maybe also test a malformed 'generate: ' to make sure the tool doesn't crash.
Neither writePackageConfigJsonUtf8 nor any of the other utility methods are exported
Oh, whoops. I misread. I thought I saw it using https://pub.dev/documentation/package_config/latest/package_config.package_config_discovery/PackageConfig/writeBytes.html
done
You could also locally override dart:io with an IOOverrides, but that is possibly not actually an improvement over the type check here.
This seems like a bandage fix, because it only applies to indexed stack. I believe there are more widgets that may not paint all of their children. Further more, you may run into circular dependencies if that widget is in Cupertino library.
This api feels weird, you may as well don't create an ink if inkNeedsPaint = false
OK
I feel the same way. I'll see if there's a better plan.
The dropdown menu button need to rebuild automatically. If we have to manually pump a new widget, that is a bug in the dropdown menu button itself.

In other word, if a `tester.pumpAndSettle()` does not work, we need to fix the code in dropdown.dart instead.
nit, add a new line at the end
It is possible that the offstage widgets want to paint themselves.
> The dropdown menu button need to rebuild automatically. If we have to manually pump a new widget, that is a bug in the dropdown menu button itself.
> 
> In other word, if a `tester.pumpAndSettle()` does not work, we need to fix the code in dropdown.dart instead.

 #35736 discusses why the widget does not automatically update the UI
our style guide suggest we only use arrow function if content fit into a single line.
same here
indent is off
Can you add a `Regressing test for https://github.com/flutter/flutter/issues/59963`
closing parenthesis in the new line
unused import?
ok
applyPaintTransform needs Matrix4,  change to: import 'package:vector_math/vector_math_64.dart' show Matrix4;
You could also expose this like time dilation so it is configurable at runtime
The alignment is so, so close to perfect
Out of curiosity, what does this do on the web?
nit: Extra '.'
"Developers using ..."

Can you give some more concrete advice here?
If possible, this message should contain suggestions to fix the problem.
Consider adding some comments here about what each of these steps is doing.
Rewrite for Windows terminals that don't support emoji here:

https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/base/logger.dart#L366
'I' also looks available. Big 'I' for a big image warning makes some sense, I think.
It currently does the widget inspector.  If we're ok with changing that I'll use it.
Lets not change the existing bindings if possible
Ah, okay. The help message only claims 'i' for the widget inspector, but the resident runner triggers it with both 'I' and 'i'. I would be okay with keeping 'i' for the widget inspector and using 'I' for this. @jonahwilliams thoughts?
That is, I would be okay with the help message being the source of truth about what they keys do, rather than what the resident runner implements.
SGTM, if its not documented it might have been an oversight/mistake at some point.
Ok, I'll take over upper case I for this.
Isn't this configurable at runtime?
Done
Done
Added a line explaining how to fix.
Ah right, I always forget that we export everything 
Updated this a bit.
Done
Done
No color filter, but it does vertically invert the image and flip.

I have a feeling we don't want this on web - on web you should be serving smaller assets. Should I just disable it completely for web?

/cc @yjbanov 
Ok - I'm fixing the resident_runner_web for this, and I've updated copy in a few places to mention resizing the asset itself as the most preferable option, particularly on web.
do we actually know the image size on the web?
dang, didn't know we had all these
![PB9d7](https://user-images.githubusercontent.com/8975114/87119152-04a07780-c232-11ea-922a-d5aea8784f2a.jpg)
Why not just do this?:
```suggestion
      return LinkedHashMap<MouseTrackerAnnotation, Matrix4>();
```
add `show Matrix4`?
Why not just do this?:
```suggestion
      (_) => (LinkedHashMap<MouseTrackerAnnotation, Matrix4>()),
```
The linter.
With `LinkedHashMap<MouseTrackerAnnotation, Matrix4>()` the linter reports "Use literal when possible". 
With `<MouseTrackerAnnotation, Matrix4>{}` the compiler reports a type mismatch.
This is the last I can do...
Explained above 
Well, that is pretty confusing.  I guess it's because the real type of `Map` is `_InternalLinkedHashMap` and not `LinkedHashMap`. It's probably no less efficient, since I'll bet `LinkedHashMap` is implemented as an `_InternalLinkedHashMap` internally, but ewww...
I brought it up in https://github.com/dart-lang/linter/issues/1649#issuecomment-656929040. Hopefully it raises some attention :/
I think probably how this should be landed is by bumping the min sdk version in the pubspec to be a 2.9 release, and removing the // @dart comments in the opted in files entirely.  @jakemac53 @jonahwilliams does that sound right?
That sounds like an approach with less churn. Is 2.9 _the_ null safety language version, or could that change?
2.9 will *not* be the final null safety language version.  It is likely, but not guaranteed that 2.10 will be the final null safety language version. 
okay, in that case we should definitely do it in the pubspec so there is only a single location, right?
I prefered to explicitly use `// @dart = 2.9` during the incremental migration for simple searchability. Once all framework is migrated I will remove it. Note that the [pubspec.yaml sdk version is already pointing to 2.9](https://github.com/flutter/flutter/blob/master/packages/flutter/pubspec.yaml#L8).

Does it look good to you?
If it makes the process easier, I would say to use it - but file an issue to clean up the overrides once it has all landed.
I think that's better, and it's how pub packages need to migrate (because otherwise you're allowing sdks that don't support null safety, which won't work).  I think with flutter, because you provide your own copy of the sdk, you don't run into the versioning problem, but it still seems like the right approach to me.  But I don't know all the details of how package:flutter works - it's Not Like Other Packages.
Ok, works for me.  Note that if/when the Dart version bumps to a 2.10 pre-release, there will a bit of a bump - you won't be able roll 2.10 in until you change all of these from // @dart = 2.9 to // @dart = 2.10.
could we set it to 2.10 now?
> could we set it to 2.10 now?

You could try it, but I wouldn't really recommend it.  You're more or less relying on undefined behavior in that case.  It might just work, in which case it's probably fine, but it also might work in some places and not others, or suddenly stop working, or whatever.
If this is really just about tracking which things are migrated, maybe consider just using some other arbitrary string to tag them?  // @dart = migrated ?
Ok I'll remove it directly. I don't use it too much now.
Is there an issue on file that we could link from here?
Why do we turn this one off?
Why is this change necessary?
This feels like a strange thing to add to flutter's public API. Looks like it is only used in one file. Can we just add it as a private thing there? Or, instead of using promote, can you just do the following in the code:

```
num n = 42;
n = n as int;
n.isEven;
```
Why `late`?
What's currently stopping us to do this?
`someMap[someKey]` is optional, while `(int value) => value + 1` is only invoked if `value != null`.
link to issue added.
This is needed to avoid warning on null assertion on non-nullable variable. For instance:

```dart
void m(String s) {
  assert(s != null);
}
```

This could change with https://github.com/flutter/flutter/issues/61042
Without this change there's an error because `removedPackagesAndClasses[className]` is nullable and you cannot use operator + on a nullable value. Without `.update` we should have used:

```dart
removedPackagesAndClasses[className] = removedPackagesAndClasses[className]! + 1;
```

The update version avoids repetitions and is less error prone imho.
I don't remind the issue but @Hixie suggested to add this function.
IIRC this will make the field lazy initialized.
`late` is a little dangerous for public member. I'm not sure the TODO is still relevant. I'll check.
It won't do anything in this case (other than maybe make it slower to access). It allows you to (yourself) lazily initialize it but leave it as a non-nullable type.
Sorry if this wasn't clear, but my question was meant as: "Why are we declaring this field as late? It seems unnecessary here."
Agreed, `update` does look nicer. Thanks for the explanation.
If the variable itself is already non-nullable, why do we still need the assert? Wouldn't we want to clean that up and remove it?
It was lazy before - I think there was a misunderstanding around what `late` means. If assigning immediately it has no meaning @stereotype441 should we have a lint for this?

To restore the lazy behavior that existed before this would have to be a nullable field type, and you would have to restore the old logic.
I am not sure I fully understand, `lastWordStart` seems to be private to this method?
Either way, It would probably be good to have a comment on this line explaining why we turn this off.
@jakemac53 that's not correct. late with an initializer means lazy.
Now I am confused. What is the difference between those two lines?

```dart
late final int foo = 1;
final int bar = 1;
```
Nothing, because you can't observe laziness with a value.  But:

```dart
class A {
  late final int foo = (() {print("hello"); return 1;})();
  final int bar = (() {print("world"); return 1;})();
  A();
}
                            
                            
void main() {
  var a = A();
  print("says");
  a.foo;
}
```

outputs
```
world
says
hello
```

because a `late` variable with an initializer only evaluates its initializer on first use.

cc @munificent this is something we're going to have to explain carefully.
Thanks for the explanation!
>If the variable itself is already non-nullable, why do we still need the assert?

See https://github.com/dart-lang/language/issues/1018:

> At first glance, it might seem sensible to remove the assertion on the grounds that c can no longer be null, but that's only true in strong mode. Flutter will have a long tail of users running in weak mode until Dart 3.0, and assertions like these are necessary to help prevent them from passing nulls to Flutter APIs.
Finally I removed this function for now.
comment removed. I added it to remind me that a lint could be done to use `late`.
Thanks for the context and adding it as a comment.
If we're no longer using 'flutter::profiling', how are we going to handle the code in https://github.com/flutter/engine/blob/f10f17257300b232d0b16c95c63a641a3e158207/shell/profiling/sampling_profiler.cc#L52 ?
`[kProfilingEvents] name` instead of `[kProfilingEvents] category`?
Should these parameters be added to a SnackBarThemeData too? Maybe create a follow up issue for it.
We'll add a SafeArea here that's not used if `isFloatingSnackBar` is true. You could break it out to a conditional below, not sure if its better?
This could be more specific and mention that:
For a floating snackbar the start padding is 16, and for non-floating 24. If it includes an action, the same padding will be added at the end.
nit: top and bottom padding could be constants
I think I prefer to leave these out of the theme for now, but could follow up with that if it is asked for
Good call, done
done
done
it's only horizontal-only by default right? maybe update this comment to say what it will be applied as
Oops, fixed
It can not be used if [margin] is specified.
Might explain that, if the width is specified, the snackbar will be horizontally centered within the available space.
Less the margin, right?
ButtonTheme. UGH. This part of the implementation needs another look; future PR.
Done
Done
Right, done
yeah, snackbar is another one of those widgets to update with new button universe
This might have been too breaking. I can updated to a separate lookup so that it does not affect the run workflow
It might be worth keeping the "h", except that the help message could explain how the server mode is different from the browser mode.
Should these have return types?
Technically these could return null, void, Future<x>. This is the pattern used by the engine already
I guess we're not linting generated code. We could make them return `dynamic` for explicitness.
I did add more details in the web server startup below (see web_devices.dart), that way it shows up in IDEs too
done
try and stick with a 2-space indent, here and elsewhere
nit: add a trailing `,` and place the closing paren on the next line.
Since you're refactoring this - could you document the reason these two messages are almost the same? Or make it more obvious by other means (moving the rest of the message generation here?)
Please consistently use the string buffer, you can use `write` as an equivalent to the concatenation below.
I add dartdoc comments
Xcode 12 didn't like this and removed it.
‚ò†Ô∏è ded
moar ded
Remove dead code tests
This wasted time shelling out to tooling in nonexistent directories when creating a new project.
rip
rip
rip
rip
TIL about testWithMocks
Will add this to my deprecate/remove list :) 
technically, you could pass in `defaultInfo.reportFlavorNotFoundAndExit` as a tear-off, since the throws matchers just require a zero-arity function. Just an FYI
Audited, got a PR coming your way.
wow...
yeah, I think it might be better to pull out each discovery instance, and then inject them into the constructor? Then the devicemanager is just responsible for ... managing the devices, and not creating the world
this will have to wait for a google3 roll, there are some updates needed internally
Let's make these null by default.
For both:
```suggestion
  /// Must be greater than or equal to 0.0, defaults to null.
```
Let's add a test that checks the behavior when both are not provided, or both null.
Why are there two instance of Align here and in the animated tests?
For all, these lookups could be:
```dart
final RenderBox textBox1 = tester.renderObject<RenderBox>(find.byKey(key1));
```
Or if there were only one instance of the class:
```dart
final RenderBox box = tester.renderObject<RenderBox>(find.byType(AnimatedAlign));
```
need to check the assetPath != path, otherwise the tool recognizes `assets: - foo.txt` as its own asset variant.
This was getting hit in devices_test and failing if it grabbed the wrong context, I did some minor cleanup but it needs to be fixed later so that there is no accidental caching
Reminder: remove null safety mode flags here
What do you mean by "that includes spaces"? Does this only happen if I hit the space bar on the english keyboard?
Yes that's right, for the case that the input is RTL.  I'll clarify.
It is not the type of keyboard, but rather the mark inserted is based on the directionality of the immediately previous run of text. This ensures the whitespace is treated as part of the same directionality run instead of defaulting to the underlying direction of the field.
@GaryQian Alright I tried to clean this paragraph up a little bit, and I removed this example sentence entirely.  I think it was making things even more confusing by introducing uncertainty.  They first sentence says it as clearly as possible: typing LTR text into an RTL field will produce LRM characters if it includes spaces.
Maybe add a slight justification for this so that it is a bit more understandable:

"This is to eliminate ambiguous directionality in whitespace and ensure proper caret placement"
Where is this set?
I wonder if there's some way we can be more explicit about requiring a `AppRunLogger` context logger whenever a daemon `AppInstance` is used (injecting it into the constructor instead of grabbing out of the context?).  

Seems error-prone that one layer needs to know `AppInstance` is only used for `attach` and `run` (and not `drive`, say) and to set context `AppRunLogger` and then the next layer needs to assume it's been set correctly without enforcing it.
The right way to do this is probably to make the Domain require an AppRunLogger in the constructor. We can pull it out of the context and cast in run/attach - at least until those don't use the context.

Though really, we could probably express all of our loggers as a single class (except for maybe BufferLogger) and then it would just be about configuration
nit: consider adding a comment here or at the top of the test explaining that this mimics the start of a gesture as seen on a device.
don't need a line break here
This is OK, but it shouldn't be necessary to use a key to identity the OutlineButton (here and elsewhere). This will work as well:
```dart
tester.getSize(find.byType(OutlineButton))
```
This kind of comment is really important, glad to see that you've taken a crack at it.  It would help to include similar comments, anywhere that the sizes aren't obvious.
```dart
// The expected width is the sum of:
//   the width of the icon
//   the gap between the icon and the label (8)
//   the width of the label (50)
//   the horizontal padding: start 12, end 16
```
nit: we conventionally have the `child` widget be the trailing named parameter in Flutter.
```suggestion
              onPressed: () {},
              child: const SizedBox(width: 50.0, height: 8.0),
```
nit: we conventionally have the `child` widget be the trailing named parameter in Flutter.
```suggestion
              onPressed: () {},
              child: const SizedBox(width: 50.0, height: 8.0),
```
nit:
```suggestion
  /// [TextStyle.color]. The [TextStyle.color] depends on the value of [enabled]
```
This should not be `=` I believe
I could make a method on `PubspecDependency` to handle this, but  .. this whole thing is pretty convoluted as it is, and all the classes are in this file anyway.
It seems like there should be a bounds check on `lines.length` somewhere in this loop.
Yeah, an invalid pubspec could cause this to crash. I'll add a check and throw with a more appropriate error.
Could we throw if ` call.arguments` isn't a `Map`?
nit: I couldn't find the definition of "main axes". Maybe "horizontal axis or vertical axis"?
It appears to me that if the user initiates a horizontal drag, then they won't be able to change the direction to vertical later (in the same gesture). Maybe add documentation for this behavior too?
Can this be done in `_onScaleUpdate` to avoid checking `_gestureType`?
Will do, that sounds better.
That's right.  I'll document it.  It seems to be how Google Sheets works on my iPhone too.
Good call üëç 
This is a rewrite of the EarlGrey [FlutterViewControllerTests](https://github.com/flutter/flutter/pull/61007/files#diff-fd7097c2fc18cf84af75aeee43e84608).
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/AppDelegate.m](https://github.com/flutter/flutter/pull/61007/files#diff-9e149ff1c1dcf4b51edd1f16e15eea54) but git didn't follow the rename.
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/AppDelegate.h](https://github.com/flutter/flutter/pull/61007/files#diff-857228bf10c8c1e20cb51a974a25baa0) but git didn't follow the rename.
This was moved from [dev/integration_tests/ios_add2app/ios_add2app/Launch Screen.storyboard](https://github.com/flutter/flutter/pull/61007/files#diff-95f972d78b529be67ee75548a2086d30) but git didn't follow the rename.
I wanted something identifiable as the home page.
Mostly copied from [dev/integration_tests/ios_add2app/README.md](https://github.com/flutter/flutter/pull/61007/files#diff-14972bc6e76cd3b7d00d54d922a9c95f).
This was essentially copied from https://github.com/flutter/flutter/blob/023532d9919463404e0ae2a8aa47d07247ad7e65/dev/devicelab/bin/tasks/ios_app_with_extensions_test.dart#L79  Next PR will convert that test to use this new function.
This was deprecated with https://github.com/flutter/flutter/issues/54408 and is a no-op.
Woo one fewer bash script!
Intentional?
ditto
FWIW, EarlyGrey is about to publish a Flutter plugin. 
Oh, I get it now, these would correspond to the one you're removing for other platforms. LGTM.
There's no more add_to_app_tests on any platform, so we don't need a windows or linux one.
Hm, this isn't working, I'm still getting errors from these files.  You guys have any hints to get it to ignore `ios_host_app/flutterapp/lib/main.dart` and `ios_host_app/flutterapp/lib/marquee.dart`?
how about `**/flutterapp/lib/**`?
I think you were looking at an outdated diff.
Also `./dev/integration_tests/ios_add2app_life_cycle/flutterapp/lib` exists and is a real package.
> Ugh, didn't even get to the analyzer this time. Still trying to figure out how to have floating dart test files that aren't really in a package, but will be copied into a newly created package by an integration test.
> 
> ```
> Warning: pubspec in /tmp/flutter sdk/dev/integration_tests/ios_host_app/flutterapp has out of date dependencies. Please run "flutter update-packages --force-upgrade" to update them correctly.
> ```

I don't think that test is even using the analyzer, it's just checking the pubspec checksum
https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/commands/update_packages.dart#L180
can this be `testWithoutContext()`?
All of the createTestCommandRunner tests hit the context due to FlutterCommand. I started refactoring things out, but I got stuck on output preferences and rolled it back a while ago
I think this is more readable as includeInputDecoration ? cons InputDecorationTheme(...) : null
Done
adding this with a post frame callback concerns me because there may now be a 1 frame lag where the render object is inconsistent for the selection and the inspector overlay. Can we update the root render object earlier to avoid this issue?
nit: end comment with a period.
here and elsewhere, prefer to end comments with a period.
give these descriptive variable names instead of m1 and m2 or remove the variables names completely as each variable is only used once.
For example. maybe instead have _RenderInspectorOverlay check what its immediate parent is.
bonus points: add a golden image test or two that renders the selection. just like the screenshots you included with the CL, that makes it really obvious what is going on.
this object isn't really related to the selection so it is a bit confusing to have as a public member of the InspectorSelection object. Can you remove it from here and maybe only track it in _RenderInspectorOverlay? That would seem like a great place to be tracking the root render object that we are trying to render relative to.
I ended up passing the _RenderInspectorOverlay parent to the layer.
I'll experiment with how to do golden tests, because I've never used them. Thanks for the suggestion!
@jacob314 I've created a golden image test. The image is attached at the end of the PR description.
to be defensive, maybe add an is check in case the parent is not a RenderObject.
inspectorRoot seems like it is unused. remove.
This is adding a tight dependency that the _RenderInspectorOverlay has a parent that is a Stack and is the last child of that parent. That is probably ok but is a little fragile. We should either add a key to the Stack that is the parent of the _RenderInspectorOverlay or document in the code where the Stack is used that we are making assumptions about its child.
https://dart.dev/guides/language/effective-dart/design#avoid-starting-a-method-name-with-get
wow I'm surprised this multiple WidgetInspector case works this well :)
Good catch. It was a remain of a different implementation I had for that.
I thought about the key, but I wasn't sure about passing it through arguments all the way down. It looked off. Also the key would have the problem of calling findRenderObject in the first frame right?
I'll add a comment to the Stack at the top as you suggest.
Actually, that is a function local to the test. I used the same name convention as the other tests that access the inspector state.
I think we should keep the name for consistency with the rest of the tests. What do you think?
Very niche use case I would say, but I was surprised as well to see it working perfectly fine in a sample app where I took it to the extreme. Multiple MaterialApps and even nesting between them ^^ 
sgtm
as long as it is documented in the build method it is fine as is. 
nit: Tweak to 
// Be careful changing this build method.
nit: `as last child` -> `as the last child`
It's somewhat confusing that `value.composing.isValid` and `value.isComposingRangeValid` seem so similar but mean different things.  I can't think of a way to make it more clear though ü§∑ 
I guess we could use null to represent an editing value that has no composing range. That would be a breaking change.
Probably not worth it.
```suggestion
  }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767
```
```suggestion
  }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767
```
```suggestion
  }, skip: isBrowser); // https://github.com/flutter/flutter/issues/42767
```
nit: maybe rename to something clearer like `useUniquePaint`?
Done (renamed to `benchmarkPaint` as discussed offline)
Is there no mac equivalent? Like the spinning beach ball? üòú
Are these equivalent? Or specific to certain browsers?
`allScroll` mentions falling back on `move`, and here it is vice versa. Is there a specific condition or precedence for one or the other?
I probably should doc this, but mac decides when to show the spinning beach ball by itself (when the application does not respond a blocked callback for a while), and does not expose a way to manually trigger it. 
Good catch, this is actually macOS.
Yeah, I thought `move` should be ubiquitous so that `allScroll` might fall back to it, but it turns out no platforms have `move` but no `allScroll` at all. I'll remove this fallback.
Is this a unique ID for each `PointerEvent` or can multiple PointerEvents have the same motionEventId?
Can we document this in a more platform-independent way so we can re-use this for the other platforms as well?

Exact wording would depend on the answer to the question below. Does this id uniquely identify the event across framework and engine? Or (if there are multiple PointerEvent with this id) does it identify the native event that generated this framework-side PointerEvent uniquely on the engine side? Something like this should be included in the doc comment.

After that, we can also include a platform-specific paragraph that on android this maps to the ID of the underlying MotionEvent. Or something like that.
A name for this property that doesn't tie it to Android's MotionEvents (and hence can be reused for other platforms) would probably also be a good idea.
Nope, this is unique per `PointerEvent`. Multiple `PointerEvent`s can not have the same `motionEventId`.
I will try to address this and the comment below here: 

What do you think of `embedderPointerEventIdentifier` as a possible name for this? Given that this is different from `pointerIdentifier` -- which is used for hit testing, whereas `embedderPointerEventIdentifier` is used to tie back the current pointer event to the platform equivalent which resulted in this event.

If you agree with that, I can elaborate the dart-doc to explain the intent of this field along with the differences between this and `pointerIdentifier`.
Can we just shorten this to `embedderId`?
The doc should still include the explanation how it is different from the other IDs in this class.
SG
... to the embedder event that created it?
Maybe add a section about Android explaining that on Android this is the ID of the underlying MotionEvent.
The naming convention here seems mixed?
If we're going to include comments like this, maybe remind devs that AnimationControllers can be created with `vsync: this` because TickerProviderStateMixin.
This is the main application widget; here and elsewhere.
Just being pedantic: these templates import the material library.

The updates look good.
```suggestion
`MaterialApp` instead. These templates import the  material library.
```
```suggestion
`CupertinoApp` instead. These templates import the  cupertino library.
```
```suggestion
These templates create a `WidgetsApp` that encloses the snippet widget. These templates import
the widgets library.
```
nit: replace generate with create?

(in the code and doc comment above too)
Any reasons this cannot be a regular `testWidgets` test? You should be able to just instantiate the custom binding in the main before all `testWidgets` methods.
Aren't those arguments the default for pump? If so, let's remove them.
What does this comment mean?
nit: space after `while`
Does this while loop actually run? I would have expected that `SemanticsUpdateBuilderSpy.observations` is empty because you cleared it above and then pumped a frame that didn't change any semantics?
Can you add an expect before the while loop to check that `SemanticsUpdateBuilderSpy.observations` actually contains the expected number of nodes?
Instead of doing the while loop I'd also have more confidence in the test if it would just check individually that all expected nodes are in `observations`.
```suggestion
      // We should have looped through all the observations.
```
What's this typedef for?
Why this second MergeSemantics?
nit: remove extra blank line.
There should also be a test where we modify the semantics of a node that gets merged into another node and ensure that only the (updated) merged node is send over.
I am surprised that it sends this many semantics nodes. I would have expected 2: the root node and the merged node. Is that because of the `MaterialApp` used in the test? Can we remove it (and replace it with the individual widget we need, e.g. a Directionality widget) to make this test more targeted? Otherwise we will have to update it whenever the semantics of MaterialApp change...
remove extra blank line
Can you achieve the same effect by removing this MergeSemantics and setting `container: true` on the semantics node below? Seems slightly simpler then the nested merging...
```suggestion
    description.add(DiagnosticsProperty<Tween>('widthFactor', _widthFactorTween, defaultValue: null));
```
```suggestion
    description.add(DiagnosticsProperty<Tween>('heightFactor', _heightFactorTween, defaultValue: null));
```
I may be clearer here and below to say Must be greater than or equal to 0.0, defaults to 1.0.
Good point.
Oops üòÜ 
I thought these could be greater than 1.0?
They can üò¨  Just pushed the correction :) 
@hansmuller just astutely noticed the Align-ment (üòÜ ) here is off. Can you fix this nit before we merge?

```suggestion
       assert(widthFactor == null || widthFactor >= 0.0),
       assert(heightFactor == null || heightFactor >= 0.0),
```
Hahaha üòÜ  done
This `assert` doesn't take into consideration for multiple input events at the same time. This often happen for `PointerAddedEvent` and `PointerDownEvent`. 
I'm not 100% sure when I need pump. Another possibility is to pump in the beginning of this else clause and in the end of this guard async call.
Is it true that we should only expect `PointerAddedEvent ` and `PointerDownEvent` here? If so, I wonder what `assert` we can put here.

Nit: maybe it's less error prone to write
```
if (condition) {
  doSomething();
}
```
than
```
if (condition)
  doSomething();
```
We have both styles in our code base and I personally prefer the first one because I've made some mistakes before with the second style.
For now, I think we can probably `assert(...framePolicy  == ...fullyLive/benchmarkLive)`and remove `pump` as this is probably only used in our tests. If in the future we want test something with some other `framePolicy `, we can then figure out where to put `pump` with the guidance of those use cases.
As we discussed today, we probably want to simulate at the `_handlePointerDataPacket` level instead of the `_handlePointerEvent`?
`framePolicy` requires `LiveTestWidgetsFlutterBinding`, which is not what we use for unit test. And my unit test also depends on this. If I have to change the behavior here I would rather just `pump`, which is what we are already doing for `WidgetTester.drag` anyway
I still feel it's better to leave the testing API `PointerEvent` and do the conversion when accepting json input, as #60741 (I'm keeping this PR up-to-date with our discussion), because this API is also useful as accepting a controlled sequence of input for testing, see my test case, and `PointerEvent` is easy to write and `PointerData` is raw without logical pixel conversion, history dependent to decide type, etc. Also, for release mode binding, `PointerData`->`PointerEvent` conversion happens before anything goes into loops for hittest or widget reaction. 
> Is it true that we should only expect `PointerAddedEvent ` and `PointerDownEvent` here? 

For the test runs I did, yes. But I can't say for sure. According to the documents I think `PointerEnterEvent` and `PointerScrollEvent` may also go here. This depends on runtime history of the input events and is hard to track the source. 

But since it's test, I would say I''ll still add assert and if people find something in the future they can add more.
This comment doesn't look clear to me... What does "The class" mean here? Is it the `Map`, or `_LiveTestPointerRecord`, or something else?
Is this the `PointerEvent` version of the `PointerDataPacket` in the sense that each `PointerData` in the `PointerDataPacket` is converted to a `PointerEvent`, and put into this packet?

If so, maybe `PointerEventPacket` is a better name to signal the relationship between this and `PointerDataPacket`.
I think this is the time stamp when the engine gives the whole packet to the framework? The time stamp of when the event happens should be `events[i].timeStamp`?
Sounds good.
This seems to suggest that `pack.timeStamp` is relative to the start of `handlePointerEventPack`. It might be helpful to clearly document it in `PointerEventPack.timeStamp`.
We might want to record the actual `timeDiff = pack.timeStamp - binding.clock.now().difference(startTime);` here to see how close it's to 0, and see how well we simulate the timing of those packets. Maybe put this logic and the for loop into a helper function so line 480-482 can use it too.
I mean `_LiveTestRenderView` but I can delete it. It's just when I read it it took me some time to find out what this `_pointers` is used for. 
What I mean here is, this member variable is only used to draw a cross sign at the location of the input event.
If if helps you, it probably would help other too. `// _LiveTestPointerRecord records these pointers to draw touch positions.` might be clearer?
I'm thinking collect `timeDiff` in a list and return it. 

And I realize one more thing. The current code kind of promises the first event (which I offset it to default `Duration.zero`) is almost certainly goes to the `timeDiff.isNegative` branch and becomes a negative timeDiff, which is not a good behavior: it should be rounded to zero. 
`handlePointerEventPack` to `handlePointerEventPackets` for the recent renaming, and make it plural to signal that there's a list of packets. `records` may be better names as packets too.
pack -> packet
similar rename update.
Add a warning here and remove "// maybe trigger a warning". No one is probably going to add warnings or paying attention to this if this is just a comment.
@liyuqian @dnfield This one is one of the places I have to modify framework. And I actually am considering it a bug: if there is a customized Widget that's specifically reacting to `PointerAddedEvent` in some way, because of this, such behavior won't be able to be tested using `flutter_test`. 
As a work around in my specific project, I can skip all recorded `PointerAddedEvent`. I'll write a failed test case tomorrow but it will look weird.
I believe it's no longer needed since the timediff is returned. 
Cool - it's fine if it looks weird, as long as it's valid :)
how does this differ from Timer?
This isn't so much "Execute a callback in a later time for the binding" so much as "advance the clock and execute the callback". Why not just have people use `pump`, which also advances the clock?
please see style guide regarding line wrapping (if there's a newline after `(` there should be one before `)`)
serials -> series
flutter -> Flutter
for -> as the
I'm not sure what this paragraph means. Shouldn't this always be zero in a unit test, since the clock is artificial?
why not implement it?
`PointerEvent` -> `[PointerEvent]`
please start documentation sentences with a capital letter (see style guide)
`PointerEvent` -> `[PointerEvent]`
this is insufficient documentation
see style guide for writing prompts
wrapping
missing space after `for` (no space implies it's a method call)
`} else {`
wrapping
wrapping

fwiw, if you're using dartfmt for formatting, you'll get the right formatting here if you either set a wider line width or if you put a trailing comma on the last argument
The idea here is that the same thing, we do it differently for different bindings: for Live binding we wait for a real period of time, but for the binding with a fake clock, we add time and then perform the callback. The `addTime` method only add to timeout but don't add the fake clock time, which influence for example animation. The pump schedule a frame which is not preferred here. 
For unit test yes. But the whole idea for this is to make the same code and API used for unit test as well as integration test on a device. 
flutter/plugins/E2E for example is using WidgetTester for running tests on device. 
I would like an auto formatting tool but we have a lot of things in our style guid that's different from dartfmt, and dartfmt will change the whole thousand-line file :(
I now don't feel very comfortable with this renaming. `PointerDataPacket` is just a list of `PointerData` without timestamp https://api.flutter.dev/flutter/dart-ui/PointerDataPacket/PointerDataPacket.html but this class has a time stamp. I'm thinking if `PointerEventRecord` is a better name, and so is `PointerDataRecord` if we are going to change the API from accepting `PointerEvent` to `PointerData`. 
please file a bug and link it here
nit: is there a clearer name we could use for this? Maybe just `delay`? 
nit: here and below, space after `for`.
nit: consider rewriting this loop as:

```suggestion
expect(logs.first, 'down $b');
for (int i = 1; i < logs.length - 1; i++) {
  expect(logs[i], 'move $b');
}
expect(logs.last, 'up $b');
```
The reason I'm calling it a timeStamp is the data comes from timeline timestamp in my recording package. But since there's no recording context here maybe I need another name. I don't like `delay` because it's too similar to `delayed` that's used `Future` everywhere. Maybe `timeDelay`. 
So happy with this review! My personal preference is your version but I'm seeing that if-in-for style everywhere in `controller_test` (e.g. https://github.com/flutter/flutter/blob/afd745e8933fe35659d347bb0740e56c263da3ec/packages/flutter_test/test/controller_test.dart#L288-L295 ) and I was thinking if I was wrong about this preference. 
timeDelay SGTM
I'm thinking implementing it should be mostly the same as the implementation in `WidgetTester`, but when I had a look at how we are using this `LiveWidgetController` in the repo I found very limited to a few test cases in `dev/`, where
1. `dev/benchmarks/complex_layout/test_memory/scroll_perf.dart` is using `fling` which already is pumping regardless. 
2. `dev/integration_tests/flutter_gallery/test/live_smoketest.dart` and `dev/integration_tests/flutter_gallery/test_memory/image_cache_memory.dart` don't pump at all
3. `packages/flutter_driver/lib/src/extension/extension.dart` is used in `flutter_driver` and don't have pump. 

From these use cases I believe 1 is just not taking much consideration about pumping while 2 and 3 already suggest not to pump. 
And `LiveWidgetController` is not unit tested. 
Already had a no-op forwarder for desktop
I guess this was this unused?
completely!
This test has the same name as above, guessing one is incorrect?
Good catch, should say disabled here
`[new Foo]` is the DartDoc syntax for referring to the Foo constructor
transparent => translucent
It's probably pedantic to say so (so don't change this line), but this color overrides the default row color. That said, we should document what the default color is, before explaining how to override it.
Since we're renaming the parameter, it seems like calling it activeColor, would be a tiny bit more straightforward.
This is just the joy of factoring. Maybe:
```dart
final Color rowColor = index > 0 ? rows[index - 1].color?.resolve(states) : null;
...
color: rowColor ?? defaultRowColor.resolve(states),
```
math to a => match a
TIL, reverting that line change.
Done.
Would `{TestBindingEventSource source,}` instead of `{TestBindingEventSource source = TestBindingEventSource.device,}` have the same effect here and reduce the confusion?
I think so. @Hixie 
I'm guessing for an `enum`, leaving it `null` is not preferred. 
Is there something missing here?
```suggestion
    return _colorIsUniform && _widthIsUniform && _styleIsUniform;
```
here and below: The previous formatting was better as it made clear where the condition ends and where the body of the if starts.
Can this (and the other two above and below) be written in a single return statement:

```suggestion
    return right.width == topWidth && bottom.width == topWidth && left.width == topWidth;
```

(Please double check that I transformed the logic correctly...
This error will be grammatically incorrect (is vs. are) if more than one property is not uniform (assuming that can happen).
same here.
Can you also add this information to the doc of Overflow.visible?
should be -> must be
Yeah, it is possible for more than one to be listed. I wasn't sure if it was worth handling the is/are. I've tried a tweak, let me know what you think. :)
See comment above.
I guess we can just `Canvas(recorder);` to avoid the unused variable warning?
given the .none constructor, should we assert it's non-null here?
additional white space after this line
same here
```suggestion
/// The optional `routeSettings` parameter sets the [RouteSettings] of the modal bottom sheet
```
```suggestion
  testWidgets('Verify that route settings can be set in the showModalBottomSheet',
```
since you already defined the routeSettings, can you directly check for identity?
`expect(retreivedRouteSettings, routeSettings)`
Yes, that's doable
This seems not addressed yet?
Missed that. Just resolved it.
interesting, this uses posix paths on windows too?
nit: maybe put this in a constant, with some docs on where exactly it comes from, like "we only support this particular sdk, see doctor blah blah".
Is this covered by our existing doctor checks?
Yes, CMake always uses posix-style paths. That's what the use of `TO_CMAKE_PATH` in the other generated file is for, but here it was easier to just convert it before writing it.

(The reason for all the escaped Windows paths in the other file is that those aren't used by CMake, but passed through back to the tool script, so I want them to stay untouched.)
The change below (line 220) makes it part of the `doctor` flow.
Done.

It hadn't occurred to me that this may mean that the next major version of VS won't actually work since the generator is hard-coded; I don't know if these values are forward-compatible. But since this is in the tool, not the ecosystem of plugins and projects, we can easily add switching logic here later if that turns out to be the case. (Unlike the requirement in the old method of having a hard-coded toolchain version in the project file, which was one of the things that really worried me about the ecosystem longer term.) I added a comment to that effect on the constant.
Can you document the problems that this can cause if this is turned on for nested navigators (or whenever you have more than one navigator doing this)?
Still need to regenerate the localized sources.
These strings do not have localized sources. They were set to 'TBD' because that was the standard before when we added new strings that needed to be localized. Now, we just use the English source as a placeholder until the localized source is present (for Pashto, it will not be anytime soon since Google does not support it at the moment).
But I think he is saying that the `material_ps.arb` has been updated, so don't we need to run `gen_localizations` update the generated localization info with this changes to Pashto? Just like we would need to do if these updates came from the translation team.
Right, that's what I was getting at.
Oops, thanks for the clarification! Done
Since these values are never set, it would be preferable to mark them `final`
formatting: put the start of the map on the same line as `_severityMap `
formatting: if you use `{ }` for a method body, its preferable to start the actual implementation on the next line. Only use `=>` for methods on the same line. 
```dart
if (...) {
  return ...
} else {
  return ...;
}
```
can be written simply as 

```dart
if (...) {
  return ...;
}
return ...;
```
Please don't ignore the analysis errors.
indent seems to be off
Thanks for the review. I addressed the indent and other minor styling issues (like adding trailing `,`) and pushed. 
```suggestion
  /// The summary dill with null safety enabled for the dartdevc target.
```
can we make this its own artifact?
Yeah, that is a good idea
same here
Thanks, it'll help me with my refactor, though I still might get trapped in merge conflict hell...
Flutter repo requires all types to be explicitly written even though they can be inferred. In this case, specifying `Queue<ui.PointerData>` should be better than the inferred `List<ui.PointerData>` to have a faster O(1) `_queueData.removeFirst()` than O(length) `_queueData.removeAt(0)`.
This function seems to assume that `_queueData` is sorted in `timeStamp`. Its current implementation seems to make a lot of unnecessary assignments of `_last, _next` in the beginning, and then continue to iterate through `_queueData` to its end unnecessarily. Would the following code be better and ready for a bisect optimization if we find the queue to be long in the future?
```
if (_queueData.isEmpty) {
  return;
}
_last = _next = _queueData[0];  // So _last and _next won't be null in any case.
int index = 0;  // The index of the first data whose timeStamp >= sampleTime
for (; index < _queueData.length && _queueData[index ].timeStamp < sampleTime; index += 1);
if (index - 1 < _queueData.length) {
  _last = _next = _queueData[index - 1];
}
if (index <_queueData.length) {
  _next = _queueData[index];
}
```

(BTW, Flutter prefers `i += 1` instead of `i++`.)

With either implementation, the edge cases seem to be non-trivial. It might be nice to add unit test cases where `_queueData` is empty or `_queueData.length == 1`.
Ditto. Flutter repo requires explicit types.
Ditto
Nit: `bool get hasPendingData=> _queuedData.isNotEmpty;`
Flutter repo requires explicit types and `final` (instead of `var`) if possible.
For multi-touch, I think we'll need to construct one resampler per touch pointer, right? Maybe it's nice to clarify that in the class doc. In general, this class could have more documentation on how it should be used, or how it should not be used :)
The plural `positions` make me think that this could return multiple `PointerData` perhaps for multi-touch. But it actually can return at most one `PointerData`. Maybe add comments to reduce confusions, or maybe return `ui.PointerData` instead of `List<ui.PointerData>`?

Also, `_sampleMoveOrHoverPosition` seems to better describe this than `_samplePointerPositions`.
Flutter repo requires explicit types and `final` (instead of `var`) if possible.
Flutter repo requires explicit types.
The resampler here doesn't seem to support multi-touch in one resampler. Shall we assert that `_pointerIdentifier` is always the same unless it's cleared by `ui.PointerChange.up` or `ui.PointerChange.remove`?
`if (data.timeStamp != _next.timeStamp)` seems to be equivalent to `if (sampleTime == _next.timeStamp)` in this context. The later condition seems to be more intuitive to not process early as we're so lucky that the sampleTime is exactly the next event's timestamp, so we should process the later `data` in the future.
Nit: `Stop if change is not up or remove. Otherwise, continue to allow early processing of up and remove events as ...` seems to be clearer than `Stop if change is not up or remove, which are allowed to be processed early as ...` to me.
Done
We need to keep something like the previous code now that we're using a queue. I made it more efficient by stopping when the first data with time stamp greater than sample time is found. The amount of data processed here should always be low. The only time we might set last/next multiple times is when input frequency is higher than refresh rate and it would need to be extremely high for this processing to become a problem.
Done
Done
Done
Done
Done
Good idea. Done.

Also explained in the class description that multiple instances are needed for multi-touch.
These expressions are not the same. This expression prevents us from processing data past the _next data. We allow _next data to be processed early for up/remove changes but we need to stop processing if we've gone past _next. Let me know if there's a comment I can add here to make this more clear.
Done
+1 From the doc it is not clear to me why I would want to use this.
I made that clear right below here. Let me know if something else is needed. Maybe explain why someone would want tot resample events? You can also find two examples of how this code is used in the fuchsia codebase:

1. https://fuchsia.googlesource.com/experiences/+/refs/heads/master/benchmarks/bin/scroll_flutter/lib/main.dart
2. https://fuchsia.googlesource.com/experiences/+/refs/heads/master/settings/lib/widgets/lib/src/utils/pointer_events_listener.dart

These examples use a map of resamplers for all touch input. data.device is the key that determines what resampler to use.
Ah yes, I forgot those events past `_next`. I was only thinking the first data with `data.timeStamp > sampleTime`. I think it's probably clearer to write `if (data.timeStamp > _next.timeStamp)` as `_next` is the `data` with the smallest `timeStamp > sampleTime` so we're not expecting any `data` with `sampleTime < data.timeStamp < _next.timeStamp`. This time I tried it with unit tests below to make sure that it's not trivially false like the `if (sampleTime == _next.timeStamp)` condition...

Overall, I wrote the following to dump all my thoughts. From the comments below, it seems that the fling smoothing ("up"/"remove" early processing) would only be guaranteed when the input frequency is no greater than the display frequency?
```
        // When this line is reached, the following two invariants hold:
        // (1) data.timeStamp > sampleTime
        // (2) _next has the smallest timeStamp that's no less than sampleTime
        //
        // Therefore, data must satisfy data.timeStamp >= _next.timeStamp.
        //
        // Those data with the minimum data.timeStamp == _next.timeStamp
        // time stamp are processed early for smoother fling. For data with
        // data.timeStamp > _next.timeStamp, the following lines break the while
        // loop to stop the early processing.
        //
        // Specifically, when sampleTime < _next.timeStamp, there must be at
        // least one data with _next.timeStamp == data.timeStamp > sampleTime
        // and that data is _next itself, and it will be processed early.
        //
        // When sampleTime == _next.timeStamp, all data with data.timeStamp >
        // sampleTime must also have data.timeStamp > _next.timeStamp so no data
        // will be processed early.
        //
        // When the input frequency is no greater than the display
        // frequency, this early processing should guarantee that "up" and
        // "remove" events are always re-sampled (by linear interpolation).
        assert(data.timeStamp >= _next.timeStamp);
        if (data.timeStamp > _next.timeStamp) {
          break;
        }
```
All the above unit tests add all events at once, and then sample gradually later. In practice, I'd expect most cases to add a few events, sample some, and then adding a few more, and then sample again. Shall we also unit test such cases?
Sounds good. Then maybe it suffices to add a comment like "Find _next to be the data with the smallest timeStamp that's no less than sampleTime, and the _last to be the previous event before _next." for easier understanding.
Thanks for taking a detailed look at this. I changed to `if (data.timeStamp > _next.timeStamp)` and included your comment (with some minor adjustments) in the code.

Yes, this early processing only works when input frequency is lower than the sampling frequency, which is when this has been determined to be critical. Good call to explain that in a comment.

We could allow the "next" sample time to be passed to the resampler and process up/remove until that time to enable the same for high frequency input events. Some experiments on devices with high frequency input events would be useful to determine the value of this. I can imagine it being useful when input frequency is 2x the refresh rate. 
Done. Latest code as a new "stream" test that behaves more like what we see on real devices.
Yeah, a quick explanation as to why somebody would want to resample events would probably go a long way here.
Is this `_isDown` a duplicate of `event.down`?
Nit: `///` => `//`.
I see in the unit test this can return a list because there may be multiple events at the same time. Does it also makes sense to comment it here in the doc comment? 
Nit: maybe it's a little clearer to name this as `_dequeueAndSampleNonHoverOrMovePointerEventsUntil`, or maybe keep the current name and add the following lines to the end of it
```
    // Add resampled pointer location event if tracked.
    if (_isTracked) {
      events.addAll(_samplePointerPositions(sampleTime));
    }
```
Yes, I cleaned up this code in latest version. Thanks for the hint.
Done.
Done.
Done.
Nit: I think `scheduler ??= SchedulerBinding.instance;` can be simplified a little to `scheduler ?? SchedulerBinding.instance;`
It would be nice to add cases like `or when the high input frequency is not a multiple of the display frequency (e.g., 120Hz input and 90Hz display)`.
Ditto: it would be nice to add cases like `or when the high input frequency is not a multiple of the display frequency (e.g., 120Hz input and 90Hz display)`.
Should we try to remove the resampler when an up/remove event happens? I'm not sure if some OS would generate a very large number of different `event.device` that would eventually make this look like a memory leak.
It's helpful to comment that `samplingOffset` is usually negative.
Is this only used for tests? If possible, it seems to be safer to override `SchedulerBinding.instance` in the test instead of providing one more changeable field for `GestureBinding`.

As a binding (singleton), it seems to be sufficient to just instantiate a subclass binding. For example, see https://github.com/flutter/flutter/blob/88118bcbd1e20de25875e43da62ceea7357feb4e/packages/flutter_test/lib/src/_binding_io.dart#L24-L28 and _https://github.com/flutter/flutter/blob/88118bcbd1e20de25875e43da62ceea7357feb4e/packages/flutter/test/services/binding_test.dart#L59_
Is 
```
final SchedulerBinding? instance = scheduler ??= SchedulerBinding.instance;
assert(instance != null);
```
equivalent as 
```
final SchedulerBinding instance = scheduler ?? SchedulerBinding.instance
```
? since the second is null-safe protected already.
`Duration.zero` is probably easier to read than `const Duration();`. So is many following. 
Nit: an extra line break between this and previous, as a style guide to have a single sentence to start the doc string. 
Can we be a little more specific for the comment or maybe remove it if not necessary? `Process events for sampleTime.` sounds already implied by the name of the method. 
Correct me if there's other reason, but can we move this part to `_flushPointerEventQueue`, so 
1. `_pendingPointerEvents` will mean the same thing with or without the resampler; 
2. relevant codes will be at the same place so it's easier to understand and maintain. 
Nit: position and delta? 
If I understand the code correctly, only `PointerUpEvent` and `PointerRemovedEvent` is skipped, `PointerAddedEvent`, `PointerCancelEvent`, `PointerDownEvent`, `PointerEnterEvent`, etc, are all resampled with almost the same algorithm with `PointerMoveEvent` and `PointerHoverEvent` as in `_samplePointerPositions`. I wonder why should we, and if we can have some part explain the resample algorithm in the doc of the class. 
ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto about `Duration.zero`
Ditto
Ditto
And generally speaking, should we skip all events that we don't recognize/designed and only limit resampling to what we know?
And is there anything else that may require resampling? One thing I can think of (but not sure) is `scrollDelta` for `PointerScrollEvent`, which looks like need a quite different logic than what's here. It might worth filing an issue to record that. 
Remove from latest change that is using SchedulerBinding.instance for testing.
Done
Done
Yes, I'm removing resamplers that are inactive in latest change.
Done
Done.
Done
Removed it.
Good idea. I've done this in latest change. I've also changed to resampler code to take a callback as that integrates better gesture bindings and avoids unnecessary use of a temporary list. 
All events except `PointerAddedEvent` will be resampled given that we have future events queued that allow us calculate a resampled position. I've found that it's important to resample all events to ensure that the beginning and end of touch based animations are smooth. E.g. if we're not resampling `up` then it will appear as a sudden change in velocity when this event arrives unless the code is careful to take time stamps into account when determining velocity.

I explained that all events except 'added' are resampled in the doc of this class.
Done
Done
So should this number depend on the frame refresh rate? e.g. on 90Hz device like Pixel 4, should this be smaller? 
If this offset can be device refresh rate dependent, should we also calculate this number instead of set a fixed one? I was told we can get the refresh rate from a service protocol extension `_flutter.getDisplayRefreshRate`, if that information is somewhat helpful. 
The ideal value typically depend on:

1. Sensor frequency.
2. Platform processing overhead. E.g. how long does it take for the event to arrive here.
3. The amount of input latency that an app is willing to add for smooth event processing.

Best way to find a good default values here are through experimentation. The value used by default for now has been proven to work well on Fuchsia systems where the sensor is ~60hz. Shorter duration will result in poor resampling results as it becomes more likely that we don't have events queued that can be used for resampling.
Refresh rate is not meaningful for this offset. input sensor frequency is but that's not something that platforms typically expose.

I think we should create a follow up task to determine good default values for different devices. The best way to do that is likely through some automatic test that can also be used to detect regressions. Automatic test is how the current default value was established on Fuchsia.
So as a particular case, Pixel4 has input frequency about 120Hz, and refresh rate 90Hz, and one use case we are planning for the resampler is to help resample this 120Hz input to 90Hz, for better scrolling smoothness. Does this sounds like need a smaller `samplingOffset`?
We could reduce this to -21.333 and add refresh rate interval on top of it. Not sure that's much better though as the 21.333 value is still what needs to be determined through testing. We currently add 16.667 to this value here assuming that we start producing a frame for the currentSystemFrameTimeStamp at that offset. That's not the best assumption but making it "1000 / refreshRate" is also not good as that gives the appearance that we're always using the interval as frame scheduling offset.
According to https://api.flutter.dev/flutter/scheduler/SchedulerBinding/currentSystemFrameTimeStamp.html, `currentSystemFrameTimeStamp`: 
> On most platforms, this is a more or less arbitrary value, and should generally be ignored. On Fuchsia, this corresponds to the system-provided presentation time, and can be used to ensure that animations running in different processes are synchronized.

which sounds like we should use `currentFrameTimeStamp` instead. 
samplingOffset being too large will not hurt smoothness but it will hurt input latency so it's in our interest to keep it as low as possible while still making sure resampling works well.

If input frequency is 120Hz then we need 8.333 ms to ensure that we have 2 input events that can be used for resampling. We need some margin for events to be delivered from the input driver to flutter. Let's use 4.667 ms to account for the situation when device is under heavy load. 90Hz doesn't really affect anything but I'd guess that the app [VSYNC ‚Äî App reads input and generates next frame](https://source.android.com/devices/graphics/implement-vsync) (when flutter produces a frame) is relatively low on a device with that refresh rate. Let's guess 9 ms.

Given above, I'd try using samplingOffset=Duration(milliseconds: -22);  // 8.333 + 4.667 + 9
It's critical that this time stamp is in the same clock as the time stamps from input events. And it's also critical that this is never adjusted or scaled like currentFrameTimeStamp. This is something I [brought up](https://github.com/flutter/engine/pull/15936#issuecomment-579026468) when we were discussing if this code should live in the framework or in the engine. I was told that we can rely on currentSystemFrameTimeStamp working like Fuchsia on other platforms. Maybe this documentation needs to be updated.
Could a `PointerScrollEvent` reach here and trigger the assert?
Good point. I've updated the documentation to make it clear what event types are supported and gesture binding is not limited to touch events.
formatting nit:

```suggestion
          event.device, () => PointerEventResampler(),
        );
```
nit: can we just use a regular for loop over the values since key is unused anyways?
Why do we need to store the current sampling time in an instance variable? Can this not be calculated when needed by doing `scheduler.currentSystemFrameTimeStamp + samplingOffset`?
nit: leave this in one line
true shouldn't be in `
```suggestion
  /// resampling. The [samplingOffset] is expected to be negative.
```
Are positive values ever ok? Is zero ok? If not, we should add an assert that warns if you add something that is not acceptable.
Add to the docs: When would I typically set this to true if I want resampling? e.g. before runApp?
... can be used _to_ get ...
...of _adding_ some _added_ latency...

Can the second added be removed?
addd -> added ?
All these should be enclosed in `[]` instead of ` so they are linked in the docs.
same here.
when _the_ position?
formatting nit: add a trailing comma and put each argument a its own line.
should we add a `copyWith` to the events instead of doing these "is" checks?
formatting: trailing comma and one argument per line (here and elsewhere)
Can you add that information as a comment here?
Isn't it possible that _sampleTime is outdated when this code runs? For example, after some frames have been rendered, the first input event is received. At that point, this code runs, but _sampleTime is still zero, no?
Done
Done
Yes, this was a leftover from then the scheduler could change for testing. Removed _sampleTime from latest change.
leave what in one line? "... _resamplers = <int, PointerEventResampler>{};" is broken into multiple lines by "flutter format" and I prefer to follow its recommendation. let me know if you meant something else.
Done
Done
Yes, I was hesitant to doing that before I had general buy-in for these changes. Added a copyWith function to PointerEvent class in latest change.
Done
Yes, but that just results in us dispatching the first event directly, which is fine in practice as that's typically a PointerAddedEvent. However, this has improved in latest change as we're now using the current scheduler frame time and the offset directly.
Done. Typically during initialization but can also be changed dynamically if desired. Also made some minor updates to the code to handle dynamic changes better.
Added a comment. Non-negative values are allowed and will just result in no resampling. Just like setting the value to an absolute value that is not enough for the device does.
Done
Done
Removed
Done
Done
Done
Done
the flutter repository doesn't use flutter format, see also: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#formatting

From that section:

> Prefer avoiding line breaks after assignment operators.
`=>` should only be used if everything fits in one line, see https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#consider-using--for-short-functions-and-methods
nit: this line break is akward
Can `hasPendingEvents` and `isTracked` ever be anything but true/false? If not, you can omit the `== false`?
See style guide about not breaking at assignment opperator.
Also true elsewhere in the PR.
Shouldn't the return type be the more specific PointerAddedEvent?
format nit: here and everywhere below add a trailing comma and put ) on its own line with indentation same as the line with opening (
Done
I am wondering whether we can separate the resampling and the gesture binding a little more, e.g. you only set a PointerResampler on the gesture binding that you want to use and it encapsulates all the logic that's currently in the binding here.

/cc @liyuqian 
Done
Done
Done
Done
Fixed
Done
I added a _Resampler helper class to the latest version of this change. It encapsulates the logic to manage multiple PointerEventResamplers and the details of how the scheduler is used to determine sampling time.
Can everything below also get encapsulated inside `_Resampler`?

For example, instead of calling `_resampler.addEvent(event)`, we can send in a list of events `_resampler.addEvents(_pendingPointerEvents)`. The `_resampler` can also save the callback `_handlePointerEvent` as its field so it can schedule a sample callback by its own?
We would fail to detect when resampling is disabled in that case but we could introduce some callback cancel logic to handle that. We would also need some wrapper to ensure that we're not violating the "if (!locked)" condition. The overall complexity might increase but if encapsulation is highest priority then it might still make sense. Wdyt?
If it's locked, could we miss some events? If so, maybe we shall reschedule a callback if `locked`.
This looks like better in the setter of `resamplingEnabled`.
I think this is put here for the `assert(!locked)` condition as `stop` will fire the remaining events.
we need this here to be sure that assert(!locked)
Should be fine as _flushPointerEventQueue() is called from unlocked sometime after this
I did this additional encapsulation in latest version of this CL
It's immediately initialized. It seems that `late` is not necessary?
I needed this to be able to pass "_handlePointerEvent, _handleSampleTimeChanged" to this ctor. Let me know if there's a better way to solve that.
Sorry I misunderstood the keyword. 
Is it true that when this constructor is called (i.e., `event.device` key is absent in `_resamplers`), `event` can only be `PointerAddedEvent` or `PointerDownEvent`?
No, that would only be true if resampling was enabled before the first pointer event. If you enable resampling after first receiving a down event then we'll need to create the resampler here when processing a move event.
This recorder does not look empty. It looks like `WidgetRecorder` without the `drawFrameDuration` timeline. If that's all the difference, why not use `WidgetRecorder` and simply ignore the `drawFrameDuration` numbers?

If this class is really necessary, let's discuss how it fits with the other recorder classes. Perhaps it should be a super-class of `WidgetRecorder`? We should also add substantially more documentation for this class. In particular we should document when it should be used.
nit: rename to `_didStopCallbacks`.

For consistency, `WidgetRecorder` should also support multiple callbacks, but perhaps making this class a super-class of `WidgetRecorder` is a good way to gain both consistency and code reuse.
This is not used afaict.
Changed the name.
I don't understand "WidgetRecorder should also support multiple callbacks" (since it does support) and I'll assume it's no longer valid after removing `EmptyRecorder`.
Should this still be skipped for the PaddleValueIndicator? I think that shape might paint the stroke around the thumb portion of it
No, the value indicator is on the overlay so it float above the thumb widget and doesn't create any problem. I just checked and can confirm this.
What happens if overlappingShapeStrokeColor is null?

The SliderThemeData constructor's doc says:
```dart
  /// Create a [SliderThemeData] given a set of exact values. All the values
  /// must be specified.
```

None of the parameters are `@required` and all default to null (per our conventions for themes).
It still passes because we expect to find a circle of theme.sliderTheme.overlappingShapeStrokeColor.

None of the parameters need to be specified. If it is not specified in the SliderTheme then the Slider has default parameters that are based of the ColorScheme 
Is the early return above not sufficient here?
It is sufficient for this crash, but `_xcdevice.observedDeviceEvents()` is nullable, callers shouldn't need to understand why it can return null (that it can only return null if Xcode isn't installed).
@HansMuller the only difference from the previous pr is that the Material.transparency will no longer absorb hittest.
swallow => obscuring
the ink splash effect => ink splashes produced by flexibleSpace children.
nit: at this point the caching does seem to be worth doing anymore? You need to find the child's render box in order to verify the cache is still valid. It's only avoiding redoing the `inflateRect` calculation which seems cheap. 
Good call.  I removed the caching.  I'm assuming `findRenderObject` shouldn't be too much of a performance hit, but I'll watch out for slowdown.
Since this will be the first place a user is exposed to the term "velocity tracker", describe what it is or reference another doc
Maybe briefly describe what's special about iOS scroll velocity to help bootstrap the next maintainer
Why this name? Either somehow describe the "free scroll start" nature of the velocity tracking in the class doc or just call this ios velocity tracker.
Not sure I understood this comment
sounds stronger than what the code seems to be doing. You're just weighing the initial velocity more rather than matching the initial velocity no?
also seems like you're always using exactly 3 samples no?
"initial free scrolling speed" is a bit vague
Please add to the velocity_tracker_bench microbenchmark too
I thought we wanted to avoid having iOS in the name? Would be nice to know that I was mistaken.
"4 `_PointAtTime` samples" is what I meant
`Horizontal/VerticalDragGestureRecognizer.isFlingGesture` has a threshold for `VelocityEstimate.offset` for it to be a fling:
https://api.flutter.dev/flutter/gestures/VerticalDragGestureRecognizer/isFlingGesture.html

Initially I used 4 samples and that broke some tests so I had to record more points. Will point to `VerticalDragGestureRecognizer.isFlingGesture` in the comments.
I was trying to say this is the velocity of the scroll view not that of the gesture. Reworded.
It's still not too clear what the difference is and why this needs to be a separate class rather than changing VelocityTracker. 
You mean the difference in terms of the strategies used? Does
> /// A [VelocityTracker] subclass that employs a weighted average strategy to
/// estimate the velocity of the associated pointer, to match iOS scroll view's
/// fling velocity calculation.

sound better?
As opposed to what though. I was looking for a text that saves the next maintainer from seeing thing as redundant, try to merge the 2 classes into one, spend 2 hours and then realized that the approach for the 2 are conceptually different (which the maintainer could have discovered in 10s by reading this text)
Added a simple comparison of the 2 velocity tracker classes.
<optional at this point, up to your judgement> can this just be done by composition? i.e. most platforms use a VelocityTracker with a VelocitySampleScorer of [1, 1, 1, 1, ...] and iOS uses a VelocityTracker with a VelocitySampleScorere of [8, 5, 2, 1] or something? 
You mean the weighted average can be expressed in terms of a least-squares estimator? Not sure how I can achieve that, could you elaborate?
Remove this?
Looks like this PR also includes the changes from https://github.com/flutter/flutter/pull/60396. Is that intentional?
Yeah, I am still waiting for the tree to go green for #60396 to land. When it does, I will merge it into this PR, and it won't show up as a diff.
Good! 
delete?
Fixed!
I know this is copying existing functionality, but should we skip earlier if we're on windows?
doesn't have to be here, but from looking at this code it looks like we could replace this with a mock.
I think this is sort of - badly testing that chmod doesn't throw.
Oh, I missed that this was using the real file system. `chmod` is a no-op on Windows in any case...

`  void chmod(FileSystemEntity entity, String mode) {}`
makeExecutable too:

`  void makeExecutable(File file) {}`
nit: might be worth mentioning that this should be used if someone is using `package:stack_trace`, with a small example of how.
nit: Same doc nit, this might be a better place for an example than the typedef

nit: avoid abbreviations, `(StackTrace stackTrace) => stackTrace;`
We can be confident that `StackTrace.current` never needs demangling - this is a bit of a nitpick, but I think

```dart
if (stackTrace == null) {
  stackTrace = StackTrace.current;
else {
  stackTrace = FlutterError.demangleStackTrace(stackTrace);
}
```

Of course, if we're already in an error state, any time this might save is pretty inconsequential.
Maybe we could add an explanation here about how to use the new static global to fix this.
There should be a comma after this if you have parameters on a new line.
Why are we removing this test?

Can't this still happen?
Well this one is a bug I didn't notice. 
The typical way to handle animations is to use an animated builder in your widget tree:

https://api.flutter.dev/flutter/widgets/AnimatedBuilder-class.html
This change is already in the tree. If you remove these lines and rebase on the latest Top of Tree it should be there.
Other tests with animation in macrobenchmarks are doing similar thing with `addListener`. I added the modification but let me know if I should keep consistency with other test cases. 
The AnimatedBuilder is designed for animating widgets so this is the most Flutter-y way to express this benchmark. 

There are some details that could be better, mostly about how much of the tree to wrap and potentially protecting the extent of rebuilds with RepaintBoundary widgets. But given that just about the entire tree changes on every frame (other than the Scaffold and the Table widget itself both of which are just wrappers) - wrapping it all is a reasonable strategy.
A nit: This line, and others that reference widget.row and widget.column did not make sense to me as the names "row" and "column" usually refer to a single row or a single column. But then I saw that these properties are the number of rows or the number of columns. Better names would be "rows, columns" or "rowCount, columnCount" to make it clear that it is a count rather than a reference to a specific element.
I see that, and I think I copied their design at some point when I was writing some benchmarks, but those particular pieces of code aren't the suggested approach for our developers to use when creating animations.

We could think about updating the other benchmarks at some point, but the benchmarks aren't meant to be code examples for developers and changing them now could potentially impact their performance and obsolete their long history of accumulated data.

Maybe a compromise would be to add a comment to them indicating that the animations should be managed with AnimatedBuilder widgets, but we are keeping the code as it is to preserve historical measurements.
@flar I added the comment here. Does this look fine? 
I don't think we need to call out app developers, the statement applies regardless of who is reading the code. There is also a typo there.

I'd go with:

```
    // Animations are typically implemented using the AnimatedBuilder widget.
    // This code uses a manual listener for historical reasons and will remain in order to
    // preserve compatibility with the history of measurements for this benchmark.
```

A similar use of `addListener` also appears in the cull_opacity benchmark.
Not sure what the "and truncates any..." part of the doc is referring to.
`linux-desktop`?
`macos-desktop`?
`windows-desktop`?
This will change everything, not just desktop; is that desired?
This change doesn't seem to have any associated test changes. If we want this behavior change, we should test it.
That was *my* intent, yes.  Whether it's desirable it up to review. ;)
nit: the line is getting a bit too long. Maybe convert this to use curly brackets?
Can this be typed as CustomPainter?
Unfortunately not, since I'm accessing properties from the private CustomPainter subclass, `_DialPainter`.
```suggestion
/// decommissioned and replaced with the hierarchy deserialized from the newly
```
```suggestion
/// listeners when they get decommissioned. In response to the notification,
```
```suggestion
/// operating system may, however, terminate the app to free resources for other apps
```
```suggestion
/// dispose of them and claim a new child as a replacement from a parent in the
```
Can you explain why they should be minimal?  Are there size restrictions on the platform(s) for serialized data, or is it a performance/memory consideration?
Why does this matter?  Is this just a race, and it doesn't matter which one wins?
nit: I'd either change the "rarely" above to "never", or the "must" with "typically".
```suggestion
  /// still part of the bucket hierarchy or to [dispose] of them as well.
```
tiny nit: might want to reflow some of these paragraphs (this line looks longer than 80 chars).
```suggestion
/// bucket for storing restoration data is made available.
```
Expanded the comment a little more. It is a race between the framework polling the engine for the data and the engine pushing the data into the framework. Who wins, doesn't matter. It's the same data.
I added a sentence that this is due to sizing restrictions on the platforms.
"minimal" means "of a minimum amount" already, so saying "as minimal as possible" is redundant. You could say "should be as small as possible while...", or just "should be minimal while..."
nit: document that the object has to be cast-able to a `Map<dynamic, dynamic>`, otherwise will throw?
Lowercase `a` after the colon
Instead of doing this, use [`checkMethodCallHandler`](https://master-api.flutter.dev/flutter/services/MethodChannel/checkMethodCallHandler.html), or make `_isListeningForEngineUpdates` just make that call.
If this is any kind of map this actually will not throw until you attempt to access something. The example below does not throw unless you uncomment the print.

```
void main() {
  var intMap = <int, int>{2: 3};
  var stringMap = intMap.cast<String, String>();
 // print(stringMap.keys.first);
}
```
This also means the type checks and casts are incurred on every access, instead of once at the beginning. If you wanted something that threw eagerly, you could use Map.from instead

I think this is save, but maybe have an assertion above this that the completer is either null or not completed, which I think will give this a better error callstack in the case where it's already compelted.
e.g. here it's not clear to me if a subclass could/would ever call this method after the completer has completed.
Ahhh. Should we really be exposing this method then? 
Link to an issue for this
Hashing the runtime type seems strange - why are we doing that? Can you document it here?
No `,`
The thought occurred to me when reading some other docs - is it worth specifying that the type of termination we're talking about is when the OS terminates us with a warning as opposed to a hard crash (e.g. a segfault) or power failure?
Done.
Removed that, I think this was left-over from copying this from elsewhere.
Looking at this again, I don't need this method at all. I am removing it.
Added the assert. This is save because this is the only place where the completer is completed and right after its field is nulled out. So there's no chance to ever complete it again. Nevertheless, the assert is a good idea.
I added the word "gracefully" here. I don't have a bullet-proved definition of when OSes do and don't do state serialization, so I'd prefer to be not too specific here.
This is fine to call after the completer has completed. It will just replace the current `rootBucket` with the new one. If there's no completer, it just means that currently nobody is waiting for the root bucket. 
Shouldn't this be in an assert in the ctor body?
why is this required?
nit: This would be more efficient as:

```dart
if (_parent != null) {
  parent._dropChild(this);
  parent_ = null;
}
```

right?
nit: since get is a language keyword, it might be good to avoid having it as a member name.
This seems prone to issues for the caller - if the manager is null, this data might not actually get stored.

I think at the least we should document this, but it might be a nicer API if we asserted the manager isn't null here instead and required callers to make sure the manager is initialized.

Alternatively, we should make this return a bool as to whether it actually scheduled serialization or not, so that a caller can think to check that and initialize the manager if it's not already.
https://dart.dev/guides/language/effective-dart/design#avoid-starting-a-method-name-with-get
Similar comment for this one - if I've arrived in a state without a manager, this won't actually get removed right?
What if we made these more like streams with multiple subscribers? Would we still have this problem?

Alternatively, could we just have the framework "automatically" hand over ownership from A to B?
Does this mean has been claimed && is in _rawChildren?
So maybe a slightly different question than my one above in the explanation about finalizers - what if instead we just asserted that there was only one owner at the end of it all?
I thought we linted against this usage, saying to prefer for loops.
Elsewhere you're allowing manager to be null, but not here. Maybe add an assert that it's not, or use the `?` again.

Similar question to the public methods though - what happens if it is null here? Seems like bad news.
Ditto
nit: avoid using language keywords for variable names.
What happens if we claim the same name someone else already uses?

Can/should we assert that's not the case here?
Why have this method _and_ dispose?
(IOW why not just fold it into dispose)
Can we assert in any methods above that the object hasn't been disposed?

Should we just fold performDecommision into this?
nit: avoid parenthetical. Maybe `new scope, or namespace,`?
Or just drop it entirely.
From reading this and the previous doc, it's not clear to me why I'd ever not use this widget.

Alternatively, could we just simplify these into a single widget that takes a boolean about whether it should create a root bucket if needed or not?
not use this widget -> instead of the other RestorationScope widget.
What happens if this is inserted into the tree after frames have already started rendering?
Also: what happens if anything below this throws? Should we try to resume frames, or should we just have a hard crash? Right now it seems like an app could get into a state where it throws in here and just never renders frames again.
assert(!_disposed)
alternatively, remove the disposed property, which seems unused elsewhere.
Yes, changed.
I really want people to provide this, otherwise they will get bad error messages in case of duplicated IDs.
I changed it to read/write.
AFAIK, the lint only applies to things that implement Iterable. This is a map, which doesn't do that. Nevertheless, changed to a real for loop.
would implementing didUpdateWidget help for the finalizer stuff above?
Done.
The same things as with claiming a child that already exists: We let it slide for now and at the end of the frame check that the old owner has given up the child. I updated the documentation to say that.
Dropped. It's cleaner.
`_disposed` is used in RestorationMixin.dispose. This is to make the life of developers using the mixin a little easier. If we don't have this we'd have to enforce that properties are only disposed after calling super.dispose().

Will add the dispose check to this and the other methods next week (left a TODO to remind me).
We don't want to hand over ownership from A to B. B needs to have a fresh, new bucket. When A is disposed, its internal state is destroyed and needs to be removed from the restoration data as well. When then at the same time a new widget B is instantiated (which just happen to have the same ID) it should not have access to the restoration data of A.

So, multiple subscribers to the same bucket wouldn't really help. We want the data in those buckets to be separate. For a short period of time (while one bucket goes away and the other one is created) we just need to be able to tolerate that two buckets exist with the same id.
Yes.
That's exactly what we do in `_finalize` below. Unless I am misunderstanding?
Fixed.
Fixed to use ?
I don't see how that would help. What is your idea?

From https://master-api.flutter.dev/flutter/rendering/RendererBinding/deferFirstFrame.html:

> Calling this has no effect after the first frame has been sent to the engine.

It's a pattern we use elsewhere in the framework [1]. If we crash, you'd be stuck at the splash screen. As a dev, you'd see the crash in the console. As an end-user being stuck there doesn't seem more or less useful then seeing our error widget... 

[1] https://github.com/flutter/flutter/blob/9cbe1dccf3a0988343ba429417f0943f5519da69/packages/flutter/lib/src/widgets/localizations.dart#L529

Dispose and decommission are different. Decommission is a notification that this entire bucket subtree is getting replaced with a new bucket hierarchy. All the children are informed about this so the owner of them can dispose them and claim a new bucket.

Dispose simply removes the information of this bucket from the hierarchy. The child bucket continue to have a live of their own and the owners of those child buckets may get them adopted by other parents.

Decommission = notification down the tree to stop using any bucket in this hierarchy.
dispose = delete the data from this bucket, child buckets can continue to live if they want.
It will get removed from the local _rawData and hence is no longer in the bucket.

Since without a manager the _rawData wasn't persisted anywhere there's no other place to remove it from.
The assert is a great idea. I will do this next week (left a TODO for now, so I will not forget until next week).

> Should we just fold performDecommision into this?

See other answer why decommission is more then just a dispose.
My thinking is that those are two separate responsibilities: When I get handed a bucket, I can store all the data I want in it. It is, however, not my concern to decide how/where the data is persisted. That's the responsibility of whoever owns the bucket and provided it to me. They need to make sure that it is hooked up to a manager.

Not requiring a manager also has the advantage that we can unhook a subtree. For example, when a widget is in the way of transitioning out in an animation, we no longer need to persist its state (in the state we've already recorded that it is gone). We can then just unhook the bucket.
If you implement a stand-alone widget, you want to use a regular restoration scope to create namespaces for restoration ids. The widget can then be used in applications that want to do state restoration and those that don't. If the regular restoration scope doesn't find an ancestor scope, it will not cause any information to be contributed to the restoration data. In fact, the entire logic of retrieving the restoration data from the engine, parsing it, encoding the restoration data when it changes, sending it to the engine will not trigger.

If you'd use a RootRestorationScope, even in an application that doesn't want to do state restoration all that logic now triggers for the part of the app that's wrapped in this thing.

So that's the biggest difference: RootRestorationScope essentially forces you into doing state restoration. The regular scope doesn't have any opinion on whether you actually want to store restoration data or not.

The root restoration scope should only be used at the very top of the app (in fact, I am going to integrate it into WidgetApp).

Let me update the docs on this a little to make that clearer.

> Alternatively, could we just simplify these into a single widget that takes a boolean about whether it should create a root bucket if needed or not?

Yes, we could just have this implemented in one widget with a flag. The implementation of that widget would be pretty complex though. And I feel that the difference in functionality is more than just a config flag. It is a whole different widget.
```suggestion
/// time, the data in the bucket should be kept to a minimum. For
```
nit: just a suggestion (reads better):
```suggestion
/// provided to, for example, the [RestorationManager] to restore the application to a
```
Maybe an implementation comment about what these maps are used for?
Maybe describe when the `dispose` must/may happen, and whether it will be done automatically, or needs to be done by the implementer. (e.g. "in response to notification of the decommissioning").

Could `decommission` be described as a "notification to dispose"?
Is there a limit as to when? Does it need to happen before the next frame, or can I just store them all up in a cache and dispose them all at once when I exit the app/save a doc/trigger a timer?
nit: wrap comment
```suggestion
  /// values. Whenever the information that the claimer needs to restore its
```
Shouldn't this be `if (_debugDisposed)`?  When would it be null?
I may be missing something, but wouldn't that let you resolve issues where a widget is moving from one part of the tree to another and transferring ownership of a bucket?
GitHub ate my last comment thread here.

Perhaps we could add a debug flag here that prints or warns somehow if serialization is being scheduled without a manager?

I don't want to eagerly add features, but this seems like something that could become confusing for users. Maybe it would help if I better understood how you could end up unhooked here.
What I was looking for here is what happens when:

1. You persist some data
2. You get unhooked from the manager
3. You try to update the data

And then your application restarts and you have data you thought you removed.
From reading some more, I think it would not help. Disregard.
You're right, fixed it. (I think this was a c&p error) I also added tests for this.
For future archeologists, the comment thread started here: https://github.com/flutter/flutter/pull/60375#discussion_r453093743
After talking this over with Dan, I agree that we should assert here for now that the manager is not null. If in the future we support that unhooking mechanism I was talking about we can revisit that decision.
Since you're asserting it's not null, you can drop the `?` right?
Oh, it might be null if it's decommissioned. I see.
```suggestion
/// guarantee that descendants have a bucket available for storing restoration
```
```suggestion
/// which effectively turns off state restoration for this subtree.
```
Are there any platforms that this doesn't work on? Or do you just mean platforms that don't use splash screens (e.g. Windows, Linux)?
```suggestion
/// Manages an object of type `T`, whose value is a [State] object that it wants to have
```
I was reading this paragraph, looking for the "other thing", thinking that the first thing was the "The mixin checks", but after reading it again, I think that the "one of two things" part should come after the "The mixin checks" sentence, so that the first thing is the case of finding data, and the second thing is not finding data.
In another PR, this seems like a great place to put a code sample.
```suggestion
  /// null, which is effectively turning off state restoration for this subtree.
```
nitty suggestion:
```suggestion
/// This widget is usually used near the root of the widget tree to enable
```
(just because "close" can mean "near to" or "to render no longer open", and I kept reading it incorrectly)
```suggestion
/// Restoration data can be serialized out and, at a later point in time, be used
```
nit:
```suggestion
/// serialized as part of the restoration state. It is up to the [State] to
```
Somehow "serialized out" feels redundant. I could go either way, though.
```suggestion
/// instantiated to initialize member variables within [State.initState].
```
Is the "or" not needed?  If you did mean to include the "or", then this sentence is a little awkward, and I'm not sure what you mean.
```suggestion
/// described by the new restoration data. All initialization logic that depends
```
```suggestion
  /// [State] objects that wish to directly interact with the bucket may
```
```suggestion
  /// is restarted.
```
I removed this line since it is duplicated from the docs above and I made the docs above more precise.
Yeah, that's what I meant. Changed the comment to indicate that better.
The value is not a State object. The State object wants that value restored. 
I rephrased this.
Should this implement ValueNotifier<T>? As it fully matches the prototype
The semantics are slightly different, though. `ValueNotifier` notifies when `value` changes. This one notifies when `toPrimitives` or `enabled` changes. And you can construct cases where `value` changes, but `toPrimitives` or `enabled` doesn't.
Why not use a `String` directly?
Instead of:


```dart
  RestorableNum<int> _counter = RestorableNum<int>(0);
  RestorableTextEditingController _textController = 
      RestorableTextEditingController();

  @override
  void restoreState() {
    registerForRestoration(_counter, RestorationId('counter'));
    registerForRestoration(_textController, RestorationId('name'));
  }
```

Would it make sense to have:


```dart
  RestorableNum<int> _counter = RestorableNum<int>(0, id: 'counter');
  RestorableTextEditingController _textController = 
      RestorableTextEditingController(id: 'name');

  @override
  void restoreState() {
    registerForRestoration(_counter);
    registerForRestoration(_textController);
  }
```

That's possible. But I figured that keeping the line with the instantiation free of the ID clutter makes the code a little easier to read. In your IDE when you click through to go to the definition of the `_counter ` variable you're most likely not interested in its restorationId. Furthermore, it keeps all IDs neatly in one place (the restoreState method) making it easier to see with one glance what IDs are in use. 
But the current syntax could complexify custom APIs built on the top of the native syntax.

Say we want to make a function that returns a `RestorableProperty`, then we would need a tuple to return both the property and its ID:

```dart
Tuple<RestorableProperty, RestorableId> example() {
  return Tuple(MyProperty(), RestorableId('example'));
}
```

vs

```dart
RestorableProperty example() {
  return MyProperty(id: 'example');
}
```
```suggestion
/// {@endtemplate}
```
Fixed. (here and in one other place) Thanks.
Why would you need to return the RestorationID? Either you return an un-registered property and whoever receives the property is in charge of registering it (under an ID of their choosing to ensure it doesn't clash with anything else in their namespace) or you return a registered property in which cause whoever receives the property doesn't need to care about its ID.
I had state-management libraries in mind ‚Äì which will have to implement a way to interact with the restoration API outside of a `State`/the widget tree.

Provider will definitely want to expose a way for users to define restorable properties, where they would define both the ID and the property from outside a `State`.

It may not be too bad, as we can use `Map<Id, Property>` instead of a tuple. I need to play around it.
typo: `@template`
do we want to make this be created by a virtual method so that it can be easily overriden?
Fixed.
Good idea. Added `createRestorationManager` to parallel `createBinaryMessenger`.
docs should probably point to createRestorationManager
ID
IDs
maybe add a parenthetical giving an example of when this might happen
ID stands for identifier, so "Instead, a small identifier (e.g. an identifier or resource locator)" is weird. Maybe "e.g. a UUID" or "e.g. a database record number" or something?
as above, add a parenthetical talking about when this might happen
\`\`\`json?
or javascript maybe
docs should mention P
docs should mention P
mention P
especially for remove, it's important to specify if the given P has to be accurate (or could be dynamic)
we could wrap this body in an assert to prevent people from depending on it in release builds (just have it always return false or something)
double space
maybe give more color as to why we have this convention
is effectively turning off -> effectively turns off
maybe mention that restorationId can be null but this disables restoration.

or have a separate constructor for disabling restoration, and make this one require non-null.
can child be null?
say more about the arguments
...if [restorationId] is not null
this seems like the real value of this widget, may be worth mentioning this earlier. earlier comments make one wonder what the point of this widget is.
discuss arguments, what inherited widgets should be in scope, what is expected of the binding
SizedBox.shrink or SizedBox.expand might be trivially more efficient
might be clearer (if strictly less technically correct) just saying "Manages an object of type `T` that a [State] object wants to have restored during state restoration" or some such.
comma before "the mixin checks"
move this below the methods that are called before it is called
might be clearer to say something like "after this is called, initWithValue will be called with this method's return value" or "the value return by this method is then passed to initWithValue", and then separately say "see also fromPrimitives which is called when ... instead"
is it expected that `x.fromPrimitives(x.toPrimitives()) == x.fromPrimitives(x.toPrimitives())` ?
maybe also assert _id != null, _owner != null?
help of an
maybe make this a comment rather than part of the template (i.e. remove the `///` on that line)
extraneous blank line
interesting question... i'm guessing the idea is that the class makes the API more self-documenting?
using an
this would be a good place for sample code (showing the use of UnmanagedRestorationScope)
what will be the lifecycle state of oldBucket?
"when the [State] is in a certain state" sounds weird
presumably in that case it has to be called again if restoreState is called?
we should also mention how to unregister such a property
mention T
The code registering the property (i.e. the code with the bucket) must be the one to come up with the IDs, otherwise it can't properly avoid name clashes.
might be worth adding some prose here saying when to use RestorableNum over the other two.
do you intend the _RestorablePrimitiveValue subclasses to be for nullable types or non-nullable types?
shouldn't we also save the selection?
Fixed here and elsewhere in the file.
No, that's not allowed. Updated doc and added assert.
Moved to earlier
Yes.
Actually, T can be removed here. Done.
Saving the selection seems to only make sense if we restore focus, which we are currently not doing.
Turns out, the dartdoc parser doesn't like that.
After thinking about this, I've removed the RestorationId class and replaced it with a string. The class didn't add too much value...
About this, it sounds like this could be a common use-case for testing. Should it be built directly inside `tester`?

Like:

```dart
tester.restorationGraph = {
  'root-child': {
    'my_id': 'Hello world',
    'sub-bucket': {
      'my_id2': 'Hello world',
    },
  },
};

await tester.pumpWidget(
  RootRestorationScope(
    restorationId: 'root-child',
    child: Column(
      children: [
         TextField(restorationId: 'my_id'),
         RestorationScope(
           restorationId: 'sub-bucket',
           child: Whatever(),
         ),
      ],
    ),
  ),
);
```
I specifically want to avoid hand-crafted restoration data in widget tests. That data can easily change (e.g. because one of the widgets is updated with an extra RestorationScope) making these tests very brittle. Instead, you should get the widget tree into the state that you want to test and then use `tester.restartAndRestore()` (or a combination of `tester.getRestorationData()` / `tester.restoreFrom(data)`) to test that you can restore the tree from its current restoration data. That way, the test remains valid even if the restoration data format changes.

With semantics we initially made the mistake that the tests were too tightly coupled to the actual semantics tree, making them very brittle whenever we had to change the shape of the semantics tree for reasons unrelated to the actual test.
Made a note. I am going to add more samples in a follow-up since this PR is already gigantic. 
Do document out discussion over chat: I am intending them to be non-nullable since that's gonna be the new default for dart. I added some more asserts to express that intend. If we in the future need a nullable type, we can add one. Those could be named with a trailing N (for Nullable), e.g. RestorableIntN, RestorableStringN, etc. similar to how in lisp functions that return a bool end in p.
That's a fair argument.

My fear is, by breaking this in two steps, it may make the test brittle because of some state that is reused between before and after the restart.
Because `restartAndRestore` doesn't fully restart the process. Singletons/Global variables are still there. And a `setup`/`tearDown` won't help, as this is within one test, not between two tests.

If we had a `tester.setRestorationData` that was executed as the first line of a `testWidgets`, this would be compatible with `setup`/`tearDown` and avoid some hassle for users of packages like `get_it`, which is relatively popular (even if I don't like it)

Raw `provider` usage would be unaffected though.
Would it make sense to use keys for this?
Like associate a `RestorationScope` with a `Key`, and target this bucket specifically:

```dart
RestorationScope(
  restorationId: 'foo',
  child: RestorationScope(
    key: Key('bar'),
    restorationId: 'bar',
    child: TextField(restorationId: 'id'),
  ),
);

...

tester.setRestorationDataFor(find.byKey(Key('bar')), { 'id': 'value' });
```

This would avoid having to specify the entire object and allows targeting a very specific scope ‚Äì which should make the issue you mentioned less problematic
This TODO is causing an error on triple-head (tip-of-tree Dart, engine, framework) flutter analyze tests at https://ci.chromium.org/p/dart/builders/ci.sandbox/flutter-engine-linux/11403
What's the failure? In the logs from the linked run I am only seeing directory-related failures (e.g. `No such file or directory`). How are those caused by a TODO in a comment?
The "flutter analyze" step with log of stdout at https://logs.chromium.org/logs/dart/buildbucket/cr-buildbucket.appspot.com/8873492683668712848/+/steps/flutter_analyze/0/stdout
has a failure due to that TODO
I am removing the TODO here: https://github.com/flutter/flutter/pull/62500
The color that [Material] widget uses to draw elevation shadows.  Please add a brief section about ThemeData.applyElevationOverlay here (similar to the TBD one for Material.shadowColor).
The [shadowColor API doc](https://api.flutter.dev/flutter/material/Material/shadowColor.html) needs to be updated. - should explain that the default is defined by [ThemeData.shadowColor] which is black by default. The doc should also include a link to ThemeData.applyElevationOverlay and briefly explain about shadows and dark mode.
Nit: the infra team now prefers to use `linux/android`
Adding a benchmark should never involve deleting code so this diff should have been a red flag during the reviews...
This is not intended. Some how when I copy paste things I override it :( I added it to a new patch #60412
I've already fixed this in https://github.com/flutter/flutter/commit/2962912d68fb72d6c9fd60f652e27f3593d692d6

It has already been pushed to the main tree.
Moved to be a part of `AndroidViewController` and renamed as `_AndroidMotionEventConverter`.
@blasten This can be it's own class or we can add `pointTransformer` field to the `PlatformViewController` class. Then Android could just use `PlatformViewSurface`. What are your thoughts on this? 
Sounds good
nit: `assert(transformer != null);`
What do you think about moving `_AndroidMotionEventConverter` methods to this controller?
gotcha. nice adapter for these two interfaces :)
I think it makes more sense to separate them. This class has to maintain a state and record `PointerEvent`s. I felt the logic was easier to follow if all of this was in it's own class. 
What about migrating this controller to use the new one?
subjective: what do you think about adding a new factory method? Maybe, `initNativeAndroidView`, and `NativeAndroidViewController`.  Feel free to use a different name. :)
That makes sense to me. I don't know if we should use the word `Native` though, since we already have a some confusion surrounding that term. E.g. `NativeAd` vs native platform view ad. 
could we add a new suite in `test/services/platform_view_test.dart` that uses the new controller?  We could start by duplicating the existing tests and covering any change in behavior between the two controllers.
this should be `event.device` + unit test
Actually, this isn't `event.device`. We will need to add a `deviceId` to `MotionEvent`, and most likely each of the Android-specific values. 

@goderbauer do you know if there's a recommended pattern for adding platform-specific data to `PointerEvent`? It looks like we will pretty much need to pass each of these constants.

None of these values are sent from https://github.com/flutter/engine/blob/712f619737f1323fd2908b397aa8bd64fb2ccbe5/shell/platform/android/io/flutter/embedding/android/AndroidTouchProcessor.java#L171
nit: this line can be removed
```suggestion
  group('AndroidViewSurface', () {
```
Is there any difference in behavior between `AndroidView` and `AndroidViewSurface`?
Can we use a similar approach that @gspencergoog used to add platform-specific stuff to the keyboard events? See `RawKeyEventData` [1] and its platform-specific subclasses.

[1] https://master-api.flutter.dev/flutter/services/RawKeyEventData-class.html
Well, I wouldn't go that route.  That's all there because of legacy that we didn't want to break. We're planning on removing it and moving it all to the platform side now.

Better would be to pass that data you need in a platform independent form and add it for all platforms.

Context: https://flutter.dev/go/platform-based-key-events
It looks like `RawKeyEventData` is constructed from a system channel message, and the params are passed in a `Map`. 

Perhaps, the equivalent is to add a `Map` to `MotionEvent`, and then populate the `PointerDataPacket` in  the engine. https://github.com/flutter/engine/blob/637a8e7cd0440e5c97706aad89ba3f4decd432ee/lib/ui/hooks.dart#L294. 

Does this sound resonable?

After studying this further, I agree with greg that adding platform-specific stuff to the pointer events like that is not a good idea. 
After some offline discussion, the conclusion was to add a unique identifier to `MotionEvent` that can be used to lookup the original motion event in the platform.
Use a switch when checking the defaultTargetPlatform.
nit: indentation
@mdebbar @goderbauer as we discussed before, we want to have an api to force create a browser history entry or not.
It looks like you can replace this with:
```dart
_heroController = MaterialApp.createMaterialHeroController();
```
Can this be moved to a method?
nit: "if we use"
where does this get set if _usesRouter is false?
typo: `s/tne/the`
this documentation is woefully inadequate. :-)

It should say things like what format it's encoding the data to (JSON, looks like), what the vocabulary is, what the meaning of each part is, etc.
why do we use JSON here?
nit: per the style guide, the order of the constructor arguments and the order of the properties should be the same.  We should make that order make sense when reading the code (e.g. routeInformationProvider and routeInformationParser should always be together).
Please see the style guide regarding requirements for documentation. There are writing prompt in the style guide for ideas of things that you should include. The most important idea, though, is that when you're writing the documentation, you have to think of why people might be reading it. They are reading the documentation because they have a question. What is the question? That's what we need to answer.
(for what it's worth, the question i had was "why would i use this"; looks like the answer is something to do with the back button dispatcher)
not sure what "whether" means in this context... maybe "with the assumption that it is a navigating event"?
We should make sure to define "navigating event".
is -> are
I'm not sure what that means. If I don't call the method, how is the callback ever going to be called?
if -> If
(also below)
"This is useful in the web application because the web platform relies on these reporting to support browser backward and forward buttons." -> "When a Flutter application is running on the Web, navigation events are used to implement the browser's back and forward buttons."
else?
or can it be null?
none-web -> non-web

I wouldn't encourage people not to support this on non-web, because it'll make porting to web harder. I would just say that it's only used on Web currently. Maybe describe it as additional data for higher-fidelity state restoration on Web, which is unused on other platforms?
Having a boolean as an argument after the callback makes it hard to read. I suggest either splitting into two methods or move the boolean argument before the callback.
"name" implies this is just an identifier, but really it's a whole blob of data... "state" is also super generic... we should come up with better names here given the current design. I'll think about better names...
Should we call `_processInitialRoute` when previous `routeInformationProvider` was null?
nit: this file could use some `dartfmt` :)
Does it work if you make the argument optional, then call `_rebuild()`?
Will this go away after your HeroController patch is in?
should this be set to `_createRectTween`?
Maybe define a color variable, set it once and use it in this and the router branch to avoid this duplciation?
A WidgetApp that uses the [Router] instead of a [Navigator].
Mention the default?
Mention the default when this is null?
nit: end with `.`

This doc also needs to describe what the routing information is.
Why is this json encoded?
Since this will potentially include the restoration data: Do the JSON encoder and the StandartMessageEncoder support the same stuff?
Should this one have a default value and assert that it is not null?
It would be helpful to have some implementation comments explaining what these mean.
Should routerState have a dedicated API where you pass in the reporting status and the callback at once? Seems odd that these informaiton are passed in through different paths.

Also, does _reportingStatus need to be reset after the callback?
nit: format this to indicate what is condition and what is the if-branch.
nit: add empty line before.
Why do we need to do this on every rebuild?
It seems like a strange side effect?
It's more then just a string, no?
It doesn't have a parse method.
yes
that is a private method in the MaterialAppState. Since is will only be use once in this static method, i found it does not worth to be turned into a private method any more
This pr will remove this all together https://github.com/flutter/flutter/pull/60655/files
the hero controller will only be initialized in initState
you are right, i forgot to update this. There are several PR that are aim to clean up the hero controller
https://github.com/flutter/flutter/pull/60655/files
https://github.com/flutter/flutter/pull/61662/files
I will update this once they are merged
System.navigation method channel uses JSONMethodCodec, but anything that can be serialize to a string will be fine, do you have any suggestion we should use here?
`location/ configuration` maybe?
Anything that can serialize into string will work because it go through the system.navigate channel or we can create a new system channel with standardmessagecodex
Map will work. Alternative we can create a new system channel with standardmessagecodex just for this
It is reset after _reportRouteInformation
We only want to report the route information once per build cycle. There is no api in the state class to inject this logic. rebuild is the only place that i can think of. 
good catch, we need to call _handleRouteInformationProviderNotification
Why do we need to report these once per build cycle? I expect we only need to report them when the current configuration changes?
Sorry for confusing, `routerState._reportRouteInformation();` will only report url update if reportingStatus = must or maybe. What i meant was that the router may detects configuration change multiple times within a build cycle, and we only want to send one url update within that cycle.

I should rename `routerState._reportRouteInformation();` to something more descripitive. maybe `reportRouteInformationIfChanged`
This comment should go above `final Color materialColor`.
remove this comment here?
The docs should tell me when its not reported automatically and I need to use this method.
When would I want to do this as an app developer?
Is this _rebuild necessary Wouldn't the routerDelegate notify its listeners in response to `setNewRoutePath` if a rebuild is required?
Should this be more clearly named `nextStatusToReport`?
And what happens if I do `navigate` and `neglect` in the same frame?
same comment as below.
same here (although I am not 100% sure about this one)
Why compare the serialized version?
I would have expected that we compare this configuration to whatever the last reported configuration was and when it has changed, we run it through `restoreRouteInformation` and `routerReportsNewRouteInformation`?
Why does `RouteInformation` need to have an opinion at all whether and how its serializable? Isn't that up to the implementation of `RouteInformationParser` to decide how to send it over?
When do we need to make the report? At the end of a frame? Could we just schedule a postFrameCallback when we detect that a report may be necessary and then do the reporting in the callback?
This should say something along the lines: When the configuration returned by this method is passed back to setInitialRoutePath or setNewRoutePath, the Router should configure the Navigator in `build` exactly like it did when the configuration was obtained.
Actually, the post frame callback may clash with the restoration post frame callback and we don't have a way of ordering them.

> We only want to report the route information once per build cycle.

Also, why do we need to restrict this to once per frame? Can we not do this immediately when we notice a configuration change?
That means two changes happened: one that requires navigation, and one that doesn't. I think navigation should happen in this case.

This would be a good addition to the docs.
Currently it throws an exception says 
```
'Both Router.navigate and Router.neglect have been called in this'
            'build cycle, and the Router cannot decide whether to report the'
            'route information. Please make sure only one of them is called'
            'within the same build cycle.'
```
I can't think of a use case where this can happen, and it may be confusing if the user does two contradictory events within the same build cycle. We can follow the suggestion @mdebbar mentioned if there is indeed a use case for this.
If we allow multiple update per frame, the state restoration cannot keep up with it.
`nextStatusToReport` to me feel like we are reporting the status(_RouteInformationReportingStatus) to someone, but this is actually the current status to decide what to do when the next time we report the routeinformation. I will think of a better name.
the best we can do without adding more complexity(without asking developer to implement the compare method for configuration) will be comparing the identity, and that will usually be different if `currentConfiguration` is dynamically generated. If they do end up have the same identity, that means developer is caching the result somewhere in the routerdelegate and that is bad, too. 

That is also true for the state in route information which cause the the router may always report the route Information back to route information provider.
If we put the serialized method to the route name provider, then we will be pushing the responsibility to figure out whether it has changed to route name provider as well because router cannot tell whether it has change by looking at the identity alone.

The RouteInformation reported from route name parser will always be different because they are usually dynamically generated.

This causes one issue, that the router also have the api to force the route name provider to report the route information back to engine even if it has not changed. we have to somehow send the reportingstatus to the route information provider, this may make the api confusing.
I think we always want to rebuild at the end of the notification.
I feel it does not hurt the performance and it will not be error prompt as well.

When I was writing router delegate it make sense to notifying the router to rebuild when i am actively changing the app state. However, it seems weird if the router told router delegate something has changed, the route r delegate has to notify the router to rebuild after it update the app state.

This has tripped me a lot when i was rewriting the stock app and they are all tricky to figure out. I feel no harm to add the rebuild here.
that could work...
I don't really see why RouteInformation is aware of the details of the message channel being used. That seems strange. Shouldn't the code that sends and receives the data be the one to encode it/decode it?
we should just change System.navigation to not use JSON.
nit: indent this more and put the `) {` on the next line to make it easier to read.
nit: fix indentation 
Wondering: should the generic type just be Object? Here and elsewhere.
```suggestion
/// The route information consists of a location string and
```
configures
remove one "with"
nit: use `*` to turn this into an actual list.
nit: remove one `to`
why the `?` here?
isn't it already `none`?
use switch/case with enums.

Instead of lumping all cases into one in this switch/case, maybe separate them out. It would also make the code easier to read. You can factor common logic out into private methods.
Why `?`
I wonder if it would make sense to take one `RouterConfiguration` object here, which basically wraps these three. If we have opinionated versions of these, you'd just have to pass one OpinionatedRouterConfiguration instead of four different objects?
This still seems like a hack. Can we just use the regular mechanism of scheduling a postFrameCallback to do the update here? If necessary we can then later introduce a synchronization mechanism in the postFrameCallback to send restoration state and router information over together, e.g. the postFrameCallback of both the RestorationManager and the Router could communicate send their final information to a third party and the third party then sends it over in one go to the engine in a microtask. We can add that synchronization when we need it (i.e. when the web engine is actually going to combine these two information).
this should be a method instead of a getter since it does more expansive stuff then just "get".
trivial nit but please (as per our style guide) put these in the  same order everywhere and ideally an order that has the four delegates either in the order that they get normally called or in the order that you'd want to learn about them in. Right now the code is inconsistent about what order these four names are sometimes put in.
(for example, this is a different order than above)
Technically, this is an unnecessary rebuild. Just because somebody wants to add a new history entry for whatever reason, doesn't mean we need to rebuild the router, right? If we uncouple the reporting from buidling, e.g. with a postframecallback we could avoid that, no?
this sentence tells me nothing about what this does. :-) it just repeats the same words as in the name of the types involved...
`Android`
nit: grammar issue here; "still respects pageless routes" maybe ?
It is unusual to hock into setState like this. Can we do it the other way around? Instead of calling `setState` we call our own method (e.g. _markNeedsRebuild) or whatever, and from that method we trigger the setState and schedule the reporting? I think that makes the code a little clearer because when you see a setState call in the code you don't necessarily expect it to have the reporting side effect.
we really should not be using json
Why the `?` here? If `oldWidget` is null, it would already crash in the previous line when accessing its `backButtonDispatcher` there.
Same here.
"In Web applications"

"the" here is confusing because it refers to an already-introduced web application... but nothing has been introduced so far.
Avoid "you" in documentation; the reader might not be the one who wrote the code, they might just be trying to understand it.

Avoid "decide" in documentation, for similar reasons.

"When overriding this method, ..."
"returns null, which prevents"
"prevents ... from reporting"
"a subclass can" or "subclasses can"
"In common use case" -> "Typically"
nit: formatting (add a trailing comma and give each argument its own line
Same for the other methods below.
formatting nit: keep this in one line
nit: just keep this in one line?
"The [parseRouteInformation] method must produce an equivalent configuration when passed this method's return value."
"descendant"
nit: just keep this in one line?
descendants
that have
handles
this wrapping is slightly confusing. Can we put it all on one line maybe?
(similar comment in other places)
nit: formatting, there should be a closing `)` for the `FlutterErrorDetails(` with the same indentation level.
It seems that doing it in a post-frame callback is the right behaviour. It can wait until we merge this and the state from goderbauer's work into a single message to the Web engine, but eventually we'll want to combine both into one message, and we'll probably need to resolve what happens when you have multiple conflicting routers. Doing everything in a post frame callback that then calls an API that schedules a microtask is the usual way we resolve this kind of thing.
Shouldn't there be changes to RouteNotificationMessages as well? It currently assumes that the arguments are all simple route names and not what we pass in now.
Doesn't didPushRoute just give you a route name instead of a complex serialized object? Do we need new API to obtain a RouteInformation Object from the engine? Or maybe this method should have two params: location and state.
This isn't the right location to serialize/deserialize. The serialization should happen in `RouteNotificationMessages.maybeNotifyRouteChange` just before things are put on the channel. And the deserialization of the engine information should happen in whoever calls our WidgetsBindingObserver implementation.
I find it weird to wrap backButtonDispatcher and routeInformationProvider together because they are pretty much standalone objects.

I am ok with wrap both route name parser and router delegate together, but I couldn't figure out what will be the api looks like if we provide an opinionated one.
oh my, this is a terrible typo
fixed
This should document what methods the channel supports, see docs for other channels.
Is this called instead of didPushRoute or in addition?
Depending on what methods are supported, can we re-use the navigation channel for them?
remove print?
Does this optionally need to take restorationData?
nit: separate some of these by blank lines? (at least between the end of initState and this line)
Why `Object`? Can this just be true/false?
Since the postframecallback is so long, maybe put that in a separate method?
assert here that _currentIntentionToReporting is not none?
Why "maybe"?
What's the setter for? Shouldn't you always go through routerReportsNewRouteInformation?
What's the difference between the value stored in _currentRouteInformationInEngine and _value?
nit: space after :
Should this also listen to didPushRoute?
We should always send this information to the engine, it's up to the embedder to ignore or process it.
This is more than just a routeName.

Also, why do we need to send the old information as well? If the engine needs it, it should keep a copy of it.
oops
instead, because the web engine will notify both router and navigator channel. These two method need to be two complete separate path. Otherwise, it may double notify the listeners
This setter is for developers who want to navigate to a different location by changing the PlatformRouteInformationProvider.value directly.

In this case, we need to notify the router and report this event to the engine directly.

I think this is a very useful feature, because developers can still build up browser history entries even if they didn't implement the routerdelegate.currentConfiguration
in some situation, the _value will be one step ahead of _currentRouteInformationInEngine. For example the value setter
I remember we decided to make web engine notify both router and navigator channel. This will cause it to receive the event twice.
Good question, I remember the last time i check the previous one is not used and discarded. I probably should just remove it.
That needs to be documented. Also, should that then be called debugSetRouteInformation and only work in debug mode?
But why do we need this?
Actually, I think we should just remove that. The feature goes against what Router wants to archive: That the current configuration of the navigator depends on the app state. If you want this, you should make your app state contain a routename string.

If your app really needs it, you can implement your own RouteInformationProvider with this functionality.
The way it is it will stop working for all other embedders, though. Should we change it so that this listens to both and then document that embedder should call only one of them? We could also update WidgetApps to listen to the new one in addition to didPushRoute to make the old Navigator approach work for embedders that decide to call the new API?
I am thinking maybe we should just make a breaking change to add a state parameter to didPushRoute and make both router and navigator channel uses it. The embedder can send message to whichever channel they like but just not both at the same time.

I can't think of other cleaner way to do this, either we need to deal with debouncing or the embedder need to migrate their code.
Why wouldn't it work to have two methods and the embedder decides which one to call? The Router just responds to both.
Existing apps will have to migrate their apps to listening on both, otherwise web application will break. Although they also need to migrate if we make the breaking change, the former will be a silent break which may be tricky to find out.

I think we will also want to merge these two if we start from scratch anyway. What do you think?
Why do existing apps need to migrate? Isn't the change just to also listen to the other notification in the framework here:

https://github.com/flutter/flutter/blob/3aa0b48a2750197017c819588fa2e793244fa080/packages/flutter/lib/src/widgets/app.dart#L1058
If we make a separate method for the route information channel. An app has a custom widgetbindingobserver will need to migrate their code to also listen to the new method. Otherwise, the widgetbindingobserver will not work properly in web application.

If we merge the two method, we will make a breaking change by introducing an additional state, and restoration state parameter in `didPushRoute`.

For both cases, existing app will need to migrate.

Would it work to have two separate methods and the default implementation of WidgetsBindingObserver.didPushRouteInformation just calls WidgetsBindingObserver.didPush? That way, you can listen to them separately, but if you don't upgrade your app everything continues to work even when the engine calls the new methods.
That is brilliant, I will do this way. Thanks!
nit: space before `location`
What happened to these messages? Don't we need to keep them?
```suggestion
  ///    the application navigates to a new locations.
```
The -> the
Oh, was the documentation here just outdated and these don't exist anymore?
Why do we need this class if `RouteInformation` already has a field for restorationData?
Maybe `didPushRouteInformation` should be given a RouteInformation object as an argument. That way, we can easily add more data to this message if necessary. Basically, I am thinking:

1. move RouteInformation class to binding.dart
2. replace the arguments of this method with a routeinformaiton object
3. remove the restorationdata for now and once we know what type that would have we can easily add it back into the object.
The call to invokeMethod itself should be in the services library (see e.g. the static methods in `system_chrome.dart`)
yes they are outdated
@goderbauer 
we have to do this check because method channel invoke method will throw if there is no corresponding listener on the engine side.
I have to reuse the old method until the engine side method is in place otherwise it will throw an exception.
... are stored ...
Should the navigator channel be an OptionalMethodChannel to avoid that problem?
nit: space between `if` and `(`.
same blow.
Just remove the else? Same above.
This shouldn't be typed "Object". Maybe take everything that's in the map as named arguments?
Instead of duplication the code, forward the call to routeUpdated?
Make these named arguments?
I just realized we are not exposing this api in the package level, we should be good to remove this without a breaking change
i missed that we were creating this with `dynamic` as the type here. That seems to defeat the purpose of having a `T` type argument on Router...

Not sure what the right answer is, but we should probably find a better solution than defining the API with `T` then ignoring it.

(I noticed this because we're changing `dynamic` to `Object` as part of the NNBD transition.)
I was struggling hard on this one too, you can not set T for a single constructor, and it is weird to define on the class level because non router constructor does not care. we could separate out router constructor to a class or method on its own, but that seems to add a whole lot of complexity to the code. For now, it will let you initialize with different type of route information parser and router delegate, but it will throw on build
ü§ï 
This is why we would sometimes use the real fs
occasionally gets stuck if these aren't locked/unlocked
I thought it would simplify the debugging if I replaced testbed with testUsingContext ... that was sort of true.
tests occasionally get stuck without this
this direct write to stdout sometimes hangs the test, not sure why
We don't actually depend on the packageConfig values for the unit test. The correct change is probably to make the loader an injectable class that could be mocked out for testing. This would be a temporary fix so that we can start shuffling tests.

Open to alternative approaches too
Can we update the `FileSystemUtils` constructor to be `const`?
ahh, nevermind, then its dependencies would have to be const too...
Based on discussion, I'm going to keep pulling on this string by

1. Checking if this reproduces with a simpler test case.

2. Making the package loader injectable
The `ProjectFileInvalidator` is stateless so this is OK.
The write buffered error below is already using print, so I figured this is OK
OK! turned out to be a similar issues to FsUtils
We're ignoring the adjustment parameter here, same as before (@pennzht - why is that?). Maybe update the API doc?
Is the value just based on [MediaQuery.viewPadding] or is it the same as viewPadding?
We want to make it clear that minViewPadding doesn't change when the soft keyboard goes up and down.
Whey are we using rectMoreOrlessEquals here and elsewhere? It would be OK to just include an explanatory comment.
According to the docs, the Y offset is not affected by the adjustment for the mini Top positions. It looks like only the X is adjusted.
https://github.com/flutter/flutter/blob/9322c80825bb582954410408de39c0ef90b395ec/packages/flutter/lib/src/material/floating_action_button_location.dart#L40
It's also dependent on `_resizeToAvoidBottomInset`, I'll update the docs. :)
I'll add some more clarification. :)
Oh I borrowed a little from other FAB tests. I'm not sure we have to use `rectMoreOrLessEquals`. I'll see if I can simplify.
Ah, just checked. This is required as it accounts for the precisionErrorTolerance. The tests will not pass otherwise.
We're providing API doc for this override, so it would be helpful to reiterate the point about ignoring the adjustment parameter here.
Device discovery created by instantiating DeviceDiscoverers looks up this entry from the cache, will fail if the path does not exist.
Same here
If the generator is not provided, one is created but that looks up the dartSdk path from the cache.
ü§¶ 
I thought it was hard to write tools tests, but turns out I had no idea...
the nice thing is ... there are no issues with the tests using testWithoutContext, so at least we are on the right path üëç 
üëç
this should be `platform_views_scroll_perf_hybrid_composition` now.  Maybe: `platform_views_hybrid_composition_scroll_perf`
does the test file name matter? The root directory is already different. (now `platform_views_layout_hybrid_composition`)
Can we `@Deprecated('Prefer BuildInfo.packagesPath')` instead of hinting in the name?
Edit: I tried this and there were no analyzer warnings where it was used.  Does that annotation not work?
Did we disable it for the framework? FYI @goderbauer ?
In practice, I tend not to use deprecated because it would flag the framework warning lint
That's annoying.
This is an example host project, and was updated by running the integration tests.
```suggestion
    @required String webBuildDirectory,
```
```suggestion
          webBuildDirectory: getWebBuildDirectory(),
```
```suggestion
       _webBuildDirectory = webBuildDirectory,
```
```suggestion
  final String _webBuildDirectory;
```
```suggestion
    _fileSystem.directory(_webBuildDirectory).uri,
```
```suggestion
      final File file = _fileSystem.file(_fileSystem.path.join(_webBuildDirectory, 'index.html'));
```
D'oh
was the process manager never getting called?
I guess not, since these are now `testWithoutContext`. cool.
Negatory, but we have a rule that a context injected FIleSystem requires a context Injected ProcessManager
rather than using both a `switch` and an `if/else`, I would only `assert(undocumentedMembers >= 0)`.
You could make this easier to test by making it a static or top level method, since it doesn't depend on anything in AnalyzeBase.
Why remove the doc comment?
I don't think these should be exposed as public fields. You could instead define `_handleAnalysisStatus` and `_handleAnalysisErrors` as closures and keep these objects above in the method body:

```

// Its OK to define methods with names in other method bodies.
void handleAnalysisStatus(bool isAnalyzing) {
    if (!isAnalyzing) {
      analysisCompleter.complete();
      subscription?.cancel();
      subscription = null;
    }
  }

try {
  subscription = server.onAnalyzing.listen((bool isAnalyzing) => handleAnalysisStatus(isAnalyzing));
```
Alternatively you could pass analysisCompleter/error as method arguments
See comment about making `generateDartDocMessage` static/top level - then this class isn't needed
AnalyzeOnce class name is enough, No additional comments.
Get new knowledge Thanks
Yeah you're right, its not a very helpful comment
This will not work on Windows. Best to use the path package https://pub.dev/documentation/path/latest/path/basenameWithoutExtension.html
This a nice improvement over what we have. The generalization of the idea might be a little better: match filenames with a suffix that matches a legitimate locale string preceded by an underscore. You can use https://pub.dev/documentation/intl/latest/locale/Locale/tryParse.html to check each possible suffix.
We're looking for the language code in the filename unconditionally now
It returns null not "null", right?
It would be useful to verify that ap_localizations_en_CA is recognized as en_CA but app_localizations_en_CA_foo is not.
You're right. In one my previous changes it was returning null because I used `toString()` incorrectly. I'll update the comment
I just tried `en_CA_foo` and it somehow parses the locale as `foo`. It seems that `Locale.tryParse` checks for the format of the locale identifier, so it would still be helpful to validate that the language is a valid one.
I feel like calling it `useNewStyle` isn't very future proof... eg. what will happen when Apple changes it again in iOS 15?

Perhaps a better solution might be to create an enum something like:
```
enum ActivityIndicatorVariant {
  iOS13AndEarlier,
  iOS14,
}
```
I'm not super happy with the naming above, but hopefully the intent is clear.

And whatever naming convention we go with, there's a bunch of other cases where code introduced in this PR talks about the "new" style that should be updated to use the new naming (eg. the names of the tests, the array of alpha values, etc) 
You've removed `_kTickCount` (which is reasonable given the change), but this comment still refers to it.
It would probably also be worth adding a comment to each enum case to describe the specific behaviour
Nitpick: Not sure what triggered these changes. Have the Flutter formatting rules changed, or is this just based on  the auto-formatting preferences from whatever IDE the PR author is using?  There's a bunch of formatting changes in this PR that mask the actual changes under the covers.
The file is formated using dartfmt. I think the diff tool should be able to show the actual change in a darker color.
Fixed in latest push.
I've added the enum `CupertinoActivityIndicatorStyle` to control the style.
The default style still remain iOS13 until the official release of iOS14.
I recommend that we remove this enum and `style` flags and only support iOS 14.  If we wait a few weeks to merge this PR so that it misses the next stable release, then the following stable release should happen pretty close to September and the likely release of iOS 14.

Flutter's usual policy is to support only the latest version of a design style.  For example, see https://github.com/flutter/flutter/pull/36087 where switches were updated to match iOS 13's style several months before the release of iOS 13.

Otherwise, if we really want to support both versions right now, we need to have a plan for deprecation. That probably involves creating another issue and adding TODOs to the code saying that it needs to be deprecated. Then someone needs to merge a PR to deprecate this, and then later another PR to remove the iOS 13 code altogether.
I think developers need time to adapt the app for iOS14 and user also need time to update to iOS14. We still need some time to deprecate the old style instead of remove it directly. It will be better to support the new style before official release of iOS14 to give developers enough time to adapt their UI.

I've added a TODO for changing default style to iOS14. (Maybe I will do that.)
Sounds good, if you want to do it this way then I'm on board with that.  Thanks for adding the TODO.  I think the deprecation process should look like this:

Roughly 1 month before the release of iOS 14, we should merge another PR that adds the `@deprecated` flag to the `style` parameter.  This PR should also change the default value to `CupertinoActivityIndicatorStyle.iOS14`.  This will have the effect of automatically updating users to iOS 14 style if they haven't specifically set their style.  The PR should be merged 1 month before iOS 14's release so that the PR is released to stable around the same time.

After iOS 14 is released and everything is working well with the new indicator style, we should merge another PR that removes the `style` parameter and `CupertinoActivityIndicatorStyle` altogether.  This will force everyone to the iOS 14 style.
We can either keep https://github.com/flutter/flutter/issues/60047 open until the final step is complete, or we can create 2 new issues to track the two points above.
`style` is ambiguous with other unrelated things in Flutter (like [TextStyle](https://master-api.flutter.dev/flutter/cupertino/CupertinoTextField/style.html)).  I think we should rename `style` and `CupertinoActivityIndicatorStyle`.  Maybe to something like `iOSVersionStyle` and `CupertinoActivityIndicatorIOSVersionStyle`?
```suggestion
  /// The style that is used in iOS13 and earlier (12 points).
```
```suggestion
  /// The style that was introduced in iOS14 (8 points).
```
```suggestion
  /// Defaults to [CupertinoActivityIndicatorStyle.iOS13].
```
Sure, we can keep the old issue and update the progress.
I've renamed it to `iOSVersionStyle`.
why do we need a pump?
Probably because mouse region takes a frame after `addPointer` to update itself? If so I recommend doing it in the following order:
- createGesture
- addPointer
- pumpWidget
- down
- up (or other gestures)
This is weird. I thought whether the text position handling is position- or word-based should be completely decided by the input device, i.e. Android or Windows touch devices should also select words based on word, while macOS should almost always be based on position. (Not only to this function but also `onSingleLongTapMoveUpdate` and `onSingleLongTapStart`)

Also AFAIK the `TargetPlatform` is defined more like how it looks instead of where it runs. +cc @stuartmorgan 
Perhaps it is to allow the focus to take effect.  That also happens in a microtask.
FWIW, I tested on an iPad with the Apple keyboard. Tapping words selects to word edges. Using the trackpad instead selects by position. 
we should figure out why we need the pump and say so in a comment
if you mark this @required, does it catch any cases where we're not setting it? we should make sure to set it everywhere, even if we don't end up marking it actually @required.
anything that looks at enums should use `switch` and explicit cases, not `if` or `default`, per our style guide
I'll figure out if the pump is needed or not, and either remove it or explain why it's needed.
Yeah I think we should ditch target platform and decide solely based on the pointer kind. Perhaps even have a global function that decides whether the kind is a precision device.
On Android, doing a touch tap does a precise placement of the cursor. The word edge behavior is a Mac/iOS/iPadOs thing. So this should remain platform-dependent.
I already went through all the usages and made sure to add the `kind` argument. The only exception is the one generated from semantics, in which case there's no device kind associated with it. Should I just use `touch` as the default?
Oh there's a `PointerDeviceKind.unknown`. I think it makes more sense to use this instead of defaulting to touch.
My point was in support of this current implementation. I don't think it'll be avoidable to have to account for both dimensions since native behaviors are so diverse. 
Ok, this 2-dimensional criteria looks good to me.
```suggestion
  }) : assert(builder != null || detailsBuilder != null,
         'DragTarget.builder or DragTarget.detailsBuilder must be set.'),
       super(key: key);
```
Might as well require that only one of them is non-null, enforcing by constructor assertion.
```suggestion
      widget.onMove(DragTargetDetails<dynamic>(data: avatar.data, offset: avatar._lastOffset));
```
Among other occurrences in this PR.
Besides being a weird (while probably unavoidable) design, is it still necessary to rebuild on every movement if only `builder` is provided?
Is a public `onMove` property necessary for your demand?
```suggestion
  /// The [detailsBuilder] is similar to [builder], except that:
  ///
  ///  * The [detailsBuilder] is called on every [Draggable] movement within the [DragTarget],
  ///    and triggers rebuild.
  ///  * The [detailsBuilder] vends a [DragTargetDetails], which contains both the
  ///    [Draggable] data and the local position.
```
```dart
///
/// See also:
///
///  * [detailsBuilder], an alternative option to [builder] but provides detailed update and triggers rebuild on every movement.
```
The event of mouse movement (according to [MouseTracker](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/rendering/mouse_tracking.dart#L543)) is exit, enter, then move. Might as well use the same order here, by moving the move event to after entering? 
Is it better to call it [DragTargetDetailedBuilder] (as well as other related symbols)?
Calling this unconditionally is problematic.
I changed it to [DragTargetDetailedMovementBuilder] to highlight that it uses 'details' and also fires on movement. Feel free to suggest something else.
Yes, in order to trigger logic (outside of the build tree) in the same way as onLeave, etc.
Agreed, good call.
Actually, why do you need the detailsBuilder? Doesn't the onMove callback give you enough information to change the state from the outside to what you want?
See my original bug description: https://github.com/flutter/flutter/issues/58982
It would be unergonomic to trigger a second rebuild outside (of the initial movement rebuild) when the user wants to update children.
Why would there be a second rebuild? If I remember correctly, onMove is executed between frame (before DragTarget can rebuild in response to the move), so any state changes that are triggered in the onMove would be applied in the same frame as the DragTarget rebuild, no?
Here's didDrop (existing code) and didMove (new code, modeled on the existing patterns). It calls setState() first, then calls any relevant callbacks. 

```
  void didDrop(_DragAvatar<Object> avatar) {
    assert(_candidateAvatars.contains(avatar));
    if (!mounted)
      return;
    setState(() {
      _candidateAvatars.remove(avatar);
    });
    if (widget.onAccept != null)
      widget.onAccept(avatar.data as T);
    if (widget.onAcceptWithDetails != null)
      widget.onAcceptWithDetails(DragTargetDetails<T>(data: avatar.data as T, offset: avatar._lastOffset));
  }

  void didMove(_DragAvatar<Object> avatar) {
    if (!mounted)
      return;
    if (widget.detailedMovementBuilder != null)
      setState(() {});
    if (widget.onMove != null)
      widget.onMove(DragTargetDetails<dynamic>(data: avatar.data, offset: avatar._lastOffset));
  }
```

Even if it were to work without needing to add it to the next frame, that's not apparent to the caller. I feel that most Dart/Flutter developers will instead assume that callbacks may be called during rebuild, and will always schedule it on the next frame, e.g. would use onMove:
```
onMove:(details) => SchedulerBinding.instance.addPostFrameCallback((_) => setState(()=>_coords = details.offset));
```
The order of calling setState and calling the callbacks doesn't matter here. setState just marks this widget to need rebuild in the next frame. It doesn't actually do the rebuild.

Scheduling a postFrameCallback like that in response to a gesture callback is also very unusual. You wouldn't do that in a GestureDetector's onDrag/onTap/etc. either.
I've confirmed that the postFrameCallback is not required, i.e. I can just call setState() in the onMove() callback. However, I think many flutter coders instinctivly avoid setState() within a build _method_ out of habit, even though it is ok in this context since it is part of a callback outside of the build phase. But yes, I agree it's not needed. More thoughts in the other comment below.

Maybe extract this out into a private method and call it below as well.
This fails with devices attached!
Seemed to be calling real filesystem, but I'm not sure how
setUp so that test state doesn't leak
doesnt do anything
no idea why this was here
again, prevent leaking test state
it is now, no idea why this test was passing
this is tested via various devicelab and integration tests, the unit tests has too many mocks to be useful and was failing with some wicked stack traces
That is, it is now available on stable channel so the test should have failed
Looking at the implementation of `NoDevicesManager`...should we just delete this test?
I'm sort of assuming this is testing the devices command logic for error states and not the devicemanager. I think `AndroidSdk: () => null,` was an early attempt to disable all devices, but that doesn't work in a web/desktop world
Well, I guess we're still testing some code here. I take it back.
Shouldn't the default `FileSystemUtils` use the file system and platform from the context (and thus the overridden test mocks)?

And if that's not happening, would removing contructor injection `FileSystemUtils` fix this? This worries me that you can override the ProcessManager + FileSystem but still end up using the real filelsystem.
Hitting real artifacts, failing if they did not exist
Hitting real cache, failing if it didn't exist.
hitting real file system, failing if a .packages didn't exist
This test apparently doesn't rely on this value, avoid looking up potentially null home dir path
This fails if .packages doesn't exist
missing windows check, was creating this as a windows style file path even if configured paths were possix style
This was calling the real fsUtils in the test. Rather than inject it I replaced this with roughly equivalent code. I'm not sure how useful ensureDirectoryExists actually is.
This was calling real artifacts, falling if they did not exist
Renamed this to stop my IDE from autosuggesting it when i type `test`
Similar to above rename
I switched this to only use a linux file system/path to make it more obvious where we were failing to correctly configure things. I.e., the windows path in the toFilePath on URI
This seems like the right property to for this:
```
  /// For example, the [Chip] class sets this to false because it can't be
  /// disabled, even if no callbacks are set on it, since it is used for
  /// displaying information only.
```

Looking good =)
you should have a newline here
Good catch! May have gotten lost when manually merging some conflicted testing structure stuff.
This is scary. I do agree it will be convenient to have ability to wait a period of time, but this may be a source of flakiness.

I was actually thinking about solving this problem before, is it possible to get all the the timer and microtask created within a zone(maybe be caching when someone calls ZoneSpecification.scheduleMicrotask and ZoneSpecification.createPeriodicTimer), and provide some kinda of api to expose those?
In general, I agree with you.

This PR does not make things less or more flaky. If your test relies on some condition to resolve asynchronously, then it may or may not get a chance to resolve when runAsync returns. This PR aims to make that *a little* better by trying to flush the microtask queue before returning. It makes sense but indeed, it is not a guarantee and thus it does not reduce flakes.

What it *does* do is to expose the pre-existing ugliness to developers. Now we have a ominous parameter `minFramesUntilIdle` which, if we want to, we can default to 0 so we don't wait at all (current behavior). With increased documentation and this new parameter, we are giving developers a strong signal that `runAsync` is working as intended and if they want less flakiness, they should consider changing their code.

Without this change, people are surprised by the behavior of runAsync and try to "fix" it by doing stuff like this:

```dart
runAsync(() => // some code that causes a side effect in my widgets);
runAsync(() => pumpEventQueue(times: someRandomNumber)); // I found this API that's supposed to help, I guess?
```

Fiddle with `someRandomNumber` until it passes. There's no other solution to this that I am aware of.

I am trying to make this part of the API and documentation so at least developers *hopefully* understand what they are doing and why they are doing it. If they start seeing flakes, they can refer to documentation and see why it is happening.

Replace code above with:

```dart
runAsync(
  () => // some code that causes a side effect in my widgets,
  minFramesTillIdle: someRandomNumber, // Ah, but now I see this is a synchronization issue.
);
```

As for exposing timers and microtasks, I think that's a problem for an IDE to solve. While debugging these tests, the users should be able to see what kind of timers and futures are now "frozen" because we ended the real async zone. I have a generic bug for this that I am hoping will get some traction. 

I tried to save this information and perhaps print a warning message that there are unresolved tasks and such but it is too noisy. It alerts when there's no need to alert (such as no side effect) and it doesn't alert when it needs to (e.g. some IO operation will eventually post a microtask but we have no evidence of that now).

The final thing we agree on: This problem bothers me :-). I think this PR makes things a bit more transparent (but, like you said, not any better).
For exposing timer and microtasks, I meant expose a handle for the user to await for them. The problem is some of our code (image decoding for example) create futures without any reference for test to await for, and that is the main reason people want to do pumpEventQueue and hope those futures get resolved.
It is not just Future's. Image has streams and other subscription mechanisms as well.  Is it possible to capture all those in a zone? I know that Future.delayed creates a Timer but I don't think an `ImageCompleter` stream would create anything that's observable in a zone. I will test this out and get back to you.

We would also need to create a polling mechanism with a completer to track timers and return when all timers return false for https://api.dart.dev/stable/2.8.4/dart-async/Timer/isActive.html as Timers themselves do not provide this functionality AFAIK.
I believe the imageCompleter is just a wrapper over a codex future, the future will either be a wrapper of timer or microtask, but then i think you are right that we need to find a way to flush the timer. flushing microtasks should be as easy as creates await Future.delay(0), but timer is tricky.
Maybe things will be easier in the fake async zone that the runTest use, in there we can control the time flow so even if we do fakeAsync.flushTimer(Duration(hours:1)) it will be finished in a instant. we can expose all the timers and make a API that is something like ```await tester.resolveTimer(Timer timer)```
I am not sure I understand. Futures/Timers cannot cross over zones. We cannot move a Timer that was created in real async zone to fake async and resolve it there.

However, I made some promising progress. If I keep track of timers, I can do this:

```dart
      final Completer<void> sideEffectCompleter = Completer<void>();
      const Duration checkInterval = Duration(milliseconds: 100);
      Zone.root.createPeriodicTimer(checkInterval, (Timer timer) {
        timerCache.retainWhere((Timer timer) => timer.isActive);
        repeatingTimerCache.retainWhere((Timer timer) => timer.isActive);
        if (microtasks == 0 && timerCache.isEmpty && repeatingTimerCache.isEmpty) {
          timer.cancel();
          sideEffectCompleter.complete();
        } else if ((checkInterval * timer.tick) >= additionalTime) {
          timer.cancel();
          sideEffectCompleter.completeError(TimeoutException('Timed out!'));
        }
      });
      try {
        final T value = await callback();
        // This is something we can expose to user or we can await ourselves.
        await sideEffectCompleter.future;
        return value;
      }
```
I want to build up a more comprehensive test involving streams. Let me know what you think.
I think you meant exposing Timers/Futures etc that we use in the widgets for testing. Even so, there are certain things where we "have to" rely on real async such as file io. Widget tests need to be able to load images from assets which means a certain part of widget testing cannot be in fake async zone. 
I am not familiar with file io, why couldn't it run in fake async?  The assets loading part should be fine because we mocked the asset channel to read file synchronously https://github.com/flutter/flutter/blob/aa0382e95d3fe19b9ee4becf3fdf4017c15a149c/packages/flutter_test/lib/src/_binding_io.dart#L40

The reason I brought up fake async is that i am thinking we can move away from writing test in runAsync if we can make the fakeasync in testWidgets expose the timer and microtask.
There has been numerous discussions about trying to run everything in fake async. See related issue: https://github.com/flutter/flutter/issues/23179 and specifically: https://github.com/flutter/flutter/issues/23179#issuecomment-452128558. For this to happen, we need to enumerate all the possible things that Flutter widgets might do and provide sync implementations of them (much like you did for file loading). I am not sure how feasible that is.

Even if it was feasible, do you think we can still make progress in making runAsync more robust and chase that problem separately? We should seek incremental and innovative solutions together. If we get rid of `runAsync` at some point, I would be *very* happy but it does not seem possible for the time being.
I see yes you are right, I don't have an idea to fix the issue you mentioned neither. i agree we should make runAsync more robust at least for now.
I updated the PR. I still had to introduce some "wait time" in there because microtasks can be scheduled by any async operation "back to back". However, I feel better about this approach because it is more deterministic and easy to explain. Let me know what you think.
The purpose of additional time is to increase the timeout value for the test section, I think we should not overload its usage. As of the current implementation it both increases the wait time for the timer/microtask and also extends the timeout.

It also raise another question, what if there are unresolved futures that user does not care about? currently it will always fail if there are unresolved futures after the additionalTime.

How about we expose a new api, something like `tester.resolveTimerAndMicrotask()`. this api create a periodic timer just like you do here, but the sideEffectCompleter will only resolve when there are no more timercache and microtasks.
In the test, the developer can decide if they want to wait for the future by calling `await tester.resolveTimerAndMicrotask()`. If they have a bad test that creating unresolved timer or microtask, it will just hang.

We don't do any waiting at the runAsync tear down, it will be developers choices to decide what they want to do.
debug statement
where is this used?
Will be removed once we agree on implementation :-)
Will be removed once we agree on implementation.
> The purpose of additional time is to increase the timeout value for the test section, I think we should not overload its usage. As of the current implementation it both increases the wait time for the timer/microtask and also extends the timeout.

Fair point. I can introduce a new parameter and also use this parameter for signaling that runAsync() should not wait for additional futures.

```dart
waitForIdle: const Duration(seconds: 2),
```
I would rather not introduce a new API. I would expect, in the normal case, for users to actually care about the Futures that their widget code introduces in runAsync. They would not be using runAsync otherwise.  We should optimize for that most common case. Once this solution makes it to SO, everyone will simply copy and use them together anyway. The APIs being separate will lose its meaning.

I agree with you that there will be advanced cases where these futures should not be awaited but then we are getting into highly custom test code category. Users can then create a future that they want to await and do that. I will put all this in actionable error messages.

```dart
// Do not wait for idle.
await runAsync(() => some code, waitForIdle: null);
await runAsync(() => await someSpecialFuture);
```

Another reason: The interplay between the two APIs would need to be carefully covered. For instance what if this happens:

```dart
await runAsync;
await resolveTimers; // What if runAsync runs into error. Now the user needs to check return value and make sure there was no error in the async block.
//
// some code later
//
await resolveTimers;  // Does this throw? Does it just return? Either option is error prone.
```

Let me know what you think.
I think i agree with most of it, but there are some more concerns i have.

> waitForIdle: const Duration(seconds: 2),

I think we don't need the duration here. this can be a true false value, and the test will either resolve the timer/mt or just timeout the test section.

>I agree with you that there will be advanced cases where these futures should not be awaited but then we are getting into highly custom test code category. Users can then create a future that they want to await and do that. I will put all this in actionable error messages.

I think part of this is also we have some unexposed future in our built-in widget as well (for example the image decoding in Image widget or localization asset loading). unless we expose those future in the widget state, user will not be able to resolve them If they want to test the result after those async load. That is why I kinda want to have a separate api to resolve this future. However, I am ok with not provide an API too since we can use the runAsync. waitForIdle to resolve the future. It just the test code maybe a bit more complicated.

>Another reason: The interplay between the two APIs would need to be carefully covered. For instance what if this happens:

I will expect resolveTimers called without an async zone (not in the runAsync callback) will just throw an error?
I see what you mean now. I thought you were proposing a separate API to await *after* runAsync was done.

Yes, providing a helper function to call inside runAsync callback is tempting. I still prefer the default behavior to be more robust because when things fail today, they fail without giving developers any direction on what might be the problem (such as defining a custom task future to await inside runAsync()).
I will think about this a bit more. Running this PR over google3 broke 24 tests. At least 2 of them were pre-existing bugs in the tests themselves that this uncovered! However, many are due to premature timeouts. Perhaps I will have to do what you are proposing after all @chunhtai and expose the periodic timer as a `Future` for apps to listen on. I will dive deep into some use cases and see what I missed. The good news is there are at least 9000 tests that exercise realAsync and only 24 failed.
Latest results: 10 failures.

- 2 due to pre-existing bugs in tests.
- 4 due to the tested code creating a periodic timer that never resolves.
   - I am inclined to warn people about this rather than awaiting on them.
- 4 due to running *a lot* of tests in a single file. This is the problematic one. Since we now wait up to 500ms to make sure there are no new microtasks created, each test (that uses `runAsync`) is lengthened by half a second which means if you are running 120+ tests, your test now runs at least a minute longer.

Due to #2 and #3, I am now leaning towards your proposal to expose this as a separate method. It would be nice to make the default method more robust but it should not come at an expense of causing half a second delay per test.

I will put in some robust documentation as well so people can make an informed decision on when to use this API.
I think this should default to infinite. For example, how should we pick a right time for this? Either a duration that is super big or a duration that is close to the actual run time. The later will make test flaky.
If this is infinite, this Future will never complete.

This isn't a timeout. It is the length of idle period that we expect to observe before declaring the application as idle.

Suppose we have the following scenario and for simplicity, assume that microtasks are executed as soon as they are scheduled:

```
microtask1 <--29 ms --> microtask2 < -----------------143 ms -------> microtask3
```

If we have `expectedIdlePeriod` as 20ms, this function will return after microtask1. If we set it to 50ms, it will return after microtask2 because it will observe that there are no pending timers or microtasks but the amount of time that passed **since** the latest microtask (microtask1) is less than 50ms.  After waiting for ~50ms after microtask2 executed, it will run and claim that enough time has passed. If you set it to 500ms, all three microtasks will need to execute before the application is declared idle.

The longer you set this, the more confident you will be of idleness. However, it will also lengthen your test execution by that much. This is real-time wait.
Ah I see, it only resolve when 
delta_time > expectedIdlePeriod and the timer/microtask caches are empty.
That is a bit weird though, shouldn't we resolve the future as soon as timer/microtask caches are empty? why do we still want to wait in this case.
I was imagining this kind of logic

if (delta_time > expectedIdlePeriod || caches are empty) resolveFuturesCompleter.complete();
else continue;
That was the first approach I tried but it does not work if your microtasks complete quickly but are scheduled by external events (such as network or disk io). That is the normal case.  For instance, if I am listing directories and stat'ing them one by one, this is what you would see in the microtask queue:

```
0 milliseconds: start
2 ms: end
15 ms: start
17 ms: end
...
```

For the vast majority of time (e.g. 2 to 15 ms), the queue is empty so you will prematurely think that the program is done.

That's why I had to introduce the idea of "idleness" into the code. Wait for a "silent" period where no microtask is fired. The length of the period is controllable by the user.
nit: I believe we use `*` instead of `-` throughout the code base for enumerations. 
We generally don't want to spam the console with warnings. 
should not -> must not?
document what the parameter does?
Looks like this doc is duplicated. Can this be a macro?
```suggestion
  /// Waits for a stable state within a single [runAsync] execution.
```
Nit: sentences should start with a capital letter.
Adding API that we do not recommend to be used seems ... wrong.
> tests might be flaky

Adding another option to make your tests flaky doesn't seem like a good idea.
i understand now. Although we make it more transparent on what is under the hood of async zone, we still have not solve the problem that this api may encourage flakiness. I don't have a good answer neither but I have some other idea that i would like to share.

It is possible to write the resolveFuture to take in a integer number `count`, and the resolveFuturesCompleter will only resolve when there are at least that # of timers has gone from active -> non-active. This way we no longer rely on the duration of the future but the # of the future that should resolve in a test, and that should never change.
I would also love to add "not recommended" to `runAsync` FWIW :-)
I would be against that because it would make the tests really difficult to maintain. Suppose that we did a Flutter roll that changed the internals of PictureRecorder (added a new Future). Now all of a sudden we have to update all the tests and increase this number by 1. It is fairly arbitrary and does not add more insight to developer. They just have to guess the right number.

pumpAndSettle is the same by the way. We recommend that people test the number of frames pumped returned by pumpAndSettle() to make sure they got the right number of frames but in reality, no one does that. It is very difficult to maintain and it can change easily by your dependencies.
nit: please use `[...]` for things like FakeAsync, runAsync, etc.
(basically everything that can be hyperlinked except parameters)
please see the style guide for writing style for documentation (https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo) -- e.g. "Note that" is against our style.
not sure what this comment means
that's a weird initial value, why that?
prefer `+= 1`
`-= 1`
also, error message should say why
(and what to do instead)
error message should say why
this seems to be encoding a race condition into the test framework, which is a no-no per the style guide
what's wrong with runAsync?
it doesn't matter how long you set it, it'll always be flaky
"note that"
> pumpAndSettle is the same by the way. We recommend that people test the number of frames pumped returned by pumpAndSettle() to make sure they got the right number of frames but in reality, no one does that. It is very difficult to maintain and it can change easily by your dependencies.

pumpAndSettle really only makes sense to test your own widget, it doesn't make much sense when testing something where you don't know how many frames are going to run. In general, app logic shouldn't be triggered on frames, so when testing app logic you shouldn't need to wait for things to settle. Just pump a frame to start animations, and pump a frame with a delay sufficiently later that all the animations are done.
- Zones.. testWidgets() has two zones, which itself is tough to grasp. runAsync within testWidgets ups that to three. Most developers don't understand zones and the side effects are bizarre and difficult to debug.
- Makes it too easy to run into synchronization problems which is another thing that's difficult to debug. 

Sorry for being generic. I can probably compile concrete examples for these. These are some of the difficulties I myself have run into and seen other developers struggle with.
nit: maybe we should restructure this block a little bit for clarity and lead with "if you're experiencing a hanging test, <reasons why this may be>". I imagine, if you scan the docs for a solution, it is because of a hanging test and you don't know yet that it is because of an un-completed task.
"The fake async environment..."
This method doesn't return a value
This isn't a safe change; most callers assume that the return-value is non-null.
The other way will be somehow prevent everything below the kept alive child from being paint. Let me scratch my head a bit...
This looks OK to me although it would help if the comment explained how we end up applying a paint transform to a child that's not supposed to be laid out or painted.

FWIW, I noticed that RenderFittedBox's applyPaintTransform() also uses transform.setZero() to defeat painting a child.
It is possible that children in the keepAlive list will want to paint themselves.
In such case, we give it => For cases like that, we give the InkFeature children a zero
Should these not be target platforms? for reference TODO on 431.
Actually going the exact opposite direction, target platforms are already super overloaded. Rather than say "hey we're building for ios_armA, ios_armB" we say "hey we're building for ios, with architectures armA, armB"
Ok, that makes sense. I'm thinking that, in terms of the cache refactor, I should re-write these as classes then, so that we can model the hierarchical relationship.
I think for caching we can flatten them back out to strings. But we should update the cache to distinguish between HostPlatform and TargetPlatform if possible
The logic that includes web is kinda weird compares to other platforms.
https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/template.dart#L112-L114
As this PR doesn't try to change the logic there, let's add another test to ensure the web related files are not created if web is not requested. WDYT?
Can we just reuse the same method channel implementation in the <plugin_name>.dart and this web class just listen to the channel message?
I don't think so. If I modify the <plugin_name>.dart this script becomes backwards incompatible, right?
I added `unexpectedPaths` to the normal plugin creation (where by default `web` is not requested):

```dart
      unexpectedPaths: <String>[
        'lib/flutter_project_web.dart',
      ],
```

Isn't that enough?
oh I missed that. that's good enough thanks.
So we keep the <plugin_name>.dart the same. And the `web.dart` file just listens to the same method channel like other platforms do.
Correct, in this case the web implementation listens to the same method channel. The fact that they both live right next to each other in the directory hierarchy is confusing. 

Imagine this `web.dart` lives in a completely separate package, that's another reason why I wouldn't reuse stuff from the "core" plugin. (The core plugin must depend on the web implementation, so the web implementation can't depend on the core plugin, or we'd have a dependency cycle)
Again, my mistake. I was looking at something else. This is good. thanks 
Need to create at the global packages path due to:

https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/test/test_compiler.dart#L136 . IF this wasn't correct we would throw errors after the test finished.
Removes testbed as a smaller incremental migration towards context free
üïµÔ∏è‚Äç‚ôÇÔ∏è 

This was throwing in the packageConfig loader in the loadPlugins way down below
flutterPlatform.loadChannel reads the package config, which was hitting the real filesystem.
missing .packages file, would fail in the loadPackageConfig function. Renamed `fs` to `fileystem` because I can't help myself.
Nit: using `r'...'` would mean you wouldn't need to do so much extra escaping; it's commonly used for defining regex strings.
Actually, a second and more important change: you should make this a multi-line regex and allow for a newline between between the constant string and the ID (and remove the ^ from the start). If someone re-wrapped the file differently (e.g., running an auto-formatter with a long ID) this would break.

Right now it wouldn't matter since this is only used in a test where no editing has happened, but since this isn't test-only code it should be made robust against that.
context => contexts.

Here and in the other copies of this comment
I wonder if the caret metrics cache should just be invalidated whenever the text painter has to relayout and its width cache misses?
not too familiar with the text painter code, just asking because `TextPainter.markNeedsLayout` seems to invalidate the caret metrics cache.
Something like this ~~554a544~~ a86c3c8?

I like the idea, it seems to make a lot more sense and reduce the need for more state.  Let me get a double check from @HansMuller that it seems like a valid idea.
nit: "moves its right edge"
Sounds reasonable to me. 
I'm not sure how any of these passed with a missing file system override, but it looked to be using the real file system sometimes
replaced skip with platform override
nit. can this be `testWithoutContext`?
The fuchsia device still uses context :( 
LGTM then
Remove abbreviation
removed single group
missing file system utils meant this was using the real android studio sometimes
missing home dir would lead to lookup of bogus path. Not sure how it worked
This is troubling...
typo "texture the texture" to "the texture"?
I think both `low` and `none` can scale the texture and bilinear/nearest-neighbor is just the typical behavior instead of the guaranteed behavior (https://api.flutter.dev/flutter/dart-ui/FilterQuality-class.html). Maybe a better documentation is `When the texture is scaled, a default [FilterQuality.low] is used for a higher quality but slower interpolation (typically bilinear). It can be changed to [FilterQuality.none] for a lower quality but faster interpolation (typically nearest-neighbor). See also [FilterQuality.medium] and [FilterQuality.high] for more options.`.
Done
Done
Is this the right path to edit?
GDK?
```suggestion
  /// "GTK_KEY_Eject").
```
Yep, it's wrong. Turns out it wasn't the only case though - https://github.com/flutter/flutter/pull/60015.
GDK is the low-level part of GTK (GDK = Gimp Drawing Kit, GTK = Gimp Toolkit in original naming), so events are in the GDK namespace.
Ahh, OK, makes sense.  I was just pattern matching... 
I would also pass --no-version-check just to be safe
https://github.com/flutter/flutter/blob/75fd73d81888966746821e65d37e1fc90dc56bfb/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart#L82
Sorry, landed this while the tree was green. Fortunately, in the command runner we bypass the version check if `--machine` is provided https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart#L82
It might be better to implement a copyWith instead of forcing us to go into flutter_test to make changes.
Change to `The framework was provided a mangled stack trace by a test binding`, the convention for assertion messages is to describe a true but unexpected state, afaik.
We should assert that the stack trace is actually mangled here.
This test can't fail, perhaps you forgot to assert `details.stack` is unmangled.
This part isn't the framework though - it's in the test binding code.
Done
It fails without the change to the test binding - it just not on this expectation. This is just here to make sure the test is doing what we think it's supposed to do.

The failure would come in the framework code where we get a Chain instead of a StackTrace.
Ahh, my bad, it fails in the reportError
I was just confused by the grammar then, specifically the `a` after `unmangled`
Ahh I see I'll clean that up
Done
should we say this on every class with a copyWith?
That's fair, I had this in here before adding copy with. Removing.
Can you add one of those issue references in case it gets lost in history?
Add: "Regression test for <issue link>" here?
```suggestion
    // If the scroll offset is at zero, we should make sure we are
```
nit: end with a `.`
```suggestion
  // meaning they have been multiplied by the ancesters and are thus relative to
```
```suggestion
  // The number of elements (from the head) in `_transforms` that have been
```
Does this work when using 3D transforms? @goderbauer did some work to make sure that our hit tests worked with surfaces that weren't screen aligned (I'm thinking of https://github.com/flutter/flutter/pull/32192, but there may be others), and I want to make sure this doesn't reintroduce that issue.
tiny nit: This could be combined with the previous line.
I would assume these cases have been added to unit tests, which this PR do not break any of. Let me know there is anything else that needs manual testing or needs to be added to unit tests.
Why are we forcing this to null now instead of keeping the original event if available?
Just the assert should be enough, no?
Since we might add more parts in the future, maybe add some short private doc comments to the methods explaining what they are for? That way, if somebody needs to add another part in the future they know what to do.
Why is this method part of the base class if it's only relevant for _MatrixTransformPart?
Why does the matrix part get a convenient factory constructor, but the offset part doesn't?
What's the purpose of this class that just wraps a single value? Can this have a more descriptive name or add a doc comment explaining this a little more?
typo: ancestors
Unless it is faster doing it this way, would the implementation maybe be simplified by just having two separate lists, one with global transforms and one with local transforms? when we need to globalize, we just pop things of the local transform list and add it globalized to the global transform list?
Also, "assert" in the name makes it sound like this should only be used in asserts?
It's guaranteed that the last transform is always of type `_MatrixTransformPart`, which is the only type that implements `assertMatrix`?
Can _transforms ever be empty in the new world? Looks like the list is pre-seeded with the identity matrix and never cleared?
typo: pushOffset
This should continue to work fine even for 3D transforms, as far as I can tell.
Why are we switching this around? Even when it is disabled it should still respond to hovers?
Why do we still need to have a separate hit testing pass for mouse events? Can that not be integrated with the regular hit testing now as well?
Short version: In order to prevent the type system complaining, either we set this to null, which satisfies the current definition of `original`, or we change the type of `original` in the constructor, which also changes the definition of `original`.

Long version: An error will be thrown in this as-cast when converting other event types using `fromMouseEvent` (e.g. from `PointerDownEvent` to `PointerEnterEvent`). This as-cast was not here when this constructor was first created, but is reasonable since the constructor requires `original` to be `PointerEnterEvent`, which also makes sense since `original` was added for the transformed constructor to **transform between coordinate space**. So if we think it this way, this `original` should be null because `original` was not defined to suit in the type converting case.
I would say just the throwing is enough, since this does not make sense in production either (there is literally nothing I can return here).
Because the matrix transform part is special: It is the only kind that we can extract a matrix out of. This is important because ultimately we will need to extract a matrix to get the transform matrix.
This class is used as a reference to a primitive type. 
```dart
class MyClass {
  _Ref<int> number;
}

MyClass a = MyClass()
  ..number = _Ref<int>(1);
MyClass b = MyClass()
  ..number = a.number;

a.number.value = 2; // This also changes b.number.value
```

The reason why this is needed is explained at https://github.com/flutter/flutter/pull/59883/files/6bf779806cdf3329fa8ec42faeec59881668b8fa#diff-cef98733ade736b1a8f03a753c9151f2R160.
Yes. A widget should never turn off the mouse region when it's disabled.

The mouse cursor algorithm detects the first `MouseTrackerAnnotation` found and uses its cursor. If the `MouseRegion` is hidden behind the `IgnorePointer` then the widget will never be able to show its disabled cursor, and the cursor will incorrectly be the one of the widget behind it, as if the `TextField` does not exist. A test that is violated can be found at https://github.com/flutter/flutter/blob/3f4f91532f5959923ed5a25fc0bed83bdd207b46/packages/flutter/test/material/text_field_test.dart#L8170

The reason why this isn't found earlier is probably because `IgnorePointer` and `AbsorbPointer` failed to support mouse events (incorrectly, see https://github.com/flutter/flutter/issues/35213).
This is a really good idea. It simplified a lot of code and is proven to be equal in performance or even faster!
This is removed.
This is removed.
This is removed.
Removed.
Removed.
Without mouse,

* During hover events, no regular hit test is done.
* During down events, a regular hit test is done, so this is an extra pass, but down events happen at such a low frequency that we might not really care.
* During move events, no regular hit test is done (the result of down events is reused).

Conclusion: The only "extra pass" is the ones at down events, which do not really matter.
nit: typo after pushOffset
This assert is a little odd. Why do we assert after removing that there's still something in _transforms? Shouldn't we assert before?
I am more concerned about the extra code complexity that we have to deal with because the paths are not unified. 
The `_transforms` should never be empty, because there should at least be the pre-seeded identity matrix.

Of course it shouldn't be empty before the operation either, but that would be detected by `removeLast` anyway.
If the mouse device update is triggered by a pointer event, then the code path is indeed more complicated than necessary: 
```

GestureBinding.dispatchEvent -> PointerRouter.route -> MouseTracker._handleEvent -> hit test
```
Maybe we could've done the hit test at `GestureBinding.dispatchEvent` and pass it all the way to `MouseTracker._handleEvent`.

But the mouse device update can also be triggered after every frame, during the post-frame callbacks:
```
SchedulerBinding.handleDrawFrame -> MouseTracker._updateAllDevices -> hit test
```
In this case `MouseTracker` have to initiate a hit test for each device, without the participation of `GestureBinding` at all. 

I'm not saying that a much more unified structure can not be achieved at all, but for now I'd rather touch as few things as possible in order to see the performance impact of the current PR.
reporting these as a full error seems harmful as this is much more of a warning than an error.
It could be reasonable to add a `FlutterError.reportWarning` to handle this and other cases where we want to add warnings to the framework. 

For example, existing errors all indicate that something has gone wrong and the user needs to take action. This just indicates that something might be inefficient. Existing heuristics like truncating all errors after the first error to de-emphasize errors that are follow on failures from other errors would not make sense for cases like this. If you had this error and then a real error then you would want that other error to be emphasized rather than this one which is just a memory usage warning.
should there also be a percentage threshold for this as well where we only warn if both the KB and percentage thresholds are exceeded? It would seem
It seems like a false positive if we warned that a 64MB image was rendered in an area that would only require a 63MB but warning that a 2MB was rendered in an area that would only require 1MB would make a lot of sense.
nit: why not take the delta in bytes and only round to kb on display? As written this could introduce some slightly strange rounding errors where warnings would be issued when the size difference was actually slightly less than the threshold. 
make exception a FlutterError object instead of a raw string.
I've shifted this around to avoid some potential rounding issues. I still want the comparison to be in KB because bytes are too small, and my thought is that developers shouldn't be concerned with deltas < 1kb.
This is opt-in - the idea is that if the developer has opted in to seeing it, they want to take action if it happens. 

If we had a facility for reporting warnings, that would work fine, but I'd rather not hold this up in trying to develop one and wiring it up in all the right places.

In my terminal, subsequent errors still have enough relevant detail, although it's good they're truncated a bit since you can run into this error on every repaint of the image, which may happen multiple times at the same size. For example, in testing this in a macOS application, I get this over and over again as the mouse moves across the application.
Done
I was considering this, but I think the absolute number is probably more useful for a few reasons:

- The developers likely to use this are working on smaller mobile/embedded devices, and are concerned with KB usage rather than MB usage.
- A developer working on a screen with a high enough resolution to show a 64MB image (e.g. a 12MB/4K image) are probably not concerned with this anyway - a machine with that high a resolution will have enough memory where it shouldn't be a big deal.

I was considering whether we could add a percentage, but that seems to complicate the interface. That said, I'm not clear on how this would get exposed to a developer in an IDE/devtools - knowing that might help here.
If we can only choose one approach: either multiplicative (percentage increase), or additive (absolute KB increase), I'd prefer the multiplicative too. Here's a more realistic case for a low-end device: suppose we're showing 100 thumbnails where each image's full resolution takes 100KB, but thumbnail resolution only takes 50KB. An additive threshold of 100KB would not report warning, but together (x100) they use 5MB more memory. A multiplicative 50% threshold would catch that.
I think this is a very useful and actionable warning/error, and I'd love it to be opt-out instead of opt-in if I were developing a Flutter app. (Figuring out what opt-in features to turn on could be a big cognitive cost.)
"tag" sounds to me like "label". The value that we've assigned to it is more like "source". If we document it as "identify the source", why not just call it "source" or "debugSource"? Forgive me if my English understanding is limited...
That's a really good point.

I'm trying to think of a way we could capture both of these:

- A list of small images that together add up to a lot (e.g. a list of even small images that could still be half the size they actually are).
- A single large image that, while a small percentage, still adds up to a lot (e.g. a 12MP camera image rendered even at device resolution)

We could add two properties, but that seems harder to manage and reason about to me. We could also probably track the images in a static map, and then check that the whole map doesn't exceed the maximum allowable KB.
I can rename this. I think I was originally expecing this to potentially be an object that might just hold the image cache key. 
It may also be simpler to have two properties (or a complex property) - something for a percentage over and an absolute max. We can figure out how tooling might set that later.
I think we could make it opt-out at some point, but we should start this way so that people have time to fix things without needing a manual roll internally.
Being able to make this opt-in by default would be a great goal. Adding an environment variable like
`flutter.imageSizeWarnings` like the `flutter.inspector.structuredErrors` one @helin24 added here could be a good way to achieve that.
https://github.com/flutter/flutter/commit/479f370379cc721d399cb8e3c0bcac79d58d17b4#diff-f01fcfe0b7237b22d168496f69be49baR947

Having the environment variable in addition to a service extension is useful as a service extension cannot be set immediately on app startup which means you miss errors that occur before the first frame renders.
I suspect the ideal UI for this is not individual errors but a table displayed in DevTools showing the aggregate unnecessary memory usage across all images and a sorted list of the worst offenders based on a combination of byte delta and ratio of waste.
That seems to lend towards just having a static variable that tracks this, and that we can push to devtools on demand.

I'll tinker with that some more.
great! I think this will be a really useful debugging feature.
So I think rather than two properties, this should work out if we use a percentage but base it on the natural log of the operands. So basically

```dart
if (math.log(displayBytes) / math.log(decodedBytes) >= allowedOverheadPercentage) {
 // bad
}
```

This should mean that you could pick a fairly reasonable percentage that will more heavily weight towards larger overheads, where it gets more important. WDYT?
that is clever but it would be really hard for users to get a mental model of what it means. I'm not sure I have a good mental model of what value of allowedOverheadPercentage would make sense as a threshold using logs and whether small images and large images are treated in a desirable way. It would be easier to say:
we flag images as being too large if one of the following is true:
displayBytes is more than X kb smaller than decodedBytes and the percentage increase in size it at least Y
or displayByes is more than Z percent smaller than decodedBytes and the # of wasted bytes is at least Q
The criticism is fair. I'm still a bit concerned by the complexity getting introduced here.

Here's another thought:

Rather than having any threshold for this, we just have a method exposed over a VM Service extension to dump this out. We also call `postEvent` with all the details we have when drawing an image.

In an test, you could assert that the total memory overhead is whatever you want it to be. And in devtools, we can offer some kind of visualization of this.
`math.log(displayBytes) / math.log(decodedBytes)` is difficult for me to understand too. It's undefined if `decodedBytes == 1KB`, or negative if `displayBytes > 1KB, decodedBytes < 1KB`.

It would be easier to understand if it were `math.log(displayBytes) - math.log(decodedBytes)`, which is equivalent to `math.log(displayBytes / decodedBytes)`, so there will be a 1:1 mapping between the multiplicative threshold and this log threshold.
yes I agree that this is the sort of threshold that is better to iterate on in devtools than to hard code in the flutter framework. Based on user studies and feedback from users we can probably come up with much better thresholds than what we could guess here. +100 to using postEvent to just dump all images added and removed from the widget tree so filtering and display can be done separately. 
This toString doesn't seem very consistent with Flutter. Maybe remove it or extend DiagnosticsNode to use its functionality for more standard looking toStrings.
Ah yes meant to remove this
this is a nice way of running a vm service test! impressively self contained as long as you can run the vm service against the app you are testing.
This is assuming 16/3 bytes per pixel which is surprising unless I'm missing something (perhaps mip-mapping?). 
Can you document why it is `4 * (4/3)`?
I would have expected either 4 bytes per pixel or 3 bytes per pixel depending on if you are assuming an alpha channel.
missing comma before displaySize.
Nit: if you'd like to make sure you don't accidentally add an extra space you can write this code like this
```dart
[ if (debugLabel != null) debugLabel, image, '@${debugFormatDouble(scale)}'].join(' ')]
```
not sure it is better.
debugLabel should only be provided in debug build if it is using the debug naming convention.
We have this issue in various places where things named debug have to be available in profile mode. I can guard this with a `if (!kReleaseMode)` - is that what you're getting at?

I'm not sure what a better name for this would be.
Done
Added a comment. The 4/3 is mipmapping overhead, which we turn on if available in the engine - and really it's almost always on, unless you're doing software rendering.
paint a couple identical images as part of this test to verify whether output dedupes or not.
That's what's happening here - as long as they're in adjacent frames, they're getting deduplicated. It's the same image painted twice here.

Are you saying you'd like to see deduplicating in a single frame?
should we use a `Set<ImageSizeInfo>` 
or 
`Map<ImageSizeInfo, Size>`
as we don't really care whether an image was rendered 10 times or 1 time.. We just care what the largest size it was rendered at was. I would expect the # of unique images should be significantly lower than the total # of issues for cases like using an image as a background texture uses multiple places in the UI. I don't have data though.
yes `if (kReleaseMode)` would be good. Can you point me at an example where we have other `debug` fields that are filled in profile mode? The ones I was aware of were all debug build only so I'm curious which ones have made it into profile builds.
yeah I was interested in a duplicate within a single frame as well as on the devtools size we don't care if the same image was rendered multiple times and we only care about knowing the largest size it was rendered at. there might be some edge cases where you have one image rendered in a bunch of places in a frame.
done
Ahh ok - I've reworked it so it will dedupe to the largest image in a frame, and added a test.
Can you add a sentence about this parameter to the doc comment above?
I updated the docstring in general here - there were some old no-longer-existant things in there and some formatting issues, as well as something that's changed about aspect ratio preservation.  PTAL
nit: This is getting hard to read.
Will these overlap? That is, would they ever need to go on the same event or command with different values?
The additional usage parameters should possibly be `Map<CustomDimentions, dynamic>` with a `toString()` before sending over to `package:usage`.

`FlutterCommand` (or elsewhere) could also have some getters for whether experiments are enabled maybe? Other suggestions?
No these don't ever overlap, using the same value SGTM
Added a private List<String> enabledExperiments and simplified the check. Updated to use Object and convert to String in the same place that the enums are converted
nit: use double quotes so you don't have to escape the `'` (I thought it was a lint rule?)
Switch painter in what way?
That's barely over 1 frame. Is that long enough? It looks like it will be jumping between the 4 corners way too quickly, no?
Doesn't Web use a simpler painter (CSS?) for simple widgets, and canvas for more advanced ones? According to my test the performance only regresses when the box has a partial border.

This duration is actually only used for the `timeStamp` of the event. The actual events are dispatched as fast as possible. The idea is to test the execution time the hit testing function. 
Let's just inline all of these; once they aren't their own file I don't think we gain anything by separating them from the point where they are used.
do we want to exit after this?
The [`exec` command](https://www.computerhope.com/unix/bash/exec.htm) completely substitutes the given command for the current process, so there's no need to exit (it already has exited by invoking the other script).
Also, the final return value is the return value of the other script.
cool
I guess that means we should never reach the other switch cases on MINGW anyway?
What other switch cases?  I mean, no, it'll never even reach the "fi" because it execs the other process immediately.
Not sure if BuildIosFrameworks makes sense here
out-of-order has hyphens as an adjective.

What does "out of order" mean exactly?
Probably spiritually the same as `BuildAarCommand`, right?
Ahh yes, but it would need to be updated to support using BuildInfo the same way that BuildAar does.
Rephrased
Oh right.  I got that work confused with the assemble work.
See https://github.com/flutter/flutter/pull/59874
can you revert the formatting?
the indentations are off
I think the indentation has been changed here, probably due to the use of an autoformatter.  Could you change it back to match the original?
The indentation should align with `assert(child != null),`
Check this indentation too.
Have we already discussed the capitalization of AutoValidateMode vs. autovalidate?  It seems contradictory.
Should we also be deprecating `autovalidate`?  Or planning to deprecate it in the future?  If so, could we assert that autovalidate and autoValidateMode are not used together? As it is, removing autovalidate in the future may be a breaking change even for people that are using autoValidateMode.

Sorry if this was already discussed somewhere in the old PR and I missed it.
```suggestion
/// Used to configure the auto validation of [TextFormField] and [Form] widgets.
```
+1, you can do that by not giving a default value to them in constructor but initialize it in the initialization list. We do want to deprecate the autovalidate, but it is causing a third party test failure (they have a more strict linting rule). Thus we have to do a soft transition...
Actualy no. I would suggest `autovalidateMode`.
I was missing this point, thanks.
@chunhtai do you have any suggestion on this?
I am not sure what the question is. What is the contradictory here?
I'm talking about the capitalization: autovalidateMode vs autoValidateMode
I vote for autoValidateMode. The autovalidate we used before seems like a typo to me. We might as well fix it now if we are going to introduce a new property.
Make sense.
Sorry, to be specific, I think we just choose only one of the following for our capitalization to be consistent:

1. `AutoValidateMode autoValidateMode;`

or

2. `AutovalidateMode autovalidateMode;`

But we should not mix/match between these two options.  The original parameter is `autovalidate`, which seems to align with option 2.
```suggestion
         autovalidate == true && autoValidateMode == null ||
         autovalidate == false && autoValidateMode != null,
         'autovalidate and autovalidateMode should not be used together.'
```
```suggestion
         autoValidateMode: autovalidate
             ? AutoValidateMode.always
             : (autoValidateMode ?? AutoValidateMode.disabled),
```
Are the order of operations going to work out correctly there without any parenthesis?
We seem to be the only framework that uses autovalidate while all other uses autoValidate. That makes me wonder if this is a typo or not.
Is it possible for autovalidate to be null at this point?
```suggestion
         autovalidate == true && autoValidateMode == null ||
         autovalidate == false && autoValidateMode != null,
         'autovalidate and autovalidateMode should not be used together.'
```
```suggestion
       assert(
         (maxLines == null) || (minLines == null) || (maxLines >= minLines),
         "minLines can't be greater than maxLines",
```
```suggestion
       assert(
         !expands || (maxLines == null && minLines == null),
         'minLines and maxLines must be null when expands is true.',
```
As @chunhtai said this seems a typo and since we are about to deprecate `autovalidate` parameter I think it is time to make things right.
Thanks, I think this indentation is weird on master.  Looks better now.
```suggestion
       autoValidateMode: autovalidate
           ? AutoValidateMode.always
           : (autoValidateMode ?? AutoValidateMode.disabled),
```
```suggestion
       assert(
         autovalidate == false && autoValidateMode == null ||
         autovalidate == true && autoValidateMode == null ||
         autovalidate == false && autoValidateMode != null,
         'autovalidate and autovalidateMode should not be used together.'
       ),
```
```suggestion
       autoValidateMode = autovalidate
           ? AutoValidateMode.always
           : (autoValidateMode ?? AutoValidateMode.disabled),
```
```suggestion
  /// If [AutoValidateMode.onUserInteraction], this form will only auto-validate
  /// after its content changes. If [AutoValidateMode.always], it will auto
  /// validate even without user interaction. If [AutoValidateMode.disabled],
  /// the auto validation will be disabled.
```
Could there be any performance concern with this? Do we ever have forms with many many fields?  @chunhtai 

This is probably ok, I just wanted to flag it.  I imagine it would be possible to check only the field that has changed here, but it might not be worth it.
```suggestion
       assert(
         autovalidate == false && autoValidateMode == null ||
         autovalidate == true && autoValidateMode == null ||
         autovalidate == false && autoValidateMode != null,
         'autovalidate and autovalidateMode should not be used together.'
```
```suggestion
       autoValidateMode = autovalidate
           ? AutoValidateMode.always
           : (autoValidateMode ?? AutoValidateMode.disabled),
```
I'm on board with that üëç 
Though, just above I see that we also have `autofill` and not `autoFill`...
autofill and autofocus seems like a validate word (by doing a google search). I can see people use it as a word, however, i couldn't find much usage of autovalidate as one word on the website. Maybe the word is more rare than autofill and autofocus, so people don't use it as much which make it not a word?
talked with @justinmc offline. We are both leaning toward using autovalidate now because all other auto- properties use lower case. It is not correct to defer the decision to the internet usages, because internet is known for its inconsistency, and that will make things complex. We should prefer a more unified API across the flutter app.
Great.So I will rename it to `autovalidateMode`. Is that right?
That's right, `autovalidateMode` and `AutovalidateMode`.
It does exactly this: it checks every element in the list and stops if it found that `_hasInteractedByUser ` is true or else keep checking until the last element.
One option would be to make the FormFields to update a property in the Form, this would prevent to iterate the whole list.
You mean `autoValidateMode`? yes, if `autovalidate` is false or true it will be null at this point.
Humm, I just noticed that we don't have any assertion that prevent `autovalidate` for being null.
Yes, I meant that `autovalidate` could be null.  @chunhtai Would it be ok to add an assertion that autovalidate is not null, or do we not want to potentially break users that are deliberately passing `null`?  It has a default value.  It seems like not asserting originally was a mistake.
> Yes, I meant that `autovalidate` could be null. @chunhtai Would it be ok to add an assertion that autovalidate is not null, or do we not want to potentially break users that are deliberately passing `null`? It has a default value. It seems like not asserting originally was a mistake.

Yes and TextFormField that also extends from FormField has a assertion fo this parameter. I already added the assertion for the DropdownButtonFormField widget.
I think adding assertion probably won't be a breaking change because i doubt that will break any test.
```suggestion
       assert(autovalidate != null),
       assert(
         autovalidate == false ||
         autovalidate == true && autovalidateMode == null,
         'autovalidate and autovalidateMode should not be used together.'
       ),
```
```suggestion
       assert(
         autovalidate == false ||
         autovalidate == true && autovalidateMode == null,
         'autovalidate and autovalidateMode should not be used together.'
       ),
```
```suggestion
       autovalidateMode: autovalidate
           ? AutovalidateMode.always
           : (autovalidateMode ?? AutovalidateMode.disabled),
```
```suggestion
       assert(autovalidate != null),
       assert(
         autovalidate == false ||
         autovalidate == true && autovalidateMode == null,
         'autovalidate and autovalidateMode should not be used together.'
       ),
```
```suggestion
       assert(autovalidate != null),
       assert(
         autovalidate == false ||
         autovalidate == true && autovalidateMode == null,
         'autovalidate and autovalidateMode should not be used together.'
       ),
```
I just realized that this comment is duplicated in a few different places in this PR.  Can you use a macro to avoid the duplication?  See https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/form.dart#L104 for an example of using a macro, and look for `@template` for an example of defining the template that the macro uses.
This might be a problem when there are a lot of fields, since it will be called on every key pressed.
What are the cases where _hasInteractedByUser gets set to false?  I guess when reset is called, but when else?  Maybe we could make an optimization like this:

```dart
if (!_hasInteractedByUser) {
  _hasInteractedByUser = _fields
        .any((FormFieldState<dynamic> field) => field._hasInteractedByUser);
}
```
Is this a example of creating a template? https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L1092

If yes is `flutter.widgets.subscriptions` the name of the macro or in this case it is just pointing into another macro?

Yes to both questions.  Sorry for being vague.  So something like this:

```dart
/// {@template flutter.widgets.form.autovalidateMode}
/// Your reusable docs from above
/// {@endtemplate}
```

Then reuse it in other places with this:

```dart
/// {@macro flutter.widgets.form.autovalidateMode}
```
Got it. Thank you
I'm wondering if this is the right macro name. I mean the main comment is placed inside the `FormField`widget so I thing the macro name would be: `flutter.widgets.form.formfield.autovalidateMode` or something similar. is that right? or in the macro name we just need to point the filename and the property name?

I'm interested to know more about macro. @justinmc do you have any resource to read about it?
I believe this is the actual docs for macros in dartdoc: https://pub.dev/packages/dartdoc#macros

As I understand it, the name is just a string to dartdoc.  Flutter has a convention of using a dot-separated hierarchy, but it doesn't matter to dartdoc.  I think you're probably right that `flutter.widgets.form.formfield.autovalidateMode` is a better name, but it should work either way.
The naming convention seems to not be mentioned in Flutter's style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo
The PR will be merged when the tree is green, but let me know if you want me to wait instead!
Thanks. That said I think I made all the changes. Let me know if there is something else to be done.
This may be nit picking, but what if the _hasInteractedByUser is set to true due to one field has change, and later on the field get reseted? I believe the form will still autovalidating in this case. This may be an ok behavior, but we should mention it in the documentation.
Good catch!
Wow, lets just revert this for now.
instead of keeping track of a bool, can we keep track the number of field that is dirty? when ever a field become dirty or not dirty, we update that number  +1 or -1. The auto validate in the form will just be number>0
Or could _fieldDidChange receive some extra information to make this easier?  Like maybe the field(s) that changed, or maybe a bool indicating if it was a reset or not.
> Or could _fieldDidChange receive some extra information to make this easier? Like maybe the field(s) that changed, or maybe a bool indicating if it was a reset or not.

I like the _fieldDidChange receiving extra information approach because with this will be easy to extend this feature with validating only the field that has changed in the future (I mean if necessary).

Edit:
And here https://github.com/flutter/flutter/blob/620eb27fb80309c7f8cf88f9d90e80cf79f69f50/packages/flutter/lib/src/widgets/form.dart#L225-L230 ~~we will not need to update the boolean property we will just need to check if _fieldDidChange parameter is null means that no form field has changed (the information of the changed form field will be null in this case).~~

Since all the form fields have changed We will just  set _hasInteractedByUser to false and don't provine any FormFieldState into _fieldDidChange().
I also would like to point out the following scenario if form has two textformfields, t1 and t2, and the form has autovalidate.onUserInteraction.

If user type in something in t1, the entire form starts to autovalidate. What should happen when the user reset the t1? should we still autovalidate the whole form, or should we stop autovalidate?
I feel like it would be nice if we stopped autovalidating in that case...

If we do that, we'd need some more logic here. Like when _hasInteractedByUser is true and changedFieldState._hasInteractedByUser is false, then we do the whole check of all fields like we were doing previously.

I wonder what everyone else thinks, though.
One way to implement that is by keeping track of number of dirty field as i mentioned in previous thread. I actually ok with either scenarios, just need to make sure we document that.
> I also would like to point out the following scenario if form has two textformfields, t1 and t2, and the form has autovalidate.onUserInteraction.
> 
> If user type in something in t1, the entire form starts to autovalidate. What should happen when the user reset the t1? should we still autovalidate the whole form, or should we stop autovalidate?

nothing will happen witht he Form and t1 will behave as if the user just entered in the form page.
I don't any problem with this approach right now, since we all agree that when a form field changes we auto validate the whole Form widget.

> nothing will happen witht he Form and t1 will behave as if the user just entered in the form page.

Do you mean the form will not autovalidate after the t1 is reset? The current code does the opposite.
> > nothing will happen witht he Form and t1 will behave as if the user just entered in the form page.
> 
> Do you mean the form will not autovalidate after the t1 is reset? The current code does the opposite.

I mean it will auto validate after one of the form fields change again.
Is this an issue?
> I mean it will auto validate after one of the form fields change again.

The current code will keep validating even if the dirty field gets reset
Maybe I don't understand you right. My thougts is that if a form field call reset() isn't normal to validate it again if its content changes?
That is different scenario. Touching a field that was reset before should start autovalidate. That is correct and our code does that.

The scenario i talked about was if a form started autovalidate due to one form field is dirty. What should happen if that dirty form field is reset? Our current code will make form still validating in this case.
What do you mean by dirty state?

Please let me try to reproduce this issue, I might have a feedback tomorrow.
for dirty, i meant user has typed in something.
@chunhtai I think I get what is the problem. So what we need to do is to prevent the form to autovalidate a field that was reseted?
Yes.
~@chunhtai can you please take a look a t this gist:~
https://gist.github.com/pedromassango/edb4b3d2fdef8524e7a2e6f1d664aee7

~I created it to try to reproduce the problem. Can you check if the code there reproduces the issue?~

Edit: I reproduced with the above Gist by: type something in the first field then reset the first field and then type something in the third field. I noticed that the first form (that was reseted) was also validated.
I think the problem is that when you type in something in the first field and reset the first field, at this moment nothing should be dirty and all fields should be cleared. the fact that only the first field is not validate is weird. Also if you rebuild the entire form the first field starts to validate again.

You can try this gist https://gist.github.com/chunhtai/09cace012092ace597cb8efb0189c96b
type in something in first field, click reset form field and then click rebuild form.
> at this moment nothing should be dirty and all fields should be cleared.

I think this is not true because we only reset the first field not all the fields. If I reset one field I expect only that one to be reset not all the others.
> You can try this gist https://gist.github.com/chunhtai/09cace012092ace597cb8efb0189c96b
> type in something in first field, click reset form field and then click rebuild form.

I solved this issue by notifying the Form widget when a field call reset. I'm wondering if this is a valid fix. Anyway I will push the changes so that you can test using your Gist: 

Type in something in first field, click reset form field and then click rebuild form. Then, expect the first form field to not being validated.

Edit: Also let me know if this is a valid fix so I can write a test case for it.
what if both field 1 and field2 have been touched by user and field1 is reseted? The correct behavior is the entire form should still validate because field2 is still dirty. but this pr makes it not validate in this case.

>I think this is not true because we only reset the first field not all the fields. If I reset one field I expect only that one to be reset not all the others.

but all other fields have not been touched by the user. That means all fields are clean. Why do we still validating the form in this case?
@chunhtai this make sense. I created a method to auto validate only the fields that was chaged. So it currently ony validate the changed fields. Does this is a good solution? Or we must validate all the fields once one changes?
Or maybe we can have one more options in the `AutovalidateMode` class:
- `onUserInteraction` - ... in the Form widget this validate fields that has change.
- `validateAllOnUserInteraction` - Used in Form widget to validate all fields in the Form if one of them changes
I prefer not to introduce a different mode for this since validateAllOnUserInteraction only make sense for form, we need to deal with the case developer use this mode for field.autovalidatemode.

The `AutovalidateMode.onUserInteraction ` should validate all fields in the Form if one of them changes

If the developer wants the behavior where the Form widget only validate fields that has change. they should just set the autovalidateMode on all the individual fields.
> If the developer wants the behavior where the Form widget only validate fields that has change. they should just set the autovalidateMode on all the individual fields.


I clearly understand you. But I think that we need to consider that some developers see the Form widget as a way to validate automatically a group of fields, and by your sentence we are about to ignore this and maybe making the Form widget useless.

That is possible, but we can always add that back if people really want a separate mode(even if they can still achieve it with a bit more code).

We can also document the behavior in the form widget and say if you want to only validate the changed field, you should set the autovalidate on each field. I feel we should not make it available now until there are strong enough demands considering it may potentially makes the api confusing (Why there is a AutovalidateMode that can only be used in form widget but not formfield widget?).

Would like to also hear about what @justinmc think.
Here's how I see it:

  * Typing in any field within the form should set _hasInteractedByUser to true for both the form and the field that was typed into, but not other fields in the form.
  * Resetting the form should set _hasInteractedByUser to false for the form and for every field.
  * Resetting a field in the form should set _hasInteractedByUser to false for the field only, and if the result is that all fields in the form now have _hasInteractedByUser set to false, then the form should also set its _hasInteractedByUser to false.

Given this information, for the case that a Form is set to AutovalidateMode.onUserInteraction:

  * The entire form should be validating whenever _hasInteractedByUser is true for the form.
  * Therefore, when a form is validating, it's possible to stop it from validating by either resetting the entire form, or by individually resetting each field that has _hasInteractedByUser true.

### How to implement this behavior, the easy way with poor performance
The only reason that this behavior is complicated is because we are storing duplicate state.  The Form's _hasInteractedByUser is derived from the _hasInteractedByUser of all its children and could be written like this:

```dart
get bool _hasInteractedByUser = _fields.any((FormFieldState<dynamic> field) => field.hasInteractedByUser);
```

I know that I'm the one that flagged this as having poor performance, but what if we did this every build instead of every onChange? See my changes to this PR here: https://github.com/justinmc/flutter/commit/ef9c7bc9d9ca0efbcdd9ca8f6095b584867a3a13

If not, I'm starting to think that maybe we can just accept the performance hit and write a new issue to improve this later.  It's certainly possible to optimize this, but we could do it separate from this PR.  Most important is to get the behavior right first.
I definitelly agree with all that you said. I think this is the way to go then.
@chunhtai brought it to my attention that the build method will be called even more frequently than onChanged in my commit that I linked above üòû. Maybe we should just go back to saving _hasInteractedByUser as a bool that's calculated in _fieldDidChange.  Then open up another issues to revisit performance later.
Do I need to do anything else?

Cc: @chunhtai 
I think this is last thing required to merge this pr
@chunhtai I reverted some changes. Please let me know if there is something else to be done.
we may need this here
```dart
Form.of(context)?._fieldDidChange();
```
I removed it because it wan't there before.

Since it is not required for this feature I though that it is better to remove it for now and add in the next PR when making performance improvements.
This not a performance improvement but a corner case i just discovered. A field reset need to notify the form to recalculate its _hasInteractedByUser and rebuild. otherwise,  the form will keep validating all its fields.
Done
Do we expect 99% of people to care? If not, I don't think we need to make this configurable in the template; title and initial size were only done because it was so common for people to want to set them. In general, if someone wants to configure the template, the right way to do it is for them to just change the code once it's generated.

(In fact, we should remove window_configuration.cc at this point, and fold it into the files that set it, since we aren't expecting any more nuke-the-whole-folder breaking changes.)
I would say most people don't care, and the ones that do will just modify the generated code. So I'll happily remove the boolean.
@GaryQian I wonder why do we need _textPainter.inlinePlaceholderScales? aren't they always the same as textScaleFactor?
I believe that in actual use cases, it is indeed true, but it is also possible (at lower levels) to independently set them. This may or may not be necessary at this level, I can look into it to see if it is safe to remove.
The scales are added into the list through WidgetSpan.build() which gets its value from the textScaleFactor. I couldn't find a possible way to have a different textscalefactor.
Can we add logging, or metrics for this?
if that string is not a valid path, `Uri.file()` will throw. I'm thinking we should catch that, especially since we're re-constructing the absolute path.
For those of us on Macs, can you also ignore [`.DS_Store`](https://en.wikipedia.org/wiki/.DS_Store)?
```
00:03 +0 -1: Check template manifest is up to date [E]                                                                                                                              
  Expected: empty
    Actual: Set:[
              Uri:templates/.DS_Store,
              Uri:templates/app/ios-swift.tmpl/.DS_Store,
              Uri:templates/module/ios/library/.DS_Store
            ]
```
Noooo
I always forget about .DS_Store
oh wait, nvm. i see the manifest is checked in.
```suggestion
  /// the button is focused, hovered, or pressed.
```
Does it make sense for these MaterialStateProperty lerp classes to be their own public API? Perhaps down the line
Should this be read from the themeData.splashFactory instead?
```suggestion
/// [ThemeData.containedButtonTheme] property.
```
```suggestion
///  * [OutlinedButton], a [TextButton] with a border outline.
```
Delete new line here
```suggestion
  /// [OutlinedButton], one could write:
```
I think OutlinedButton padding should follow ContainedButtons (16 not 8)
I think OutlinedButton padding should follow ContainedButtons (16 not 8)
Why not use `Colors.black` here
Why not use `Colors.black` here
This should use the same padding as OutlinedButtons with Icons, (12 leading and 16 trailing)
```suggestion
  /// [ThemeData.outlinedButtonTheme] is used.
```
I believe for TextButtons with Icons, this padding is incorrect. I think it should be 8 leading/trailing
Duplicated from above with only materialTapTargetSize changed, could be extracted into an inner function?
I didn't see a corresponding test like this in contained button tests
Should there be a test for all 3 buttons that confirms the behavior of:

```
foo.style ?? theme.style ?? defaultStyle
```
Same comment as ContainedButton's test, could put this into an inner function to avoid duplicating
It might, we'll have to see if the pattern crops up again.
Yes. We're going to need to provide a way for developers to simply configure a theme based on a ColorScheme that uses the 2018 text styles and the InkRipple splashFactory. 
You're right, will fix that.
Good point, done.
Yes, done.
Added one.
'container' may be confused with the `Container` widget? Perhaps 'A simple set of visual properties that most buttons have in common.'? Or maybe 'group' instead of 'set'? Not a huge deal one way or the other.
Nice examples here.
While it is typically used instead of the textStyle color, when is it not? Might be good to specify when it is and isn't (unless it is more confusing to explain than use :smile:).
Is this necessary with the `other is ButtonStyle` check below?
Nice, succinct description!
`ThemeData.textTheme` and `ThemeData.colorScheme`.
So is the difference between `defaultStyleOf` and `themeStyleOf` that `defaultStyleOf` provides the default style for a given subclass, where the `themeStyleOf` can override the defaults for a given instance of the class?
Nit: might want to break up to multiple lines for readability.
Is the reason for having this class not just be a `ButtonStyle` is because we would want to a place for future parameters that are not part of the style but are specific to the `OutlinedButton`?
```dart
      mouseCursor: t < 0.5 ? a.mouseCursor : b.mouseCursor,
```

Should we make a function for this pattern?
Is there any case where `textScaleFactor` can be 0?
Should it be ```` /// ``` ```` (with a space)? (Same for a few other occurrences in this PR)

https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/foundation/diagnostics.dart#L410
`themeStyle` is omitted. Is this because `defaultStyle` uses the same `visualDensity` and `tapTargetSize` as `themeStyle`?
https://github.com/flutter/flutter/pull/59702/files#diff-d5a6a7e71470fb01469989a4553e89adR250

Could `themeStyle.visualDensity` and `defaultStyle.visualDensity` diverge in the future? If they might, it make sense to use `widgetStyle?.visualDensity ?? themeStyle?.visualDensity ?? defaultStyle.visualDensity` here, so that later we don't forget it.
I think the following form is clearer (same for the other two `final double gap`s):

```dart
    final double gap = lerpDouble(8, 4, (scale - 1).clamp(0, 1));
```
We also need to test copying with / merging two different `ButtonStyle`s.
I understand that it's necessary.

In the long term, I think it makes sense to introduce, say, a `Lerpable` mixin, so that we don't have to write duplicate code. Such a mixin can also handle `null` on its own.

What do you think?
The "widget ?? theme ?? default" pattern shows up a bit often (see below), so you can use the following form to reduce some duplicate code:

```dart
    T effectiveValue<T>(T Function(ButtonStyle style) getProperty) {
      final T widgetValue  = getProperty(widgetStyle);
      final T themeValue   = getProperty(themeStyle);
      final T defaultValue = getProperty(defaultStyle);
      return widgetValue ?? themeValue ?? defaultValue;
    }

    T resolve<T>(MaterialStateProperty<T> Function(ButtonStyle style) getProperty) {
      final T resolvedValue = effectiveValue(
        (ButtonStyle style) => getProperty(style)?.resolve(_states),
      );
      assert (resolvedValue != null);
      return resolvedValue;
    }
```

There is a slight difference, though: in your original version, we assert `getProperty(defaultStyle)` is non-null, but the final result could still be null (if `defaultValue` is a non-null object that always resolves to null). Here, we assert that the final value returned is non-null.
You can still edit this code to suit the requirements.
Using the suggestion above, this becomes:
```dart
        return effectiveValue((ButtonStyle style) => style?.overlayColor?.resolve(states));
```
Using the suggestion above, this becomes:
```dart
        final VisualDensity resolvedVisualDensity = effectiveValue((ButtonStyle style) => style?.visualDensity);
        final MaterialTapTargetSize resolvedTapTargetSize = effectiveValue((ButtonStyle style) => style?.tapTargetSize);
```
Also, there's an extra space on L246 but the three `=`'s are not aligned.

Done.
Done
Done
Done
Done
You're right, and that's what the spec says:

![Screen Shot 2020-06-26 at 11 04 20 AM](https://user-images.githubusercontent.com/1377460/85887505-cd938600-b79c-11ea-9ad3-44d4e9b1efc6.png)
Done.
Done.
Done.
Done.
I changed it to "visual properties that most buttons have in common"
Done
Yes
Done
That's a possibility, but the real reason was just to conform to the naming conventions for component themes and their configuration data classes.
I qualified a bunch of the API doc in this class with "typically" because it's up to the subclasses and even though the subclasses I've defined are typical, there's no reason to assume that all subclasses will be.
I think the two tests mean something slightly different. This test proves that `this` and `other` have the exact same type.  The `other is ButtonStyle` is weaker, since other could be a ButtonStyle subclass.
Do you think something along these lines could work to save a few lines of code?

```dart
class _LerpProperties<T> implements MaterialStateProperty<T> {
  const _LerpProperties(this.a, this.b, this.t, this.lerpFunction);

  final MaterialStateProperty<T> a;
  final MaterialStateProperty<T> b;
  final double t;
  final T Function(T, T, double) lerpFunction;

  @override
  T resolve(Set<MaterialState> states) {
    final T resolvedA = a?.resolve(states);
    final T resolvedB = b?.resolve(states);
    return lerpFunction(resolvedA, resolvedB, t);
  }
}
```

Then the calls could look like:

```dart
static MaterialStateProperty<TextStyle> _lerpTextStyles(MaterialStateProperty<TextStyle> a, 
  MaterialStateProperty<TextStyle> b, double t) {
    if (a == null && b == null)
      return null;
    return _LerpProperties<TextStyle>(a, b, t, TextStyle.lerp);
  }

```
And actually, if that _did_ work, then you would be able to condense some of the methods above.

Something like:

```dart
  static MaterialStateProperty<T> _lerpProperties(MaterialStateProperty<T> a, MaterialStateProperty<T> b, double t, T Function(T, T, double) lerpFunction ) {
    if (a == null && b == null)
      return null;
    return _LerpProperties<T>(a, b, t, lerpFunction);
  }
```

And above you would do something like:

```dart
 return ButtonStyle(
      textStyle: _lerpProperties<TextStyle>(a?.textStyle, b?.textStyle, t, TextStyle.lerp),
```
These two constructors end up being very similar. Do you think it would be reasonable to consider combining `ContainedButton` and `ContainedButton.icon` into one constructor? The constructor could have an optional (nullable) `icon` param, that, when non null, will place itself alongside `child`? 
nit: double space here and the one below

```suggestion
class _ContainedButtonDefaultBackground extends MaterialStateProperty<Color> with Diagnosticable {
```
I agree, in fact I'd written it that way. I changed it because the analyzer complained and I wasn't able to find a nice way around the complaint:

```
  error ‚Ä¢ The argument type 'num' can't be assigned to the parameter type 'double' ‚Ä¢
         packages/flutter/lib/src/material/contained_button.dart:419:41 ‚Ä¢ argument_type_not_assignable
```

I believe it's complaining because clamp returns a num, not a double. Introducing another line of code didn't seem to make the statement simpler either, so ... 
It's true that it's very common, however I'm not sure a function call would make it easier to read. If we were going to use a function for this kind of lerp statement, we'd have to apply it across the whole framework. That would be a different PR.
Good question. The documentation doesn't specify any limits: https://api.flutter.dev/flutter/widgets/MediaQueryData/textScaleFactor.html

The code handles all possible values, so there's no need to assert that its `>= 0` here.
Yes, good point.
Good catch! That was a mistake. It also implies that I need more tests.
Done
I've updated the code per MH's suggestion, https://github.com/flutter/flutter/pull/59702#discussion_r446395569

It's not a mixin, but it does eliminate much of the boilerplate.
Both suggestions are nice boilerplate reducers, I've incorporated them.
FWIW, the Foo and Foo.icon constructors are how this was factored before. We're not trying for API compatibility here, so there's no need to include the factory again. On the other hand, Foo and Foo.icon have different defaultStyleOf overrides because their default padding is different and because the padding's dependency on textScaleFactor differs. This and the difference in how the child is handled could certainly be blended together into one build method, but separating the two cases with a class (albeit a private one) simplifies that a little.
I added a few additional copyWith/merge checks.
This is a nice way to factor the code, I've used it. The new version is even more closure-intense than the old one, hopefully the compiler will see how all of that can be flattened out.
I've added basic tests for all three new themes. 
@HansMuller What about let the user provide the minimum width/height as in the old buttons. I know we can always wrap it in a SizedBox but I think it would be great to have that option.
Also, this can avoid one more wiget in the tree :)
Specifying a minimum size is still supported: the `resolvedMinimumSize` you're referring to is based on the button style's minimumSize: https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/material/button_style.dart#L160


I meant the Widgets that depend on this one does not have a way to provide a custom size like the `ContainedButton` and `OutlinedButton` they does not have a `height` or minWidth property for example, just like the old buttons.
It's true that the new buttons don't have explicit width or height parameters. However one can specify the minimum size for an individual button:

```dart
TextButton(
  style: TextButton.styleFrom(
    minimumSize: Size(100, 100),
  ),
  child: Text('I am at least 100x100')
)
```
For a fixed size button, you're right that it would be necessary to use a SizedBox:
```
TextButton(
  child: SizedBox(
   width: 100,
   height: 100,
   child: Text('I am 100x100'),
  ),
)
```
Size is now parte of the button style?
Is the last piece of code valid? I mean you set the size for the child instead of the whole button widget.

I need to try this :)
I think we can take advantage of the possibility of passing the widget size on its parent widget to allow users to customize the widget without the need for another widget.
The `minimumSize` is part of ButtonStyle (it was part of the ButtonTheme too, see https://api.flutter.dev/flutter/material/ButtonThemeData/constraints.html).

The second example produces a fixed size button, although it's not exactly 100x100 because padding.
Sounds right. Thank you.
I'm not sure how this line could be reached because the spawned function will either return something or throw. The `dart:isolate` doc doesn't say too much about when and how onExit is used and interact with other ports.
This change broke a `compute` function for us, which returned null, starting in Flutter 1.20.x. I assume this is resolved by enabling the nnbd feature and returning an optional via compute?

Do you have nullsafety enabled on your project?
@a14n no.
This should be fixed by #63515
nit:
```suggestion
  testWidgets('ExpansionPanelList respects dividerColor', (WidgetTester tester) async {
```
nit:
```suggestion
  testWidgets('ExpansionPanelList.radio respects DividerColor', (WidgetTester tester) async {
```
nit: trailing comma
```suggestion
      ),
```
nit: slightly more description
```suggestion
    // For the last DecoratedBox, we will have a Border.top with the provided dividerColor.
```
nit: slightly more description
```suggestion
    // For the last DecoratedBox, we will have a Border.top with the provided dividerColor.
```
You missed updating the rest of the numbered list :)
Fixed, accidentally removed point 2
:+1: 
Thank you for updating this!
The `0.135` coefficient is actually accurate.  You can verify this in a native `UIScrollView` (or `UITableView`) by adding the following code to its delegate and flinging the scroll view:

```swift
func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
  let actualTargetVerticalOffset = targetContentOffset.pointee.y
  let computedVerticalOffset = scrollView.contentOffset.y - (velocity.y - 0.01)/(log(scrollView.decelerationRate.rawValue))
  print("actual target vertical offset: \(actualTargetVerticalOffset), computed from velocity: \(computedVerticalOffset)")
}
```
The computed value is going to be very close to the actual content offset (but not exactly the same, I guess there's rounding/flooring happening in the actual implementation, so the final value snaps to physical pixels).

The default `scrollView.decelerationRate` value is 0.998 ([`.normal`](https://developer.apple.com/documentation/uikit/uiscrollview/decelerationrate/1619415-normal)), but the velocity is in a different unit here in `scrollViewWillEndDragging` (pixel per millisecond I guess), thus the 0.135 (0.998^1000).
The velocity we use to create the ballistic activity is responsible for the most content offset error here.
Is there a better place to export this?
This seems like the best option in lib/*.dart
Could combine these if statements

```suggestion
      if (focused && _focusedDay == null) {
```
Should the whole grid be colored for focus vs just applying the color to the focused day?
What is the reason for moving this into the PageView?
Could `oldWidget` not be strongly typed to `_FocusedDate` like I've seen in other InheritedWidgets? Then you wouldn't need to check the type
I believe we should always call super first (Except for `dispose`)
Call super first
Perhaps an RTL test would be useful?
Not sure, but it was how the original Android date picker handled this. As the navigation in the grid is a little different (you only use the tab to go in and out of the grid), it seems like a good way to indicate that.
I wanted the headers to scroll with the days, so you could keep their context while they were scrolling. Looking at the spec, they have the headers moving with the dates as well (in addition they also have the nav controls scrolling, which seemed wrong to me).
Yup. Good catch. Thx.
Indeed it would. Added.
Gotcha, sounds good
Looks like you are right about the spec, but yeah I agree that the nav controls shouldn't scroll
ues => use
When would both `date != oldWidget.date` and `utils.isSameDay(date, oldWIdge.date)` both be true?
` { TextDirection textDirection = TextDirection.ltr },`
It is `!utils.isSameDay(date, oldWidget.date)`. It should return true if the date is different than oldWidget.date. This is a convoluted way of saying that though, so I moved some null checking into the `isSameDay` code to simplify this to just:

```dart
return !utils.isSameDay(date, oldWidget.date);
```
@goderbauer thoughts on this API change? It seems likely to be non-breaking. I could instead create a mocked window ... but this seemed more straightforward
Instead of adding the extra slightly awkward one-off API, could you just do the following in `app.dart`?

```dart
MediaQueryData data = MediaQueryData.fromWindow(WidgetsBinding.instance.window);
if (!kReleaseMode) {
  data = data.copyWith(platformBrightness: debugBrightnessOverride);
}
```
How do you use it "through the [BindingBase]"?

As implemented, it appears to be a debug setting in the widget layer, determining what brightness the MediaQuery of WidgetApp inserts into the tree, no?
I guess it isn't really true - maybe "Used by MediaQuery to override the platform brightness?"
Sounds better, we should probably move it to widgets/debug.dart then since its more a debug setting of that layer?
Ahh, I missed the existing `copyWith` method - that seems more straightforward
I wasn't sure, the window is exposed through BindingBase which is where the Brightness comes from. If one was hypothetically depending only on foundation, it would not be usable if the brightness was in the widget layer
Ah, that's fair. If we add some more documentation to this property here I am OK with leaving it where it as.
nitty nit: missing a `.`
Maybe just say "See also:" since that's our style. You could incorporate this half-sentence into the explanation after the `[WidgetsApp], which` below.
Is this just no longer a thing - or why remove it?
its not a thing
Can dark be tested?
I didn't know what "[brightness](https://api.flutter.dev/flutter/dart-ui/Brightness-class.html)" meant, maybe 'Toggle the platform brightness (dark and light mode).'?
Good idea, fixed
I can't actually change the value in this test or I'll trigger reassemble and break the test framework. I will update the integration test
the integration test now confirms both brightness settings and that a bogus value does not change anything
Can you add a comment that this is purposely bogus?  It looks like a bug in the test.
Done
Done
nitty nit: just leave the `.toString()` on this line? Looks so lonely on the next.
maybe add that it only uses it in debug mode.
Gave it some friends
Done
Are the changes in this file related to deferred loading?
Yes. It was quite hard to pin this down. If you look at the description of the PR you can see the full details.

The TLDR is that this change is needed as the `Localizations` widget rebuilds itself after localizations have loaded. This change ensure that all of the printing widgets in the test will wait for all localizations to load first.
nit: adjust this to our style for constants?
nit for all the docs: In Flutter, if the doc is referring to a parameter of the method it should be enclosed in ` instead of []
We control the SDK version for Flutter, which error is it for us?
nit: put this on one line or use a trailing comma to have each parameter on a separate line.
Same comment about arguments and the CastError as above.
nit: add trailing comma and put `) {` on next line?
nit: keep this on one line or one line per argument
one line or one line per argument
nit: the multi-line argument lists in this file or not following flutter style.
nit: style
Done.
That's an interesting question.  When I tried, this, it gave me:

```
The following _CastError was thrown building Home(dirty):
type 'Foo' is not a subtype of type 'Comparable<dynamic>' in type cast
```

The interesting thing is that `CastError` is deprecated in the SDK version we're using, with the reason "Use TypeError instead".

So, it seems that the SDK is throwing a private, deprecated error?

The definition of `_CastError` is:

```dart
class _CastError extends Error implements CastError, TypeError { /* ... */ }
```

So... I'm not sure what the right answer is.  I think I'd rather it be `TypeError`, but that's not what the user will see, at least for now.
Done.
Done.  And I did it elsewhere as well.
Done.
Done.
Done.
As above... It's complicated.
I'm not sure why the SDK's not sending a `_TypeError`, as that is defined similarly:

```dart
class _TypeError extends Error implements TypeError, CastError { /* ... */ }
```
Fixed.
Done.
I guess we can leave the docs as-is then until its cleaned up in the SDK.
If `CastError` implements `TypeError`, then it is a `TypeError` - the comment is not necessary
Well, sure, but that's not what it prints when the error is shown.  It prints `_CastError`.
Oh, right. A _CastError is a TypeError, so we should just mention the TypeError in the doc.
But you can't use _CastError in your code anyways. I'd assume if you read the doc you are wondering what error type you're supposed to catch in a try-catch - and that would be a TypeError, no?
It would.  That's why this is complicated.  Nowhere does the stack trace output say "TypeError", yet that is the type of the error that you need to catch.
I think I'd like to leave it as just saying `TypeError`, and remove the parenthetical about `CastError` since that one is deprecated, and point out that the output may say `_CastError`.
OK, I updated it to say that.  See what you think.
Does this really need to be a mixin, they're a bit more complicated in terms of visibility? You could instead create this as a base class that extends FlutterCommand, and then have Create and AddPackage inherit from that. 

"Command to " is redundant. See the existing flutter help text:

```
Available commands:
  analyze           Analyze the project's Dart code.
  assemble          Assemble and build flutter resources.
  attach            Attach to a running application.
  bash-completion   Output command line shell completion setup scripts.
  build             Flutter build commands.
  channel           List or switch flutter channels.
  clean             Delete the build/ and .dart_tool/ directories.
  config            Configure Flutter settings.
  create            Create a new Flutter project.
  devices           List all connected devices.
  doctor            Show information about the installed tooling.
  downgrade         Downgrade Flutter to the last active version for the current channel.
  drive             Runs Flutter Driver tests for the current project.
  emulators         List, launch and create emulators.
  format            Format one or more dart files.
  install           Install a Flutter app on an attached device.
  logs              Show log output for running Flutter apps.
  precache          Populates the Flutter tool's cache of binary artifacts.
  pub               Commands for managing Flutter packages.
  run               Run your Flutter app on an attached device.
  screenshot        Take a screenshot from a connected device.
  symbolize         Symbolize a stack trace from an AOT compiled flutter application.
  test              Run Flutter unit tests for the current project.
  upgrade           Upgrade your copy of Flutter.
  version           List or switch flutter versions.
```
The only ones that list commands are referring to subcommands.
There is already a hook for this: FlutterCommand.verifyThenRunCommand
Why are these false? Can you separate the refactor from changing the default behavior?
```suggestion
}

```
How much if this test is copy-pasted from the create_test? This is really difficult to review if there are non-trivial changes
I would expand this comment a bit for each kind of template. Talk about what it does/does not generate
project -> plugin?

> The project will not compile until you add platforms implementation.

This isn't quite true, it just isn't useful
Can you hoist this out into a constant so it is easier to read?
Rather than conditionally checking here, you _might_ be able to only add web, linux, macos, windows to the list itself if the experiment is enabled. Then you can do:

```
for (final String platform in platforms) {
  context[platform] = true;
}
```
I would recommend pulling this logic into a new class that is separate from the create command. in general the use of string processing here is concerning to me. The pubspec.yaml is already structured data, you should take advantage of that to add the platforms.
NVM, it was already there! my bad
Or remove this line?
done
updated, see if you like this.
Updated with a slightly different approach, please take a look and see if you like it.
nit, remove : ` please remove the argument and try again`
formatting
`platforms.join(',')` ?
clarify "respective folders"  - "platform folders (android/ ) ?
Maybe: Adding desktop platforms requires the corresponding desktop config setting to be enabled
hoist this into a const list at the top of the file
if no values are provided, this should give you an empty list, I think the wasParsed check is unecessary
please move to the top of the file
this is confusing, why do we need to only check projects if we're creating an example app
This is confusing, everything gets set to false by default, then everything get sets to true, then some are conditional set to false.
Assuming that someone is migrating an old plugin and trying to use add-platform, it would be nice to at least link to page explaining the formatting
missing a type check here, platforms could be anything
platformsToAdd.removeWhere(existingPlatforms.contains);
Does this rely on on having a fake platform key?
It seems like there are a lot of ways for this method to fail, and it requires a sentinel data in the form of the comment. Is there a way this process could be simplified by ignoring comments? Is add-platforms going to be usable if it requires a very specific structure?
done
done. Good call!
done
done
done
because I made the parameters defaults to all platforms. And for plugins, we only want to accept the `platforms` if it is passed explicitly by the user.
done
As a side effect, this method always generates the `GeneratedPluginRegstraint` files for iOS and Android unless the checkProject flag is true. When the plugin is not for mobile, this method still generate those files, including iOS and Android.
you are right, I deleted this method and updated the caller a bit. Please take a look see if it makes more sense.
done. We only need to show  this error if the `platforms` map is missing or not valid, other failing scenarios are just general invalid pubspec.
done
This logic doesn't. however it does remove the `some_platform`.
The reason that `some_platform` needs to be there is that we need to keep the pubspec.yaml valid. Otherwise, other steps of the `create` command would fail (pub get for example)

Another way is to perhaps not having the whole `flutter` map in the pubspec if there are no `--platforms` specified, then add the `flutter` map programmatically when `--platforms` is specified. 
one way to improve this is to ignore the lines that starts with a `#`

Other than that, I don't find a perfect solution to update this without breaking the existing yaml comments. Which I think we need to preserve because those are great instructions for new users. 
This seems pretty fragile, what if someone develops android/ios and then wants to use add-platform to add a new desktop or web implementation?
I would say ignore the comments and focus on the structured data.
"that supports no platforms is generated"?
Space between `generateModule` and `?` and `module` and `:`
Missing space: "Platform folders (android/)"
I didn't see an issue tracking this crash, surprisingly (it's not the same as https://github.com/flutter/flutter/issues/43734)
(ew.)
Can we move the parsing and validation in this method by using FlutterManifest?
```dart
final FlutterManifest manifest = FlutterManifest.createFromPath(pubspecPath, fileSystem: globals.fs, logger: globals.logger);
```
Then move `getPlatformsYamlMap` logic into `FlutterManifest` as something like this:
```dart
  List<Map<String, dynamic>> get supportedPlatforms {
    if (isPlugin) {
      final YamlMap plugin = _flutterDescriptor['plugin'] as YamlMap;
      if (plugin.containsKey('platforms')) {
        return platforms = plugin['platforms'] as YamlMap;
      }
    }
    return <String>[];
  }
```
And put any missing type logic (if any) into `_validateMultiPlatformYaml()`.

(bonus, then androidPackage can become:)
```dart
  String get androidPackage {
    if (isModule) {
      return _flutterDescriptor['module']['androidPackage'] as String;
    }
    if (supportedPlatforms.containsKey('android')) {
      return supportedPlatforms['android']['package'] as String;
    }
    return null;
  }
```
This should also work as the code is to look for the `platforms:` key and add an entry under it. i think I have a test covers this scenario: 'create a plugin with ios, then add macos'.
It only removes 'some_platform' map, which is an invalid platform. 
Did you mean to overwrite all the comments when updating pubspec.yaml?
Something like
`file.write(pubspecYamlMap.convertToString)`?
(I'm making up APIs here)

Or did you mean to skip comments like 
```
if (line.contains('#')) {
  continue;
}
```
makes sense
What if instead of trying to edit their pubspec and potentially corrupting it or changing their formatting or accidentally removing comments, we print out something like (assuming `--platforms=web,macos`):

```
In order to support web and macos, update your pubspec.yaml platforms map.
See https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin-platforms for details.

  plugin:
    platforms:
      android:
        package: com.example.hello (actually put the existing map we parsed for them)
        pluginClass: HelloPlugin (actually put the existing map we parsed for them)
      ios:
        pluginClass: HelloPlugin (actually put the existing map we parsed for them)
      macos:
        pluginClass: HelloPlugin (put the suggested pluginClass)
      web:
        pluginClass: HelloPlugin (put the suggested pluginClass)
        fileName: hello_web.dart (put the default fileName)
```
I think we need to wait until well after 1.20 is released to give the plugin consumers time to upgrade (not just the plugin author)
"You see this message because" is kind of clunky.
What about "This plugin project..."
Given the time constraints and the downside of getting this wrong, this seems like a reasonable compromise in the short term. We can always circle back later if the feedback is negative
done.
done
Do you guys think `pluginExampleApp` is confusing? I am thinking it might be better just to call it `checkProjects` or `checkProjectsWhileEnsuringTooling`
good point! done (with the androidPackage refactoring)
done 
pub is adding a check for non-iOS plugins to not able to publish if they don't set the min SDK constraint to 1.20.0 and they don't have iOS folders. This prevents the app authors from hitting the error if they haven't upgraded to 1.20.0
done
Sounds good, we can add the message for this release.
I still think that this pubspec surgery something good to have for better UX in the future. I haven't found a better solution than doing a line by line parsing and testing tho.
done
Are you OK if we just fix it in this PR? Or do you think a separate PR would be better?
`--platforms=android`?
I'm fine with fixing here, I'm just surprised I couldn't find a crash report of this.
I think the non specificity of "checkProjects" is what's throwing me off (I know you didn't name it).  Like, check what?  If that was a better name, `pluginExampleApp` might make sense.
"Legacy" is only a useful term until the new version gets deprecated and you need like "legacy 2".  Maybe "Pre-multi-platform plugin format"?
`iosPrefix` is deprecated?
done. The test probably didn't even check for specific plugin folder, thats why it passed?
They may not have a `platform` key if they generated in an older plugin format, right?
```
Add below lines to under the `platform:` key in the `plugins:` section of your `pubspec.yaml`
```
? Something like that?  I guess it doesn't matter so much because we gave them a link to more detailed instructions below.
Makes sense to me
By looking at the code of `ensureReadyForPlatformSpecificTooling`, I also not sure what that meant. @jonahwilliams  do you have any idea? Maybe we can add a TODO comment on that method to either fix the param name or add some doc/comments on the `checkProjects` param?
Makes sense! done!
yes. We don't need iosPrefix in the multi-platform format.
yeah, TODO for now. 
I think it makes sense to also give users a warning if they are using the old format, I updated the message for those users. PTAL.
2 space indent here
indentation of `'''` is weird.

```
const String _noPlatformsErrorMessage = '''
<< message text >>>
''';
```
find a detailed instruction -> find detailed instructions

add platforms in the -> add platforms to the
module or package
2 space indent
2 space indent
e.g. android/
_kAvailablePlatforms
_kNoPlatformsErrorMessage
The cast<String>() will throw if the pubspec is not formatted correctly, does createPlatformsYamlMap validate the structure?
2 space indent
```
return <String>[
  if (templateContext['ios'] == true)
    'ios',
   ...
]
```
Add a newline here
Import common.dart and not test_api
done
done
done
done
done
done
done
done
done
done
done
done
done
Yes, `createPlatformsYamlMap` creates a valid <String, dynamic> YamlMap based on a Map<String, dynamic>
done
done
in #59408 @Hixie deprecated this and introduced a newly named property. Is this potentially breaking?
It is not breaking according to our breaking change policy. I didn't have to modify any tests and g3 is also fine. Therefore, I opted to not do the depreciation.
SGTM!
nit: maybe use `switch` instead?
That seems simpler to me, will do üëç 
I think using `default` clause is discouraged.
I'm not sure I follow this comment. Which will it be constrained to, kToolbarHeight or toolbarHeight?
See snippet just below this (291-302). The comments here have removed references to kToolbarHeight, but it is still in the sample, can you update the snippet to reflect a custom value?
```suggestion
  /// Defines the height of the toolbar component of an [AppBar].
```
I didn't change it because it was covering the default `toolbarHeight` case, in case if the user doesn't provide any toolbarHeight. You are right, it may create some confusion, I'll change it.
I'll improve it in the next commit.
The period here is causing the web test to fail. 
```suggestion
      expect(error.toString(), contains('is not true'));
```
Thanks for pointing out, I have fixed it.
Awesome. Thanks!
nit line length
It would be OK to leave out "such as how to use them".
which defines cursors that are supported by most native platforms
This is just bike-shedding, but it feels like "enabledCursor" would be the natural name for this
More bike-shedding: maybe EnabledAndDisabledMouseCursor?
I guess textable is like clickable (but I don't think textable is a word).  Would it be OK to just call this "text"?
mouse pointer => the appearance of the mouse pointer
I agree with the concern, but "text" can confuse people with `SystemMouseCursors.text`. I'm aware that I'm fabricating words here and it's wrong grammar, but I wonder if we can just take it as a special nomenclature where "\<system cursor name\>+able" stands for the system cursor's might-be-disabled sibling.
That makes sense; I hadn't realized what the "able" suffix was really for.  
I wonder what your version means, because:
1. If it means some platforms do not support system mouse cursors, then they do not support mouse cursors. There hasn't been a platform that support mouse cursors that do not come with some system cursors.
2. If it means these cursors are only the most common ones, it's quite the opposite. `SystemMouseCursors` is meant to be a superset of all cursors from all platforms. Some of these cursors are only supported by 1 platform, we include them anyway, and they fall back to the basic cursor on other platforms.

And what does "native" platform mean, because all platforms are native.
stands => stand
I agree that native platform is redundant.

By "cursors supported by most platforms" I was implying that the superset of cursors we picked for SystemMouseCursors _mostly_ included cursors that were supported in multiple platforms. Otherwise developers could reasonably ask if we were really balancing portability with flexibility.
```suggestion
/// with the more generic advice regarding [Directionality].
```
ultra nit, and only if we're using American punctuation rules (personally, I think it's a dumb rule, but it is what it is):
```suggestion
///    AlignmentDirectional value." Should be a fully punctuated sentence.
```
The string here is a literal, not a quote, so I'm inclined to go with programming punctuation rather than usual prose punctuation.
nit: maybe mentioned what "handled" (or returning true) means, e.g. that the event will stop propagating and nobody else will see them?
Should we assert here that if the keyEventHandler was provided it returned true/false (and not null)? Assuming that returning null from keyEventHandler is illegal. 
If null is illegal, let's document that on RawKeyEventHandler as well.
maybe link to [addListener] as well from here and say how that's different then receiving the key events from here.
Done.
Done.
Done.
This is changing the behavior. Can we instead just assert that the values are in the right range as it is documented?
Nit: Please add new lines between each `test` to make it more readable
Nit: might be more readable if these were broken into more asserts (at least one per param?)
Why call this cancel instead of dismiss?
In what sense is this intent bound by default?
In the sense that the default shortcuts for `WidgetApp` have it mapped to the `escape` key. Is there a better wording I can use here?
I actually started with dismiss, but it seems like it could be more generic as a cancel/negative action/dismiss feature. It is fairly common in game interfaces to have the A button mapped to 'activate or select the focused thing', and the B button mapped to 'cancel/go back/dismiss'. That was my thinking, but if others feel strongly it should just be dismiss, I can put it  back.
Mentioning "default keyboard shortcuts in [WidgetsApp]" is actually good enough, although maybe [WidgetsApp.defaultShortcuts] would be better.
I don't have a strong opinion about it; just noticed that in most of your descriptions of this intent/action you used "dismiss".
I think dismiss is better.  Cancel and dismiss are slightly different things, and this is definitely a dismiss.  Cancel implies that the user specifically doesn't want something to happen, or wants to interrupt something in progress. Dismiss means that they just want to ignore something or to acknowledge that they saw something and put it away. Users can always create a separate cancel action for the other sense if they need it.
Sounds good. I just renamed them back to Dismiss*. Let me know what you think.
nit: empty line - Typically we use empty lines to separate logical procedures for better readability.
empty line removed
need to make this non-required for g3
Removing these APIs since they are unused, which simplifies null-safety migration
these tests now set the right version when the experiment is enabled but the library is not opted in
This regex looks like it's missing an initial escape `\` and has too many `\` in the middle, but it's obviously working?
`\/\/\s*@dart`

Also:
https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/feature-specification.md#individual-library-language-version-override
```
it would be possible to have a line containing just //@dart=2.3 inside a block comment. That will not count as a language version override marker.
```
Also need to check for block comments?  It would be unlikely someone would have a block comment containing it above the imports but hey that's the spec.
So 2.8 is pre-null safety?
Yes, I changed this back to pre-null safety since we can't actually run tests with sound null safety yet - the actual platform (dart:ui) isn' migrated yet.
Trim the whitespace before you check `startsWith`.
Maybe also check for `library` `part of`?
Can you do one with tabs instead of spaces?
Good catch!
@jmagman I went through so many iterations of the RegExp I considered lifting the actual parser from the SDK
Anyway, will check for block comments too
Could `_packageConfig` be `null` if `loadPackageConfigWithLogging` fails?
Done
No, it will throw a tool exit if `throwOnError` is true (which it is by default)
Missing the // prefix so i's not really detecting it's in a block `//@dart = 2.9`
Same, missing `//`
This still looks malformed with the unescaped initial `/`.  Check me @christopherfujino, shouldn't this be `\/\/\s*@dart`?  How is this working?
Fixed
Fixed
Yeah, I looked at earlier, and agreed both that it looks wrong and that I don't know how it works. Lemme dig a little deeper...
I agree it is completely bonkers. Confusingly the obvious regex pattern didn't work, and I haven't been able to figure out why
@jonahwilliams ah! it's because you didn't use a raw string!
(thank you vim dart syntax highlighting @natebosch)
```suggestion
final RegExp _languageVersion = RegExp(r'\/\/\s*@dart');
```
2020
The doc should be clear that the returned String _is_ a language version override comment.
2020
For reasons(?), all copyright comments, including for new files, retain the original copyright date.
ditto
Will this mess up hit testing on e.g. Android? I would expect that on Android whenever you try to touch anything in the alert to a11y focus it, you‚Äôll actually focus the modal barrier now...
nit: revert formatting change?
nit: remove this empty line?
Should this be `semanticsDismissible` instead of `barrierDismissible`?
Maybe add a comment here: `// To be sorted after the _ModalScope.`
Maybe add a comment here: `// To be sorted before the ModalBarrier`
Please add: "// Regression test for <issue link>."
Doesn't the barrier have a label and/or action we can use to identify it better? This could just be any stray semantics node...
nice catch, actually it should check both. the semanticsDismissible name is confusing, it means the semantics should include this modal barrier, barrierDismissible is the actual one whether the barrier is selectable. If the barrierDismissible = false and semanticsDismissible = true, the barrier is still excluded from the semantics tress.
Do we want to check the version of GTK here? If so this should be changed to `'gtk+-3.0 >= 3.22'` or similar. `pkg-config --exists gtk+-3.0 >= 3.22` or `pkg-config --exists gtk+3.0 --atleast-version=3.22` will return 1 if the version is not recent enough. You could use `--print-errors` to get error text or `--modversion if you want to do this yourself, i.e.

```
$ pkg-config --exists 'gtk+-3.0 >= 10' --print-errors
Requested 'gtk+-3.0 >= 10' but version of GTK+ is 3.24.18
```
```
$ pkg-config --modversion gtk+-3.0
3.24.18
```

I noticed we're not checking the version in the engine BUILD.gn - it should probably be done there too.
Again version information should be here.
Version information...
This is the only package I saw that seems to have jumped >1 major version, however 0.6.0 seems to have been very short lived (only [5 days](https://pub.dev/packages/webkit_inspection_protocol/versions))
Formatting seems a bit off here, perhaps it makes more sense to add the key to the `FlatButton` instead?

Same with the OK button
I'm not super familiar with keyboard mappings/shortcuts. Is this some boilerplate that is necessary?
Is there a reason for this `Material` widget when there is one below it?
This had to do with the key'd widget needing to be inside the InkWell that handled the activation. I have decided that this is not a great way to handle this and removed it from this PR. I have a better way to more generically handle dismissing modal routes with a 'escape' that I will talk with Greg about and put together another PR.
This was a way to have a key shortcut activate a specific widget. I was doing this so that using the 'escape' key would look like you had tapped on the Cancel button and 'enter' would look like you tapped on the Ok button. I have decided there is a better way to handle this in a generic way for dismissal, and the confirm shortcut is a bit problematic. I will rework these in follow on PRs.
Nope üòÑ . Nor is there a reason for the Row widget here either. Thanks for calling this out. I think this was some left over experimentation that shouldn't have made it in. Should be fixed now.
Also what do you mean by "names" here?
```suggestion
    help: 'Target device id (prefixes are allowed, names are not supported).\n'
```
nit: this doesn't really need to be commented
nit: I would early return to avoid the else

```
deviceId = _findMatchId(await discoverDevices(), deviceId);
if (deviceId != null) {
   _workingDevice = AndroidDevice(deviceId: deviceId);
    print('Choose device by ID: ' + _workingDevice.toString());
    return;
}
throw DeviceException(
  'Device with ID $deviceId is not found for operating system: '
  '$deviceOperatingSystem'
 );
```
Same here
and here
I would name this and the enum to `FakeDevice`/`fake`. in Dart it is generally the case that classes with `Mock` in their name extend `package:mockito`'s `Mock` class
`environment `  is always null here, just use `=`.

Is there any reason you are conditionally passing environment? You could instead conditionally insert the device id:

```
environment = <String, String>{
  if (deviceId != null)
    DeviceIdEnvName: deviceId
}
```
I was thinking maybe in the future there will be more environment variables adding. But yeah I should have made it simpler. 
This comes from `flutter drive` help info (`Target device id or name (prefixes allowed).`), where both id string and model name (e.g. `moto` for a moto G4 device) are allowed. This feature depends on the classes from flutter_tool devices.dart that provides method for getting device name. `adb.dart` doesn't have that, so only id-s and id prefixes are allowed. 
Just realize but should I also replace the logging strings to "fake"? 
Here and above, it looks like there is some shadowing over `deviceId`, this point would only be reached if it was null right? Or is the intention to print the original `deviceId` passed as an argument?
Thanks for the catch! It is a bad design to log the unmatched null deviceId. Fixed. 
The script `dart dev/tools/localization/bin/gen_missing_localizations.dart` had no effect when I ran it at this point, so I'm assuming that it's not necessary to run it.  I've left it out of these docs.
When I ran this script in my other PR, it actually created a few labels in new English locales (like en ca) with the old values. I manually updated them to the correct values.  I guess this shouldn't be part of the process, though, and any new labels created in new locales with the old values should be translated like normal.
Manually updating them actually caused an analyzer error, which gives me more confidence that you shouldn't do that :) Those strings will get translated and set to the right values later.
maybe add a statement along these lines to the docs so that people don't get confused?
Good call üëç 
Wow. This could be the source of real bugs?
This looks like it could have been masking a bug. Wow.
nit: long line
This line is only 129 characters long.  The consistency on line length recommendations is all over the place (you're not alone, I've seen this comment in other reviews).  Is this really more readable?
<img width="652" alt="Screen Shot 2020-06-11 at 9 31 20 AM" src="https://user-images.githubusercontent.com/682784/84414692-d2661080-abc6-11ea-9af2-3196f1415410.png">

I don't get why we care about "long" lines.  Your IDE wraps and scrolls and you're probably working on a ~27" display anyway (130 characters doesn't look long on a 13" laptop either).

I can't even get the Android Studio column guide feature to work, it always just shows 80 characters no matter what I put in the visual guide field.  [What decade is this?](https://en.wikipedia.org/wiki/VT100)
<img width="1109" alt="Screen Shot 2020-06-11 at 9 33 10 AM" src="https://user-images.githubusercontent.com/682784/84414281-9d59be00-abc6-11ea-92d2-37a8edf191f5.png">

I'm all for consistency, but either we should have a linter or we shouldn't enforce it, and should just wrap where it's naturally readable.
I agree, I don't really have anything to go off of here (feel free to ignore nits). I would certainly prefer if we had a standard max line length,  _probably_ longer than 80 but I'm not sure how much until we hit the terminal width limit for @zanderso 

The framework "hand-formatting" standard is really making this harder than it should be. Not to mention all of our lines are longer than they need to be due to the unnecessary RHS types for locals
Here is the relevant section of the style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#prefer-a-maximum-line-length-of-80-characters. In particular, 'prefer going over if breaking the line would make it less readable, or if it would make the line less consistent with other nearby lines.'

'less readable' is subjective, so at the end of the day, this really means something like, "come to a consensus with the code reviewers."

I would vastly prefer it if we could use dartfmt under packages/flutter_tools with a line limit of say, 100 or so, and just not have these conversations anymore, but I believe that ship has sailed.
Can we add a line here that says for modifications required in the host Android or iOS apps, make those modifications in your own wrapper apps that import the Flutter module?
Good idea. I'll open a new PR.
I was pointed to this as an example of why we should use dartfmt... It's worth noting that dartfmt never breaks strings, so it would not make this better. In fact it would make this worse because it puts a random newline before the `(` and then puts the rest of the line on the next line indented by four:

```dart
  void _printDeprecationWarning() {
    if (deprecated) {
      globals.printStatus(
          '$warningMark The "$name" command is deprecated and will be removed in a future version of Flutter.');
```

My recommendation for formatting this would be:

```dart
  void _printDeprecationWarning() {
    if (deprecated) {
      globals.printStatus(
        '$warningMark The "$name" command is deprecated '
        'and will be removed in a future version of Flutter.',
      );
```

(If you do that, then it happens that dartfmt will keep that output unmodified. But it won't proactively cut the string.)
Ruby std lib module available since Ruby 0.4, CocoaPods depends on it, safe to use here.
https://github.com/flutter/flutter/issues/45197#issuecomment-642201335
Is there potentially an end-date for these mitigations, or is this code needed forever? 
The primary purpose of https://github.com/flutter/flutter/pull/59044 is to move most of this logic into the tool so we can change it without requiring the user to regenerate their Podfile.  It imports a new Ruby helper (bleh) from flutter_tools/bin and then calls those helper methods.  So, ü§û this is one of the last migration prompts we ever need (knock on wood as well).

So this particular migration prompt is to get them to generate the new version of the Podfile that imports from the tool.  It will be needed long as we want to support projects created in 1.17 that upgrade to latest.
All these tests are checking that the RichText is not null, is this necessary? I think the test would fail if it couldn't find the RichText anyways.
You're definitely right, I copied this from the `DefaultTextStyle` test cases, maybe it would make the failure more readable? 
This is really unfortunate, i.e. I would have expected: 
```dart
 textHeightBehavior ?? defaultTextStyle.textHeightBehavior ?? defaultTextHeightBehavior.textHeightBehavior;
```

Would it be possible to change DefaultTextStyle.textHeightBehavior to be null by default, and have null mean `const TextHeightBehavior()`?

We're going to need to explain how this interacts with DefaultTextStyle
We usually don't put vital info like this in the constructor's API doc
Instead of returning the inherited widget, we should return textHeightBehavior and `const TextHeightBehavior()` by default
Can we avoid referring to this (and having developers refer to it) using dart:ui?
I don't think this is needed; see related comments
Added some docs explaining the relationship.
Moved
Done
Discussed offline, but yes I'll adopt this pattern. 
Done, as discussed offline with the minor tweak of returning `null` by default.
Removed.
in the same tree as => below 
It seems to still be here.
Done.
This isn't your problem but it would be great if we could rename all the other variables to finish with Data. For example, `timePickerTheme` should be `timePickerThemeData` maybe we can start this change with this widget. 
Remove comment
Remove empty space
Why do all the variables have a _k in the beginning what happens if you replace that with just _defaultShape
single if statements should still use { } so instead of if (true) statment it would be if (true) { }
single if statements should still use { } so instead of if (true) statment it would be if (true) { }
single if statements should still use { } so instead of if (true) statement it would be if (true) { }

Great comment.
This should be a assert method instead with a comment.  Or maybe a throw instead.

If that is an error we should not return empty string.
return null seems wrong. Maybe you should write a comment why you are returning null over throws or assert method.
Same as above
swap onPressed and child
swap onPressed and child
The `k` at the beginning is because they're `const` (as per the style guide)
I think we've been mostly consistent in dropping the `Data` from the variable name since it felt unnecessary, so I'm gonna leave as-is.
These comments are actually used in some way to help with generating documentation. I'm not really sure how but I'm going to leave this in.
Space is useful to delineate sections here.
good catch, done
Done
Done
I can't take the credit here haha, this is from the existing picker
So the `_validateHour` and `_validateMinute` functions are passed into the `TextFormField` validator param and they basically use the presence of non-null strings to indicate an error state. So unfortunately, it has to be done this way.

This error means the user has type something that isn't a valid hour/minute and we want to update the UI to indicate that, so we don't need to assert or throw anything because this is about user-facing errors.
Same comment above but I'll clarify the comment a bit
Same answer as above
Done
Done
This is a pattern flutter uses for constants (prefix with k), so I'm going to leave as-is.

https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#begin-global-constant-names-with-prefix-k
should this only be indented 2 spaces?
Why is this assert here and not above with the asserts in the constructor definition?
Maybe a comment here that width stays null for X reason?
This might need a github issue to go with the TODO
It doesn't look like this method does anything (I may be misusing Github difftool)
This implies that if amSelected is false, then 'pmSelected' would be true, consider making `pmSelected => !amSelected`
`this._minSize`, cool
can you use += here and below?
can you use += here and below?
this should probably be on the same line as the return, or it could have a trailing comma for better formatting
Don't need `|| value.isEmpty` because `int.tryParse('')` (which is done below) will return null
Don't need || value.isEmpty
Could be `return newHour == null ? '' : null`
Same comment as above
Same comment as before about TODO possibly needing issues. I am unable to find the rule though.
Is it common to use __ instead of _ here?
this should be min48
Why is this an invalid hour?
nit: use `w` or `widget` for all of these finder predicates
same comment as above
done
Looks like it was already in the constructor, removed here
done
It's not required and so I'm just going to leave this, I'll be following up with that work
I think that may just be the github diff tool, it does do something.

```
  void _setPm(BuildContext context) {
    if (selectedTime.period == DayPeriod.pm) {
      return;
    }
    switch (Theme.of(context).platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.linux:
      case TargetPlatform.windows:
        _announceToAccessibility(context, MaterialLocalizations.of(context).postMeridiemAbbreviation);
        break;
      case TargetPlatform.iOS:
      case TargetPlatform.macOS:
        break;
    }
    _togglePeriod();
  }
```
done
I think so, good idea
thanks
yep
Done
true. done
Done
Done
Done
Leaving as-is, the rule only requires username, GH issue being optional. I'm going to be following up with a l10n pass anyways
nope, this is an unfortunate side effect of the IDE, fixed
good catch, fixed
Oops comment should read invalid minute, fixed
oops, fixed
done
If the type of dayPeriodShape was OutlinedBorder, then this property could be a BorderSide, which is more flexible and would make it possible to specify the appearance of the border independently of the shape.
If we had just one hourMinuteTextColor property but the implementation used MaterialStateProperty.resolveAs<Color>, then a MaterialStateColor could be used to specify select and unselected colors (as well as colors for other states if that made sense).

If the internal representation of the default color was MaterialStateProperty<Color> then you could effectively resolve color like this:
```dart
theme.hourMinuteTextColor.resolveAs<Color>(states) ?? _defaultHourMinuteTextColor.resolve(states);
```
That way developers could use a MaterialState color to override the effective color for just one state (return null for the others) or all of them.

Statements like this should to explain the default comes from the overall theme's color scheme
As with ColorScheme, need to explain that "brightness" refers to the overall theme's brightness.
Should be required, assert non-null.
If you read this carefully, it's not really correct.
It would help to mention [showTimePicker] in here somewhere.
see also [TimePickerTheme] also
Mode => Interactive input mode 
"Either a dial or text input." isn't really needed.

Not sure if the DartDoc will recognize [dial] as [TimePickerEntryMode.dial]
Looks like we're assuming that isSelected is non-null, so assert that.  Likewise for text
This looks quite a lot like _RenderInputPadding in button.dart. In a future PR, maybe we should create a shared public widget for this.
Does this work correctly if font changes or if textScaleFactor > 1?
origin 2-space indent was OK?
Looks onChanged is assumed to be non-null, assert here.
This is formatted a little unusually. Here's an alternative that's still unusual/compact:
```dart
return !widget.isHour ? localizations.formatMinute(widget.selectedTime) : localizations.formatHour(
  widget.selectedTime,
  alwaysUse24HourFormat: alwaysUse24HourFormat,
);
```
Sometimes this kind of thing is easier to read if the short and simple clause is first
This is OK but it makes it clear that the TimePickerTheme's inputDecorationTheme is underpowered - it can't reflect the time picker's state. Maybe make this a MaterialStateProperty instead.

Also: maybe InputDecorationTheme is more flexibility than is really needed here (I realize that it's convenient).  Maybe all that is needed are two properties: a MaterialStateProperty<BorderSide> and a MaterialStateProperty<Color>.  InputDecorationTheme implies more flexibility than we're likely to test or anyone is likely to need.
prefer to reserve `=>` for one-liners that return a value
```dart
setState(() { _autoValidate = true });
```
What's 1.1 for? Aren't we constraint textScaleFactor to 1.0?
MediaQuery.of(context) => media
Shouldn't we be using ColorScheme colors here?
ButtonBar is problematic. Can we avoid it here?
We can have const values here
```dart
orientation == Orientation.portrait ? const EdgeInsets.symmetric(horizontal 36, vertical: 24) : const EdgeInsets.all(24)
```
NICE
Yeah I based it off of the button.dart implementation and it could definitely be extracted in a future PR
I elaborated more on this,  some elements do scale up (like the help text and the buttons at the bottom), and 1.1 worked well while testing different scale factors.
I'm not sure what you mean, could you elaborate?
Done throughout
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
Done
it does run into problems at higher text scale with the dot overlapping the text unfortunately.  I think this is fine though, the existing Android time picker has this problem.
Spoke offline and agreed that InputDecorationTheme provides enough flexibility to customize the TextFields if necessary
Done
Done
Done
I think ButtonBar gives some helpful logic (like moving to a Column layout if the buttons don't fit) so I'd like to keep it for now. I'll add a TODO to move away from this in the future.
I think you mean:

The [data] value of the closest instance of this class that encloses this context.

Or you could just say

The [data] value of the closest [TimePickerTheme] ancestor.
Ohhhhh that makes more sense, fixed!
If you define variables like this with one statement, then the default object doesn't get created unless it's needed.
```dart
    final Color textColor = timePickerTheme.hourMinuteTextColor
      ?? MaterialStateColor.resolveWith((Set<MaterialState> states) {
           return states.contains(MaterialState.selected)
             ? themeData.colorScheme.primary.withOpacity(isDark ? 0.24 : 0.12)
             : themeData.colorScheme.onSurface.withOpacity(0.12);
         });
```
The color of the header text that represents hours and minutes.

If [hourMinuteTextColor] is a [MaterialStateColor], then the effective text color can depend on the [MaterialState.selected] state, i.e. if the text is selected or not.

By default the overall theme's [ColorScheme.primary] color is used when the text is selected and [ColorScheme.onSurface] when it's not selected.
 Similar feedback about wording for this property as for hourMinuteTextColor:

The background color of the hour and minutes header segments.

If [hourMinuteColor] is a [MaterialStateColor], then the effective text color can depend on the [MaterialState.selected] state, i.e. if the text is selected or not.

By default the overall theme's ...
The color and weight of the day period's outline.
Done
Done
Done
Makes sense, fixed
```suggestion
// See https://github.com/flutter/flutter/issues/59189
/// Currently, [NestedScrollView] does not support simultaneously floating and
```
Commenting here in case I forget when reviewing the tests: Did you add a test for this?
nit: maybe remove the "more on using" since its just fluff. "[SliverAppBar]s with [NestedScrollView]s" seems to work as a heading. 
nit: maybe add a high level comment here preparing the reader that the next few sections talk about the functionality and limitations of SliverAppbars when used within a nested scrolly thing.
Maybe preface this with the fact that pinned appbars in a nested scroller work exactly like they would in any scroll view. I was scanning the paragraphs for any drawbacks/limitations.
should -> will? I mean it actually does do this, right?
nit: add a space after the comma
High-Level comment: Reading this entire section, I am wondering if we can shorten this a little bit. Instead of giving longer explanations referring to the internals of the nested scroll view, maybe we can just say in each section whether that type of app bar does or doesn't work out of the box as expected. And if it doesn't work out of the box mention how the scrollview needs to be configured to make it work (the code examples should be left in, of course!). 
I'll add one.
I go back and forth on this. I think it's important to explain a lot of these things, as we often have issues filed that are resolved by just explaining oh you need the SliverOverlap* widgets etc. 
You can never have too much documentation, right? :)
I got tired of mocking Artifacts when I don't actually care about the contents. This should trivially generate unique-ish artifact paths for testing
this type was wrong and the case is bogus
@annagrin I need to remove this because it prevents regular compiler errors from showing up on the web
Rather than printing this message after a bunch of compilation failures, the new test compiler checks for a dependency before compiling and exits early. This gives a much clearer instruction on how to resolve the error too
By checking the package config we know definitely there is a missing dependency. Added instructions on how to fix
Can any of these use `testWithoutContext`?
ditto
Yes, fixed
not until these tests are re-written.
I need to understand this better. I added this to communicate compiler errors to the debugger during evaluation, so something might break there...
This is only printing trace messages, how is the debugger using printed messages?
For expression evaluation, the debugger does not need messages printed to the console, but instead is handing them specially, depending on the context (watch window, hover over, expression evaluation box, conditional compilation all need their own error handling). Not sure how the debugger is getting the error messages though, will find it out and update.

I tried the change and figured out that if we suppress the compilation messages in compile.dart :

```
Future<CompilerOutput> _compileExpressionToJs(_CompileExpressionToJsRequest request) async {
    _stdoutHandler.reset(suppressCompilerMessages: **false**, expectSources: false);

```

then we get the desired effect - the error messages are still propagating to the debugger but the printing is gone.
   
Ahh, awesome - I will make that change!
Figured out how debugger gets compilation errors:

https://github.com/flutter/flutter/blob/96711b00ce3f3addec82ebe0ee34b4c36cc3c9ba/packages/flutter_tools/lib/src/build_runner/devfs_web.dart#L85

So as long as the generator writes them to the file, the debugger should get them:

https://github.com/dart-lang/sdk/blob/ecc7a2110667284d792946775f471f4a7f409afb/pkg/frontend_server/lib/frontend_server.dart#L964

And the errors table is filled by:

https://github.com/dart-lang/sdk/blob/ecc7a2110667284d792946775f471f4a7f409afb/pkg/frontend_server/lib/frontend_server.dart#L360

This a bit too complicated, may need revisiting and simplification...
@annagrin this change is sufficient to get verbose logs in the terminal of VS Code
This works, thanks! LGTM
This line is a bug that didn't matter, since we never added error statuses. Still fixed in case this gets updated in the future
Would be nice if a lint could have caught that.
`isHint` could be a getter that returns a random value, if I extended ValidationMessage poorly. you would need to figure out the concrete type of `ValidationMessage` here. Then maybe you could prove that isHint will always return the same value for the same instance.

Seems like a fun problem :) 
Nit: Since this is only used once, maybe just inline it?
Why is this needed? Wouldn't it be null to start with?
Same thing here, wouldn't message already be null?
Would we only want the `Tooltip` if the text scale factor is greater than 1?
I dont think you need this new line
Changed to:

```dart

    final MediaQueryData mediaQueryData = MediaQuery.of(context);
    return MediaQuery(
      // Do not grow text in bottom navigation bar because there is no room,
      // instead, properly scaled tooltips will show on long press.
      data: mediaQueryData.copyWith(
        textScaleFactor: math.min(1.0, mediaQueryData.textScaleFactor),
      ),
```
It needs to be explicitly initialized because it's a final field, but I don't want to expose it in this constructor.
Guidance from design was to always include it, because it is useful for more than just text scale, for example when an item has no label.
Removed.
Same as above, it needs to be explicitly initialized (because it's a final field) and I don't want to expose it in this constructor.
Add `container: true` to this Semantics widget and move it back to after the `Tooltip` widget in the Stack. That should fix the issue you mentioned on Chat.

(Basically replace lines 466-513 in this PR with the content of this gist: https://gist.github.com/goderbauer/8913e43d987e76b7b89451dd2ac89089)
As explanation: It looks this is a quirk of the semantics compiler. Since the `indexLabel` was not in a container, its semantics information were implicitly merged to the highest node possible in the tree (which here happens to be the `MergeSemantics` widget). Due to this, before the force-merge triggered by the MergeSemantics widget happens, the SemanticsNode of the MergeSemantics widget already has a label of `indexLabel`. During the force-merge, the labels of the child SemanticsNodes (here: only the one of the Tooltip) are added to the end of that label. Hence, no matter how you order the children in the stack you get the incorrect merged label.

If you now make the `indexLabel` a container itself, it will own its own semantics node. The MergeSemantics widget now has two semanticsNode children and they get force-merged in the order the children have in the tree.

Hope that's somewhat clear. If not, let me know.
`container: true` can be removed here.
This worked!! Thank you for spotting that. Very tricky. 
Done.
I hadn't really thought about this before in other contexts, but is there any advantage in scaling down the text if it already fits?
nit: extra line
why are 5 seconds needed?
Maybe I'm just unfamiliar with these APIs but why do you call this in the constructor?
`markNeedsSemanticsUpdate` is what triggers `assembleSemanticsNode` to run, and as soon as this node is created, and I wanted to make sure that method gets called. I'm also loosely following the `_RenderScrollSemantics` example, which adds a listener to call `markNeedsSemanticsUpdate` in its constructor.

https://github.com/flutter/flutter/blob/025463f4632dbce15da7749d5d3883bea4e6457b/packages/flutter/lib/src/widgets/scrollable.dart#L726

It's possible that this is unnecessary. @goderbauer Do you think this call is safe to remove?
Fixed
In this particular case, I believe that there are some users who are using `textScaleFactor: 0` as a workaround to hide the labels, I do not want to break this use case. There was a period of time when `BottomNavigationBar` did not support hiding labels on the items.  
They weren't needed, changed to 2 seconds, which is what the tooltip uses (there needs to be _some_ time for the tooltip to appear).
Maybe add a quick comment here explaining why we have this widget and what it does to the future reader.
This seems unnecessary. Newly created RenderObjects will always receive a semantics update when they first render (if semantics are turned on). What breaks if you remove this?
`assembleSemanticsNode` only runs if semantics are turned on. Semantics are only turned on if an a11y service (e.g. TalkBack or VoiceOver) is running. I thought this label also needs to show if semantics are turned off? Based on that, I would expect that the tooltip is not showing a message when a11y services are turned off?
Side-note: For technical reasons, a11y are always turned on when running in a simulator. Did you try the tooltip thing on a real device without having any a11y services (outside of scaling the text) enabled? You may have to force-quit and restart the app after turning the a11y service off to delete the cached `label`.
Maybe we should have a separate constructor for this new feature. It may be difficult to debug if you forget to specify the message and suddenly a random string from the semantics tree appears. 
I am surprised that this works because the test doesn't turn on semantics. Maybe I am missing something...
Oh, wait. I think a while ago we turned on semantics by default for all tests. That's why the test is probably fine with this.
The test probably fails if you turn semantics off for it here: https://github.com/flutter/flutter/blob/812c189de8a2d09cb6f52dc1f5186b33f451f837/packages/flutter_test/lib/src/widget_tester.dart#L116
I think we should add the deprecation notice in the constructor too, [see example](https://github.com/flutter/flutter/blob/5cfb16b193886e68e51cc7256389d78a21f31bfd/packages/flutter/lib/src/material/text_theme.dart#L129).

Also it should mention after what version it was deprecated (https://github.com/flutter/flutter/wiki/Tree-hygiene#deprecation) and you might want to add a note that this is to improve text scaling support.
Since restructuring the PR, is this still needed?
Is this because of the overlay assert you added?
Do we still need the MergeSemantics here?
This should follow the deprecation style: https://github.com/flutter/flutter/wiki/Tree-hygiene#deprecation
Also: Can you update the doc comment on this to mention that this property is deprecated and link to the one that should be used instead?
I get the following test failure from the bottom navigation tests when I try removing it:

```
The following TestFailure object was thrown running a test:
  Expected: has semantics with label: AC
          Tab 1 of 3 with actions: [SemanticsAction:SemanticsAction.tap] with flags: [
            SemanticsFlag:SemanticsFlag.isSelected,
            SemanticsFlag:SemanticsFlag.isFocusable
          ] with textDirection: TextDirection.ltr
  Actual: SemanticsNode:<SemanticsNode#6(Rect.fromLTRB(0.0, 2.0, 266.7, 54.0), actions: [tap],
flags: [isSelected, isFocusable], label: "AC", textDirection: ltr)>
   Which: label was: AC

When the exception was thrown, this was the stack:
``` 
Oh, you'll also have to undo some of the other semantics changes we did here:

* remove MergeSemantics
* make the semantics widget below (the one with `selected: selected`) a container again
* Remove `container: true` from the semantics widget with `label: indexLabel`

I think that should do it and it makes the tree slightly simpler. 
Ah yes, that worked, thanks!
I simplified the tree based on goderbauer's comment: https://github.com/flutter/flutter/pull/59127/files#r450472105
Yes, exactly
Done.
Done.

Based on the breaking change guide you sent, I also created this breaking change proposal: flutter.dev/go/bottom-navigation-bar-title-deprecation, it has been open to discussion for a ~week or so now. 
@darrenaustin may already have a plan for this.
```suggestion
  'This feature was deprecated after 1.19.0-4.0.pre.'
```
I think the deprecations here are just missing a period to make the analyzer happy. :)
d'oh
Nice comprehensive doc comment!
Which samples is this referring to?
Maybe add a link?
gallery in samples. they've said they'll fix it when i land this.
https://github.com/flutter/gallery/blob/74d9d92883c6ca10742c44df309f065289cf2f55/lib/demos/material/text_field_demo.dart#L225
How do I indicate that these strings have been changed and need to have their translations updated?
nit: a collection for statement that loops from 0 to `itemDatas.length` seems a better fit here? Having side effects like `itemIndex++` is a bit weird in map.
With `RTL` text direction the extra horizontal padding (5.0) is going to face inward I think. Maybe use `EdgeInsetsDirectional` instead?
Sounds like a @shihaohong or @HansMuller question? I'm interested in knowing the answer too.
nit: the cupertino localization file is not updated so this is probably not needed?
The instructions for adding the strings is a comment at the top of this file. I think there's a script that automatically does that in google3, so long as the default is modified here and in [material_en.arb](https://github.com/flutter/flutter/blob/master/packages/flutter_localizations/lib/src/l10n/material_en.arb). 

We should probably update those instructions to include a guide for how to modify existing strings.
I did a quick investigation and whenever Flutter is rolled into google3, material_en.arb is the template that determines what new strings are added or if any existing strings were modified, so make sure to update those as well! 
Thanks for the help!  I just created a separate PR to add instructions for doing this based on my understanding.  More code review welcome :) https://github.com/flutter/flutter/pull/59273
Yes that is much better, thanks.  I forgot about the fanciness with for loops in an array.
I played around with this in DartPad and it seems that EdgeInsetsDirectional start is what will face inward when the text direction is RTL, so it should be correct as-is.  Let me know if I'm not thinking about this right though. https://dartpad.dartlang.org/98d77d79c6664a4f64968b899836419f
Good point.  I'm going to keep it as Paste for consistency, and because the iOS text selection menu isn't all caps either. It probably should have been Paste before this PR.
If the direction is `RTL` then in the column the first item in the list will be placed at the right edge with extra padding on its left I think?
In the dartpad if I do `crossAxisAlignment: CrossAxisAlignment.start` on the column and set the text direction to RTL for the column, then the buttons do align right.  In selection menu though, the position of the buttons isn't affected by text direction.  It also seems like when the menu is overflowing and some buttons end up in an overflow menu in a column, they are always aligned left.  Does that make sense or am I missing the case where it doesn't work?
Oh sorry I thought the buttons will be put in a text direction aware container like a `Row`. Looks like `_TextSelectionToolbarContainer` doesn't care about the text direction. It appears if I turn "force RTL" on in a native android application the menu will flip. I'll file a bug if there isn't one
Thanks!  I didn't realize the menu order flipped on native.
uber-nit: `expect(response.json['protocols'], hasLength(2));`
uber-nit: `expect(protocol['protocolName'], anyOf('VM Service, 'DDS'))`
what is the status of this TODO?
This is a very helpful comment!

 I would suggest hoisting this and the attach comment into flutter_command.dart with something like:

```
void addDdsOptions(bool verboseHelp) {
  argParser.addOption(...)
}
```

And then call that from run and attach.
For new code, we're trying to avoid using anything in globals. This can be restructured easily enough as:

```
class DartDevelopmentService {
  DartDevelopmentService({
    this.logger,
    this.launcher = defaultValue
  });

  final Logger logger;
  final Future<dds.DartDevelopmentService> launcher;
}

```

Nit: This class doesn't do a ton but I would add a short doc comment on the purpose.
Wasn't sure where to find whether or not we were running with ipv6, but I've figured it out.
Thank you! Disabling this can cause some very subtle issues so I wanted to make that very clear in the help message.
nit: extra indent.
nit: I believe we generally put the fields ahead of the methods.
nit: missing trailing comma.
nit: no newline after '='. (See the style guide in the wiki)
Could you link this to an issue?
This was also disable in flutter_web_runner, right?
Done, but for convenience here it is: https://github.com/flutter/flutter/issues/61259
err, resident_web_runner
slash => splash
Please add a comment above this line:
```
// This is a regression test for https://github.com/flutter/flutter/issues/58665
```
Shouldn't we be using the Ink widget here?

https://api.flutter.dev/flutter/material/MaterialType-class.html
Ah nice
I took a look at the ink widget, and couldn't figure out how to apply it here. If i understand correctly, the Ink widget just make the splash go through the decoration of the Ink. but there is a stack on top of the material widget
You're right. I thought Ink would draw the splash on top of the Material's descendants, but that's not right. Your original approach was the right one after all, sorry about the detour.
Without this change we hit an assert in the integration tests.
this is the fix
and this
Oops, I didn't notice that I was inconsistent about this. Can you make all the `INSTALL`s lower-case to match the other function uses?
Are there any other uses of this left in parent scope?
I forget when I wrote up the bug that this was already here even in the BundleUtilities version :)
We should update the plugin template to have an empty list with this name, with a comment explaining what it's for, so that plugin authors can easily see how to add a library rather than needing to dig into the rest of the build system to discover it.
@Piinks: does this particular change looks good to you? I haven't found place where this constructor is call with null. 

In NNBD a factory constructor can not return `null`. If we want to return `null` the only solution is to replace this factory constructor by a static method. 
I think this will be ok. The only use of this factory is above on line 569. :)
nit: un-indent this line by 2 spaces.
Thank you! It's updated. This indent is the default behavior of vs code flutter plugin. Should I report it somewhere or is it not actually managed by the plugin? 
Avoid `__dir__`, I used it in add-to-app version of this and people have [had issues](https://github.com/flutter/flutter/issues/54675).
Hopefully CocoaPods never removes `defined_in_file` (the path to the Podfile) but if they do, fallback to... this file.
This gives us flexibility to support bitcode (someday).
This logic will be updated to do https://github.com/flutter/flutter/issues/39659.
nit. including `generated_xcode_build_settings_path` in the message would be helpful
should we log a warning if it doesn't repond to defined_in_file?
Changed it to include the path
```
[!] Invalid `Podfile` file: /Users/m/Projects/test_ruby/ios/Flutter/Generated.xcconfig must exist. If you're running pod install manually, make sure flutter pub get is executed first.
```
and
```
[!] Invalid `Podfile` file: FLUTTER_ROOT not found in /Users/m/Projects/test_ruby/ios/Flutter/Generated.xcconfig. Try deleting Generated.xcconfig, then run flutter pub get.
```
\o/
what's the transition plan for add-to-app? Can we change this line in https://flutter.dev/docs/development/add-to-app/ios/project-setup#option-a---embed-with-cocoapods-and-the-flutter-sdk to load `File.join(ENV["FLUTTER_ROOT"], '.ios', 'Flutter', 'podhelper.rb')` or some such? 
I was sensitive about this due to https://github.com/flutter/flutter/issues/42513 but we know the location of the Podfile--it's this file.
I think I'm over-engineering this a bit.  I just need to pass in this file.  We can keep the fallback to `defined_in_file` and subsequent `raise` [in the podhelper](https://github.com/flutter/flutter/pull/59044/files#diff-9a4a61b0e60143d9364139b944b2d485R43-R44).
Added this hook for future use (could have been used for the old `install! 'cocoapods', :disable_input_output_paths => true`, for example)
Currently the CocoaPods add-to-app module lays down a similar but not quite the same podhelper in the ephemeral directory, which gets recreated on a `flutter clean`.  As long as we didn't rename those methods and break existing host Podfiles (unfortunately the names don't reference iOS or the module: `install_all_flutter_pods`, `install_flutter_engine_pod`, `install_flutter_plugin_pods`) we could transition them to this bin podhelper, but I don't know what it would really buy us (other than they would get updates instantly instead on a `clean`).  I'm concerned it would make the CI story more complicated because `flutter` would need to be available on every machine, even if the entire module and podspecs and binaries were already placed in the right spot.

P.S. We wouldn't want them to need `FLUTTER_ROOT` on their path, it would have to be parsed from the Generated files the same way this one is.
ya, it should be a separate task. 

What I had in mind actually may or may not work. One small ergonomic annoyance now is if someone checks out the iOS and flutter projects, it currently takes 3 steps to build again. Go to flutter, flutter pub get to make the .ios folder with podhelper.rb, then go to iOS, call pod install, then open xcode, run.

Perhaps we can save one step if the various flutter_install_* code called flutter pub get to make the underlying xcodeproj if needed etc?
That would be cool.  Want to create a new issue?
One more change to make more future proof: pass in the target instead of the build configuration.  This will give us access to the target name so in the future we can just make changes to the Flutter-specific targets (like adding a Flutter linker flag).
Nice, good catch
The cache is only for downloading artifacts (I think). Could we release the cache automatically after checking for cache updates? that way it wouldn't need to be done adhoc in each subcommand, and would be able to skip the cache for commands that don't download anything (like --version)
That makes sense.  The one-off I see is test command explicitly running [`await globals.cache.updateAll(await requiredArtifacts);`](https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/commands/test.dart#L159) which is causing it to check for updates twice.

(Introduced at https://github.com/flutter/flutter/pull/30254/files#diff-57bf7f0d5a70ab392ae3047369120c83R102).
Also `precache` probably needs it re-locked.
Remove "early" semantics.
Pre-cache still needs the cache lock.  I tested this manually and confirmed two concurrent `precache` commands wait for each other.
This is the magic line, correct?
Unless I'm totally missing something, this did a second required artifacts update check.  When I stepped through it it called `updateAll` with the same artifacts twice.
Yup that's the good stuff.
I'll add a comment.
odd...

I'm sure that is my fault
Moved `releaseLock` so it can run before `ensureReadyForPlatformSpecificTooling`.
Could you add a command test for the re-lock? somehow..
Added two new tests.  Kind of lame but I needed:
```dart
  @visibleForTesting
  static bool isLocked() {
    return _lock != null;
  }
```
nit: put spaces between `1 / _kFinalLabelScale` for readability.
nit: Remove comment here, unless it was intended to make it more clear? I don't think it should be needed.
Remove `);` at the end
It is to make it more clear and to be consistent with the other tests in this file
nit. is this guaranteed to match, even with the surrounding whitespace?
We generated this as part of the template with https://github.com/flutter/flutter/pull/4893/files#diff-fddbdff9cdb9e32ee9b9a95f74f30788R5-R8.  Xcode and CocoaPods won't add it (at least how we have the project set up now).
Can we rely on a build stamp so it invalidates on every upgrade?  Build system behavior could change without this file changing (could be a different PR).
The engine version is used as a shortcut for this: https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/build_system.dart#L318

It should also include `flutter/version` though.

The goal of this input is just for local development, not to handle upgrades
@jonahwilliams 
This line also causes an error when installing the service worker.

```suggestion
  return contentCache.addAll(resources);
```
thanks!
what data type is this? what's going on here?
its a JavaScript Array
ahhh, ok, I see it now!
TODO: re-add these checks with better implementation
TODO: remove once fixed
TODO: remove once fixed
Provided a default here for the google3 roll
is this supposed to be commented out?
Looks like the logic changed and this comment is no longer accurate.
Fixed
Fixed, and added test case that we default to 100 if terminalColumns is null
This was the actual bug fix, everything else is for testing
And here too
```suggestion
          'The material library uses Localizations to generate messages, labels,'
```
```suggestion
  /// This is parsed from the "traceEvents" data within [json] and sorted by timestamp. Anything
```
What do you mean by "time statistic results"?
end the line with a `.`.
per style guide: avoid empty prose like "note".
end sentences with `.`
I am not 100% sure I understand what this sentence is supposed to tell me...
Nit: "Assuming" -> "This routine assumes that"
We just renamed "GPU thread" to "raster thread" (https://github.com/flutter/flutter/issues/29443), so maybe change "the GPU rasterizer" to "the engine rasterizer"
This change involves `kRasterizeFrameEventName`, which is the part of the JSON item name, and part of engine interface. Are we sure we should change it here? 
Ah, I see that we forgot to rename `GPURasterizer::Draw` to `Raterizer::Draw` in the tracing events (CC @filiph ). I think it's fine to leave `kRasterizeFrameEventName` as is (since the change needs to start with the engine repo), and just remove `GPU` from this documentation. The `engine rasterizer` would be more accurate than `GPU rasterizer` because there's no longer `GPURasterizer` class in the engine. There's only `Rasterizer`.
Didn't we intentionally keep names of timeline events so as to not break people's measurement scripts?
Yes, now I remembered! You and Nathan were explicitly discussing about avoiding changing `GPURasterizer` in the tracing. Now it's also clear that if we change the `GPURasterizer` label in the engine, it will also break our framework performance tests.
Returning 0 if the list is empty may have the following problems:
- It's unclear whether the 0 is caused by an empty list or that all values are 0 in the list.
- It's going to add many 0-valued metrics to our benchmarks that currently don't have CPU or memory measurements (i.e., all Android tests). It will add a lot of dummy graphs to our dashboard, and may need a lot of baselining work.

Maybe we should assert the list is not empty when we're expecting CPU/memory measurements, and drop the value (not calling computePercentile) when such measurement doesn't exist.
The value is already dropped when it doesn't exist. I do a check here: https://github.com/flutter/flutter/pull/58820/files#diff-9277fbf8cff9518e455fc51bac717a7aR81 to ensure that a profile exists. I will change this to an assert though, given that this should never happen.
Nit per style guide: avoid empty prose like "note". How about"List [doubles] will be sorted"?
Nit: I believe we have the following pattern in other places:
```
eventByType[type] ?= <TimelineEvent>[];
eventByType[type].add(event);
```
Nit: `eventsByType` to suggest that it's a list?
Nit: we can use stricter `Map<String, double>` here?
Nit: throw exception or `assert` if it's unreachable?
Done
Done
Done
done
I didn't know this and I really like this.
I started by adding `userIdentifier` to `DebuggingOptions` property bag which meant that `userIdentifier` was explicitly passed around in fewer places.  However that didn't really make sense--the user isn't relevant for debugging or build, it's only relevant once you go to install or start the prebuilt app.  So I moved it into FlutterDevice.  You could theoretically deploy to multiple users on the same device, but I don't picture needing to happening often so it's not supported.

I'm all ears if you guys have a better suggestion for how to inject this into the AndroidDevice install/uninstall/start methods.
 dartdoc should have a newline between the top level comment and additional comments:

```
/// Check if a version of the given app is already installed.
///
/// Specify [userIdentifier] to check if installed for a particular user (Android only)
```
This needs more context on why someone would need to use this. Work profiles?
I agree that it doesn't really make sense for debuggingOptions. Updating the Device APIs seems like a reasonable approach - though I'm fairly certain there are overrides in google3, so you might want to double check even if FROB passed
We could also run `adb shell pm list users` for them to list possible users
I went through about 4 different versions of this help text, but none of it worked for every command I added it to.  It's too sparse though, I'll change this to make the help text different per command.

You might want to use this because you have multiple users on the device (System > Multiple Users) and only want to install to one user OR because you have [work profiles](https://developer.android.com/work/managed-profiles#testing_tips).

> For example, to find the users on a device, you would run this command:
```
$ adb shell pm list users
UserInfo{0:Drew:13} running
UserInfo{10:Work profile:30} running
```
> In this case, the primary user("Drew") has the user ID 0, and the work profile has the user ID 10. To run an app in the work profile, you would use a command like this:
```
$ adb shell am start --user 10 \
-n "com.example.myapp/com.example.myapp.testactivity" \
-a android.intent.action.MAIN -c android.intent.category.LAUNCHER
```
We could it for them, but I don't want to parse the output since there's no machine readable format options and this I doubt this flag will be used except by users who are already familiar with Android and `adb` (see b/142944798).
```
$ adb shell pm list users       

Users:
	UserInfo{0:Owner:13} running
	UserInfo{10:jane:10} running
```
I don't think launching will work if the user isn't running (though install will?) and I don't want particularly want to explain all that.
Makes sense!
don't hesitate to add a big, huge help text that encompasses every possible command
In fact, rather than give each command a different flavor I would consider just adding headings to the flag:

```
with run:

...

with install:

...

```
So you run `flutter attach -h` and see the details for `flutter run` and `flutter drive` etc?
well, I would hide this particular option under verboseHelp, so -h v. 

Maybe adding them all together is a bad idea, but I'd be worried about keeping the documentation up to date. Maybe a shared header + command specific details added on
How about:
`'Identifier number for a user or work profile on Android only. Run "adb shell pm list users" for available identifiers.'`

What are our criteria for hiding options?  This one may be uncommonly used, but it's not like experimental or only relevant for Flutter or g3 development (like local engine flags, etc).
usually just go with your gut
> though I'm fairly certain there are overrides in google3, so you might want to double check even if FROB passed

I don't see any obvious overrides that would be impacted by this change.  @mehmetf can you double check me?  You were thinking about this awhile ago
https://yaqs.corp.google.com/eng/q/4970372142465024 (internal)
b/142944798
Will this break -d all with a user identifier?
Before this change `flutter drive -d all` runs on the first one it finds.  I can't find an issue complaining about that.
```
$ flutter drive -d all -t test_driver/route_test.dart
Found multiple connected devices:
Pixel 4           ‚Ä¢ 98281FFAZ005T6                       ‚Ä¢ android-arm64 ‚Ä¢
Android 10 (API 29)
iPhone 11 Pro Max ‚Ä¢ 16AF0D86-8F62-410C-8CC2-8F70C49835AF ‚Ä¢ ios           ‚Ä¢
com.apple.CoreSimulator.SimRuntime.iOS-13-5 (simulator)
Using device Pixel 4.
...
```
This `validateCommand` Android check is against the one device that's about to be used in `runCommand` [`_device = await findTargetDevice();`](https://github.com/flutter/flutter/blob/1e4d9f8502b7911f920c11d289b807c0ec7afd1b/packages/flutter_tools/lib/src/commands/drive.dart#L151).
Never mind, @jonahwilliams pointed me in the right direction.
We override the DeviceManager. If tests pass, this should be OK to land. Feel free to update the internal bug so we can try it out internally when this lands.
Supporting CL has been submitted.
I cannot make it targeted because navigator.dart cannot depend on hero.dart or app.dart. otherwise it will be circular dependencies. The other choice is merge hero.dart and navigator.dart, but that will probably be a nasty breaking change.
nit: use a trailing commabetween the ) and put the second one on a seperateline.
Why can navigator.dart and hero.dart not import each other? They are both in widgets layer.
Maybe define an observers getter on the NavigatorState that returns the widget.observers followed by the inherited one and use that everywhere instead of `navigator.widget.observers` to avoid this duplication?
Why do we need to do this? if `didChangeDependencies` finds a different InheritedNavigatorObserver it would just update it. If it finds the same `_updateInheritedObserver` would just short circuit. 
Can we move this up to where we initialize the other observers?
nit: rename the argument to `newObserver` to avoid the confusion between `inheritedObserver` and `_ inheritedObserver`?
nit: sub -> nested
Is that acceptable? I thought that is not a good design pattern. Do we have example in our code base that does it?
This should have minimum duplication once https://github.com/flutter/flutter/pull/57605 is merged, I separate them out because i don't want to create a list or using a yield everytime the getter is called
Ah you are right the InheritedNavigatorObserver.of will get called in didChangeDependencies anyway even if it will short circuit in _updateInheritedObserver.
navigator.dart and routes.dart - within the same layer it should be fine.
I am not in love with the name, I don't think we usually put "inherited" in the name of "InheritedWidget" subclasses. But I also don't have a great suggestion for it...
nit: update this comment.
sub tree -> subtree
maybe: which is the standard way of providing a [HeroController].
Should `_updateHeroController` just call `_updateEffectiveObservers `?
Call `_updateEffectiveObservers` here?
Why not just iterator over `_effectiveObservers`?
Maybe `HeroControllerScope`? 
Why not always wrap it?
This is an optimization I feel like doing. Would you rather be safe and always wrap it?
Let's always wrap it to avoid changing the shape of the tree when this changes.
Ah yes, I forgot about changing the tree shape cause the whole subtree to rebuild...
extraneous blank line
why? it seems perfectly reasonable to use this class to provide a HeroController if you're making a widget that gets a Navigator from somewhere else.
it's not more "Standard" than this way :-)
would be clearer to have two constructors, one that requires that controller be non-null, and one that doesn't have a controller argument, with a name like `HeroControllerScope.none` or something.
we should have a test that verifies that changing the hero controller mid-way through a hero animation works.
I think we should encourage user to use observer instead if they can?
I mean until we finally refactor the hero controller to not depend on navigator observer
This is a temporary workaround for router api, eventually we want to build a more flexible system. I think we should not further improve this api?
there is nothing connected to this, so it is safe to delete
Uber nit: what about adding try/catch, so if it fails for whatever reason, it doesn't stop the test
Well, it's already within a try/catch in the calling function, but I added one around this one too.

Actually, I also changed the other try/catch blocks so that they only catch `Exception`s since otherwise they'll catch everything, including `AssertionError`, `NoSuchMethodError`, and other `Error` subclasses that represent programming errors and not regular failures. I also upgraded some throws in here to throw a `DeviceException` so that they would be caught.
nit: fix indentation:

```suggestion
      child: GridView.builder(
      padding: const EdgeInsets.all(0),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount:2),
      keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
      itemCount: focusNodes.length,
      itemBuilder: (BuildContext context, int index){
        return Container(
          height: 50,
          color: Colors.green,
          child: TextField(
              focusNode: focusNodes[index],
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
          );
        },
      ),
    ));
```
same here
@goderbauer  thanks for your review. I have some doubt about format.  I have tried to format file  by  flutter format xxx.dart ,  but it doesn't meet the requirements. Could you please tell me how to check it and what's the standard? thanks
@Hixie Could you please clarify the rule of flutter format when you have a time? i have tried flutter format xxx.dart and   flutter analyze. but it seems not good.
The rules for the style of this repository are written down in https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo.

Most notably, this repository does not use automatic formatting (e.g. with dartformat or `flutter format`). This rule about trailing commas is also relevant for this particular case: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use-a-trailing-comma-for-arguments-parameters-and-list-items-but-only-if-they-each-have-their-own-line
It's kind of you. Thank you for your patience. please take a look when you have a time.
done
We need test for each constructor as well
As I see,  arguments are refer to BoxScrollView,  is it a duplicate test code for that?
we can just make sure the below boxScrollview receive the right parameter.
@liyuqian would it be easier if the command required you to pass in a destination file?

like --write-sksl-on-exit=foo.sksl.json ?
That sounds good to me. It also makes my test easier as I don't have to worry about whether the tool will create sksl_02.json or sksl_01.json. With `--write-sksl-on-exit=foo.sksl.json `, I'd expect the file to be overwritten, right?
Yup!
Lowercase "o" on "Only" here.

Also I think you forgot a word after that. "save"?
Extra empty line.
"Finishes the current autofill context and potentially saves the user input"
"input and is ready to submit."
Duplicate "the an" here.
This feels a bit inconclusive.  Is there anything we can recommend for users to do who want multiple contexts?
Nit: I think there should be no comma at the end of this line, but it's fine either way.
InheritWidget => InheritedWidget
I think you meant to finish this sentence here.
Nit: Another comma that I feel like should be removed.
Weird line break here with a floating comma.
Maybe open an issue about this and link to it here.
Can we avoid this? we want to move away from using navigator observer-like system?
Yes I would like to avoid doing this. Is there a better way to monitor global route changes? (Or did you mean `NavigatorObserver`s should not be used in general)?
At some point we want to remove NavigatorObservers. It was a compromise to implement hero controller, and people started to use it to monitor the route history which is not what it built for. This result in people wants to add more and more functionality to this class and things started to get out of control. One other way will be creating a new route class to monitor Route.didpush, Route.didpop and such...
question: why does the function receive savedForm? I remember we discussed in the future we might want to send more parameters with save. Is it related to discussion?
Should this call shouldSave: false?
There is nothing in the lifecycle which calls "shouldSave: false", is it possible to have a scenario that we want to cancel the form?
Question: why are we adding this check in the framework, can we handle it on the iOS engine side?

The reason that I'm concerned is, platform is does not necessarily mean that this is a flutter app running as an iOS mobile app. It can also be a Flutter Web app running on iOS Safari. Since web also return TargetPlatform.iOS, in this case, this branch won't work correctly on browsers on iOS, running Flutter for Web. The code is here: https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/foundation/_platform_web.dart#L20

The `FormState` here is just a bit of additional information that helps the developer determine what needs to be done when this particular form gets saved. The framework doesn't really send the information to the engine.
I'll check if `kIsWeb`.
Can we just do this on the iOS specific implementation in the engine? 
Having this global is odd. Why do we need it? If you want different settings, you'd just wrap your subtree in a different `AutofillContextLifecycleAction` widget.
Why is this the condition for saving? What if I have my form an an Alert box or something like that?
It's very odd to special case this. Also, why does autofill depend on the navigator?
It is less data we're sending to the engine on iOS I guess? 
Why do we need to do this filtering on the framework side? Can the iOS embedder just pick the fields that it finds relevant?
This should document what happens if called when not on Android.
```suggestion
  /// input for future use if `shouldSave` is true.
```
And elsewhere in this doc since it is a parameter to the method and not a member of the surrounding context that we can link to.
assert that this is not null?
I think by doing this we would be able to reduce the size of the messages we have to send to the platform every time the focus changes. 
It does get rendered differently I think, for instance `children` and `onValueChanged` on this page: https://api.flutter.dev/flutter/cupertino/CupertinoSlidingSegmentedControl/CupertinoSlidingSegmentedControl.html. Also the LSP client I'm using is able to pick up method parameters that are in square brackets. 
It's nullable, and on dispose action is going to be a no-op when it's null.
We should document what no-op in that case means (and instead of using null, can we define a `AutofillContextAction ` for that?
See also: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#dartdoc-specific-requirements
_isInAutofillContext can never be set to false once it becomes true, is that right?
Yes. If a text field's was in the current autofill context, and then its autofill gets disabled (by setting `autofillHints` to null), the engine needs to remove it from the autofill context. It lets the engine know by sending its new `TextInputConfiguration`, instead of remain silent in which case the engine will just assume the text field is gone and it will keep the old user input (See line 1528).
I wonder why is a separate enum case preferred over `null`? I think in this case using null to stand for "no action should be taken" makes sense too. Is it because the analyzer has exhaustiveness check for enum cases?
lives => live
also have the ability to call => call
they are getting => they are
This is a rather long and informative comment. It might help to briefly summarize how a typical app will use finishAutofillContext, before going deep.  The paragraph at the end of this would serve the purpose.
A typical app can  make sure that no input field is focused but I don't think typical apps have any idea if  "any connected [TextInputClient] is disconnected".  

It would helpful to illustrate the typical form case with a brief example. 

If developers typically need to check if the TextInputClient is connected, we're going to have to explain how.
the default behavior can be overridden by using ...
all these => all of these
autofill context related actions will be automatically taken  => no action will be taken
Question: Since we have only one `autofill context` multiple AutofillGroups can end up in the same context right?
question: If "onDisposeAction" is called on an autofill group, and if it calls "finishAutofillContext", it will still save all the autofill values, is it correct?
Maybe we can reword this part as for example on platform X, "savefor autofill" dialog and disrupts the user's flow. Otherwise it might look like all platforms have a dialog with the same warning message, which might confuse the developer.
Can we also change this method to send "commit/cancel" information as an argument to make it similar to the other methods?
I guess it depends on what the `onDisposeAction` was. The `onDisposeAction`, if not null, is destructive. So if a finishAutofillContext call to save the user input is called after an `onDisposeAction`, that call has nothing to save because the context is destroyed at that point.
Yes
removed the assert so it's no longer a hard requirement.
Update to take a bool. Let me update the engine PR.
The definition on topmost (the ones that are closest to the root widget) is in the comments on line 54. It is not very close to this variable. In order to increase readability of the code, and make it easier to understand by developers checking this variable, let's document `topmost` here as well.
Added a comment in the code.
The formatting is slightly off here. Should be:

```dart
home: Scaffold(
  appBar: AppBar(
    title: const Text('Title'),
    shadowColor: Colors.yellow,
  ),
),
```
I fixed it [here](https://github.com/flutter/flutter/pull/58708/commits/788b6fca084e88ae4d3d4e901f56bbfd66d0884a)!
We should consider what this means for the copy of `DualTransitionBuilder` in the animations package once this makes it into stable. Would we be able to safely remove `DualTransitionBuilder` from the animations package and use this version instead? 

Also, I don't think this'll be a problem, but I'll ask just in case since I'm not sure what will actually happen -- Will there be any conflicts/problems with having both the copy here and the copy in the animations package exist at the same time?

cc/ @goderbauer
We shouldn't import the widgets package in this file since this file is also in that same package. Instead, we should import every file that's needed independently [like this](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/heroes.dart#L7).
If we do bring the builder in here, we should bring in the tests from the animations package as well:
https://github.com/flutter/packages/blob/master/packages/animations/test/dual_transition_builder_test.dart
Did you mean when the animation was _not_ completed?
It might also be valuable to describe how `isCompleted` is used for the `ScaleTransition` as well, since that isn't clearly explained.
Thanks for adding these API docs! 
nit: indentation.
Can you leave the key argument? Even though its not used it's convention to just have it on all widgets.
nit: add a key param
animation has to be non-null, presumably? add an assert?
I'll wait until we have conclusion from Goderbauer about the copy.
This also applies to the other widgets defined in this PR.
Just define the statics in the class in which they are used for cleaner encapsulation. 
I don't fully understand this. Why does the opacity jump to 0.0 when the animation is completed?
Why this? It appears that both tweens produce the same value when the animation is completed?
The container will have to be wrapped in an AnimatedBuilder since you access the animation's value directly, the container needs to rebuild every time the value changes.
Same here as above: why do we jump suddenly when the animation is dismissed?
+1
We should delete it from the animations package and use the one from the framework here. Deleting itself should be fine since the builder was never part of the public interface of the animations package. However while the DualTransitionBuilder exists in two places, I suspect there may be a conflict within the animations package as there are now two competing DualTransitionBuilder definitions. If that is the case, we should hide the framework implementation in the package until this change has made it to stable and then delete the implementation in the package (while increasing the minimal flutter version). 

Can you please check whether the example app in the animation package builds correctly with this change applied to your Flutter version? If it doesn't we will have to hide this implementation in the package before this change can land.
nit: can you turn this around for easier readability: isDismissed ? kAlwaysCompleteAnimation : foo.
here and elsewhere
> Can you please check whether the example app in the animation package builds correctly with this change applied to your Flutter version? If it doesn't we will have to hide this implementation in the package before this change can land.

Got it, scheduled for tomorrow since it's already 2.A.M.
> Same here as above: why do we jump suddenly when the animation is dismissed?

I've update the explanation about why the `isCompleted` and `isDismissed` exist, can you check it out to see if it has enough information for the reason?
Done.
Done.
Using `AnimatedBuilder` to wrap the `Container` will cause the forward transition failed. (For now idk why it'll happen).
The forward builder stays in the widget tree, so the container needs to be transparent otherwise the child will be all in black.
Yes but it produce different value when animating. It require different value between the forward end and the reverse start, as the implementation before.
What do mean statics here? The animation needs access in methods...?
Should this be renamed to `_ZoomEnterTransition` for readability?
`_ExitTransition` -> `_ZoomExitTransition` ?
If we export it here it'll be public for use.
Confirmed, there're conflicts in animations package if we export it.

![image](https://user-images.githubusercontent.com/15884415/83935217-2305f400-a7ea-11ea-9a5f-350bfdc55bca.png)
@goderbauer Confirmed, there're conflicts in animations package if we export it.

![image](https://user-images.githubusercontent.com/15884415/83935217-2305f400-a7ea-11ea-9a5f-350bfdc55bca.png)
Great implement! ‚ù§Ô∏è 
Sounds good to me
Sounds good! 
nit: newline at the end of a file
This is a layer violation. You can't import an implementation file from the widget layer directly into the material layer. The widget layer should export the transition builder so that you can just import `package:flutter/widgets.dart` here.
assert that `reverse` (and probably also `animation`) is not null.
This one is still unresolved, as far as I can tell, there is nothing right now ensuring that the Container gets rebuild when the opacity changes. 
A comment should explain why code is written the way it is, it should not paraphrase the code in words like this one is doing. In particular, this comment should explain why the animation status matters (this is still not clear to me). 
Same asserts here as above.
nit: fix indentation
Instead of `!reverse` express this positively: `reverse` to simplify things.
Oh I thought that we need to hide it from here. Sorry for that.
@goderbauer Is it good to use
```dart
(reverse
  ? _scaleDownTransition
  : _scaleUpTransition
).animate(animation)
```
Or
```dart
reverse
  ? _scaleDownTransition.animate(animation)
  : _scaleUpTransition.animate(animation)
```
It's really hard for a person whose native language is not English üòï. I'm wondering if this looks okay:
```dart
// When the transition is running with the [reverseBuilder] in [DualTransitionBuilder],
// the status of the animation will be always [AnimationStatus.completed].
//
// To ensure the opacity only changed with forward animation, we need to combine
// the [reverse] flag with the animation status.
```
@goderbauer 
Thanks for improving the wording here, the original I left in here was really vague. Let me try to clarify this more, you can use what you think makes the most sense from it and add parts of yours that you think is helpful as well: 
```
    // The transition's scrim opacity only increases on the forward transition. In the reverse
    // transition, the opacity should always be 0.0.
    //
    // Therefore, we need to only apply the scrim opacity animation when the transition
    // is running forwards.
```

cc/ @goderbauer I think I tried `if (!reverse && animation.status == AnimationStatus.forward)` but it did not behave as I expected, but I cannot remember the exact details of the weird behavior. 
```suggestion

// @dart = 2.8

```
```suggestion

// @dart = 2.8

```
I'll take your wording, because the reason I've written which related to the `DualTransitionBuilder` seems unnecessary here.
the docs should also include a description of the constructor (or you can change `///` to `//` to indicate it's not camera-ready documentaion)
```dart
/// Creates a [_ZoomPageTransition].
///
/// The [animation] and [secondaryAnimation] argument are required and must
/// not be null.
```

Something like this?
Or we can remove these comments since the transition is a hidden one.
I think we can keep the comments. What you have proposed looks good to me
I looked into it again for the reason it has to be `if (!reverse && animation.status != AnimationStatus.completed)`. This allows an interrupted reversal of the forward transition to smoothly fade the scrim away.

Using `if (!reverse && animation.status == AnimationStatus.forward)` causes the scrim to instantly vanish if the animation was interrupted while it was transitioning forwards. This results in a disjointed experience, so it's likely better to have the scrim fade away rather than having it suddenly disappear.
So should I take further action with this comment?
I was thinking of waiting for what goderbauer thought, but I think it also makes sense to add a few sentences explaining this:
```
    // The transition's scrim opacity only increases on the forward transition. In the reverse
    // transition, the opacity should always be 0.0.
    //
    // Therefore, we need to only apply the scrim opacity animation when the transition
    // is running forwards.
    //
    // The reason that we check that the animation's status is not `completed` instead
    // of checking that it is `forward` is that this allows the interrupted reversal of the
    // forward transition to smoothly fade the scrim away. This prevents a disjointed 
    // removal of the scrim.
```
Then I'll hold off the commit since there are already 31 commits in this PR. But he has disappeared for a week. ü§£ 
The number of commits shouldn‚Äôt matter for the PR since we squash and merge (everything shows up as a single commit).
Okay then I'm going to mark this as resolved.
Was this change necessary for the fix?
Per adb specs, the `-T` has to be followed with either plain number or quoted timestamp.
And it does fail for me otherwise.
This looks like you're adding the hitmap twice here and below
oh good catch, missed it during the re-sync, removed it
I would assume that this is resolving *from* web, downwards, but it seems to be resolving from web's parent (??)
Its actually from above where we look for dart source. We need to resolve down from the project directory to handle requests like lib/main.dart for source maps, so this is working as expected I think
Ahhh, makes sense. Thanks for the clarification!
We try and reserve the '=>' notation for one-liners that return a value. If you want make this a one-liner then:
```dart
 void _handleDragStart(DragStartDetails details) { _startInteraction(details.globalPosition); }
```

Here and elsewhere.
This can go on the previous line
Need a comment that explains why we're including a Builder here.

Here and below.
Create const Color vars for these values, to make it easier to read the code that checks them.
```dart
() { Navigator.of(context).pop(); }
```
Here and elsewhere.
Please add a comment here that explains why we expect 1 drawRect and 2 drawRRects.
I think if we can't use the => notation is makes sense to have it as it used to be. I think having the separate lines are closer how the formatter works and easier for people to read.
Done
Done.
Done
Done
Updated
This was missing from https://github.com/flutter/flutter/pull/58538.  Handle the null param.
Nit: Parameter list is getting long, add a trailing comma and reformat it
Maybe these consts should be moved to the top of the test and then used above to not duplicate?
Done!
Done!
It's not clear if "the size of the app bar when it is collapsed" is widget.collapsedHeight + [bottom.preferredSize.height] etc, or if it's just widget.collapsedHeight. It looks like you meant the latter, but maybe it should be the former?
Makes sense.

## Collapsed height
After looking more at it, I think collapsedHeight should set the collapsed height excluding any padding. It is similar to how the expandedHeight works:

![Sliver app bar](https://user-images.githubusercontent.com/1770678/83883744-2fd00c80-a744-11ea-948c-b4e78390abee.png)

The user will have to make sure that they do not set a too small of a collapsedHeight, as that could cause overflow error for the bottom widget or hide the title. I am not sure if we need to add any assertions for this, I do not think it should be needed as it is quite obvious.

## Opacity change
I noticed also an issue with how the opacity changes when a user scrolls up, it does not correctly change the opacity for the title in my current implementation, so I will fix this too:
![no_opacity_change](https://user-images.githubusercontent.com/1770678/83883938-7887c580-a744-11ea-9218-8024364f5642.gif)

Here is how it looks like without collapsed height and the opacity changes correctly:
![without_collapsed_height](https://user-images.githubusercontent.com/1770678/83884386-167b9000-a745-11ea-8b2d-58cec2235661.gif)
is => are

I assume that you're describing the default collapsed height here. So "the collapsed" => "the default collapsed"
This property is no longer just the size of the app bar ... It would be OK to say: Defines the height of the app bar when it is collapsed.
is set to => is
If a [bottom] widget is specified, then its ...
then the [MediaQuery] top padding, [MediauQueryData.padding.top], is added as well.
any top padding => the [MediaQuery] top padding
The `collapsedHeight` is actually ignored when `pinned` and `floating` are true and `bottom` is set. See line 1330 in `app_bart.dart`.

But I should respect it, and default it to `0.0` if `collapsedHeight` is not set. I'll do another revision for this, it will require me to update the `toolbarOpacity` calculation though.
NICE, I think this is easier to read then the original truth table.
do we not want to print any error?
Ahh good catch- I deleted too much here
ha ha, catch
Fixed
This seems odd...
perhaps it needed the real project so it could run the real doctor?
I mean the `globals.flutterUsage.isFirstRun` check part circa https://github.com/flutter/flutter/pull/3523/files#diff-1202b4fb926dd6b56d4fb16f50f6baedR50
`globals.flutterUsage.isFirstRun` is always false because it's backed by a `LogToFileAnalytics` which is a `AnalyticsMock` which hardcodes `isFirstRun` to false.
This added nothing
Only show for verbose errors, actual bugs will get logged to stderr
This was fixed several months ago by @aam 
https://github.com/flutter/flutter/issues/35924
When there is an applicationBinary then there was no native build step, so we need to show the flutter run errors as normal
Can you add a comment for when you would want to suppress errors?  Doesn't sound like something you would generally want to do.
done here: https://github.com/flutter/flutter/pull/58539/files#diff-e78651ad5bd5c46811f2b76bc465220bR375
I guess this PR is the crumb trail for the signature as to why you would want to suppress errors (so they aren't displayed twice in certain scenarios).
nit: `@visibleForTesting` 
Looking at this, is it correct that the label (and some of the other properties here) are only published when the slider is interactive? I'd assume a disabled slider should also have a label?
Yeah, I thought that was weird too, but I didn't want to change it without understanding it. @clocksmith, is there a reason for that?
nit: this is the default and could be omitted. 
Is it save to publish these actions when the slider is disabled? My intuition is that despite the disabled flag, TalkBack/VoiceOver will now announce the actions. Can you double check that with TalkBack/VoiceOver?
(see earlier comment): Since the slider is disabled I would have expected it not to have these actions. AFAIK a disabled button also doesn't publish a tap action.
Same here.
Well Talkback seems to tell you what the next increment will be, but not actually increment things, but you're right, it probably doesn't make much sense even if it doesn't do anything.
Done.
Removed.
Removed.
Did you define this one and forgot to copy it over or does it already exist ?
Did you mean `{@macro flutter.dart:ui.textHeightBehavior}`, which is what we are using as the macro in `text_painter.dart`
Thanks for the spot, I updated all the macro references to `{@macro flutter.dart:ui.textHeightBehavior}`
Forgot to remove this on the first go.
I let the tool migrate all these examples by `flutter build ios`ing them.
magic
This was the most basic Apple Swift Package I could find.  When we run the integration test it will check out this dependency from the GitHub repo.
sure hope that repo doesn't disappear...
nit. is the `.toString()` necessary?
nit. can you use a `FakePlatform` instead?
This is the example package used in the [Swift docs](https://swift.org/package-manager/#example-usage) so hopefully if they every remove it they will replace it with some other example we can easily migrate.  Fortunately it's not actually being used anywhere, so it will be extremely trivial to replace with some different package.  
No, copy paste problem.

Actually I forgot about `migrateLine`, I can make this:
```dart
  @override
  bool migrate() {
    if (!_xcodeProjectWorkspaceData.existsSync()) {
      logger.printTrace('Xcode project workspace data not found, skipping build location migration.');
      return true;
    }

    processFileLines(_xcodeProjectWorkspaceData);
    return true;
  }

  @override
  String migrateLine(String line) {
    const String legacyBuildLocation = 'location = "group:';
    const String defaultBuildLocation = 'location = "self:';

    return line.replaceAll(legacyBuildLocation, defaultBuildLocation);
  }
```
I didn't know about `BufferLogger.test()` when I first wrote this file.  Good eye.
I spent a whole day once removing `const LocalPlatform()`'s from tests, so it instantly jumps out at me.
The addition of `frame_rasterizer_begin_times` looks good.

For the order change, considering that most text editors will show the top of a file by default, is it better to still keep the key statistics on top? Or maybe we should only write the key statistics (e.g., average, percentiles) in the summary json file, and write all timestamps in another json file?
Since the output at the end of the run is only loosely related to what is in the file, we could have the output put important information at the end, but the file contain important information at the top. Let me look into that.
Actually, I'll make the changes separately and undo the ordering in this PR.
it looks like all cells are updated. Would it be better to selectively update x% of cells?
Non-updated cells would have to go through `addRetained` and hit the same logic anyway
Changed the benchmark so it's 50% updates and 50% retaineds. The numbers are still the same (as expected), but this should catch regressions in either of the codepaths.
Why do we need the Mixin? Isn't _PageBasedCupertinoPageRoute just a subclass of CupertinoPageRoute that has an extra `page` getter?
Looks like docs are duplicated. Any chance of using a macro?
Why do we need this `page` getter? The class is private and nobody in this file seems to be using it?
Same questions about the mixin and the page getter here.
nit: indentation
The name is not great, not sure what to use instead, though.
Why the indirection via _PageBasedPageRouteBuilder? Could it just return a PageRouteBuilder?
All the override getters below are using it.
I need to override all the property getter in CupertinoPageRoute, i figure it is cleaner to separate out the logic into a mixin
PageRouteBuilder takes in builder methods and they cannot be changed through out the route lifecycle. Let's say someone update the page with same key but different builder, the route underneath will update its settings to be the new page, but it cannot update its builders to be same as the page's builders.

The _PageBasedPageRouteBuilder that builds its transition through the pages builder. That means the builders it use will be up to date when page updates. The same philosophy applies to MaterialPage and CupertinoPage

Does that actually work, though? From what I can tell, the builder is called from `Route.buildPage`, which is only called when the route first builds (as documented). In fact, I believe its result is actually cached somewhere and reused for all subsequent builds of the route. So even if the builder changes, I would expect it to never take affect.

The tests in this PR seem to indicate that it does take effect, though. How are we clearing the cached page?
I didn't see where we cache it in our code, maybe the document is outdated? Even if the caching is true, using _PageBasedPageRouteBuilder will just make the TransitionPage.pageBuilder as responsive as thePageRouteBuilder.pageBuilder but not less.
This is the cache I was talking about:

https://github.com/flutter/flutter/blob/4d7525f05c05a6df0b29396bc9eb78c3bf1e9f89/packages/flutter/lib/src/widgets/routes.dart#L699-L703
The pages update in navigator will called changedExternalState which clear the cache
This is not good, it seems like we only want to call this when pages list actually change. Currently, it is calling whenever the navigator rebuild, and that that is wasteful
well, maybe not that wasteful, because it is just widget build and we do that all the time
Interesting. I believe there are some other properties that are not honored when they are changed after the route build for the first time. `maintainState` is one example I can think of.
I do a little search it looks like `maintainState` is the only persistent flag that doesn't change through out the route lifecycle.

MaterialPage:
builder: ChangedExternalState
fullScreenDialog: ChangedExternalState

CupertinoPage:
builder: ChangedExternalState
fullScreenDialog: ChangedExternalState
title: ChangedExternalState

TransitionPage:
pageBuilder: ChangedExternalState
transitionsBuilder: changedInternalState
transitionDuration: changedInternalState
opaque: changedInternalState
barrierDismissible: changedInternalState
barrierColor: changedInternalState
barrierLabel: changedInternalState
fullscreenDialog:ChangedExternalState

for me, it seems like this is still a reasonable thing to do, what do you think?
`OverlayEntry.maintainState` is a setter, could we call it in `changedInternalState` to sync the Route's maintainState with the OverlayEntry again to make the flag take effect?
make this one private since it is only intended to be used within the class?
private?
the class itself is private. I thought we don't usually make property private if it is already under a private class?
If we would make this class public should this property be public?
I see, yes, that should be private
```suggestion
  /// it is recommended to cache the results of this method if the value is
  /// used multiple times.
```
It might work in this case, but it's generally not a good idea to have explicit timers like this in tests. There are two options. The first option is to use a `FakeAsync` block. I think that might be overkill here. Instead, it looks like you might be able to pass around some `Future`s to await and some `Completer`s to complete to achieve the execution order that you're trying to exercise.
I've replaced this one with a `Completer` to wait on.  I didn't think that particular case would be controversial since it involves a 0-delay timer and a non-zero delay timer, and I expect that timer callbacks would fire in order.

I really don't like the `Timer` in `SlowCrashReporter`.  The point of that is to make `runner.run`'s failure path take longer than the success path if they're racing.  I don't think there's anything along the success path that I can wait on; I can't add a `Completer` to the test-implementation of `exit()` since the fix is to *not* call `exit()` in this situation.

I could add an explicit, global, `@visibleForTesting`-only `Completer` to `runner.dart` that will be completed when we continue down the success path.  That also feels gross, but I suppose it's better than the hard-coded delay.  Is that acceptable?
Does anything go wrong if you do `runCompleted.complete()` here instead?
It seems to work, but it would be a bit more brittle.  If asynchronous work ever occurs after `FlutterCommand.runCommand()` returns, the test could pass when it should fail.
Sorry, I'm not quite getting it. Could you spell this out for me a bit more? What's the sequence of events that would be problematic?
If `CrashingFlutterCommand.runCommand` completed `runCompleted` instead, the desired sequence of events would be:

1. `CrashingFlutterCommand.runCommand` generates an asynchronous error.
2. The `onError` callback from `runner.run`'s `runZoned` call fires.  We proceed down the crash reporting path. `WaitingCrashReporter` waits for `runCompleted`.
3. `CrashingFlutterCommand.runCommand` continues, completes `runCompleted`, and returns.
4. `runner.run` continues in its `try` block.
5. `WaitingCrashReporter` is unblocked and successfully reports the crash.

If execution yields between steps 3 and 4, then step 5 could run first.  If step 5 runs before step 4, a regression where `runner.run`'s `try` block makes its own call to `exit()` would not be detected.
Okay, thanks. I understand the concern now. Other than a stray call in `analyze_continuously.dart`, the tool only calls `exit()` in `runner.dart` and `base/signals.dart`. We should guard against proliferating calls to exit with a more on-the-nose test, but not in this PR. For this PR, I think it would be best to move the `runCompleted` completer from `runner.dart` into the test.
I filed https://github.com/flutter/flutter/issues/59338
```suggestion
      Checks that an iOS app with extensions can be built for physical and simulated devices.
```
```suggestion
Integration test to test building an iOS app with
```
this should probably be `dev.flutter.extensionTest.watchkitapp`, but that's probably a bigger refactor for another day
Not sure I fully understand, a IEEE 754 64-bit double-precision value is always 64bit long and doesn't need any alignment?
Each double value has padding before it so its starts on a 64 bit boundary from the start of the message. The other aligned elements in the standard codec are Int32List, Int64List and Float64List which have "the smallest number of zero bytes needed to align the position in the full message with a multiple of the number of bytes per element".

Both comments aren't super clear to me, but I couldn't think of anything clearer at the time.
Maybe we should say instead:

Zero bytes are added before the encoded double value to align it to a 64 bit boundary in the full message.
This was missing
CocoaPods added this, `disable_input_output_paths` suppresses this behavior.
Why has this test changed?
Why the name change? I think we avoid using 'Apple' explicitly in the framework.
The old name was `buildSimpleRefreshIndicator` which, to me, was accurate in that it was a simple implementation that didn't deal with the complexities of how iOS renders its indicator. Having the full implementation labelled "simple" didn't feel quite right.  Your point is taken about referencing Apple, though, so I've renamed it to simply `buildRefreshIndicator`
The old test used to check for the presence of an icon (the down-arrow) and make sure that the colour of the icon was correct. The change introduced in this PR (which matches iOS implementation) doesn't have an icon any more, so now the test makes sure that the in-progress calculations are correct.
Nit: We usually include the `.0` for doubles, just to clarify that it is a double.
Needs a period at the end of the sentence.  If you want you could probably even simplify this to:

```
// Rotate so that the top tick is the first to be drawn.
```
Should use the American spelling "behavior" per the style guide: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#spell-words-in-identifiers-and-comments-correctly
"animated" => "animates"
Nit: Would it help to include references to the states like `[RefreshIndicatorMode.armed]` here?
Nit: I've been called out on my PRs before for using static methods that return widgets and told to just make a new StatelessWidget instead.  In this case I realize that `buildSimpleRefreshIndicator` was already guilty of this though :) Just something to keep in mind if you see a better way to do this, otherwise it's fine as-is.
Period at the end of the sentence here and two more comments below.
"let's" => "lets"
Should this still be tested in dark mode one way or another?
Fixed. Also updated the `radius` variable above.
Fixed.
Fixed.
Fixed.
I had a couple of goes at trying this, but each attempt resulted in an unwieldy mouthful. 

At the moment, the function description is more like an overview, rather than an explanation of the internal mechanics. As a consumer of this function, I'm not sure if I would really need the gory details, which seem reasonably clear in the `switch` statement further down, but I'm happy to try further if you feel it is warranted.
Fixed.
Fixed.
Excellent question. We don't do anything specific depending on what mode we're in... not sure if the standard practice is to always do a light and dark mode test, or only if the widget actually does something different. Do you know if there's any specific guidance one way or another?
nit: it would make the paint logic slightly easier to understand if `tickFundamentalRRect` starts off from a vertical position, instead of making the adjustment later using `canvas.rotate(math.pi / 2);`
It seems when progress is under 1, setting `animating` to true or false makes no difference visually? Maybe we should `assert(!animating)` if progress < 1 , since `progress` basically takes control from the state's animation controller and it doesn't really make too much sense to have the animation running when progress is manually set?
Maybe the percentage of spinner segments? The value ranges from 0 to 1. Also I think most people would expect the segments to distribute evenly when progress < 1, or even mistake this parameter for something that can be used to configure the total number of segments.
`shouldRepaint` should return true when progress changes. Not sure why it's repainting, maybe it's because the indicator is inside a LayoutBuilder.
If you change the rotate direction here, doesn't it counteract the iteration direction change?
nit: Should this be
```      final int t = (i - activeTick) % _kTickCount;```
so the segment sitting at `i == activeTick` becomes the most visible one, when `progress == 1` (But watch out this changes the direction of the opacity gradient too)?
Maybe mention this color change in the API documentation.
nit: native `UIRefreshIndicator`s dismiss with a 0.3s shrink + fadeout animation (independent of `percentageComplete`)
+1. This is implicitly controlling whether it's static or animating. It should definitely be pointed out in the docs. Perhaps allow null and make it mutually exclusive with animating? Since it's a bit harder to explain that 1 specific value of this double has a secondary meaning. 

I also strongly encourage consistency with https://api.flutter.dev/flutter/material/ProgressIndicator/value.html
optional: but this function would look cleaner if we just drew from the top first (adjust the tickFundamentalRRect if needed) instead of having to rotate twice in the paint. 
Describe also in your code comments how you derived these values. (i.e. when the next maintainer comes to change this, how does that person have more or less confidence that that person applied more rigor in deriving these values than the existing values?)
I wonder if it is worth creating an explicit constructor for the "progressive release" version? That might help with trying to keep the mutually exclusive values separate... not sure if there's any specific guidelines around when we should/shouldn't create a separate constructor?
No, it's not necessary if the change doesn't have any special dark mode behavior. But why was this test replaced?  Could you keep the original test and add your new one, or does the original test conflict with the new behavior?
No worries, I'm happy with leaving it as-is.  Thanks for taking a look.
Ah I see your [response](https://github.com/flutter/flutter/pull/58392#discussion_r434209381) to @Piinks above asking about the same thing.  This is fine as-is since the dark mode specific behavior was removed. üëç 
I think that's a great idea! Many widgets have more than one constructor so it doesn't look like a problem to me. 
Fixed.
Have added a new constructor called `CupertinoActivityIndicator.partiallyRevealed()` but am open to suggestions about better naming (I'm not super-thrilled about what I have now). Also updated some of the internal comments to be more accurate.
Fixed.
Fixed 
There's three things all going on here at once: 1) looping through rendering each tick when spinning, 2) pulling out an opacity for each tick, and 3) incrementally revealing each tick when `progress < 1`.

The first two don't really matter what sequence you do them in (or rotate) as long as you get the indexes correct for the colours (this is because in the finish, all 12 of them need to be drawn). However, the last case /must/ reveal the ticks in specific order (clockwise).
I've adjusted most of the maths to be simpler (well, as simple as it can be)
I've extracted that out into a private constant to be clearer
Fixed
mmm... mostly it was me just stepping through a recorded video frame by frame watching for when the fade-in finished. There wasn't much science to it...  is that still reasonable to document?
Note that I had to update a testcase to reflect this change because the testcase assumes that the 9 o'clock tick is the one that gets drawn first. I added a comment in the testcase for clarity.
I don't want to answer for @xster, but I would say it's definitely valuable to document that. "These values were obtained by stepping through a screen recording of \<native widget\> on \<device\> running \<iOS version\>."

I have lots of comments floating around stating that I just loosely eyeballed some value. It's valuable because if someone comes along with a value they got with a more precise method, they can be confident that their value is better than mine and they should update it.
```suggestion
    // An earlier implementation for the activity indicator started drawing
```
Is the end value (0.2) correct? From what I'm seeing in Xcode the opacity seems to go up to 1.0 based on the drag distance.
This moves the center of the spinner to the top center from the center of the canvas, if the canvas has a big enough size. Is it because the activity indicator needs to be pinned to the top when it's in `done` state? 
Thank for cleaning this up! Now the `_alphaValues` array is a lot easier to reason about.
With 
```dart
const List<int> _alphaValues = <int>[47, 47, 47, 47, 64, 81, 97, 114, 131, 147, 47, 47];
```
the starting position of the activity indicator remains the same (as the current behavior on master, the most visible segment appears at 9 o'clock initially). Since the native activity indicator also starts at 9 o'clock, I think we should keep it as is to avoid introducing breaking changes. 
Yes, I believe so. Note that 0.2 isn't controlling the final opacity... it is shaping the curve so that that the opacity is 1.0 by the time the drag is 20% complete. See example below.

![example_ios_spinner](https://user-images.githubusercontent.com/1574429/84445344-20424d80-ac87-11ea-808c-84b00b9c9fd7.gif)
Yes, precisely. Once the drag is fully complete, `size.height / 2.0` should be the same as `radius`, however where we were coming unstuck was that during the initial stages of the drag, `size.height` is less than the diameter of the spinner and changes as the user drags. This has the undesirable effect of moving the spinner as the user drags down.

By using radius, we ensure that the translation is constant and the spinner doesn't move. I've added some comments to this effect.
I've modified the order of the values in the list so that the most prominent tick starts at 9 o'clock, and have added some comments explaining the meaning of the values. 

Regarding the "breaking" test case... there's a bit of subtlety here. This test case is designed to confirm that the rounded rectangle has been generated correctly and it happens to do so by inspecting the /first/ rrect that is painted.

My implementation draws the first rrect at 12 o'clock, whereas the old implementation used to be at 9 o'clock. However, both implementations still draw all 12 ticks... the only thing that has changed is the sequence that they get drawn in.

There are no user-facing breakages at all. This test case just happens to be very much a white-box test, and we've now changed the internal implementation details. 

Hope that makes sense.
The accurate end value seems to be 0.35. The value is the duration of the `CABasicAnimation` that changes the opacity.
Activity indicator is a public widget so we probably shouldn't change its behavior just to suit our needs. I think we might want to change the `SliverGeometry` the `_RenderCupertinoSliverRefresh` reports to its viewport  (or we can add it to the list of things we want to improve later).
OK, no problems. I'll update to use that value... how did you find this, so that I can also update the comments about how we derived that value? Ta
The value was extracted using Xcode, from inspecting a native app running on iOS 13.5. 
Ah I see. I don't think having to change this specific test makes the PR a breaking change, it was meant to ensure the corner radius scales with the activity indicator. 

What I meant by "breaking change" is the angle of the most prominent segment when `animating` is false. It used to be 9 o'clock and now its 11 o'clock. If we shift the alpha array to `[47, 47, 47, 47, 64, 81, 97, 114, 131, 147, 47, 47]` then it can go back to 9 o'clock. I doubt it will break anyone for real but it would be best if the appearance can remain exactly the same imo.
üëç I think I shuffled those entries in an earlier commit to reflect the original behaviour. All good.
Ah, of course ... that makes total sense. I've reverted that change and pushed a change that manipulates the sliver geometry. 

While I was in there, I realised that the standard iOS pull-to-refresh interaction has a super-subtle effect where the first few pixels of the top tick get drawn out of the clipping bounds over the top of the content being dragged down. By adding the margin to the `paintOrigin` I achieve the same effect... however, it has the knock-on effect of impacting a couple of testcases.

At the time those test cases were written, the widget bounds that it was checking were correct, but I've had to adjust them slightly to accommodate these sliver geometry changes.

Let me know if I'm on the wrong path, or if there's a better way.
Sorry for the delay. Thank you for putting detailed comments in the code!

Is it possible to add a padding to the activity indicator, instead of applying the `paintOrigin` change, and achieve the same thing? My concern is it might hurt the customizability of this widget, if the sliver has a hard-coded top margin.
Also, here's a gif showing the native behavior:
![refresh-control](https://user-images.githubusercontent.com/31859944/84831507-485fe280-afe0-11ea-8576-d216e106f4d3.gif)

The native refresh control seems to become fully visible on screen (in terms of extent) as soon as the drag begins, and fades in as the user keeps dragging the content down.

When the refresh control becomes active (`armed` or `refresh`), it stays at the top unless the user drags the content up far enough, at which point it simply disappears. It reappears when the content goes back down.
I think we can remove the height constraint from the `BoxConstriants` we apply one the `child`: https://github.com/flutter/flutter/blob/a0d8fdf393816cbd222c98e1e15ce3602cc4078e/packages/flutter/lib/src/cupertino/refresh.dart#L136-L143, but that will be a hard breaking change, as it breaks every custom refresh indicator that doesn't have an intrinsic height.
One test is failing because the `Container` is now gone. Could you fix it?
Oh wow this is brilliant :+1: 
hmm... that's weird. Somehow I didn't push that change up. Sorry... changes incoming.
Nit for constant:
```suggestion
const double _kActivityIndicatorRadius = 14.0;
```
I also noticed that in packages/flutter/lib/src/cupertino/activity_indicator.dart above, `_kDefaultIndicatorRadius = 10.0`, is this expected? I wasn't sure if they were intentionally different.
Is this also a constant? 
ah, thanks. Have updated this constant, plus also the margin one you mentioned further down.

The default radius for the activity indicator has been set to 10 since the very initial commit (and it used as a default in the constructor, so I guess forms part of the public API)... any apps that just use the activity indicator (outside of the pull-to-refresh context) would expect for that to remain the same. 

In the pull-to-refresh context, though, the default radius is set to 14 (since the original commit). 
Cool! Thanks for checking!
Should we pass `-Force`? I can't tell from the docs https://docs.microsoft.com/de-de/powershell/module/microsoft.powershell.archive/Expand-Archive?view=powershell-7
The Unix versions throw an exception if the process exits with a non-zero status. Two questions:
1. Should we spawn these the same way with `throwOnError: true`.
2. If the expansion fails, will the powershell process fail with an error?
If `Expand-Archive` fails when the zip file is malformed, I wonder if `verifyZip` could be implemented by using the Windows equivalent of `/dev/null` as the output path.
From my testing locally it didn't look necessary. It is also not used in https://github.com/flutter/flutter/blob/master/bin/internal/update_dart_sdk.ps1#L81
Good question, I'll need to test this locally to verify.
TIL about `NUL` https://stackoverflow.com/questions/313111/is-there-a-dev-null-on-windows
Looking at cache.dart, I'm not really sure why we're verifying the zip. Expand-Archive doesn't extract anything if it fails, so verification seems like we would just be extracting it twice
The powershell process exits with 0, but we can check that the stderr output is non-empty
Is this missing a trailing comma?
ditto
Cool way of doing this that I haven't seen before üëç 
Unused
Can this be `@visibleForTesting`?
I think it could actually be made private again
Done
This should probably be in a try/catch, in case something else was already listening.
Use `globals.printStatus` instead of print.
Where this is located it currently won't work for web builds, since the setup there is a bit more involved. It would also need to be added somewhere to resident_web_runner.dart
It was in the try/catch with `connectToVmService` but probably deserves its own try/catch. So it sounds like if something else is already listening for extension events, then it won't be possible to also attach this listener? If that's the case then maybe the next line (the event processing) should also be in this try/catch too.
```suggestion
        globals.printStatus('\n${json['renderedErrorText']}');
```
nit: I would name this something like "StructuredErrorLog" or something like that so it is more obvious that it has to do with the structured error feature
I don't think this is the right approach. If the structured errors are enabled and we can't listen to this stream, then a user would get no error output. I would say let it crash
This needs to be hooked up somewhere to work, are either of the Hot/Cold runners passing this through?
I would recommend unit tests to validate:

Extension event for non-structured errors is ignored:
Extension event for invalid json is ignored:
Extension event for valid structured errors is OK
this indentation doesn't seem like it matches the flutter style. I think it should be indented 2 and maybe it should be on the previous line.
They both call `connectToServiceProtocol` defined on `ResidentRunner` in their `attach` methods, so that should mean they use the `printErrorEventMethod` defined on `ResidentRunner` too. Are there other places that need to pass in a print method too?
make sure renderedErrorTest is truncated is this is not the first error since reload. If you look at the default onError implementation in Futter it should do that.
the existing output prefixes each line in the error with `flutter: `
@jonahwilliams will this replicate that behavior and is that desirable?
I thought that was only for logs that go through logcat
The first and last situations are tested, but I'm not sure how to test invalid JSON since the JSON seems to be formed (and presumably checked) when the event is created. Would I need to test with different setup or is this out of scope?
Did we copy this from assertions? In that file it's all on one line but exceeds 80 characters, and I got this from Cmd+Alt+L. [80 characters is just a preference](https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#prefer-a-maximum-line-length-of-80-characters) so maybe we should just keep the same as there.
The existing code prefixes with `flutter: ` for my test of throwing an early error, but the new code does not prefix with `flutter: `. I figured since this is similar to the change in the flutter-intellij plugin (using structured errors there will stop prefixing) it would make sense to have the change here but can adjust if the prefix is useful.
I wouldn't worry about invalid JSON then, perhaps just json without a renderedErrorText field?
Without the prefix is fine
```suggestion
    expect(testLogger.statusText, isNot(contains('other stuff')));
```
format issue: single quote instead of double quote
Done.
/cc @gspencergoog I seem to remember that you recently also ran into the problem that "self" is not included when you look up ancestors. How did we solve the problem there again?
I believe these two ifs can be combined into one.
I created [`_getAncestor`](https://cs.opensource.google/flutter/flutter/+/master:packages/flutter/lib/src/widgets/focus_traversal.dart;l=26?q=_getAncestor&ss=flutter%2Fflutter) to fetch the parent so that I can start searching using `getElementForInheritedWidgetOfExactType` from the parent element, which avoids returning itself just by starting the search with the parent element.
And my problem was the opposite: `getElementForInheritedWidgetOfExactType` can return self, and I didn't want it to.
```suggestion
  testWidgets('When isAlwaysShown is true, must pass a controller',
```
```suggestion
  testWidgets('When isAlwaysShown is true, must pass a controller',
```
Will this test pass prior to the change? Before this change the assert should still trigger at the end of the frame right?
I just tried it and it fails prior to the change (so does the corresponding material test).

It does still throw an error though, but I guess it's happening in the post frame callback and so it's not caught by this.
Is `none` exclusively simulators?
AFAIK but it's also a fallback in case they add some new type we can't parse.
Added a clarifying comment.
Thanks
nit: space here to match other `{`

```suggestion
MaterialApp _buildAppWithDialog(Widget dialog, { ThemeData theme, double textScaleFactor = 1.0 }) {
```
so that buttons whose labels wrap to an extra line align with the overall [ButtonBar]'s alignment within the dialog.
Not clear what "edge padding" means here.
It might be a little clearer like this:
```dart
final EdgeInsets defaultTitlePadding = EdgeInsets.fromLTRB(24.0, 24.0, 24.0, content == null ? 20.0 : 0.0);
final EdgeInsets effectiveTitlePadding = titlePadding?.resolve(textDirection) ?? defaultTitlePadding;
```
If we're really doing the exact same thing here (?) it might be better to factor out the code.
It is very similar. The difference lies in the way paddingScaleFactor is applied to each edge (it is skipped for certain edges). The paddingScaleFactor calculation is factored out into a function, but I can't think of how to further factor this out.
Done
replaced with just padding
Done
Should we just say:

This builder must only return a widget and should not have any side effects as it may be called multiple times.
same.
Maybe say something around that it could potentially be called every frame and should not have any side effects.
Same here.
per style guide: avoid empty phrases:

```suggestion
  /// method can potentially be called in every frames and should not have any 
  /// side effects beyond building a widget.
```
same as above.
should this be inside the if case?
I'd rather not change this to be nullable - creating it does not automatically alter any global state (until `register` is called).
And I've updated TestTextInput in another patch to assert that it's registered for any method that wouldn't make sense in an unregistered context.
sgtm
I would modify the assert on line 90 to say
```dart
       assert(disabledElevation != null && disabledElevation >= 0.0),
```

Since `RawMaterialButton` does not allow a null `disabledElevation` anyway.
Yes, that sounds sensible to me.
I agree. This would e a breaking change because the current constructor is const and doing this change requires to remove the const keyword!
You could instead do this:
```suggestion
      disabledElevation: disabledElevation ?? 0.0,
```
Here some context for the problem I managed to find: https://github.com/dart-lang/sdk/issues/36511
Right
Is there already a test for the default value? Just to make sure that we don't regress to not using `0.0` by default.
Actually no, but let me add one right now :)
I am surprised this is not allowed. What if there is an inherited widget that both container and _StatefulLeaf depend on. When the inherited widget mark both them dirty, the container rebuilt without the _StatefulLeaf?
Do we need test for this? 
I'm not sure what you think should be allowed? Can you elaborate?

My intent was for this to test the error message that is reported as a result of a bad `visitChildren`.
The precise message? I can add a test if you like, sure. I hadn't added one for this because I wasn't particularly concerned about whether the message was changed.
Oh Nvm, I was confused at the setup, I think this is fine. We should update the test title to be a bit more clear though.
I think without a test is fine
Why do we care about can pop?
It used to change value (that's why the pages rebuilt, basically). This is mostly making sure that it isn't rebuilding even if it's changing value.
Not sure if I understand, the doc string of canPop does mention it should rebuild when the value changes https://github.com/flutter/flutter/blob/27186c784f593af47c43efe89cd01c50af37d540/packages/flutter/lib/src/widgets/routes.dart#L1393
Ah, I should update those docs. Good catch!
Instead of duplicated here and in the hot runner, can this be inherited by both from the base class?
Done
Didn't this deletion pre-exist the cache.dill optimization? Why is it no longer needed?
since it is a temp dir it gets cleaned up automatically right? Or should we still clean it out manually?
I'd prefer still making an effort to do manual clean-up. The automatic cleanup doesn't work in all situations, for example if the tool is killed by a signal on Windows after `preExit()` runs.
Makes sense, will add it back
Done
Can you please update the constructor documentation to describe that `tristate` can not be null, and that `value` can be null if `tristate` is true?
Done. BTW the prohibition of null value for `isTreeLine`, `selected`, `controlAffinity` and `autofocus` parameters is also missing. But I think this PR is not the right place to fix that. 
sentence should end with a dot
applied!
Learned this trick from https://github.com/flutter/flutter/pull/12079/files#diff-5a9a07600dceb28cbe887a5a64a24b0aR502-R504.
g3 PollingDeviceDiscovery subclasses don't override `startPolling` or `stopPolling`.
Renamed `_items` -> `deviceNotifier`
nit, you can simplify this a bit since `List.remove` returns whether it successfully removed the item:

```
if (_items.remove(item)) {
  _removedController.add(item);
}
```
```suggestion
      },
```
... or something like that
So I'm understanding this correctly: since we're relying on a single long running process now, it needs to restart in case it goes down unexpectedly, otherwise IDEs wouldn't be able to discover new iOS devices without restarting - right?

That's it.
Android Studio's auto indent is confused by this one.  Will fix.
What if the device discovery exits immediately on start up (something is broken). Will this keep scheduling work in a loop? Likewise if this is killed as part of tear down.
`PollingDeviceDiscovery` polling currently schedules a timer every 4 seconds to call device-specific discovery code, so that's the existing behavior.  It depends what we want the behavior to be.  If I `killall` xcdevice (exits 137), I would expect it to get rescheduled and the IDE not to need to be restarted.  However if it just fails in some other way, rerunning it probably won't help?  @zanderso What do you think?

Restarting after `stopPolling` is bad though...
Its a bit of a tricky situation. How common is it for this process to go down during an IDE session? It might be less risky to log a message and move on
I never saw it organically go down in my testing, but I also never saw my hard drive fill up with `xcdevice` caches described in #56826.

Good opportunity for metrics?
yeah, if we're not sure lets measure
It looks like `close()` on the `StreamController` for this `Stream` isn't called, so how does the 'onDone' callback get invoked?
Can you check/assert somehow that you're not blowing away your handle to an active process?
This was the piece I was missing when I wasn't closing `_deviceIdentifierByEvent` on the last commit.  I want polling to be able to be started, stopped, and re-started.  Before, I was avoiding closing it so it could be re-listened to, but I guess it should be closed when no one is listening.

Really I want to be able to pause the subscription and resume it, but the `pause()` documentation says:
```
   * To avoid buffering events on a broadcast stream, it is better to
   * cancel this subscription, and start to listen again when events
   * are needed, if the intermediate events are not important.
```
I also changed this to `--both` to reflect what I just did in https://github.com/flutter/flutter/pull/58257/files#diff-8d108d6a887a4f5b74f7c7d77003e795R97.  Wireless devices aren't being sufaced yet, so if one attaches it will kick off an unnecessary fetch.  Should be rare.
Done.
It is now.  See comment at https://github.com/flutter/flutter/pull/58137#discussion_r432732711.
nit: doesn't need to be async
consider changing to `then` to add the exit code to a trace output.
should this be `== null` ? This gets called from the `listen` from `_setupDeviceIdentifierByEventStream`, but the whenDone nulls out the process: https://github.com/flutter/flutter/pull/58137/files#diff-ebc648b2067d73f2af30539f5d3a59faR389
these should grab the stackTrace too and pass it to addError
It should always be null since as you saw the `whenDone` should handle nulling it out.
https://github.com/flutter/flutter/pull/58137#discussion_r432661646
> Can you check/assert somehow that you're not blowing away your handle to an active process?

I think the concern is there would be a logic error where `_startObservingTetheredIOSDevices` could be called twice without the process exiting.
Oops, I forgot how != worked briefly...
Will also cancel the stdout and stdrerr subscriptions in there.
I believe the stack traces that @jonahwilliams is asking for below will end up here, so consider printing them a long with `error`.
Shouldn't this be async now?
Should this not call `super.dispose()`?
Also, if the super signature was async, this would just be `await stopPolling()`
nit: can you link this to an issue so we know it's safe to remove when the issue is closed?
nit: add the same TODO here so we don't forget to remove this as well?
The issue spans a few different changes required, like updating the engine/framework licenses. WDUT about linking to the PR? (https://github.com/flutter/flutter/pull/57871)
PR's perfect!
Done
Done
This is a little confusing because "which is used" refers to one file. It might be simpler to just say that is generates `stock_strings.dart` which contains the StockStings class.
see `l10n.l10n.yaml` ... => change  the `l10n.yaml` file.
supports => supports locales 
this should be named
isStructuredErrorsEnabled or similar not set. The word set in the name implies a value is set.
this shouldn't be a setter either. A setter should typically take a parameter with a new value. 
This method is more along the lines of
`initStructuredErrorHandler` or similar.
Some of these imports aren't used.
don't import a test from another test. I would move TestWidgetInspectorService to a shared file used by multiple tests.
I didn't see a specific area for utils so just added a _utils file. Not sure if that's what's intended.
is this still needed now that you have the setUp method?
If the error handler hasn't been overridden at the time of setUp you can remove the initStrucutredErrorHandler completely and just set it in the initServiceExtensions call.
TestService is a vague name. Maybe just _TestWidgetInspectorService or similar.
remove print statement.
move this if statement directly into initServiceExtensions. it is just setting the initial value for the service extension.
give a name that describes what this is not where it came from.
maybe: inspectorServiceErrorHandler.
drive by nit: I would give this some sort of namespace so it is less likely to conflict with a user define: flutter.inspector.structuredErrors
Maybe better:

Each run of the animation will have a duration of `period`. If `period` is not provided, [duration] will be used instead, which has to be set before [repeat] is called (either in the constructor or later by using the [duration] setter).
nit: documentation should always include full sentences that end in a `.`
ok updating witht his one.
both times: "period" should be enclosed in ` instead of [ ] since it is just an argument to the function.:

```suggestion
  /// Each run of the animation will have a duration of `period`. If `period` is not
```
Thanks @goderbauer. same error yet !
needs ///
This is a comment though and not documentation (hence `//` instead of `///`). If we want it to be documentation it would have to be moved somewhere else.
1, 1.34, 2
Done!
NVM, forgot about https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use--for-public-quality-private-documentation
This would be a good place for a link to the place in the MD spec where this limit is given.
This comment doesn't help developers reading the API docs however it's an odd enough corner case that I think it's OK to leave it as it is - a private implementation comment.
Added a TODO for this, to add the link when the text scaling is added to the spec. https://github.com/flutter/flutter/issues/58769
You should specify somehow that when this flag goes away the behavior will be to cap the title text scaling by default.
Done.
nit: add a comment linking to the issue
Good call. Done.
nit: add a newline to the end of files
```suggestion
Ayush Bherwani <ayush.bherwani1998@gmail.com>

```
This is the trailing whitespace:
```suggestion

```
But, isn't that a new line? It feels weird that analyzer is complaining about it.
It's not the new line. It's the whitespace within the line. 
```
{whitespace}{whitespace}
```
vs
```

```
I see, thanks for clearing silly doubt @shihaohong.
I'll do the required changes.
I don't like this solution. Ideally the animation should be smart enough to not send animation status update when there is an ongoing gesture. However, I can't think of a good way to do it because the animation is provided from TransitionRoute and we also need to send animation status update when the gesture is lifted.
The letter after _k should be capitalized for these two, and dragging should have two letter g's.

Also maybe add a comment about where these values came from, like whether they're just what felt right to you, or if they were calculated somehow, etc.
Could `pumpAndSettle` work here?
Same for two other cases below.
Is this comment about 0.0-1.0 still accurate with the changes?
So the clamp prevents the animation from finishing by keeping its value between 0.0 and 1.0?  I can't think of a better approach off the top of my head...
So this causes the side effect that there will always be a ballistic scroll at the end of a drag no matter where we dropped it off? 
Is this description right?
no its not, thanks for catching it
I want to make sure the ballistic scroll is small enough that can be neglect by human eyes.
yes, I try to update the test to make sure it just requires a small pump to finish the ballistic scroll that can be neglected by human eyes
Ah I see, sounds good.
One thing that troubles me in this approach is that we push the responsibility, that gesture should trigger animation update when it ends, to the route transition class. I am worrying the third party library developer might trip on this
I think we already crossed that bridge. Since Navigator and Hero are both from the widgets package and heroes.dart is already making use of the user gesture state. 
Does this still work if the user dragged it to the end and dropped it exactly there?
yes we have tests to ensure that https://github.com/flutter/flutter/blob/fed18fc4331e6b109ff96be87cd209730b514246/packages/flutter/test/material/page_test.dart#L541
https://github.com/flutter/flutter/blob/fed18fc4331e6b109ff96be87cd209730b514246/packages/flutter/test/material/page_test.dart#L506
```suggestion
    // The animation will not finish until the user lifts their finger, so we
```
Nit: Same thing, but maybe the error message is more informative if you do this:

```suggestion
    expect(finalPosition, greaterThan(firstPosition));
```
I know you don't like groups, but should we wrap this completer and the test to enforce not re-using it?
Yeah, good point - this is the right place to use one
Done
LGTM
Remove the trailing whitespace (these lines shouldn't be changed.
This sets `_pluginsPath` then immediately resets it to the legacy location if that directory isn't found.  How about something like:
```dart
    final String homeDirPath = globals.fsUtils.homeDirPath;
    String pluginsPath = globals.fs.path.join(
      homeDirPath,
      'Library',
      'Application Support',
      'JetBrains',
      '$id$major.$minor',
      'plugins',
    );

    // Fallback to legacy location from < 2020.
    if (!globals.fs.isDirectorySync(pluginsPath)) {
      pluginsPath = globals.fs.path.join(
        homeDirPath,
        'Library',
        'Application Support',
        '$id$major.$minor',
      );
    }
    _pluginsPath = pluginsPath;

    return _pluginsPath;
```

This is two I/O checks instead of one, though I think that's what we do for spots like https://github.com/flutter/flutter/blob/c2b7342ca470b11cfaad4fbfb094f73aa4c85320/packages/flutter_tools/lib/src/android/android_sdk.dart#L286-L294.
Added via d6eb051
Added via 6205755
why did you parse these into `int`s?
These lines were moved from [line 923](https://github.com/flutter/flutter/pull/57963/files#diff-255359560ed70a721505c86fd02ff145L923).  Not the best way to do it, but that's how it was done before.
I used it to check the major and minor version numbers. It was simpler to compare these as int since the can be easily converted back to strings.
Oh wait @christopherfujino is right, I totally misread this.
The original `intellij plugins path checking on mac` tests thought they were using these two Info.plists, but they actually weren't...
Unused, delete.
Right, in the previous version I used an if to check the version numbers. I think the ints can be removed now since they are not used. Can I push an update to this?
You can revert them back to `String`s now that you aren't actually checking if it's `> 2020`
Done
Ahh, again demonstrating the difficulty of reviewing different versions of a PR on github. Thanks for updating, @Nash0x7E2 
could we add a comment here to explain why we have two paths?
üëç I had suggested a comment in https://github.com/flutter/flutter/pull/57963#discussion_r430725149
Code updated with comment üëç 
@igorakkerman this check should be preventing the issue that you are describing.  I have created a new app and imported `shared_preferences`, I don't see this issue.
@blasten Indeed, I could not reproduce the issue with the current `shared_preferences` package, sorry for that. But I do get the message with `location` and `firebase_core`.

I created a flutter project where the issue appears: https://github.com/igorakkerman/flutter_57907_example

```
> flutter clean
Deleting build...                                                  319ms
Deleting .dart_tool...                                               7ms
Deleting Generated.xcconfig...                                       2ms
Deleting flutter_export_environment.sh...                            1ms
> flutter pub get
Running "flutter pub get" in flutter_57907_example...               1,2s
> flutter run
Using hardware rendering with device Android SDK built for x86 64. If you get graphics artifacts, consider enabling software rendering with
"--enable-software-rendering".
Launching lib\main.dart on Android SDK built for x86 64 in debug mode...
Plugin project :firebase_core_web not found. Please update settings.gradle.
Plugin project :location_web not found. Please update settings.gradle.
Running Gradle task 'assembleDebug'...
Running Gradle task 'assembleDebug'... Done                        38,0s
‚àö Built build\app\outputs\flutter-apk\app-debug.apk.
```
Feel free to reopen this PR again (It got rolled back).  It's good to remove any reference to .flutter-plugins in the plugin.
Thanks, @blasten. I re-opened it as #59294 .
extra newline
Done
was this note wrong or did it get fixed?
It was wrong, per our discussion a while back :)
I guess we talked about it like, months ago, but seems like it was last week!
nit: trailing comma
```suggestion
    this.contentPadding,
```
Just a suggestion for improvement to the wording, but you can do something else that might make more sense to you. I'm trying to use wording to distinguish between the insets for the entire tile vs. padding that insets every single widget in the tile (ie. 10px padding surrounding the tile's entire contents vs 10px padding surrounding checkbox, 10px padding surrounding title, etc).
```suggestion
  /// Defines insets surrounding the tile's contents. 
  ///
  /// This value will surround the [Checkbox], [title], [subtitle], and [secondary]
  /// widgets in [CheckboxListTile].
```
Can we specify a size for the Container to make this example a little clearer? Or maybe use a SizedBox?
Done
This should probably also have a width if we specify a height.
Done‚úî
Uber nit: Link to https://flutter.dev/docs/deployment/android#what-are-the-supported-target-architectures
Ahh, good idea!
Please fix the typo.
https://github.com/flutter/flutter/pull/61548
Not sure if this is too strong
That looks fine.
This change shouldn't be included in the PR
fixed (removed this from pr)
Is there a reason we're only testing this on macOS? If so, we should document what the reason is since it's probably better to test this behavior on all platforms
@shihaohong yes, this is redundant. Removed it.
Add 
```dart
      // Hover animation should not trigger an exception when the checkbox is removed
      // before the hover animation should complete.
      expect(tester.takeException(), isNull);
```

This signifies to future readers or contributors that the point of this test is that an exception does not occur in the above situation.
@shihaohong added.
Since this class is abstract anyway I would leave out the empty outputs

Moved down to the subclasses.
complitaion -> compilation :)
Oops!
You should also account for textScaleFactor being less than 1, since this will result in a negative number. It might be easier to just use `MediaQuery.of(context).textScaleFactor - 1.0` and then clamp it between 0 and 1
Looks like a bunch of formatting changes snuck in, can you please undo those
Add new line back in
Add new line back
Undo formatting
Undo formatting
Undo formatting
done
Done
Done
done
done
Done
Done
Done
Done
Nit: Reduce indentation to match above.
Done.
This would be a good place for a comment based on this PR's description:

> Now the chip starts with 8px on each side and as text scaling gets closer to 2 the label padding is linearly interpolated from 8px to 4px. Once the widget has a text scaling of 2 or higher than the label padding remains 4px.
lightTheme => darkTheme
lightTheme => customTheme
The original test was inexplicably testing for anyOf(n, n+1). Shouldn't your test do the same?
Done
Done
Done
Done

Updated because of this ticket: https://github.com/flutter/flutter/issues/12357
Now the => The 
2 or higher => 2 or lower
It should remain 2 or higher because the widget will have 4px label padding only if the text scaling is 2 or higher.
Done
What happens when the text scale factor drops below 2? That seemed to be the point you were trying to make here, since the first sentence describes what happens as the text scale factor decreases towards 2.
The chip starts with 8px on each side and as text scaling gets closer to 2 the label padding is linearly interpolated from 8px to 4px. 

If they text scaling decreases towards 2. Lets say text scaling is set to 3 and if we change it to 2 than the label padding remains 4px.
And what happens when the text scale factor drops below 2?
The chip at text scale 1 starts with 8px on each side and as text scaling gets closer to 2 the label padding is linearly interpolated from 8px to 4px.
Thanks for updating the comment, that's better.
Done
Could you write these tests to be similar to [this example](https://github.com/flutter/flutter/blob/51cf4b327850042c313ed356cc2dbdac91b18d64/packages/flutter/test/material/app_bar_test.dart#L151)?

It's preferable to check for the locations of the titles rather than checking that a property is `true`/`false`. The concern here being that there could be a bugs where `centerMiddle` is set to `true`, but the render object decides to place itself in a non-center location.
Could you write these tests to be similar to [this example](https://github.com/flutter/flutter/blob/51cf4b327850042c313ed356cc2dbdac91b18d64/packages/flutter/test/material/app_bar_test.dart#L151)?

It's preferable to check for the locations of the titles rather than checking that a property is `true`/`false`. The concern here being that there could be a bugs where `centerMiddle` is set to `true`, but the render object decides to place itself in a non-center location.
Could you write these tests to be similar to [this example](https://github.com/flutter/flutter/blob/51cf4b327850042c313ed356cc2dbdac91b18d64/packages/flutter/test/material/app_bar_test.dart#L151)?

It's preferable to check for the locations of the titles rather than checking that a property is `true`/`false`. The concern here being that there could be a bugs where `centerMiddle` is set to `true`, but the render object decides to place itself in a non-center location.
Nice, this is a good test to add! 
I had written a similar test, but then I thought it might not be relevant cause `AppBarTheme` is only responsible for providing the value and not rendering the widget.
Said that, if I check the offsets for the `title` it would like writing a test for the `AppBar` which we are already doing.
 
WDYT, should I check the offset of `title`?
I think your reasoning makes sense. I just posed the question in the `hackers-framework` channel of the `flutter` Discord channel to see if anybody has any thoughts about this. I don't really have a good answer except that I felt that checking the rendered location felt "safer" :) 
Sure, I'll follow up üòÉ 
The existing test should be good to go!
The existing test should be good to go!
The existing test should be good to go!
the `emulators` command for listing emulator images is not the same as the `avdmanager` command for launching/creating them.
These are the same, just moved into the class
This is the check that prevents the crash
I hoisted the logic out of the MockProcessManager in favor of listing out the exact commands with the FakeProcessManager
This is the only way I can think of to keep the MethodChannel class const constructable. Making it non-const is probably pretty breaking, and we can't otherwise compare the handler functions properly.
I would be open to guarding these for release mode, but wouldn't want them to be assert guarded since we might want to use this functionality for e2e tests in profile mode.
My rationale for not considering this breaking is that this is an unusual test-only implementation that implements instead of extends. I checked the internal repo and all other cases like this use mockito and won't need to be updated.
We are also running e2e tests on release mode. For example, sometimes a functionally doesn't work in release mode.
Autofill functionality is relatively very new. I think that is why no tests will be breaking.
This wouldn't have broken any tests either, but the class in here is just a pure implementation rather than a mock, so it needed to be updated for this. I don't think this is a particularly common thing to do though.
```suggestion
/// This sample code shows a scroll view that contains two [SliverList]s,
```
I recommend extracting the key to a variable so you don't duplicate it below
Done.
Good point, done!
nit, remove .0 for consistency with the rest of the example
here too
The height needs to be a double though, and the other ints
I'll mark it as resolved
Need to start out by explaining why we're setting the scroll view up in this way.
I updated the description now, to try to explain the use case.
Here's a word-smithed version, see what you think:

By default, if items are inserted at the "top" of a scrolling container like [ListView] or [CustomScrollView], the top item and all of the items below it are scrolled downwards.  In some applications, it's preferable to have the top of the list just grow upwards, without changing the scroll position. This example demonstrates how to do that with a [CustomScrollView] with two [SliverList] children. The top one SliverList will grow upwards, and the bottom SliverList will grow downwards.
It would be helpful if we consistently referred to the second sliver list as the "bottom".
second => bottom
I like this! That's better. 

I only changed one sentence to mention the center key part:
```This example demonstrates how to do that with a [CustomScrollView] with two [SliverList] children, and the [CustomScrollView.center] set to the key of the bottom SliverList.```
Done.
intractibility = interactability 
However, "interactability" isn't really a word. Suggestion:

This kind of [MouseCursor] is useful when the set of interactive actions a widget supports varies with its state.
Since this cursor is typically the default for Material widgets, maybe call it DefaultMaterialMouseCursor?

Although ... see comments about maybe merging this class with MaterialStateMouseCursor.
This cursor is typically the default for Material components.
This cursor should only be used for [MouseStateMouseCursor] parameters.
Instead of making this class abstract, could we combine it with ClickableMouseCursor so that it would serve as the default cursor as well? Subclasses could use super.resolve() to produce the default cursor.
Maybe: A mouse cursor that resolves differently for enabled and disabled components.
This whole expression is nicely coded.
Could be `return super.resolve(states)` per the comment about merging this class with Clickable...
NICE
I forgot to make this required, and it was null - causing the failure.
How did that pass the Cirrus tests the first time?
I guess no integration test hit android device discovery for real.
FWIW I did test the change initially, but not after I updated device discovery ü§¶ 
nit: maybe call this flushObserverNotifications? (similarly to the _flushRouteAnnouncement below).
As an idea: maybe use a polymorphic approach: 

* remove this enum
* have an abstract `void notify(List<Observers> observers)` on _NavigatorObservation
* have subclasses for the various actions that implement the correct notification dispatch for the observation.

That also avoids the big switch below
I'd maybe add a line of comment here to just say that this was added as a "reminder". You can obviously check your key into your (ideally private) repo if you want. It's not "unclean" unlike say GeneratedPluginRegistrant.java. 
Good idea.  Is that comment okay?
LG
substituting `{` -> `(` means the function body runs in a subshell? I've never seen this before...
Yes, that's what it means.  That's why I added the comment too.
any particular reason for `3` -> `7`?
Seven is a larger number (and thus less likely to be used by something else). It's really just defensive: 3 is probably fine 99.999% of the time.
Besides, seven is lucky. :-)
I was 99.999% sure that was the reason...
(about it being a larger number)
input meaning `$file`? when will that ever resolve to `/`?

When I remove the sed substitution and run this from `/`, it seems to work fine.
If the script location is a link to `/`. Yeah, it's not even really valid.

I mean, we could just assume that it'll never happen, and not invoke `sed` at all. I have a feeling that the reason it failed in https://github.com/dart-lang/sdk/issues/28143 (the reason for that URI transform) was because of the difference between `dirname` and `${file##*/}`.
Thanks for the link, for future excavation there's further discussion in https://github.com/flutter/flutter/issues/7279.

I agree with your assessment the substitution was probably because we used `${file##*/}`. I think we should remove the sed substitution, because if in the future we get double slashes, it will be a different regression and we should probably catch that.
nit. should we print a newline here? when I issued `dart -h` while another process had a lock, it looked like this:

```
~/git/flutter$ bin/dart -h
A command-line utility for Dart development.se the startup lock...
```
The reason this prints with a return is that the Dart code itself will start up and lock, printing that same message.

So, with the newline, it can look like this:
```
~/git/flutter$ bin/dart -h
Waiting for another flutter command to release the startup lock...
Waiting for another flutter command to release the startup lock...
A command-line utility for Dart development.
```

Maybe printing it twice is better than printing it once and sometimes overwriting it, but...

I had an idea: the code now prints
```bash
printf "                                                                   \r"
```
when this lock is released, and then if the Dart code locks, it'll just flicker once, and then there's no confusion.  Does that work?
there's a lot of duplicated content here, might be worth seeing if there's a way to factor it out so the branches are only the pieces that differ
these can all just be on one line
here and in other places where you have build methods, might be better to factor those out into their own widgets
Can you turn this into a TODO saying to remove the workaround, and reference the issue that describes the bug (and if there isn't one, please file one)?
I think this should default to returning null, since if a finished localization doesn't define a zero case, then it will fail to compile:
```suggestion
  String get licensesPackageDetailTextZero => null;
```
Shouldn't we just skip (and not display) any packages that have no licenses at all? That way we don't need to do translation for the zero case. You could update the description to say that it isn't allowed to have a value of zero.
Use a more descriptive name for `sc`.  (e.g. `scrollController`).
localisations => localizations. We try to use American English spellings, for consistency.
We try not to have "magic" numbers. It's best to have a constant for each of the numbers like this, so that they're self-documenting.

For instance:

```dart
  static const int _narrowGutterWidthLimit = 720;
  static const int _wideGutterSize = 24;
  static const int _narrowGutterSize = 12;
```

https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-mysterious-and-magical-numbers-that-lack-a-clear-derivation
Use a more descriptive name for `a`.  e.g. `detailArguments`.

https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-abbreviations
Here, and the next `Container`, please define this constant as a separate static const variable to make it self documenting.

Also, consider using a `SizedBox` instead of a `Container`: `SizedBox` can be a const object, and so it's more performant.
These can be `static` strings.
Consider breaking out this function, and `_lateralUI` into separate `StatelessWidget`s.
Use a more descriptive name for `sc`.
Make 840 into a constant with a name.
If you skip packages with zero licenses, this case should assert.
Perhaps skip packages with zero licenses?
Doesn't one of these need to return `1` to keep the first package at the front? Seems like if it returns -1 for both a and b being the first package that it'll be ordered arbitrarily.
All of these "Zero" cases would be eliminated if you skip packages with zero licenses.
Of course. If b is firstPackage, then a > b, therefore return 1. Thanks.
The license page is an inversion of the data hierarchy. LicenseRegistry collects licenses and includes the packages from which those licenses came from as a property on each license. As such, there is a many-to-many relationship between licenses and packages with the constraint that each package has at least one license, and each license has at least one package.

So the zero case is not checked for, since by implementation, it should come up. However, it is undeniably more robust to add checking for, and the exclusion of, packages that have zero licenses. _So I will do this._

However. I would like to highlight, should you include special dispensation for zero license packages, it may be arguable that it is better to highlight packages with zero licenses by using a special unlicensed, or commons, page. But, I also suggest that it is unneeded and zealous work to add this. We should never normally encounter packages with zero licenses. Unless, of course, there is a design change down the line.
I just realised why this zero case keeps getting regenerated. It is coming from the default text generated for the different locales from when I ran gen_missing_localizations.dart as instructed to do when adding to material_localizations.
I said below in https://github.com/flutter/flutter/pull/57588#discussion_r443198697 that I would do this. However, going over the code again it really is already the case that each package always has one or more licenses. This is because we only know about a package should it be recorded as a package to which a given license applies.

Obviously the code must not be clear enough as is, so I'll go through this part and added comments to try and clarify it.
Thanks.
Sorry. It looks like I was trying to avoid the stuttering caused by the cast. The style guide should have been followed.
You're right. I remember thinking I would fix this when I wrote it. I clearly didn't.
Ah, the z. It kills me. Yeah, okay, I should have stuck to the US spelling no matter how it does the head in.
Thanks.
Thanks.
Added assertion licenseCount >= 1, removed case 0.
Be consistent about doubles: either use `16`, or `18.0`.
Okay, I'll go through the change list and conform to `18.0` everywhere. On closer inspection it seems to be the convention.
This print (and probably the entire gesture detector?) should probably be removed?
Ooh, yes, good point.  @TonicArtos can you take care of that?
Yes. It is late here. I'll get caught up and get the fix sorted tomorrow.
OK, no huge rush: most of us will be on holiday until Monday (it's Independence Day in the U.S.).
I went through my journal. It turns out the GestureDetector is left from when I was looking at #59741. I forgot to remove it once I figured what was happening.
PR #60730 Remove superfluous GestureDetector.
@TonicArtos 

Why did you specify `theme.primaryTextTheme`?

It may break color system when `AppBarTheme` is used for example.
Indeed, it broke my background color.
I would have preferred for this to (private) widget to have been factored a little differently - to not have used primaryTextTheme.

If you can file an issue with a simple test case that demonstrates a regression, we'll try and fix it.
@HansMuller 

> If you can file an issue with a simple test case that demonstrates a regression, we'll try and fix it.

Okay, I've created an issue: #63239.
@HansMuller 

I tried to fix at #63249, but I‚Äôm welcome to be closed and refactored by your pull request.
> I would have preferred for this to (private) widget to have been factored a little differently - to not have used primaryTextTheme.
> 
> If you can file an issue with a simple test case that demonstrates a regression, we'll try and fix it.
> 

Sorry about the issue. What do you think the original solution should have been?
@TonicArtos 

> What do you think the original solution should have been?

I think #63249 is the simplest fix for existing implementation.
Wondering if for consistency, this should use "v2" or "new" so as to not be confused with other benchmarks
Yes! I'll use `gallery_v2`. Thank you!
Done.
Is this  number (5) similar to other tests that have recorders?
The other tests with recorders use the default warm-up frame count of 100 (the first 100 frames are ignored).

From what I understand, the other tests mostly contain animations ‚Äî for example, [bench_card_infinite_scroll](https://github.com/flutter/flutter/blob/master/dev/benchmarks/macrobenchmarks/lib/src/web/bench_card_infinite_scroll.dart) is an infinite scrolling test. The frames are very similar, so the first 100 frames are ignored in a total of 300 frames.

The Gallery test opens up different studies and widget demos, and there isn't any animation at the beginning, so the actual warm-up frames should be much fewer than 100.
2020. Check all new files.
This is fine. We like putting old years on everything. Makes us look retro :)
I'm not sure 5 frames will be enough to warm-up the JIT. I'm wondering if it makes sense to control the warm-up based on higher-level concepts, such as "the number of demos opened", just like you decide when the benchmark is `_finished` based on demos exercised.
The word "demo" is too specific to the gallery to be used in this file. Let's give this a more generic terminology, maybe `printToConsole` for method/function names and `consolePrinter` for objects/closures. Instead of "report" I'd use "message".
The urls will need to be updated before merging.
Have you found out if there's a way to not have to list all the assets? /cc @jonahwilliams 
Let's use a more generic terminology so other benchmarks can use this.
We should make these available to all benchmarks, and in a way that each benchmark doesn't have to do this plumbing. For example, we could have top-level functions `printToConsole` and `printErrorToConsole` that any recorder can call. During the setup (first thing inside `_runBenchmark`) this file would redirect those function to `_client.reportDemo`, etc.
Jonah responded me. Wildcard is not supported for assets, so we have to list them.
I think the best way is to add the new assets to `flutter_gallery_assets`, and bump up the version.
`printToConsole (String message)` and `/print-to-console` look good to me.
The gallery recorder can be constructed as:
```dart
  GalleryRecorder(
    benchmarkName: '${_galleryBenchmarkPrefix}_animated_widgets_perf',
    consolePrinter: _client.printToConsole,
    errorPrinter: _client.reportError,
    runCriterion: (String demo) =>
    typeOfDemo(demo) == DemoType.animatedWidget,
  )
```
`/print-to-console` (see above)
## Print reports

**Is it good practice to use top-level functions that can be reset?**

I like this solution, and I can implement it if there's no restriction.

My idea is adding `printToConsole` to `recorder.dart` as a top-level function, and setting it to `_client.printToConsole` in the `main` function in `lib/web_benchmarks.dart`.

## Errors

I just realized that `web_benchmarks.dart` already handles errors:
https://github.com/flutter/flutter/blob/77ea2da7464a0c2801d9aad4214483b43b235f5b/dev/benchmarks/macrobenchmarks/lib/web_benchmarks.dart#L96

I would remove `reportError` for the `GalleryRecorder`s, and let `GalleryRecorder` raise errors directly.

Added a TODO.
> Is it good practice to use top-level functions that can be reset?

It's not my favorite, but that's the pattern that Flutter uses quite extensively.

> I would remove reportError for the GalleryRecorders, and let GalleryRecorder raise errors directly.

SGTM. Do you need to pass it to `GalleryRecorder`?
`/print-to-console` SGTM
We shouldn't need to pass `consolePrinter` and `errorPrinter` to `GalleryRecorder`. It should be just:

```
  GalleryRecorder(
    benchmarkName: '${_galleryBenchmarkPrefix}_animated_widgets_perf',
    runCriterion: (String demo) =>
    typeOfDemo(demo) == DemoType.animatedWidget,
  )
```
We prefer to use present tense in docs: "accepts", "returns".
We prefer the term "predicate" instead of "criterion".
This line should be indented.
This line should be indented.
Should `runCriterion` be necessary if the benchmark `testScrollsOnly`?
I am working on updating `flutter_gallery_assets`.
> SGTM. Do you need to pass it to `GalleryRecorder`?

I don't think we need to pass `_client.reportError` to `GalleryRecorder`. Errors are automatically caught by `web_benchmarks.dart`, so when I need to report an error, I'd raise it from the `GalleryRecorder`.
I can make `runCriterion` (`runPredicate`) optional, so it can be left as `null` in this case.
I like "predicate". I'd change it to `shouldRunPredicate` in this case.
@yjbanov 

I worked on this a bit more and realized:
- If any **async** exceptions were thrown inside any of these `Recorder`s, it wouldn't be caught by the `catch` statement in [lib/web_benchmarks.dart](https://github.com/flutter/flutter/blob/master/dev/benchmarks/macrobenchmarks/lib/web_benchmarks.dart#L96)

This happened with `GalleryRecorder` so I noticed it. It didn't catch the exception, so the program inside Chrome was paused, and the driver (tasks/web_benchmarks.dart) was always waiting for an answer.

A possible solution is wrapping the entire `try { ... }` block in a zone, so that **any** exception in this zone, async or not, are caught and reported.
(I think you mentioned zones earlier.)

If we use zones, it would make `printToConsole` unnecessary too, since we can also use a print handler on zones.

What do you think?
@yjbanov My response is below at https://github.com/flutter/flutter/pull/57576#issuecomment-633480886
I think it's a great idea! It will catch the cases when some asynchronous error affects what we render, which could lead to false benchmark numbers.
SGTM
Updated to remove `reporter` and `reportError` for recorders.
Updated to include all assets. `flutter_gallery_assets` is upgraded.
Done.
Replaced `try ... catch` with zones. I did an experiment, and it turns out zones can catch synchronous errors too.
Done.
Done.
Done.
Done.
Done.
If we reach this line and `_isMeasuringFrame` is false, doesn't it indicate that there's a bug in the benchmark or in the recorder? If so, we should probably throw an error rather than silently keep on trucking.
What do you think of using a strategy pattern? We could have an abstract `WarmUpStrategy` class with default implementation, which could be replaced by a custom one. Then there would be no need to check `if (useCustomWarmUp) ...`. The API of the strategy class could be something like:

```dart
abstract class WarmUpStrategy {
  bool shouldContinueWarmUp(Profile profile);
}
```

For as long as `shouldContinueWarmUp` returns `true` the warm-up continues. As soon as it returns `false` we start measuring.
nit: I'd call this `isWarmUpValue`.
nit: we prefer `_warmUpFrameCount += 1` syntax.
no space between `!` and `useCustomWarmUp`
ditto
nit: s/report/message/
This pattern takes care of the following scenario:

If the `isWarmingUp` flag is set to `false` when a frame is **being** measured, then the `startMeasureFrameSkippingWarmUp` method, which was called **before** the switch, would not start measuring a frame. So, the `endMeasureFrameSkippingWarmUp` method, which is going to be called **after** the switch, should not call `endMeasureFrame` either.

If `_isMeasuringFrame` is false, this means we were still in the warm-up phase when the proposed measured frame starts, so we should not measure this frame.

If we just decide whether to call `startMeasureFrame` and `endMeasureFrame` based on whether we are **currently** in a warm-up phase, then in the scenario above, `endMeasureFrame` would be called without a `startMeasureFrame` call first, causing an error.

So, it's to make sure that `endMeasureFrame` is called only when a `startMeasureFrame` has been called earlier.
Done.
Done.
Done.
Done.
Done.
There are some tricky issues we have to consider.

1. What API should we use to reconcile these two very different strategies?
    * In the **default** implementation, everything **except** the last 100 data points of each `Timeseries` is warm-up, so we are only able to determine the warm-up data points **after** we have all the data points recorded.
    * In the **new** implementation, the `Profile` marks data points as warm-up along the way.
2. Different `Timeseries` within a `Profile` may have different lengths.
3. Similarly, we are unable to skip warm-up **measured** frames (for "total UI frame") in the default implementation. Since we don't know how many data points we would have in the end, we cannot know where these "last 100 data points" begin, and therefore we cannot know when the warm-up ends.

I did a quick experiment. It turns out that all **existing** benchmarks record exactly 300 data points for each `Timeseries`, so the first 200 data points of each `Timeseries` are warm-up.
I suggest switching the **default** logic to using the **first 200** data points as warm-up. This should not change existing behavior, and it's easier to know which data points are warm-up as we go.

In this new setting, the default `shouldContinueWarmUp` would be
```dart
bool shouldContinueWarmUp (Profile profile) =>
    profile.scoreData.isEmpty || !profile.scoreData.values.every((String timeseries) => timeseries.count >= _kWarmUpSampleCount);
```
and the new `shouldContinueWarmUp` would be
```dart
bool shouldContinueWarmUp (Profile profile) => profile.isWarmingUp;
```
Let's keep this as-is for now. We can introduce this in a later PR.
Modified according to discussion.
This is not needed, we do this check for warpping > 1 tab because it is physically changing the children order.
```suggestion
      return Future<void>.value();
```
why do we remove the listener? can we keep it until the end?
Aha! I get it. Will remove this check, thanks!
Oh, I thought doing `return;` and `return Future<void>.value();` was just the same thing. Sorry, will change this too.
yes, they are the same, but we might want to be consistent with other short circuit in this method
You're right. I naively thought `tabController.index = 1;` will invoke `pageControllerListener()` but it doesn't, cause page animation starts from next frame. Checked it working without removing it here, will apply it now. Thanks :)
Nice, thank you
Remove print
In range slider, you do this logic at the end of the dispose method, I'm not sure if the order is important but either way it should be consistent between both.
Looks like divisions isn't used, and is hardcoded to 3 below, was that intentional?
Looks like divisions isn't used, and is hardcoded to 10 below, was that intentional?
```suggestion
        ..rrect(color: const Color(0xff2196f3)) // Active track.
        ..rrect(color: const Color(0x3d2196f3)), // Inactive track.
```
```suggestion
            ..rrect(color: const Color(0xff2196f3)) // Active track.
            ..rrect(color: const Color(0x3d2196f3)) // Inactive track.
      ),
```
Done
Done
Done
It wasn't intentional a lot of the method use buildApp in the slider and range slider test. To keep it consistent I also used the similar format. I used the divisions variable but it doesn't change anything 
Done
Done
We're not checking to see if parentBox is null here.  More importantly, I assume we're failing to do some work in _RenderSlider.detach: when the Slider is detached, we should be removing the value indicator's overlay entry. In other words, we shouldn't end up here if the slider is detached.
I tried removing the value indicator from the slider detach method but that wouldn't work because it would still appear as attached by the time it got to this part of the code. 

It was similar to the lag issue we were having with the overlay and so was the solution. Instead of checking if the parentbox is attached I am checking from the paint methods with an overlay. 

This is easier to understand through the commit changes.

https://github.com/flutter/flutter/pull/57535/commits/6b4636afcdc7f8851786e3dabd9d8e141dc9c885
If this really needs to be `firstRenderObject` please add a comment explaining why. It seems like `renderObject` would be sufficient.

Here and below.
The value indicator is added to the overlay when it is clicked or dragged because both of these gestures are occurring then it adds same value indicator twice into the overlay.
Is this right? it's a bit different from the original doc. What happens if it's not?
Updated the doc to explain the suggestion. I believe they're roughly equivalent (has no effect if too early, invalid if too late)? 
typo
Tip: this one is easier to review with whitespace changes ignored:
![Screen Shot 2020-05-18 at 3 20 17 PM](https://user-images.githubusercontent.com/682784/82265117-1d1fa000-991b-11ea-9ee9-6ff3a803d0c0.png)
I think this is true, but it's a little bit difficult to parse. Maybe

> By default, containers return false for all hit tests. If the [color] property is specified, the hit testing is handled by [ColoredBox], which always returns true. If the [decoration] or [foregroundDecoration] properties are specified, hit testing is handled by [Decoration.hitTest], which also always returns true.

It's a little unsettling to be documenting such behavior of other widgets, but I don't see how that could change without some kind of break anyway at this point.
I don't think it's fair to say `Decoration.hitTest` always returns true, since the subclass will very likely override it, such as in [ShapeDecoration](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/painting/shape_decoration.dart#L286).
Other than that, I've updated the doc. Thanks for the suggestion.
uber nit: this looks a little weird in `widgets`, I guess it's so you can use `Colors`?  I have a vague hope that someday we could run tests based on what they import, and things like this will probably have to be rewritten. But it happens elsewhere, it's ok to leave for now.
Moving these into the context so that they can use zone values in the constructor
Making creation lazy, so that we can setup the zone and inject feature flags/platforms to commands directly. This will let us avoid globals in the commands classes, and also gate commands like `build web` behind the right flag
Will we be able to get verbose logging from the daemon anymore (I was literally using that to debug something yesterday)?
I'll update the top level to check for daemon + verbose so that still works
actually, I confused myself here: how were you using the verbose logging? I guess the way it works today is that you get verbose logging up until we hit the runZoned in daemon right?
```
$ flutter daemon --verbose
[  +10 ms] executing: [/Users/m/Projects/flutter/] git -c    
log.showSignature=false log -n 1 --pretty=format:%H
[  +40 ms] Exit code 0 from: git -c log.showSignature=false log -n 1
--pretty=format:%H
... blah blah verbose
[   +5 ms] Starting device daemon...
[{"event":"daemon.connected","params":{"version":"0.5.3","pid":35828}}]
```
stdin:
```
[{"id":1,"method":"device.enable"}]
[+2399 ms] executing: /usr/bin/xcode-select --print-path
[   +7 ms] Exit code 0 from: /usr/bin/xcode-select --print-path
[        ] /Users/m/Applications/Xcode-11-5-beta2.app/Contents/Developer
[   +1 ms] executing: /usr/bin/xcodebuild -version
[ +111 ms] Exit code 0 from: /usr/bin/xcodebuild -version
... blah blah still verbose
```
WDUT about the verbose messages from the notifying logger?

```
[{"event":"daemon.connected","params":{"version":"0.5.3","pid":15152}}]
[{"event":"daemon.logMessage","params":{"level":"trace","message":"executing: [C:\\Users\\Jonah\\flutter/] git -c log.showSignature=false log -n 1 --pretty=format:%H"}}]
[{"event":"daemon.logMessage","params":{"level":"trace","message":"Exit code 0 from: git -c log.showSignature=false log -n 1 --pretty=format:%H"}}]
[{"event":"daemon.logMessage","params":{"level":"trace","message":"34736b7568880662af9cf42bdc383154f7ed07f1"}}]
```
I'm fine with that. Or just not having verbose available if it's too painful.
boom, non-breaking!
Can you add a documentation comment for what types are expected?
Done, with todo to fix
Can this still throw if it's a `List<String>`?
`List<dynamic>` is a `List<Object>`, and `List<String>` is a `List<Object>`. (I checked locally too)
I don't love this, but I also didn't want to change absolute everything.

Medium term, we should split up the device object from the device service.
Can this be `testWithoutContext`?
How about the assert up on line 537? Does it need the same fix?
I'm not sure since I don't have the original context. It is possible the dump output never contains fewer than 3 lines, so that prevents test regressions.
While the previous message did say observatory, let's update these new message to specify "VM Service", which is more correct
I'd imagine that most users hitting this point are actually dealing with a native crash, so this advice may not be the most useful.
why not `attempts == 50`?
consider adding messaging to check native logging (adb, xcode) and ensure the app started correctly on the device
Done.
I've changed the wording to recommend trying `--host-vmservice-port` if the Flutter application is visible on the device and to check the device logs otherwise.
My preference is to have a message that prints periodically (but slowly) if it's still attempting to do work so that it does not appear to be a hung process.  In practice I expect that most people will give up waiting fairly soon, so I doubt it would matter much either way.
nit: 2 space indent.
Rather than checking for a terminal in the prompt, I would check here and skip this part if there isn't one attached
Since this is only used in once place, I would move it to _readUserInput and simplify:

`<String>[ for (int i = 0; i < length; i++) '$i' ]`
I don't think this check is quite right, it should happen when there is either more than one ephemeral devices or when there are no ephemeral devices but still more than one
this will throw a formatException if the result is not a valid number. Use `int.tryParse` and check for null. On an invalid result, either exit or prompt again
I'm a little confused here, as I understand, promptForCharInput from the terminal class already takes care of this with the acceptedCharacters list. When an invalid input is provided by the user this already prompt again. So I don't see how this could generate an invalid result. Am I mistaken?
Thanks, changed it now
Thanks, I have changed this
Ahh you're right, good catch
Maybe hoist this version string to somewhere more visible to make updating easier?
Here and elsewhere: use the isA matcher: https://api.flutter.dev/flutter/package-matcher_matcher/isA.html
This doesn't look right.
OMG What I just did üòë Fixing it right now.
The closing `)` is missing here
Instead of resetting the center parameter, could you create a final variable here with a name that implies what changed, like globalCenter. It would also help to add a comment that explains why we're shifting to global coordinates here.
Done
```suggestion
    if (_currentFakeAsync.periodicTimerCount != 0 ||
        _currentFakeAsync.nonPeriodicTimerCount != 0) {
```
nit: `assert` takes two parameters, `assert(condition, message)`
I fixed the assert.
nit: empty line.
I think you probably want to check that the assert exception just includes the assert message.
What is the proper way of doing this? I checked by creating a timer and not cancelling it. I see that the code is no longer printed below, but I don't know how to include a unit test for this without causing the `Some tests failed` message due to the actual assert error message needing to be printed.
```
Pending timers:
Timer (duration: 0:00:01.000000, periodic: false), created:
#0      new FakeTimer._ (package:fake_async/fake_async.dart:283:41)
#1      FakeAsync._createTimer (package:fake_async/fake_async.dart:247:27)
#2      FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:180:19)
#5      main.<anonymous closure>.<anonymous closure> (file:///Users/christiangonzalez/Desktop/flutter/packages/flutter_test/test/widget_tester_test.dart:764:27)
#6      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart:144:29)
<asynchronous suspension>
#7      testWidgets.<anonymous closure>.<anonymous closure> (package:flutter_test/src/widget_tester.dart)
#8      TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:703:19)
<asynchronous suspension>
#11     TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:683:14)
#12     AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1083:24)
#13     FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:177:54)
#18     withClock (package:clock/src/default.dart:46:10)
#19     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:177:22)
#24     FakeAsync.run (package:fake_async/fake_async.dart:177:7)
#25     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1080:15)
#26     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:137:24)
#27     Declarer.test.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:172:27)
<asynchronous suspension>
#28     Declarer.test.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#29     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:246:15)
#34     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:243:5)
#35     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:170:33)
#40     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:169:13)
#41     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:400:30)
(elided 36 frames from class _RawReceivePortImpl, class _Timer, dart:async, dart:async-patch, and package:stack_trace)

‚ïê‚ïê‚ï° EXCEPTION CAUGHT BY FLUTTER TEST FRAMEWORK ‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
The following assertion was thrown running a test:
A Timer is still pending even after the widget tree was disposed.
'package:flutter_test/src/binding.dart':
Failed assertion: line 1134 pos 12: '!timersPending'

When the exception was thrown, this was the stack:
#2      AutomatedTestWidgetsFlutterBinding._verifyInvariants (package:flutter_test/src/binding.dart:1134:12)
#3      TestWidgetsFlutterBinding._runTestBody (package:flutter_test/src/binding.dart:716:7)
<asynchronous suspension>
#6      TestWidgetsFlutterBinding._runTest (package:flutter_test/src/binding.dart:683:14)
#7      AutomatedTestWidgetsFlutterBinding.runTest.<anonymous closure> (package:flutter_test/src/binding.dart:1083:24)
#8      FakeAsync.run.<anonymous closure>.<anonymous closure> (package:fake_async/fake_async.dart:177:54)
#13     withClock (package:clock/src/default.dart:46:10)
#14     FakeAsync.run.<anonymous closure> (package:fake_async/fake_async.dart:177:22)
#19     FakeAsync.run (package:fake_async/fake_async.dart:177:7)
#20     AutomatedTestWidgetsFlutterBinding.runTest (package:flutter_test/src/binding.dart:1080:15)
#21     testWidgets.<anonymous closure> (package:flutter_test/src/widget_tester.dart:137:24)
#22     Declarer.test.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:172:27)
<asynchronous suspension>
#23     Declarer.test.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart)
#24     Invoker.waitForOutstandingCallbacks.<anonymous closure> (package:test_api/src/backend/invoker.dart:246:15)
#29     Invoker.waitForOutstandingCallbacks (package:test_api/src/backend/invoker.dart:243:5)
#30     Declarer.test.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/declarer.dart:170:33)
#35     Declarer.test.<anonymous closure> (package:test_api/src/backend/declarer.dart:169:13)
#36     Invoker._onRun.<anonymous closure>.<anonymous closure>.<anonymous closure>.<anonymous closure> (package:test_api/src/backend/invoker.dart:400:30)
(elided 36 frames from class _AssertionError, class _RawReceivePortImpl, class _Timer, dart:async, dart:async-patch, and package:stack_trace)

The test description was:
  timers pending
```
updated
you could have something like:
```dart
expect(
  () { 
    // Put code that throws here.
  },
  throwsA(predicate<AssertionError>((AssertionError e) => e.message == '<the-message>')),
);
```
This assertion should be the coming from binding.dart#1132.  Have you tried to see what happens if you add a nested `testWidgets`, for example:

```dart
expect(() {
  testWidgets('Code under test', (WidgetTester tester) async {
      // Add timer
  });
}, throwsA(...));
```
I tried that, but I get an error saying "expect() may only be called within a test." I also tried nesting the expect() within another test, but that didn't work either.

I added a timer in the expect, but the closure returns null. I've also tried checking if tester.takeException() is not null after calling timer.
It turns out you could do something like this:

```dart
group('Pending timer', () {
  TestExceptionReporter currentExceptionReporter;

  setUp(() {
    currentExceptionReporter = reportTestException;
  });

  tearDown(() {
    reportTestException = currentExceptionReporter;
  });

  test('Throws assertion message without code', () async {
    FlutterErrorDetails flutterErrorDetails;
    reportTestException = (FlutterErrorDetails details, String testDescription) {
      flutterErrorDetails = details;
    };

    final TestWidgetsFlutterBinding binding = TestWidgetsFlutterBinding.ensureInitialized() as TestWidgetsFlutterBinding;
    await binding.runTest(() async {
      final Timer timer = Timer(const Duration(seconds: 1), () {});
      expect(timer.isActive, true);
    }, () {});

    expect(flutterErrorDetails, isNotNull);
    expect(flutterErrorDetails.exception, isA<AssertionError>());
    expect(flutterErrorDetails.exception.message, 'A Timer is still pending even after the widget tree was disposed.');
  });
});
```

@Hixie wrote the package. I'm not sure if there's a simpler way of testing this behavior for #53296.
it doesn't need this import anymore
I just realized that it doesn't have the setUp/tearDown code?  `reportTestException` is a global, so changing it within the test would cause other tests to fail if run in a different order.
Oh, sorry that didn't occur to me. I added setUp and tearDown again. 
```suggestion
    // That's fine, but you now need to add a copy of that file to gradle/settings.gradle.legacy_versions, separated
```
good catch
"Move the caret to the end of the text."
There is a bug that I believe is caused by this line:

  1. Type a bunch of numbers into the input.
  1. Move the cursor to the middle of the text.
  1. Insert another number at the new cursor position.
  1. The cursor jumps to the end of the line, but it should stay at its position.
Noted. I must work on that soon
Hey @justinmc I was unable to reproduce this issue, can you provide the code that you've used?
I found it :)
@justinmc I did some updates!
Capital letter "We" and period at the end of the sentence.
Capital letter "Non"
Done :)
Please move this finder into the test that is using it.
Done!
```suggestion
# `dart.bat` script in the same directory to ensure that Flutter & Dart continues
```
```suggestion
# `shared.bat` script in the same directory to ensure that Flutter & Dart continues
```
```suggestion
# `dart.bat` script in the same directory to ensure that Flutter & Dart continue
```
What about multiple embedded slashes? e.g. "/foo//bar//baz".
Also, what about things like "/foo/../bar/./baz"?

Actually, this looks like a bug in follow_links. Why don't you just fix follow_links to not emit double-leading slashes if $PWD is "/", which should be the only time it will emit a double slash.
Same here: I think follow_links just needs to not emit double-slashes.
```suggestion
REM `dart` script in the same directory to ensure that Flutter & Dart continue to
```
```suggestion
REM `flutter` script in the same directory to ensure that Flutter & Dart continue to
```
```suggestion
REM `shared.sh` script in the same directory to ensure that Flutter & Dart continue to
```
```suggestion
# `shared.bat` script in the same directory to ensure that Flutter & Dart continue
```
What about using the mkdir method described in this FAQ, at least as a fallback when flock doesn't exist? It seems more reliable than shlock, and would probably work on platforms without either one: http://mywiki.wooledge.org/BashFAQ/045

It goes something like this:
```bash
 lockdir=/tmp/myscript.lock
 if mkdir "$lockdir"
 then
     echo >&2 "successfully acquired lock"

     # Remove lockdir when the script finishes, or when it receives a signal
     trap 'rm -rf "$lockdir"' 0    # remove directory when script finishes

     # Optionally create temporary files in this directory, because
     # they will be removed automatically:
     tmpfile=$lockdir/filelist

 else
     echo >&2 "cannot acquire lock, giving up on $lockdir"
     exit 0
 fi
```
@gspencergoog both of your suggestions (this one and the change to `follow_links()`) seem worth doing. However, is it all right if I make those changes in a follow-up PR so that if it breaks the world, we still have these scripts factored out into multiple entrypoints.

As far as I can tell, the problems you've pointed out won't be exacerbated by this change, right?
Sure, that's fine. We should address them, though.
> Sure, that's fine. We should address them, though.

pinky swear :)
Filed https://github.com/flutter/flutter/issues/57512 to track.
There are some poorly implemented userland filesystems where the mkdir trick doesn't work, but those are edge cases on an edge case.  It's a pretty solid backup for flock.
> There are some poorly implemented userland filesystems where the mkdir trick doesn't work, but those are edge cases on an edge case. It's a pretty solid backup for flock.

*sigh*, it seems like BASH scripting is all about choosing which edge cases you want to optimize for...
There's another case that is an edge case and a problem: If I'm mounting the flutter dir over a file share, and I access it from both a Linux system and a Mac system simultaneously, then the locking won't hold, since one is using flock and one is using shlock (or mkdir). They'll happily overwrite each other then.
This is true. Using the same repo from multiple host OSes is not supported anyway (the cached artifacts can't be shared), but we should detect this.
BTW, I put up a draft PR to try and address some of this (although it doesn't address the two-hosts problem): https://github.com/flutter/flutter/pull/57590
you can use `if (mounted)` instead, but as I said in my other comment, I don't fully understand yet why this would be necessary here. 
actually the problem may be we are missing a 
`_showTimer.cancel()` elsewhere int his code when the unmount event occurs.
revert this comment change.
should we also cancel the hideTimer or is that also covered by _hideTooltip?
I believe we still need to retain the old widget's loading builder here. 
There are a few other places in this class where we remove the listener. It seems like in all of them we would want to reset the listener right? Why not just make reset listener remove the old listener if it's not null, and then null out the old listener, and then use that in all the spots where we currently call `removeListener`?
It used to get the old widget's loading builder, because it tries to replicate the old ImageStreamListener with that. Now that ImageStreamListener is stored you don't need to pass that loading builder anymore, because it is retained in _imageStreamListener.
This is the only place where you want to replace the listener with a new one, but I guess it doesn't hurt to combine the calls. I'll check the other calls to removeListener.
Actually, the resetListener is a confusing method overall. The problem is that you also have the boolean for _isListeningToStream, and you don't want to touch that one. 

I replaced _resetListener with an optional parameter on _getListener: `_getListener({bool recreateListener = false})`. Now it just does what it says, recreating the listener and nothing else.
nit: revert whitespace changes on these lines.
I imagine we should turn the anonymous method into a class method and assign it here so that we dont need the recreateListener boolean
```suggestion
        onError: widget.errorBuilder != null ? _onError : null
```
You'd still need the recreate if the widget first doesn't have an error Builder, but the new widget does. 
ah, that make sense
Is there a plan to add inputDecoration as param to the picker theme once that is created? For internal use, we would need that functionality, so that the picker can have a different input decoration than the theme provided one.
Yeah, I hadn't thought much about it yet, but that would make sense. If one exists in the picker theme it would be used, otherwise we would use the logic in this PR.
This URl could be null, which wouldn't change after running pub get ... took me a while to see
I think there's only one more usage of this left, if you want to kill it.
Theres a few more...
`errorString.contains`
`contains`
Missing space between `(` and `{`
Based on an audit of user messages, how about:
```
'You are not currently on a release branch. Use git to '
'check out an official branch (\'stable\', \'beta\', \'dev\', or \'master\') '
'and retry, for example:\n'
'  git checkout stable'
```
done
done
done
done
Empty!
Maybe add that ideally we would want to run the tests with an empty clipboard as well, but there is no reliable way to clear the clipboard. 
This long sentence was a little confusing. Does this mean each substring split by `/` is treated as an individual route?
The substrings from the start of the string up to each `/`is treated as individual routes. The next paragraph describes an example. I am not sure to better describe it.
Ok! SGTM
.packages isn't needed since that is an input to app.dill
Likewise, `dart` isn't used by this target 
Same here
app.so
app.so
Whoops :P
Thanks! Will fix these now.
nit: put the `else if` on the same line as the closing `}`
There's a bunch of duplicated logic across these three targets. It would be good to use inheritance and/or dependent targets to share code (see Windows, which has a mix of both, as an example; it's not necessary perfect in that I don't have a good argument for that mix vs. going entirely to inheritance or dependencies, but it does avoid repeating logic 2-3 time).
There's only one file, isn't there? I'm not sure how there could be stale files in this structure.
Surprised that an empty string is the best way to describe this cursor?
Wordsmithing: Returns the first cursor that is not a [DeferredMouseCursor] or null.
Maybe use `DeferredMouseCursor]` instead of "deferred"?
Should explain that this is a singleton whose value is `[DeferredMouseCursor.instance]`.
NICE
typo: remove "the"
Maybe add what this cursor means semantically.
Why do we allow null here? Shouldn't this just be

```suggestion
    this.cursor = DeferredMouseCursor.instance,
```

with an assert that cursor is not null?
Maybe add in one sentence what this cursor means semantically.
Where do we draw the line between the widgets that don't allow null values (use default argument), and those that allow null values (calculate default values in the implementation)? Because the material widgets certainly belong to the latter. My plan here is that _all_ widgets and render objects also belong to the latter category so that the design looks more consistent. Suggestion is welcome.
Since this seems to be causing too much confusion I'm changing how it works. Previously `toString` returns `$runtimeType($debugDescription)`, now it returns `debugDescription`. Implementations of classes are changed accordingly.
In my opinion all the basic widgets in `widgets/` should use regular default values to indicate that this value is very much not computed. Only the them-able widgets in Material/Cupertino need the other behavior.
I agree. Widgets in the widgets library typically have  conventional defaults.
Update comment starting on 233. Also could you add an explanation in the PR description about why we don't actually rely on .packages having a more recent modification time.
Done
We can't yet declare this as `String?` or use '!', so just use `??` as we will fail either way.
Can rename to _discreteValues or even just _values (RangeSlider context is implied)
Is this the same example as above?
Same comment for naming as above
Done
Done
I think we can leave this line (and the others) out. I think it's safe to assume that the developer will understand that the image represents what the sample app looks like.
It would a little more helpful to explain what's not obvious about the demo.  For example why are the range label values rounded?
Needs a type parameter
As before, try not to just restate what's obvious. Maybe explain that typically the slider's current value is part of a StatefulWidget's State subclass.
type parameter
This might be slightly clearer if it were called _currentRange
As with the earlier example; might be slightly clearer as _currentSliderValue
Done
Done
I changed it to _currentRangeValues to keep consistent with Slider demo
Done
Done
Done
Done
This key does not seem necessary. I think it could just be removed.
These params (`hint` and `decoration`) do not seem necessary. It would be better to remove them to make the test clearer.
I think `onChanged` does not need to be defined for the `DropdownButtonFormField` to be enabled. If that's the case, we can remove this parameter as well.
There should only be one instance of DropdownButton in this test:
```suggestion
    await tester.tap(find.byType(dropdownButtonType));
```
Add a comment to explain what the steps of the test accomplish. For example:
```suggestion
    // Taps the dropdown button to open the menu item.
    await tester.tap(find.byType(dropdownButtonType).last);
```
Add a comment to explain what the steps of the test accomplish. For example:
```suggestion
    // Tap the first dropdown menu item.
    await tester.tap(find.text('one').last);
```
The problem with this expect statement is that is does not check the rendered value. This only checks to see if the state value has updated (This test would pass even without the change that was introduced in `dropdown.dart`). You will need to check the value of the text in the `DropdownButtonFormField` as well.
Same comment as above:
The problem with this expect statement is that is does not check the rendered value. This only checks to see if the state value has updated. You will need to check the value of the text in the `DropdownButtonFormField` as well.
Right
Right
Fixed
Sorry I didn't get this
Ahhh. Sorry I was confused. I get your point. The problem is that this param is required that is why I didn't removed it.

Do you think that I should (// ignore:) the warning?
I passed the default value created at the start of the file!
Remove this key, since it isn't necessary.
Remove the hint, since it isn't necessary.
Avoid dangling parameters, as they're easy to miss (aka, we always put longer parameters at the end of the parameter list). We also tend to put child/children params at the end of the parameter list. In this case, the `items` parameter is synonymous to child/children:
```suggestion
                onChanged: onChanged,
                items: menuItems.map((String value) {
                  return DropdownMenuItem<String>(
                    value: value,
                    child: Text(value),
                    onTap: () {
                      setState(() {
                        currentValue = value;
                      });
                    },
                  );
                }).toList(),
```
Add a comment to explain why we do this, since future readers of the code might need some more context on why these assertions are important:
```
// Make sure the rendered text value matches the initial state value.
```
Add a comment to explain why we do this:
```
// Make sure the rendered text value matches the updated state value.
```
That works! I had assumed that `onChanged` did not need to be defined for the button to be enabled, so this was my mistake as well
```suggestion
    // Regression test for https://github.com/flutter/flutter/issues/56892.
```
Instead of having a list of list maybe define a helper class to make the test more readable: 

```dart
class RoutePair {
 const RoutePair({this.previous, this.current});
 final String previous;
 final String current;
}
```
There is an assert to make sure that _RenderDecoration.textAlignVertical is not set to null, so I had to use this `if`.
Nit: it doesn't do anything if `textAlignVertical` is set to null from a non-null value? That sounds a little weird. `textAlignVertical` seems to be nullable but I couldn't find the corresponding behavior in the public documentation. Maybe we should document it?
The top part of this class is hand-maintained. The bottom part is auto-generated. I'd really prefer to separate them into two files, one 100% hand-maintained, the other 100% generated. The generated file should provide instructions for how to regenerate it.
What is the source of these path ops? How do we update them later?
You can't regenerate. It is very invasive throughout code base and probably not something we want to maintain.
Recording of each SurfacePath call and hooks into runPath. Not feasible to update. Unless all material components get reimplemented with new paint functions, the order/count will likely not change. 
The top part is still something we'll maintain by hand (e.g. we can change the `Recorder` API). Let's split the file into two files.
Let's leave a comment explaining that this is a recording of the Flutter Gallery on May 2020. Otherwise, one year from now it will be very unclear what this is.
Done.
Done.
‚ò†Ô∏è
üëè 
This test could use some comments to explain the scenario it is setting up.
üëç I'd seen this when trying local upgrades of `package: webkit_inspection_protocol`.
That's because WipError implements exception now. Analyzer rules:)
This means the user could still specify a `brightness` that doesn't match the given `colorScheme.brightness`. Perhaps if they are both given and don't match we should throw an assertion? Or maybe have the `colorScheme.brightness` take precedence as that is what the eventual value will be? 
Maybe more explicit here?

```suggestion
  /// A default dark theme with a teal [ColorScheme.secondary] color.
```
This seems a little odd. When would you want to change the brightness of the colorScheme without changing its colors as well? Is this because we don't want to break the existing API by removing the brightness param here?
Do we need a test to check that the brightness is set correctly with the changes to the constructor?
I did the opposite. If you specify both, then the brightness parameter replaces the ColorScheme's brightness. Developers occasionally specify a brightness value in local Theme overrides, to override the the "correct" value, in order to flip light/dark color choices.
Yes. I found one use-case in an internal app so I'm assuming that there are others in outside apps.

I think this is comparable to allowing the ThemeData brightness constructor parameter override the color scheme's brightness.
Good point; I will add that.
Ah, then maybe I am missing something because if I set the brightness here that is different from the colorScheme's when do you override the colorScheme's in this constructor? I see where this brightness is used in the constructor to set a bunch of stuff, but then the colorScheme's brightness will be used after that with the new getter. 
Done.
Actually, you're right. It makes more sense to catch this (likely) error than to support it.  I've added the assert and a test for it.
There's no lint to detect this?
nit: "is set to null" -> Isn't it just left untouched? (i.e. nothing is actively forcing this to be null).
> which reduces the runtime overhead of performance tracking to approximately zero.

This sentence confused me. It seems to imply that you still get full performance tracking even when no callback is registered in release mode. Is that true? If so, why don't we use this penalty-free way of tracking in all run modes? Or should this make clearer, that if no callback is registered, performance tracking is more-or-less disabled and that's why its performance overhead is zero?
Ah, never mind. I missunderstod this change.
I went with "not set", which is ambiguous. It is actively set to null if you register then unregister, so I don't want to say "left untouched".
tried to clarify
Hopefully this is only used for testing and build fns in this class?

If so, can it move to `FlutterBuildSystem`?
Done
Without this change its really hard to stop the log reader with mocked output from just passing everything though
Let's move the if (_disposed) check to be the first thing in this callback since we don't have to do any of the other work if that happens.
Smart, will do.
What's compatected?
Oh, you probably meant compacted?
Yeah, fixed
It sounds like we should make sure that we get these platforms correct.

@yjbanov You [commented](https://github.com/flutter/flutter/issues/51218#issuecomment-592230646) about this not being an issue on web.  Do you want the behavior to stay as-is on web?  Or @goderbauer mentioned that Safari on iOS shows the last character, do we want to try to match that specific behavior?
The code inside the if statement is actually revealing the last character, so maybe this is better:

```
// Reveal the latest character in an obscured field only on mobile.
```

That's assuming that it's true that we want to do this only on mobile.  See my comment about platforms.
I have adopted the comment üëç
There are trailing spaces at the end of this line and the following 2 lines, which is causing the [analyzer check to fail](https://github.com/flutter/flutter/pull/56794/checks?check_run_id=739489669).
Note: I need a better solution here since this will change every time dart rolls
This is not the gallery, is it?
```suggestion
      '/': (BuildContext context) => const Text('home'),
```
This is a big behavior change, who knows what build scripts out there are leaving off `--debug`.  Can we leave the default behavior and just fix up the text?
This doesn't change the default, see https://github.com/flutter/flutter/pull/56720/files#diff-c616f0a92b2c8f4d7b8d95d2367e0ff6R61

Unless a user passed simulator, we're defaulting to release anyway.
Doesn't it have the side effect of setting _defaultBuildMode?
https://github.com/flutter/flutter/blob/0a4f6cdef0c39c73cab310342784813dfe6b5ec8/packages/flutter_tools/lib/src/runner/flutter_command.dart#L381
But that is overriden again on L61
So it is.
Its a confusing API
Do we know that for non-English messages, this order of the strings would be desirable? (ie. `Start Date` comes before `$semanticLabel`). It might be important to share some context on words/strings regarding the label (what might come before/after the string), as well as whether it will be read aloud, visually read, or both (this came up as a question recently with the Cupertino tabs semantics label).
Ditto w/ above question
Might be worth naming/mentioning that this is a semantics label that will be used for VoiceOver and Talkback.
```suggestion
              label: MaterialLocalizations.of(context).selectYearSemanticsLabel,
```
For the `_en.arb` descriptions, could we specify if the label is going to be a visual element, a semantics label, or both? I recently had translators ask me about this with the Cupertino tabs semantics label and the translations for certain languages will be unique based on that context.
Good point. I just changed these two labels to parameterized messages, so they can adjust the order as they like.
Renamed.
I was just following the pattern I saw in the existing labels in the file. They are all visual elements unless described as an 'accessibility label' or 'accessibility announcement'.
I think the 2nd bullet point needs better documentation on which keyboard types and autofill hints are compatible. I did some tests on an iOS 13.5 device using a native app, most `UITextContentType` only works with `UIKeyboardType.namePhonePad` (which is mapped to `TextInputType.name` in this PR), including content types like `.streetAddress`, `.zipCode` and `.telephoneNumber` (despite there're more fitting keyboard types). I can't really make sense of it so I'm not sure we should put that behavior in public documentation.
There're surprisingly many `UITextContentType`s that don't trigger autofill (at least I couldn't find a way to, I had added all the fields, middle name, name prefix, etc., in Contacts). Maybe I should rename the field to `textContentType`?
Will these tests work even when they're run on other platforms after the PR is merged?  I would have expected you to need to use TargetPlatformVariant, but maybe I'm wrong.
Maybe our users should be seeking out native iOS documentation on this stuff anyway, and we should just be clear about how we map to native.
From the looks of it,  they do the same thing. Changed to `TargetPlatformVariant` as it seems to be more conventional. 
Unfortunately the behavior isn't documented there either. Maybe I should change the name `autofillHints` to `contentType` to emphasize that it's not only for autofill, and it doesn't guarantee the platform autofill will trigger?
looking for a better word for "availability" 
I think availability is pretty good choice here. Alternatively you could say "how well they're supported on different platforms".
Not sure what `textContentType` field you're referring to. Calling the enum that's used to select a keyboard `TextInputType` seems reasonable to me.
is this missing the rest of the sentence
You should delete the file before the test starts and then poll for the existence, that avoid scraping stdout which I 100% guarantee is less reliable. See https://github.com/flutter/flutter/blob/master/dev/devicelab/lib/tasks/track_widget_creation_enabled_task.dart#L118
I added a vm service request for this, so the stdin is unnecessary:  https://github.com/flutter/flutter/blob/master/packages/flutter_tools/test/integration.shard/vmservice_integration_test.dart#L85
Removed and replaced with `--vmservice-out-file`
Good idea. Done.
I tried the vmservice but got `flutterGetSkSL: (-32601) Method not found` or `s0.flutterGetSkSL: (-32601) Method not found`... Can you please check my latest commit and see what I did wrong?
Right now the method is only hooked up in debug mode, are you running in profile/release to generate the sksl? or are you sending the request during drive?
if its easier I could add logic to write on exit for drive
Does this work: https://github.com/flutter/flutter/pull/58743 ?
Yes, I'm running in profile mode. https://github.com/flutter/flutter/pull/58743 would make this PR much more easier, and it would close https://github.com/flutter/flutter/issues/54484!
Requiring these permutations of build configurations is still a bit icky, which is what the rest of https://github.com/flutter/flutter/issues/14648 can track.
This is the default for a new Xcode project.
Xcode decided to fix this whitespace and alphabetize.
Important change 1: remove the target check
Important change 2: use the scheme (flavor or default Runner) instead of the target.
This file is a duplicate of `Info-Free.plist`, but a user could set this up to have different launch screens or whatever.  This just proves they can be different between targets.
Thanks for the walkthrough :)
Does this require a template # bump?
Nope, this is only needed because the template is now using FlutterEngine; the refactoring in the engine is still only partial, so the view controller path is still separate from the engine path at the public API level.
It looks like didChangeDependencies() should remove the child from its old list of active children (the way deactivate does) if its _ParentInkResponseState has changed.
please don't do it this way -- just use the same style the rest of the file does
we're trying to keep this file to as rigorously simple a style as we can
Are you referring to adding a `SHARD_TEMPLATE` for the environment or pushing the shard numbers down into the test?
it might be a good idea to move this to test.dart rather than having its own separate shell script.
Indeed that would be better.  I split the difference and dumbed down .cirrus.yml and pushed the subshard -> test logic into test.dart.  firebase_testlab.sh still lives, though.
i mean using `matrix`
I'd really much rather we just duplicate all the text. i think the burden on people who look at this file without knowing Yaml's more obscure features is going to be much greater than the burden on people who have to deal with duplicated text.
It might make sense to do the trick we use elsewhere that verifies that the right number of shards are actually given (by having the last shard be named something like `5_last` or something, I forget exactly how we do it).

Up to you.
> just use the same style the rest of the file

Would you prefer https://github.com/flutter/flutter/pull/50306 be reverted?  I would guess so based on https://github.com/flutter/flutter/pull/50306#issuecomment-583177860.
Well, that does end up saving a lot of duplication, huh...

Ok, so long as we have just the one mechanism for doing this, I'm good. The syntax you use here is exactly the same as in #50306?
Yup!
https://github.com/flutter/flutter/blob/master/.cirrus.yml#L573-L583
etc
flaky: true please, unless you've verified that it works on the devicelab hardware
Done.
nit: I would make this a top level instead of a static, since it isn't really related to the FlutterDevice
Why did this line change? `_dillOutputPath` could be null here
Yep, but here's how `dillOutputPath` defined
```dart
String get dillOutputPath => _dillOutputPath ?? globals.fs.path.join(artifactDirectory.path, 'app.dill');
```

There were only 2 places where `app.diil` was hard-coded in this file and I thought it was a good idea to reduce this to 1
moved to `bundle.dart` as top level `getDefaultCachedKernelPath` 
Ahh makes sense, thanks!
Maybe `The following devices were found, but they aren't supported in this project:` 
Maybe `flutterMissingPlatformProject`, `Your project $project is missing some platform projects.`, `Consider running "flutter create ." in the root project to create them.`
unsupportedDevices
```dart
String get flutterFoundButUnsupportedDevices => 'The following devices were found, but are not supported by this project:';
```
I like the idea of showing unsupported devices when no supported devices are found, but the "Your project is missing platform projects, run `flutter create`." message is far too strong, and will be alarming to the much more common scenario of people who are trying to debug their Android app just forgot to plug in their phone.

I think just mentioning that the discovered devices are unsupported will be a sufficient hint.
`'shows unsupported devices when no supported devices are found'`
Or we could change that message to something less alarming like:
```
If you would like your app to run on Android or web, consider running `flutter create .` to generate projects for these platforms.
```
where "`<Android or web>`" are examples generated based on the discovered but unsupported devices.
Supported it. message alarm like: 

```
No supported devices connected.
The following devices were found, but are not supported by this project:

MIX 2      ‚Ä¢ 2e7847af   ‚Ä¢ android-arm64  ‚Ä¢ Android 9 (API 28)
Web Server ‚Ä¢ web-server ‚Ä¢ web-javascript ‚Ä¢ Flutter Tools
Chrome     ‚Ä¢ chrome     ‚Ä¢ web-javascript ‚Ä¢ Google Chrome 81.0.4044.138

Your project /Users/liufengkai/Documents/Code/FlutterSupport/a_test is missing some platform projects.
If you would like your app to run on android or web, consider running `flutter create .` to generate projects for these platforms.
```

`<android or web>` generated by unsupported devices.
I still think "Your project is missing some platform projects." is too strong.  The vast majority of current Flutter users only intend to support Android or iOS.  We don't want to imply there's an error in their project when there isn't one, and they just need to plug in a missing device.

How about:
```
String flutterGenerateAdditionalPlatforms(List<String> unsupportedDevicesType) =>
'If you would like your app to run on ${unsupportedDevicesType.join(' or ')}, consider running `flutter create .` to generate projects for these platforms.';
```
(`FlutterProject.current()` can be extremely expensive to call, we should avoid if possible.)
Missing space between `flutterFoundButUnsupportedDevices` and `=`
Can you alphabetize so this stays stable between runs?
This needs a test.
ok done. 
`flutterMissPlatformProject` -> `flutterMissingPlatformProjects`
nit: This is 4 spaces instead of 2.
nit: This status would probably be better constructed as a `StringBuffer`
nit: I think this also has 2 extra spaces.
Does this work?
```dart
return devices.map((Device d) => d.platformType.toString()).toSet().toList()..sort();
```
Will this new `ScrollPhysics` provide a way to override platform defaults? I see it's `Bouncing` for iOS and `Clamping` for Android, but we do use `Bouncing` for both platforms. Will we be able to override it? I'm thinking about 1 `overridePhysics` parameter that overrides all platform defaults, or even 1 parameter for each supported platform. Great work!
A function called `approveNewDimensions` and returns a bool presents itself like a query but this method has side effects.  This is why I removed the side effects from this method and renamed it `doesApproveNewDimensions`.
What is the logic here?  If the old position is out of bounds that means that it wasn't previously corrected right?  Then why do we take it into consideration?  There is some weird feedback happening where the last decision made by this function is affecting its next decision, no?
This is just the default, you can set your physics to whatever you want, either globally using a ScrollConfiguration widget, or individually on each Scrollable/ScrollView using the physics argument.
What I meant is that, if I override a `ListView`'s `physics` with this one:
```dart
ListView(
  physics: const RangeMaintainingScrollPhysics(),
  ...
),
```
I won't be able to achieve the`BouncingScrollPhysics` effect on Android
correct, but instead just use `const BouncingScrollPhysics().applyTo(const RangeMaintainingScrollPhysics());` to compose the two physics models together into one.
Having the method be separate makes it easier to override in custom scroll positions (much easier, given the privates accessed in the caller). But I agree about the name. I'll see if I can come up with a better one.
The most common case for why you'd be out of bounds here is that the user was previously overscrolling (e.g. on iOS). It also might happen in cases where the initial scroll position is out of bounds, though I didn't run into that case in testing so that's just a guess.
Maybe just coming up with a different verb is enough, since `approve` usually is a boolean query, "do you approve?"
how about `correctForNewDimensions`? (i've done that for now)
@goderbauer this is the breaking change here; what do you think, should we write a migration guide for it? It seems pretty minor to me and I'm not sure what I'd really put in a migration guide.
(obviously if it turns out to break some customer tests that'll be a different question)
Is this truly the "old position"?  For example what's the value of `pixels`?  It's not the value it was previously, it is what the value is currently.  Do you think it would be more clear to pass the old extents into the function instead of a ScrollMetric?  There is extra baggage with a ScrollMetric that might be weird referring to this as "oldPosition" since it is the current position modulo minScrollExtent and  maxScrollExtent?
missing newline
It also includes useful information like the axisDirection and the viewportDimension, but you're right that only the min/max scroll extents can be different between the two arguments.

I'm loathe to make `adjustPositionForNewDimensions` take 9 arguments or whatever it would be to pass all the useful information along, though. I guess I could do 5 arguments (oldMinScrollExtent, oldMaxScrollExtent, metrics, isScrolling, velocity) but then the code looks weird because it's doing things like "oldMinScrollExtent < metrics.pixels" and comparing that to "metrics.minScrollExtent < metrics.pixels" or whatever, which is asymmetric and makes the code harder to read...

I called it "old" and "new" "position" because it's literally copied from the ScrollPosition. Would it help to document the weirdness here?
fixed
You can keep the same number of arguments if you send in a Range datatype.
`adjustPositionForNewExtents(this, Range(oldMinExtents, oldMaxExtents), isScrolling,  velocity)`

You could even compress it smaller if you made an immutable view for ScrollActivity and passed the current activity instead of the isScrolling and velocity (I'm not sure if it is  immutable already): `adjustPositionForNewExtents(this, Range(oldMinExtents, oldMaxExtents), activity)`
Good catch! Did you add a test that specifically covers this fix?
that would require introducing a whole lot more API surface, though. So while we simplify this one API, we do it at the cost of more code size and a more complicated API overall.
nit: switch this around: you need to call correctPixels first before returning false.
I'm surprised we don't have a Range class already, pretty typical and useful.  I think my suggestion is more clear and I'd error on the side of clear API over code size when we are just adding something like a Range class.  It's not worth a long discussion, if you don't think it's worth doing that's fine.
If this doesn't break a customer tests I would be comfortable with not providing a migration guide.
A large number of the tests cover this case now that we're clamping when the content changes height.
(to be 100% honest I'm not sure how to directly test this case...)
hah good catch
I poked at this some more but couldn't come up with something that would improve it enough to outweigh the costs. :-( I'll land this like this for now and if we can come up with something better we can always change it. This is unlikely to be widely used anyway.
should `nearEqual`?
This was the test that should have failed but didn't.

`platform.pathSeparator` is null, `fileSystem.path.separator` is `/` but this processManager `runSync` was never being verified.
`const <String, String>{}` will also create an unmodifiable map
This line is odd ... is this a stray empty string or are we default to `''` for some unset value?
The second parameter in `await xcodeProjectInterpreter.getBuildSettings('', '')` is the target, and it's just trusting that input as the target name.  I can make it Runner or something more obvious.
Maybe for people who haven't read the issue you should explicitly call out that we shouldn't add to this group unless absolutely necessary
Does the comment need to updated too?
```suggestion

  String getOutput(String command, String explanation) {
```
This is change 1
If this fails to catch something, this will throw an NPE here instead of failing to match.
This is change 2
same here
This is part of change 2. Instead of describing HEAD, we grab the exact tag at the tip of `refs/heads/dev`.
Created this wrapper so we can inject mocks for tests.
Good catch
Apparently `null` implements `.toString()`
Oh right, its `null`!
I guess it's still safer to use `exception?.toString()` though, so it doesn't match `'null'`...
For future us:

This check was bogus. The assumption was that if we were trying to track a live image from the listener below and we didn't already know about it, we had either (a) missed a branch where we should have tracked it previously or (b) were being called synchronously, and thus hadn't had a chance to hit all the branches.

The problem is that even if we're not called synchronously, someone could have cleared the live image (e.g. by calling `clearLiveImages`) before the code reached this point asynchronously, which would then trigger the assert. While it's very strange to do that, we shouldn't bother with asserting about it, and in fact it was happening in the test(s) that were failing here.
I wonder if we could add a teardown here like we do in the widgets test binding, and check that `FlutterError.onError` is still the one we want it to be. WDYT?
flutter_test doesn't add a tearDown, does it? I think it just wraps `test` and tests it there. I'd rather burn `tearDown` to the ground and remove it entirely, it always causes me confusion...
We do both - see for example https://github.com/flutter/flutter/blob/13501af6e61e7623d5e3663aa16a934aa3a2f138/packages/flutter_test/lib/src/widget_tester.dart#L136

Instead of using string replace, create a map and use json.encode:

```
_inputsAndOutputsListFile.writeAsStringSync(
  json.encode(<String, Object>{
    'inputs': _inputFileList,
    'outputs': _outputFileList,
  }),
)
```
titled => named
The value of this option is the directory...
Perhaps I could _only_ warn on a release build, and change the phrasing to "before building a final APK for upload to app stores?"
How about:
```dart
final int suffix = Object().hashCode;
...
```
Done
Could a trace message be helpful here?
Yeah, if someone is curious why everything is re-running I should provide some context
Added and linked to the issue so that someone that is curious and investigating can find the right place to discuss (hopefully)
nit: manifest -> Manifest.
done
Will this ever evaluate if the extension is already added? If not, we might need to cancel the stream subscription after `Future.any` returns.
nit: What level of logging is this? Perhaps this should be for `--verbose` only? I imagine in normal circumstances a developer may not even know what "service extension" is. I think something like "Connecting to the application" might be more intuitive.
same comment w.r.t. log level.
What caused the change in the sequence of events here?
Currently on master, `streamListen` is the operation that happens when `enableIsolateStreams` is called, which is a prerequisite of `waitForServiceExtension`. However, `waitForServiceExtension` is actually an unawaited future 
https://github.com/flutter/flutter/blob/2f993d70c178f4a927da5d7d76bd527115920695/packages/flutter_driver/lib/src/driver/vmservice_driver.dart#L181

and it is only awaited after `resume` is called, which is not reflected in the test as the mocks are synchronous. As such, I have reordered `enableIsolateStreams` and `waitForServiceExtension` to come after the isolates are resumed, to match the asynchronous order of when they are needed.
It doesn't look like the current logging mechanism supports verbose logs, so I have removed this as it isn't useful for the user. "Connecting to the application" is already logged earlier in this file.
Same as above, removed as it is not useful
Good catch, we cannot use `.contains` in that case, fixed.
nit: other options in our tools use the dash to separate words, e.g. `ab-result-file`.
Would it be possible to move the `main` under `bin/`? The Dart VM doesn't like entrypoints under `lib/`. It's also a pub convention (e.g. you can `pub global activate` an executable from `bin/`).
nit: I like checking for bad state at the beginning of the function. This way you throw early and you don't need to indent the normal logic.
same nit
Would also be super-useful to have some docs in the README.md about how to use this.
Done
I'll do that. Also, I print the name of the output file at the end of a run - should I mention the "processing" program there too?
Done and...
...and done...
tool code moved to `bin/summarize.dart`
`README.md` updated
An alternative to the trimming in `RenderSliverPersistentHeader.showOnScreen` is to confine `inflatedRect` so that it doesn't exceed `renderEditable`'s paintBounds. But that breaks around 6 tests.
It seems the paint transform that does `child -> this` is applied twice here. 
It took me awhile to understand this comment, so I tried to clarify a bit. Definitely double check this and make sure I understood correctly, though.

> Trims the given Rect `original` so that it fits within the boundaries given by `top`, `right`, `bottom`, and `left`.
> 
> This is used to prevent the case where `rect` or `descendant` specified in showOnScreen exceed the leading edge of this sliver.  If this were to happen, the viewport would move towards the leading edge (reducing its scroll offset) in order to unpin the persistent header.  This is almost always undesirable.
This should be indented according to the style guide, if I'm not mistaken.
:+1:  I'll put the comment above the `showOnScreen` method instead. 

Is it OK to limit the size of the caret's scroll padding instead, so that it will never exceed the leading edge (see the comment in "editable_text.dart" file)? That makes a little bit more sense to me (in case the caller of `showOnScreen` really expects us to respect the `rect` specified). Or maybe we should reduce the default `scrollPadding` (`EdgeInsets.all(20.0)`) and document this edge case?
That makes sense, but would it be a breaking change in normal situations?
child must only be != null if a descendent was provided, right? You could call showOnScreen on a child-less header to bring the entire header back on screen.
nit: instead of defining this inline, this code just be a private method on this object to declutter this method, no?
same child comment as above.
why does it need to stay in the bounds of the child? Doesn't it just have to stay within my own bounds?

If that is the case, could this all be simplified to `paintBounds.intersect(boundsOfDescendantInMyOwnCoordinateSystem)`?
isn't the idea of a snapping header that it will always snap to its max extend?
who starts this AnimationController? The only place I see calling "forward" on this sets a new animation to _animation overwriting the one set below?
So the app bar just jumps from one size to the next in one frame? That seems ugly. 
What if descendent (and thus child) is null?
showInViewport already skips scrolling if the descendant is fully in view. What case does the logic above cover?
Nice catch. Did you add a test for this?
If the header is still visible (as said below), why do you need skipOffstage: false?
same here.
Maybe I missed it, but did you have tests for when the header animates and for when it doesn't?
You're right we only need to override `showOnScreen` for pinned headers where it's always the case (I'm overriding the wrong class).  But I'm not sure which approach we should take, relying on the caller to pass us the right rect, or trim the rect the caller passed down? The latter sounds a bit hacky to me.
`showInViewport` uses `getOffsetToReveal` (which assumes the target sliver moves linearly) to determine whether a sliver is still visible. With pinned headers we can get false negatives (the scroll offset indicates the sliver is not in the viewport but it is), with floating headers it may take less scroll offset than `getOffsetToReveal` suggested to reveal. 
Removed. Adding this in a different PR.
I'm tempted to make this a private extension method to avoid the null check. Is using method extensions not recommended? It doesn't seem to be in the style guide.
I'm curious too.  I feel like we avoid this pattern because I never see it in our codebase.

Also a nit: are square brackets like `[original]` supposed to be used outside of public doc comments?  I guess it doesn't matter if they are.
Nit: "Defaults null" => "Defaults to null"
Nit: I think this comment is repeated in PersistentHeaderShowOnScreenConfiguration unless I'm wrong.  It could be a template.
Nit: "its" => "it's"
This doc is a little user-unfriendly as it refers to a method (showOnScreen) that's not even available on this widget. Maybe provide a better doc that describes what this settings means for the SliverAppbar specifically. 
Using "pinning" here seems a little confusing because a "pinned" app bar is a particular kind of app bar and my understanding is that this setting is not exclusive to the pinnid app bar, right?
Also, it is not super-clear to me that we need this setting. When would you ever want to unpin the app bar?
How does this relate to `expandedHeight`?
What if `widget.floating || widget.pinned` changes from true to false? Don't you have to update _showOnScreenConfiguration to null?
Same for this and the next comment. The macro is kinda on a different API level talking about maxExtent and minExtent that don't exist on SliverAppBar.
Can you just ignore the individual uses? Otherwise more usages of deprecated members will slip into this file without us realizing. 
How is this different from `PersistentHeaderDelegate.minExtent`?
What `minExtent are you refering to here? Is this https://master-api.flutter.dev/flutter/widgets/SliverPersistentHeaderDelegate/minExtent.html? Maybe make the doc link to it properly. Same for maxExtent
These two (maybe all three) new properties seem to be on a different abstraction level then the other properties.
nit: format so that the `: childBounds` is on a separate line aligned with the `?`

same below
This double-clamp is hard to follow. Maybe calculate the lowerLimit/upperLimit and then clamp once?
The use case doesn't seem common at all. I'll remove it.
Lone `endtemplate` here with no `template`, unless I'm missing it...
The added logic does assume the layout is up to date with the current `offset`. I'll add a check to invalidate the skip logic if the assumption does not hold. 
@goderbauer got rid of the visibility check because the viewport could be scrolling / about to scroll. Could you take a look?
Sorry nvm that broke some tests. Fixing.
I think we can remove this ignore, the analysis settings don't require it anymore.
```suggestion
    this.vsync,
```
Should I even bother using InteractiveViewer in these two gallery demos anymore now that the main gallery is a separate repo?  I guess these are just for integration tests.
The [child]
Here and elsewhere: just leave rotation out of the API and docs.
This doesn't seem like a simple case because DragTarget. The examples of the PR's description seem like what you'd want here.
+= 1 instead of ++ because Flutter style
With a few more lines of code this could be a stateless widget. Widgets are preferable to static methods.
If this was its own type it would be easier to add functionality in the future. Or convenience methods for doing the coordinate transforms now.
This needs some elaboration. When can child _not_ have an intrinsic size? What's an example of a child with an intrinsic size? What's an example of a child that does not?
Whoops I forgot I had left DragTarget in here.  I'll simplify it to be like the first example in the description.
I've since updated the widget so that it handles both cases just like any other widget would.    For `child: Container(width: 100, height: 100)`, you'll get a 100x100 box.  For `child: Container()`, it can expand to the size of the parent, like it would if there was no InteractiveViewer.  Things like boundary work intuitively in both cases.

I'll update these docs.
This should be exported from https://github.com/flutter/flutter/blob/master/packages/flutter/lib/widgets.dart and not from here.
nit: group the imports, i.e. dart imports, package imports, and non-package imports should all be in separate groups separated by newlines. 
nit: sentences should be grammatically correct and start with a capital letter. 
Rename the "disableFoo" parameters to avoid double negatives? See https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#avoid-double-negatives-in-apis
Any restrictions on maxScale? e.g. must be larger than minScale?
[ValueNotifier]
`TransformationController` sounds like something stateful. Should this be owned by the state so it only gets initialized when the state is created?
Can we assert this?
[EdgeInsets.zero]
What constraints? Maybe say its the exact same size of the child?
add an empty line after "see also" and each bullet should have a brief description saying why I should look there (see most other "see also"s in our code base.)
This also applies to the other "see also" in this PR
Are there any restrictions for setting this? e.g. has to be larger than or equal to minScale?
Maybe put this in a macro since it is repeated multiple times below?
nit: this sentence is a little awkward. Maybe phrase this a little different, e.g. a gesture detector wrapping the interactive viewer will not receive gestures x, y, and z. Use foo to respond to those.
Maybe add a half-sentence describing what it means to set this (e.g. the InteractiveView will update to honor the new transformation).
Can this be private?
Does the duration ever change? Maybe just initialize the AnimationController with this.
Why does this need to happen in a setState? I'd assume that the InteractiveViewer just listens to the transformation controller and rebuilds itself when the value in there changes?
Maybe expand this comment to explain what this value is used for?
Unlike the others, this method seems to just modify the matrix in-place? If that's ok, why are the other methods cloning? 
Caching the constraints here seems a little sketchy. When you need the constraints, can you not just get them from your own RenderObject (via `context.getRenderObject().constraints`)? 
I don't fully understand the intend of this. Why do we use a different child width/height if min and max intrinsic width/height are the same?
It's also not super-clear to me why we need the constraints at all?
Maybe I missed this, but I would have expected that you'd listen to the `TransformationController` somewhere to rebuild when the transformation changes? 
üëç  I must have put this here as a hack at some point...
Can we leave this out of the public API until rotation is supported? Just the public API, not the implementation.
try to break doc lines at about 80 characters
Good call, yes.  I'm actually going to refactor these a bit so they can't be null either, now that I look at them.  Will document.
This would be a good place to use `@template`
I think it would be best to not suggest factoring Widgets with functions. It's easy enough to just create a const widget instead:

```dart
/// class _ResetButton extends StatelessWidget {
///   const _ResetButton({ Key key }) : super(key: key);
///   @override
///   Widget build(BuildContext context) {
///     return IconButton(
///       onPressed: () {
///         setState(() {
///           _animateResetInitialize();
///         });
///       },
///       tooltip: 'Reset',
///       color: Theme.of(context).colorScheme.surface,
///       icon: const Icon(Icons.replay),
///     );
///   }
/// );
```
Maybe what we want to assert here is boundaryMargin.isNonNegative?
Would this demo be easier to see if the container's background was a gradient?
Not sure if it would be clearer, but you could write:
`_boundaryRectCached = boundaryMargin.inflateRect(Offset.zero & childSize);`
If this assert fails, should have a custom error message
or `return Offset.zero & viewportSize`
Does this doc need to be updated? We seem to be just handling a scale gesture here. Or maybe you just mean "_gestureType" (here and elsewhere).
this can go on the previous line
NICE
Not sure if there's a situation where value can't be inverted or if we should fail gracefully in that case. Probably OK for now.
Good call, that's more accurate.
I've updated this (see my comment https://github.com/flutter/flutter/pull/56409#discussion_r431268112).
It does not, good catch.
Currently it does require the setState and it does not listen to the TransformationController.  That seems to be counterintuitive and probably not in line with how Flutter usually works.  I'll add a listener and remove this setState.
This change seems to have cleaned up a lot of setState stuff üëç 
I intended to always operate on a new matrix, but looks like I missed a clone here.  Good catch.
Done as part of https://github.com/flutter/flutter/pull/56409#discussion_r431324470
Well even if it's not easier to see it will definitely be cooler üî• 
I like it üëç 
I'm using the onScale series of events from GestureDetector, but then I interpret the gesture as being _GestureType.scale, pan, or rotate.  I'll clarify the comments.
That's an interesting thought.  I've seen these matrix operations start spitting out NaNs when there are infinite values in the matrix for example, which was the reason I prevented partially infinite boundaryMargins.  I'll keep an eye out for other problems coming from stuff like this.
Yeah that's definitely more straightforward now that I think about it, will do.  I was really bending over backwards to keep a few lines of comments that mentioned disableRotation.
I did some research about the whole problem with _getChildSize from several comments here.  This is how I believe users will expect InteractiveViewer to work:

  1. If a user passes a child that has an explicit size larger than the InteractiveViewer itself, it should be drawn at its explicit size and should be able to have overflowing parts panned into view. For example: `Container(width: 10000, height: 10000)`
  1. If a user passes a child without an explicit size, it should size itself as it would if the InteractiveViewer weren't there.  For example, a Container with no width/height should fill the InteractiveViewer. An image should be able to use BoxFit like normal.

For point number 1, I can't use `renderBox.size` to get the true size of the child when it's larger than the screen.  The value it gives will be clamped to the size of the screen.  Wrapping it in an OverflowBox doesn't help, as `renderBox.size` still gives the size of the screen.  Wrapping it in two SingleChildScrollViews does work and renderBox.size gives the correct size, if I use one with axis horizontal and one with vertical, and use NeverScrollableScrollPhysics to prevent actual scrolling.  Besides being hacky though, this breaks point number 2, because the child no longer receives any size constraints.

My current implementation of _getChildSize does work for the cases I've given, but is there a more robust way to achieve this?
The getFooIntrinsicBar() methods are quite expensive because they potentially have to compute the layout of the entire subtree.  Would constraints.hasTightWidth and constraints.hasTightHeight work as well here? It's not quite the same, but it might have the same effect for the use-cases that matter.
nit: per convention we put the child parameter usually last.
nit: can we group the *Enabled parameters (e.g. scaleEnabled and translationEnabled)?
nit: Is translating the same as panning? Maybe we should unify the terms in the docs and API?
It looks like you don't really need this setState?
You'll have to dispose the controller if you're replacing one that was created in initState
Also: What happens if widget.transformationController changes from non-null to null? You'll probably have to initialize a local controller.
Are the nested scrollviews necessary? Can we achieve the same effect by wrapping it in an UnconstrainedBox?
This is still not clear to me. It appears its used to calculate the size of the "viewport". Can you just ask one of the parents around the child widget what its RenderBox size is to get that information?
Wondering if some (all?) of these should be static members of the class above to avoid putting them into the public namespace (even when tagged as visibleForTesting they will show up in our docs, I believe). 
I don't find it super-clear to understand from the description what the property does, but unfortunately, I also don't have a better suggestion. 
Good call.  I will use pan to refer to the user gesture and translate to refer to the matrix operation and make sure everything is consistent.
That's right, good catch.
Good catch here and below, I'll update the logic to make sure it handles all cases of initializing/disposing.
An UnconstrainedBox does seem to allow me to get the full size of the child, even beyond the size of the screen.  However, it complains about the child overflowing it.

I mentioned this before, but if I use an OverflowBox, it still constrains the size to the screen.  I just tried a couple permutations of both OverflowBox and UnconstrainedBox and didn't have any luck either.
Any other ideas?
True. I'll clarify in the example description a bit at least.
ah, right I forgot about the overflow warnings that UnconstrainedBox generates. However, I'd expect that you can get the same behavior without the warnings by using an OverflowBox configured as unconstrained:

```dart
          ClipRect( // to clip the visual overflow
            child: OverflowBox(
              minWidth: 0.0,
              minHeight: 0.0,
              maxWidth: double.infinity,
              maxHeight: double.infinity,
              child: Container(
                width: 1000000,
                height: 1000000,
                color: Colors.green,
              ),
          );
```

But you're saying this doesn't size the Container to 1000000 x 1000000? Odd.
I moved them to be static methods on InteractiveViewer with `@visibleForTesting`.
I was missing the min/max sizing. This works, fixed in https://github.com/flutter/flutter/pull/56409/commits/49b329ce2aa51fc828864c795b755e253c5a1da6.
In this case, the controller is owned by oldWidget, right? We shouldn't dispose it here.
Same here.
Yes, good catch.
should we have a TODO to re-enable?
Done, and moved to correct section
This is the fix
This is the test
https://github.com/flutter/flutter/issues/56068#issuecomment-622054920
> The build_aar command would need to be refactored to get the buildInfo from the flutter command instead of manually constructing it.

Is this what you meant, @jonahwilliams?
This isn't ideal, but it's the pattern the rest of this file uses.  I started yak shaving (hence https://github.com/flutter/flutter/pull/56335, https://github.com/flutter/flutter/pull/56331, https://github.com/flutter/flutter/pull/56330, https://github.com/flutter/flutter/pull/56329) but didn't get far enough to do https://github.com/flutter/flutter/issues/43863 or inject a fake process manager into the command (boy are commands are hard to test...)

Anyway it's no worse than it was...
Yup! though there are some edges here. For example, If a user builds a debug aar with obfuscation enabled, the sources might be scrambled. This might cause confusion if there is some expectation that these flags only work on "release" builds
@xster What do you think the best user experience would be here?  
1. Ignore the flags for the debug and profile output
1. Ignore the flags for the debug and profile output, and print a warning
1. Only allow the flags accompanied by `--no-debug` and `--no-profile`
FWIW  we do support --obfuscate on --debug `flutter build apk --debug` today, but not through flutter run. The former isn't very common so I didn't think it merited any interception, but it might be more common to build artifacts together here
Consider https://api.flutter.dev/flutter/package-matcher_matcher/containsAll.html
Possibly overly pedantic, but It would be nice to separate the control flow from the expectations here. You could nest `contains` and `predicate`/`isA<>` matchers to accomplish this, though I don't know if its an improvement
Bleh this fails:
```
[android_obfuscate_test] [STDOUT] Executing: grep aaa jni/armeabi-v7a/libapp.so in /var/folders/mv/qlhc4vsj6tqct166rw3zwmth00mfq2/T/flutter_devicelab_gradle_plugin_test.bY7bhQ/aaa
[android_obfuscate_test] [STDOUT] stdout: Binary file jni/armeabi-v7a/libapp.so matches
...
Task result:
{
  "success": false,
  "reason": "Found project name in obfuscated AAR dart library"
}

```
Does the build aar call into assemble in the same way?
I tried it, I think it's harder to read...
I vote for 2
```
$ flutter build aar --target-platform=android-arm --obfuscate --split-debug-info=foo/                                  
Building flutter tool...
Changing current working directory to: /Users/magder/Projects/aaa
Dart obfuscation is not supported in Debug mode, skipping.              
Running Gradle task 'assembleAarDebug'...                               
Running Gradle task 'assembleAarDebug'... Done                     20.6s
‚úì Built build/host/outputs/repo.
Dart obfuscation is not supported in Profile mode, skipping.            
Running Gradle task 'assembleAarProfile'...                             
Running Gradle task 'assembleAarProfile'... Done                   21.4s
‚úì Built build/host/outputs/repo.
Running Gradle task 'assembleAarRelease'...                             
Running Gradle task 'assembleAarRelease'... Done                    3.2s
‚úì Built build/host/outputs/repo.
```
This is in the wrong spot, I moved it out of the local engine check.
Added the `-q` flag.
LG. "skipping" is a bit ambiguous since you didn't skip building debug/profile. Maybe just say building debug/release in unobfuscated mode?
@dnfield Can you confirm you didn't intentionally want the tree shake check to only happen with a local engine?
Correct - it should be able to work with both. I probably only tested with a local engine.
Changed to: "Dart obfuscation is not supported in Debug mode, building as unobfuscated."
I also see one in hot_mode_dev_cycle_macos_target__benchmark
Oh and I see `FLUTTER_WEB : true` in other devicelab tasks, can you do a sweep?
Do we still need the enableIncrementalCompiler checks?
Removed FLUTTER_WEB, FLUTTER_MACOS that are set by config


FLUTTER_EXPERIMENTAL_BUILD is dead code too
Nope, removed
these were for the frontend_server based web compilation, but that is on by default now
As a treat.
ü§î 
üç™ 
nit:

```suggestion

  group('Validate build number', () {
```
Maybe: must be one of Tap/Longpress?
Assets can be caught in unit tests too, just saying :) 
I didn't want to be too specific here, as I don't see why we cant support DoubleTap or MultiTap as well. If we add it shortly, then that would be overly specific and not strictly correct
This previously had a 'This is taking a long time' message. Should that also be restored, or is this already wrapped in a status spinner thing?
Ahh, status spinner is a good idea. Let me add that instead of adding a print
Done
nit: one line or add a comma
I believe style guide wants this to be one line
ditto
typo: 400s
TODO for discoverability?
Please don't provide default values here. In the future, if we support configuring these properties with a theme, we'll need to know if they haven't been set.
@HansMuller I have done the appropriate changes and removed the default values from the Constructor.
This description is a little too "internal", meaning, a Flutter developer would have to look at the source code to figure out what you mean here. I would use more general language to describe what this property controls in the first sentence. For example:

```suggestion
  /// Specifies the alignment of [children], which are arranged in a column when the tile is expanded.
```
We can expose the internals here a little bit to give clarification to the user. I think we need to be very careful about how clear we are here, because any confusion we cause with the description of each parameter could lead to many new filed issues from misuse of the parameter, as well as misunderstanding it's intent:

```suggestion
  /// The internals of the expanded tile make use of a [Column] widget, and
  /// the `alignment` parameter is passed directly into the [Column].
  ///
  /// Modifying this property controls the alignment of the column 
  /// within the expanded tile, not the alignment of [children] widgets
  /// within the column. To align each child within [children], see 
  /// [crossAxisAlignment].
  ///
  /// The width of the column is the width of the largest child widget 
  /// in [children]. 
```
Maybe specify with the parameter name that is aligns the list of [children] widgets.
```suggestion
  final Alignment expandedTileAlignment;
```
```suggestion
  /// Specifies the alignment of [children] when the tile is expanded.
```
We could also add a pointer to [alignment]: 
```suggestion
  ///
  /// The internals of the expanded tile make use of a [Column] widget, and
  /// the `crossAxisAlignment` parameter is passed directly into the [Column].
  ///
  /// Modifying this property controls the cross axis alignment of each child
  /// within its [Column]. Note that the width of the [Column] that houses 
  /// [children] will be the same as the widest child widget in [children]. It is 
  /// not necessarily the width of the entire expanded tile.
  /// 
  /// To align the [Column] along the expanded tile, use the [alignment] property
  /// instead.
```
We should be more specific with the property name here, although I cannot think of a better one than this.
```suggestion
  final CrossAxisAlignment expandedTileCrossAxisAlignment;
```
```suggestion
  final TextBaseline expandedTileTextBaseline;
```
Add a line here stating that textBaseline cannot be null if [CrossAxisAlignment.baseline] is used.
nit: no need for trailing comma if it's all in the same line
```suggestion
              Container(height: 100, width: 80, key: childKey)
```
```suggestion
    // Considering the default value for crossAxisAlignment is [CrossAxisAlignment.center],
```
Can we also add a test for each of the default ExpansionTile alignment and crossAxisAlignment properties as well?
```suggestion
              Container(height: 100, width: 100, key: child0Key),
              Container(height: 100, width: 80, key: child1Key)
```
Could we also add a test testing that setting `textBaseline` causes a change in UI as well? 
@shihaohong  I can't think of a case where `textBaseline` is doing any changes in the UI. Usually, I use `textBaseline` for `Row` to align the baseline of different text. 

Can you provide any example for the `Column`?
Hmm, that's true. Sorry I hadn't thought about this a little more clearly. It then feels odd to even introduce `textBaseline` here in this case since it would be confusing to provide this as an option. Should we then remove `textBaseline` and instead introduce an assert that prevents the use of `CrossAxisAlignment.textBaseline`? If users come up with a use case for or a way to use `CrossAxisAlignment.textBaseline`, we can simply remove the assert and introduce `textBaseline` at that point.
That's a good suggestion. I have removed the `expandedTextbaseline` and added an assertion.
Provide some hint on why this isn't allowed. This will help clear it up for developers like me, who didn't understand why CrossAxisAlignment.baseline doesn't really do much for ExpansionTile.
```suggestion
       'CrossAxisAlignment.baseline is not supported since the expanded children'
       'are aligned in a column, not a row. Try to use another constant.'),
```
```suggestion
    // The width of the Column is the width of the largest child. The largest
    // width being 100.0, the offset of the right edge of Column from X-axis should
```
I understand the intent behind these `expect` matchers, but I do not think that this section is important for the sake of the unit test. Basically, the title of the test is `ExpansionTile expandedAlignment test`, but this part of the test is testing for the behavior of 'expandedCrossAxisAlignment'. 

Maybe just remove this, but add some of the comments from here to the comment above to distinguish between and explain the intended effects of `expandedAlignment`.
Explain with a comment here why `Alignment.centerRight` is important for the intents of this test. Something like:
```
// Set the column's alignment to Alignment.centerRight to test 
// CrossAxisAlignment of children items. This helps distinguish
// the effect of expandedAlignment and expandedCrossAxisAlignment
// later in the test.
```
```suggestion
    // The width of the Column is the width of the largest child. The largest
    // width being 100.0, the offset of the left edge of Column from X-axis should
    // be 700.0.
```
Add a comment here to explain why these assertions are important:
```
// Since expandedAlignment is set to Alignment.centerRight, the column of children
// should be aligned to the center right of the expanded tile. This provides confirmation 
// that the expandedCrossAxisAlignment.start is 700.0, where columnRect.left is.
```
nit:
```suggestion
              Container(height: 100, width: 80, key: childKey),
```
nit:
```suggestion
              Container(height: 100, width: 80, key: child1Key),
```
nit:
```suggestion
              Container(height: 100, width: 80, key: child1Key),
```
Nice! Thanks for being clear here.
Makes sense, it's testing the behavior of `expandedCrossAxisAlignment`.
nit: you could move the comment down here instead, so it's right above the actual parameter :)
```suggestion
            // Set the column's alignment to Alignment.centerRight to test CrossAxisAlignment
            // of children widgets. This helps distinguish the effect of expandedAlignment
            // and expandedCrossAxisAlignment later in the test.
            expandedAlignment: Alignment.centerRight,
```
nit: I find this format easier to read, but this one is up to you:
```suggestion
       assert(
         expandedCrossAxisAlignment != CrossAxisAlignment.baseline,
         'CrossAxisAlignment.baseline is not supported since the expanded children '
         'are aligned in a column, not a row. Try to use another constant.',
       ),
```
Learning a lot from your reviews üòÑ 
I was trying to save vertical space, but I'll do the changes, it will be easier to read.
I'm a bit concerned about updating the doctor check. Maybe start small with just -d edge
Does this check if it's a Chromium-based Edge or the old one?
I'm surprised that this passes. The `findEdgeExecutable` function specifically checks that `platform.isWindow`, and this test uses 'linux' as the OS.
ditto
I'll add a registry check for the version number
Edge is supported on all platforms, it just matters whether the executable can be located.
According to https://github.com/flutter/flutter/blob/0830c75c59b462975dbfb8da642ed8a2a3ff4550/packages/flutter_tools/lib/src/web/chrome.dart#L97 it won't be found, unless you explicitly specify the `EDGE_ENVIRONMENT` variable. Is that what you mean by "executable can be located"?
Done
Fixed to only check on Windows
Is this a useful value? If so, maybe extract into a constant and add docs? If not, how about throwing `ToolExit` instead?
typo: missing "s" in contraint
If we throw a tool exit, then we would not be able to check for whether edge meets the installed version constraint. Will add a comment
Fixed
recommendation: Since this is the new Edge, this will should trigger Chrome(blink) paths for browser related branches on Flutter Web Engine. Shall we add a note around it?
I'm not really sure what you mean @nturgut ?
Today a Flutter for Web engine developer can locally run edge tests using `felt` tool.
One scenario is, the developer sees a failing test when they run:
`felt test --browser=edge test\abc_test.dart` Let's say they try to reproduce the error by running flutter.  They run `flutter run -d edge`. But this time it is successful.

In order to not to confuse the developer in this way, we might add a comment (or a note to the README for flutter run) saying, `edge` option is running chromium based edge not the legacy edge.

So far I saw many issues filed for legacy edge, therefore I want to make sure those developers do not get confused.
I'm confused how someone would end up in that scenario, either they have old edge installed or they have chromium edge?
That's a good point indeed. There is a way of keeping the old edge for corporate customers but probably that would be a very small proportion. 
Using this we can safely "skip" the target if l10n.yaml does not exist and clean up the old outputs.
Really the whole tool though, right?
nit: think positive
```dart
if (runtimeSkip) {
  ...
} else {
  ...
}
```
Have you considered moving the new `canSkip` check here? That is, not including it in the dependency list at all?
Should we file/is there an issue about making this more precise?
I don't quite remember how/whether the build system aggregates errors, but I sort of remember that exceptions from running a target will get printed at some point, and at that point will it be confusing to have one with an empty message?
Should we be spamming the top-level lib by default? Should we prep for the generated package by putting this by default under something like `lib/src/flutter_gen` ?
Does this make it into the inputs somehow as well?
ditto question.
for better or worse its the gen_l10n tool default
No. since we're running it from source it wouldn't be sufficient to capture the dependencies either.
https://github.com/flutter/flutter/issues/55503
This won't work for now because I store inputs/outputs at the target level. So if a target is totally excluded from the build, then we don't know enough to skip. I could change the serialization format so there is only a single file, but that would take more refactoring.
Err, I mean that we don't know enough to clean up the old outputs
yes, though this is really a convenience for me when developing. the tool doesn't really support development by users so it shouldn't be necessary
What this looks like is:

```
arb-dir: /Users/jonahwilliams/Documents/flutter/examples/hello_world/lib/l10n does not exist.
Target gen_localizations failed: Exception                              
Compiling lib/main.dart for the Web...                              0.1s
Exception: Failed to compile application for the Web.
```


I think its fine, we show the error text and that is the important part. We can't control the formatting as easily if we stick it in the exception.
KK. Please add a comment.
You mean, like if someone removed the `l10n.yaml` file, you wouldn't be able to clean up the generated source file? Or something else?
Please add a TODO or reference the issue in a comment.
Can the tool pass a `--output-localization-file` flag to `gen_l10n` if there isn't one specified in the yaml file?
Please leave a comment here about that with a link to a tracking issue.
If I conditionally added or removed the entire target, I couldn't clean up the output because its tracked in a file controlled by that target.

With this change I can cleanup the output if that file is removed
nit: here and elsewhere
```suggestion
  File outputLocalizations;
```
```suggestion
/// [LocalizationOptions] with all fields as `null` if the config file exists
```
nit:
```suggestion
    // The target will write a file `foo`, but only if `bar` already exists.
```
Added a comment below on the Target inputs
nit:
```suggestion
    // This is added as a convenience for developing the tool.
```
These options and their help texts will somehow need to be exposed to users once they transition to using the l10n.yaml over the command line tool by default.

Created an issue https://github.com/flutter/flutter/issues/56681 to track
The command now needs to account for the inputs/outputs list:
```
01:32 +232 -1: test/general.shard/resident_runner_test.dart: ResidentRunner can run source generation [E]                                                                                              
  Expected: ['bin/cache/dart-sdk/bin/dart', 'dev/tools/localization/bin/gen_l10n.dart']
    Actual: [
              'bin/cache/dart-sdk/bin/dart',
              'dev/tools/localization/bin/gen_l10n.dart',
              '--gen-inputs-and-outputs-list=/build/6ec2559087977927717927ede0a147f1'
            ]
```
ditto
```suggestion
          '--gen-inputs-and-outputs-list=/',
          '--arb-dir=arb',
```
Wait, to find the last focus node we call `_findFirstFocus`? :smirk:

Joking aside, perhaps `_findStartFocus` with a `fromEnd` or `backwards` boolean parameter?
Looks good, just curious why you made these doc comments if it isn't a public interface?
Yeah, fair point.  Changed to `_findInitialFocus` and `fromEnd`.
Because it was good enough to be public docs, and having just re-read our style guide for the first time in a while, realized that it should have doc comment markers.

https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#use--for-public-quality-private-documentation
During install, we unconditionally cache the minimal set of assets needed to run:

main.dart.js, index.html, AssetManifest.json, FontManifest.json, LICENSE
If there is no manifest, we're upgrading from an older version of the service worker. The tool has to clear the entire cache.
There is where we unload the temp cache populated in install into the real cache after install
we serialize the RESOURCES, which contains a map of url -> md5 sum. This is used for smarter upgrades
Parse the old manifest.
For each cache resource, delete it if it isn't in the new cache, or if the file hash doesn't mash.
TODO: test this
`main.dart.js` depends on the name you choose for `lib/main.dart`, doesn't it? Do we need to document that you need to call your main entrypoint `main.dart` for it to be cacheable by the service worker?
No, the output is always named `main.dart.js`, see also:

https://github.com/flutter/flutter/blob/master/packages/flutter_tools/lib/src/build_system/targets/web.dart#L164
What's the difference between this listener and the one above?
ü§î 
Removed!
Can you please turn your Github comments to code comments? These will be useful next time we look at this code.
We should also have a test that checks that we don't include stuff we don't want to include.
I mentioned this in the chat, but TLDR I'm not sure if I should since we're including this in applications as source.

I'm not sure if that would violate expected web norms of minifying everything into unreadable junk? If not I'll happily add comments.
Done
There is no need to conditionally set these flags, assemble just checks if `== true`, so an empty string if they are unset is fine. 
```suggestion
  /// This is not considered a build input and will not force assemble to
```
Would it be simpler to just wrap all of the subtree that's actually being tested with a MaterialApp()? All the stubbery is impressive,  but maybe it's not worth the trouble.
I concur!
There is also one of these in the new `date_range_picker_dialog.dart` (line 410). I can update it if you don't want to do it with this PR.
@darrenaustin I thought I might use a flag via DialogTheme, but the _defaultDialogShape here is actually used as a fallback for the dialogTheme here in the base Dialog class.

I anticipate the turn over being quick, as this is not a severely breaking change. Once this lands I can migrate those affected from the dev roll and remove this flag quickly, the flag itself should not reach stable, instead there will be a migration guide for those that may notice a slight difference in the border radius, or have a golden file test that is affected.
Oh thanks! I missed that one! I've added it. :) 
Nope, you didn't miss it, it was landed after this PR was created. Thanks.
Ah, that totally makes sense and I agree that it isn't that much churn.
are we considering desktop browsers android?
This PR makes sure scroll physics etc are correct on iOS/Mac. We will likely add to this, yes for now when running on fuchsia for example, it defaults to android physics.
Can `fuchsia_tools/` go under `bin/` instead of living at the top level? Additionally, can the Fuchsia entrypoints under `bin/` go under `bin/fuchsia_tools/` instead?
I can move the fuchsia_tools directory to be in bin/ but we cannot move the entrypoints out of bin. The reason is that the //topaz/runtime/dart/flutter_test.gni has the path to the flutter tester hardcoded so changing them will break the fuchsia build. 
Kk. Let's just move the new directory under bin/ then. Thanks!
Actually, it seems that our build rules make some assumptions about where the main file lives in relation to the package root. Moving the fuchsia_tools directory under bin/ causes the build to fail with the following error `Invalid package URI 'package:/fuchsia_asset_builder.dart'`
Why are they going into the same .packages file in the first place? Is the fix in the `dart_tool` template rather than here?
It isn't so much that they are writing to the same .packages file but rather that we end up having two packages with the same packageUri. There was a recent change to the dart compiler which enforces the unique packageUri rule which is why the rolls into fuchsia have been failing. 

We need to update the dart build rules to use the new package_config.json format instead of the .packages format and I think we can figure out a more elegant solution here when that happens. We have had other places in the tree where this is a problem and we have had to restructure the code to fix the problem because we had something like a `flutter_app` and a `dart_library` in the same BUILD file.  

I am fine with not landing this change and just fixing the build rules to be more resilient but I'm not sure how long that will take and we have been without a roll on the order of ~2months now. 
nit: indentation.
What is a mark? Are timestamps and hashes different types of marks?
will use -> uses?
Can these be `testWithoutContext`?
wasn't sure what to call it. Essentially just a string key checked for `==`. Maybe just `assetKey` instead.
Fixed
renamed to assetKey
Done
Done
I don't love this cast, I think we get way too cute with factory patterns in flutter_tools--sometimes it's better to just make what you need if you need to understand the internal details of it anyway.
Print some of the FormatException details to give the user a hint.
Same
Done
Done, also rearranged this to use an `is` check instead of catching the type error.
Done!
nit: improve
Nit: is this conversion just to reduce the number of platform-mismatch warnings? If so, I'd probably prefer to not convert, and print warnings if one tries to use the SkSL bundle from android_x64 on android_arm64.
I'm not sure how this would be possible today. When building an apk or appbundle, the tool builds for all ABIs simultaneously and assumes that assets are shared. It would take a significant amount of refactoring to support ABI-specific assets.
Are the SkSL files ABI specific? If so this needs a lot more work :( 
No, they're not ABI specific. I was only thinking about giving them warnings as platform-mismatch may make them less efficient. But there's absolutely no problem of cross-ABI compatibility (as I've used x64 SkSLs on arm).
This might be something we could fix long term then, would you file an issue with some more details on the efficiency loss from the current implementation? 
Here's an experiment on the efficiency loss: https://github.com/flutter/flutter/issues/53607#issuecomment-608587484

I don't think the current implementation has any issues. If we truly want to be 100% effective across different ABIs/devices, we probably have to rely on our medium-term solution "Test-based shader warmup #53609".
Please let me know if there's a better way to do this, as there doesn't seem to be an engine in the tests that actually calls the callbacks.
nit: remove this comment and put the onReportTimings call on one line.
Remove the setup and just say

```suggestion
      final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized();
```
Not sure what you mean by this. In order to provide a new list of pages you have to rebuild the navigator.
The old doc was a little clearer because it explained what "updating the list" means (i.e. remove the page of this route from the list). Why make this weaker?
This is odd, if the route is no longer present, the transition delegate shouldn't be allowed to make a decision about how it should exit (especially if that decision just gets ignored). To say it with the assert above: "[The route] does not require an explicit decision on how to transition out" because, well, a decision has already been made... The only thing the transition delegate is allowed to do with them is to re-arrenge them.
We may need to extend the transition delegate to accommodate this...
yes, either this or we break the transition delegate api. I honestly don't know which is better, It is a corner case that should not happen too often. I wonder if it will be even more complicated to handle this in transition delegate given how complicated it already was.
In the navigator.pop, it already marks the route entry to be pop, and the route.didpop will trigger the popping animation, at this point the navigator should be happy with its state. Triggering another page rebuild is not necessary, we just need to make sure the 'next' time it updates with the new page list.

The only concern with this is the navigator.pages might still contain the removed page, but it will not be used in any case until a new pages list is provided. If we really want to get rid of it, we might need to change the way we handle popping page route.
What if user does want to have the page persist in the list? I feel kinda weird to ask user to remove the page, so i update the document to be more generic and state what will happen if the page is still persist in the list.
Breaking the transition delegate API should be fine. The API is so new and shouldn't be in much use it.
In the transition delegate could these pages just be part of the locationToExitingPageRoute list and there entry is marked somehow to indicate that this are already in the process of exiting?
In all use cases I can think of you would remove the page from the list after you decided to pop it. We should be clear in the docs that that's the expected behavior and then point out what happens if you don't do that.
That rebuild should be cheap, though, since nothing has changed? It is gonna be confusing if the current page list of the navigator doesn't match its internal configuration.
I am thinking if we should make developer responsible for rebuilding the navigator with the new pages list, and the navigator just call the onPopPage callback and does not do anything after that?
There is another bug, if a new page matches the a popping route, that route will be updated but still popped.

It can easily be reproduced If user rebuilds the navigator without the removing the page from the pages list in onPopPage callback.
That does sound like a bug. Since our documentation says:

"The next time the [pages] list is updated, if the [Page] corresponding to this [Route] is still present, it will be interpreted as a new route to display."

we should in updatePage ignore pages that are on their way out and treat that page as a new one.
You'd have to make sure that the transition delegate actually marks this page for pop then. Seems a little odd.
actually this seems to be taken cared of already where we check the ```currentState.index > _RouteLifecycle.idle.index``` in canUpdateFrom
I renamed this to be more descriptive.
```suggestion
  /// location is null if the route to be removed is the bottom most route. If
```
nit: leave this on one line.
nit: leave this on one line.
nit: leave this on one line.
slightly cleaner and to be symmetric to `isWaitingForEnteringDecision`: Move this field into _RouteEntry and add a method there (something like markNeedsExitingDecision) to set it to true.
as per comment above, this would then be:

potentialEntryToRemove.markNeedsExitingDecision();
same here.
Should we also set this to zero for https://github.com/flutter/flutter/blob/bd897dfafc65042e175e0f860d376a562e31ba31/packages/flutter_tools/test/general.shard/resident_runner_test.dart#L812?

Is there anything we can do to ensure future tests also override this?
I don't think there is a requiredButOnlyForTesting ... that would be neat. In this case, we don't hit that code path with the timeout, but if we did the test would fail since it would receive an unexpected vm service request for ext.flutter.exitApp
ahh, good point.
Wondering whether we really need this class. The renderobjects in question could just use the mixin directly?
It's strange that there are two flags here to control whether to clip or not. clipToSize and clipBehavior.
Same here, it's strange that there are two flags to control clipping.
ClippableRenderBox claims that the default is none.
in the constructor its set to hardEdge
(This comment applies to some other places in the PR as well)
I added `ClippableRenderBox` for `SingleChildScrollView respects clipBehavior` test: https://github.com/flutter/flutter/pull/55977/files#diff-dc4070bb6bd99e8491da558051581285R45. Its render object `_RenderSingleChildViewport` is private so I have to create a parent render object class for testing... I'd love to remove `ClippableRenderBox` if there's another way to test it.
I'd love to remove `clipToSize` and `overflow`! My previous concern was how it affects our breaking change migration. My old post https://groups.google.com/g/flutter-dev/c/XMHE0XdsXxI/m/nonrNQpbBAAJ seems to still cover this PR if I don't remove `clipToSize` and `overflow`. But after a second thought, I think it's better to remove them immediately so the old code would result in compile errors instead of runtime errors saying that `clipToSize/overflow` is incompatible with the default `clipBehavior`. My next patch will remove them, and I'll write a new breaking change announcement with migration suggestions.
Will remove.
Do you mean that the auto-generated API doc for `RenderViewportBase` will say that the default is `Clip.none` instead of `Clip.hardEdge` because `ClippableRenderBox` defaults it to `Clip.none`? Some `ClippableRenderBox` subclasses default to `Clip.none` while some default to `Clip.hardEdge`. I'd like to know if there's a way to specify/modify in each subclass.
Good catch! Forget to change after copy/paste... Fixed for all 5 widgets now.
Could you re-write the test as follows:

```dart
    final dynamic renderObject = tester.renderObject.where((RenderObject o) => o.runtimeType.toString() == '_RenderSingleChildViewport');
    expect(renderObject.clipBehavior, equals(Clip.hardEdge));
```

Note the cast to dynamic which should allow you to call whatever you want on it.
I don't think dartdoc provides any affordances for this, but I am no dartdocs expert.

But the auto-generated documentation for all classes that extend ClippableRenderBox or mixin the mixin and set the default to something other then "none" will have incorrect documentation with the current approach.
we definitely shouldn't add to our public API surface just to work around Dart testability limitations. Better to just go fix Dart.
this doesn't belong in `object.dart`. It's way too specific.

Is there any reason we wouldn't just duplicate this code everywhere rather than using mixins? Mixins aren't free (they add more classes to our class hierarchy, etc). I don't know how well they interact with tree shaking either. We don't have any trouble duplicating other fields. Why is this one special?
why not clip with the hard edge by default? This only kicks in if there's overflow, so it's not like it makes much difference in most cases.
That will also fix the documentation trouble I mentioned in the other comment.
I wouldn't bother with the mixin. Just inline the duplicate code. It's not complex logic, and it might not be identical everywhere (as shown by the different defaults, for one).
if you change the default to hardEdge make sure to update this too
update to match render object
ditto
here and elsewhere, please always give the default value
Done.
Removed the Mixin. BTW, I'm curious if we had any experiments on the Mixin's impact on app size? For example,  what's the Flutter gallery's size difference between (1) copying a small piece of code dozens of times and (2) defining a small mixin which is reused dozens of times?
Changed it to hard edge by default. I previously was following https://github.com/flutter/flutter/issues/21830#issuecomment-421141732. 
Done.
Done.
Done.
Done.
now that stack defaults to clipping, you'll have to add something here to not clip, no?
should this be part of the if (!hasOverflow) above to simplify the logic?
add this condition to the if !_isOverflowing above and merge the ifs?
change this to not clip again?
Yes, and that's why some unit tests are failing: I forget to update the default behavior.
I didn't do this in `if (!hasOverflow)` because we still need to execute the `assert` below to trigger some warnings. Otherwise, some unit tests would fail. Actually, I believe I moved it out of `if (!hasOverflow)` after I discovered the unit test failure.
Same as before. Still need to execute the `assert`.
Yes, thanks.
This will have to change back to `clipBeahvior: none`, no?
[nit] It might be useful to copy the "Some children in a stack might overflow its box." introduction before. New developers might not realize why Stack needs clipping. But this could be a rabbit's hole, talking the size of the stack versus positioned widgets. So: nit.
A slightly more gentle way to do this would be to do the following as an in-between step:

1. Don't remove `overflow` just yet.
1. Mark `overflow` here as deprecated, with something like `@Deprecated('use clipBehavior instead, see http://...')`
2. Remove the default for `overflow`, so it's `null`.
2. If `overflow` is non-null, assign to `clipBehavior` accordingly. 

Especially here in Stack, that's going to be a lot of hard breakage if you just remove `overflow`, I think.

I'm fine either way, just wanted to point this out. There are a lot of `Stack`s out there.
Thanks for catching it! Done.
Yes!
Ok, in my next patch I'll only make them deprecated instead of removing them.
https://github.com/flutter/flutter/pull/55977/commits/deaff1f1d1fbf4a7ebeae9fc9cbacfe296dee7d5 restored `overflow`, but presumably a later rebase removed it again, because `overflow` is gone in the final merged patch.

```
Compiler message:
../../Flutter/.pub-cache/hosted/pub.dartlang.org/flutter_speed_dial-1.2.5/lib/src/speed_dial.dart:249:17: Error: The getter 'Overflow' isn't defined for the class '_SpeedDialState'.
 - '_SpeedDialState' is from 'package:flutter_speed_dial/src/speed_dial.dart' ('../../Flutter/.pub-cache/hosted/pub.dartlang.org/flutter_speed_dial-1.2.5/lib/src/speed_dial.dart').
Try correcting the name to the name of an existing getter, or defining a getter or field named 'Overflow'.
      overflow: Overflow.visible,
                ^^^^^^^^
Exception: Build process failed
```
I don't think the range picker supports the SelectableDayPredicate since it would be tricky to work around that UX
Could this be a private class inside of another file?  People can still include this directly, even though it isn't exported, of course.

Or is it for testing purposes?
nit: Should all the string params be grouped together?
Should it be "Material Design"?  It's a proper noun, so maybe.
```suggestion
/// the user saves their selection. If the user cancels the modal dialog, null is
```
I think we always use "must" when we talk about nullability: e.g. "Both must be non-null" or "Both must not be null".
I'd add definite articles here and below:
```suggestion
///   * [helpText], the label displayed at the top of the dialog.
```
Long lines of doc comments should be wrapped at 80 columns.
You can use `BorderRadius.zero` here
There will be theming support coming in the future right? We'd want to be able to customize the corner radius for example.
Should probably be consistent with usage of `.0` for doubles
You could probably format lines like this like so to be closer to 80 chars:
```suggestion
    final TextStyle startDateStyle = headlineStyle?.apply(
      color: selectedStartDate != null ? headerForeground : headerDisabledForeground,
    );
```
This inline conditional chain is getting a little out of hand... Maybe use a conditional block or two here?
Should use a different string for save text than what the default is
When you say "appropriate", you mean "locale-appropriate", right? Not just, like, without cuss words. :-)
Why not private?
```suggestion
  /// separator using one of these characters (slash, period, comma, dash, or space).
```
super-meta nit: doesn't _have_ to be a doc comment.  Fine to leave it though.
```suggestion
/// end dates that represent a range of dates.
```
```suggestion
  /// Will return true if the range is valid. If not, it will
```
Dialog defaults to 24, I wonder if this should be left out so that when a user modifies the `DialogTheme`'s elevation, it applies to the pickers too (same comment probably applies to the already merged DatePicker)
Yeah, I just caught this when I was looking at the shape. I will fix this shortly and double check the Date Picker (but I am pretty sure I already deferred this to theme for that one). Thx.
It was mostly because I wasn't yet ready to commit to it being part of the public API, but didn't want to add it's bulk to the already long `date_range_picker_dialog.dart`. I really wish dart had a 'package private' access control for things like this.
Because it is shared between the `InputDatePickerFormField` and the `InputDateRangePicker` which is in another file. I could move the range picker into the `input_date_picker.dart` file, but `InputDateRangePicker` is not a public API either.

Again a package private feature would be welcome. I didn't see many examples of how to handle this sort of situation elsewhere in the framework. Most components are as complicated as these date pickers, so they just put everything in one large files. With the date pickers that just seemed too unwieldy.
Well, it does have "library private", but the library can only be extended to multiple files with the `part of` directive, which we discourage. I know what you mean though: it would be nice if things could be made private to anything in the pub package.

Like it or not, it's part of the public API, it just isn't exported with the top level include points.  Anyone can use this class with:
```dart
import 'package:/flutter/src/material/pickers/calendar_date_range_picker.dart';
```

Sure, it's not likely, but they could.

Anyhow, it's not a big deal: I suspect that a) people are on their own if they do that, and 2) that we might want to make this a public API anyhow.

If you're not ready to make it public, though, it's probably OK to put it in the other huge file and make it private. We have plenty of those in Flutter (mostly for that reason) already. `widgets/basic.dart` is 7,144 lines...
Yeah, I mostly landed on "a) people are on their own if they do that". It is called out as a "DON'T" in the effective dart guide (https://dart.dev/guides/language/effective-dart/usage#dont-import-libraries-that-are-inside-the-src-directory-of-another-package), but I totally get the point that it is technically still public.

I am leaning toward leaving this way for now. That will make it slightly easier if we do want to make it public at some point.
Yup, I updated this to defer to the shape from the theme if there is one.
All of the other parameters can be null too? 

If they're not null, assert that lastDate >= firstDate etc?
Should be a companion dispose() override that calls _controller.dispose()
NICE
const?
I've tried to only use `=>` for one-liners that return value. So 
```dart
onTap: () { onChanged(dayToBuild); }
```
this can go on the previous line
Unfortunately the asserts use DateTime methods which prevent this. I could move them to the body of the constructor, but as this was an internal API, it didn't seem worth it.
The assert provide more safety than the const provides readability. Sounds OK.
@darrenaustin Why is this hardcoded? If I have InputDecorationTheme with filled: false, I expect it to be false, but now it's not the case. 
It is following the Material Design for this picker, which calls for it to be filled. That said, we should probably defer to the ambient `InputDecorationTheme` if one is set for this. We have a future theming pass that we will be doing on the date pickers that will allow for more customization, but I might be able to put together a small PR to fix this one issue.
@darrenaustin Thanks. It would be great for my use case. 
This expression and the following one might be a little easier to read if allowed the lines to get a little wider.  Doing it this way makes the similarity of these statements easier to see.
```dart
final double minContainerHeight =  expands || decoration.isDense || decoration.contentPadding != null
  ? 0.0
  : kMinInteractiveDimension + densityOffset.dy;
```
Do we really want to lose this comment?
two space indent
The doc comment is no longer accurate.
Thanks for catching that!  It makes me worry about people relying on the old behavior, though I think technically it's not a breaking change.  I wonder why isCollapsed was not passed through in the first place.
The requested overall height is 18dps, however the min height is kMinInteractiveDimension
because neither isDense or isCollapsed are true.
Please insert
// Regression test for https://github.com/flutter/flutter/pull/42449
For the sake of clarity, it would be nice to include a second part to this test that verifies that the height _is_ 18 when collapsed is true. And a third part, same thing for isDense.
In some other places we call this kind of parameter `throwOnError`
Also, is this parameter used anywhere?
Forgot to check in the actual change
Should these be formatted back to the way they were?
I think this should stay, since we still do want the same color assignments for the old indicator shape.
undo spacing?
under spacing?
undo spacing
Same comment as before about keeping this logic
Done
Done
Done
Done
Done
Done
resting, pressed, hovered, and focused state
Does the overlay cause issues with browser tests?
Done
No, updated.
We just announced 1.17 so we didn't get the release quite right here. I don't think it matters (anymore).
When I run flutter --version it gives me 1.18.0. I wonder why.

Let's move this comment into a separate section that will discuss the options for manipulating the glow in custom scroll views. How about adding a `## Customizing Glow for Advanced Scroll Views` or something like that starting at line 37 below?
Further below (starting at line 42ish) can we change this to something like:

```dart
/// To manipulate the position of the GlowingOverscrollIndicator in this case, 
/// you can provide a [OverscrollIndicatorNotification.paintOffset] to the 
/// notification, or use a [NestedScrollView].
```
WDYT of putting your sample first before the NestedScrollView sample?
```suggestion
/// The position where the glow is drawn in a [CustomSCrollView] can be 
/// manipulated by making use of a
```
```suggestion
/// This can be used to place the glow at an arbitrary offset, such as after a [SliverAppBar].
```
After this, let's link to some of the elements you have referenced here, like `OverscrollIndicatorNotification` and `NotificationListener`. There is a `See also: ...` format that is used in other classes.
Done.
Done.
Done.
I dropped the whole paragraph, since it was redundant after moving the example before the `NestedScrollView` example. 
Also removed, since it was redundant.
Done.
Keep the test from running for 15 minutes if it gets stuck
should just be for verifying that onDone did not return.
This would be a great comment in the code.
Same here. If you feel you need to explain a line of code, consider leaving the explanation as a comment in the code.
Should `onDone` have an `onError` handler as well that ignores the error?
Ahh yeah, good idea :) 
Instead of setting up a potential future timing issue, you could structure the test so that you can hold the exit until you have verified the log output:


```
var completer = Completer<int>();
when(mockProcess.exitCode).thenAnswer((_) {
  return completer.future;
});
...
final DeviceLogReader logReader = device.getLogReader(
  app: await BuildableIOSApp.fromProject(mockIosProject),
 );

await expectLater(logReader.logLines, emitsThrough(...));
completer.complete(0); // not sure if its actually necessary to exit, cloud dispose instead?
```
1. I renamed the Flutter Gallery integration test in Xcode's UI, which names in the project, not the Info.plist.
This project is used in Cirrus and devicelab tests, any if it can `flutter run` with a "Flutter Gallery.app" instead of "Runner.app" then it proves this works.
2. The last attempt at this PR was reverted because of a g3 test that checked the format of a simulator log from some older iOS SDK.  I added that test at https://github.com/flutter/flutter/pull/55808, and it passes in this PR.

This code is filtering out log lines that come from an app other than this one (category doesn't match the app name).  The previous regex assumed the app name was one word (Runner), but now we don't know how many words it will be, and it's hard to separate it out from the hostname, plus we don't know how many tokens the date will have since it's different formats across iOS SDKs.  So now it checks if anything after the date (green match below) ENDS in the app name instead of exactly matches.

<img width="1195" alt="Screen Shot 2020-04-30 at 10 29 36 AM" src="https://user-images.githubusercontent.com/682784/80740810-80ad6f00-8acd-11ea-9556-adacd146f8a8.png">
Caught one! https://cirrus-ci.com/task/5961945742311424?command=main#L27
This is a great comment, very clear (and the screenshot helps as well). That being said, I was completely bewildered from just reading the code. Do you think you can add more context to the comments here (especially why you're using `.endsWith()`?
nit: avoid getters that do work: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#getters-feel-faster-than-methods

The way we usually set this up is to have a private `_ hostAppBundleName`, and then a `_compute HostAppBundleName` that initializes the field:

```
int _foo;
int _computeFoo();
int get foo => _foo ??= _computeFoo();
``
Will swap `productBundleIdentifier` too.
`category != _appName && !category.endsWith(' $_appName')` is redundant.
This line has the fix, `views` caused a stack overflow.
I added this test to cover the view filter
We do not use the vm_service based-devfs. Base64 encoding files to be sent through JSON rpc is too slow
This test causes a Dart native crash on my computer. I also had tremendous difficulty updating it due to the level of mocking.

I think this needs to be re-imagined as an integration test
I remove this functionality because we shouldn't be testing via a real server in a general shard test.
I don't know the history behind this, I'm guessing nothing uses `writeFile`?  Is there a better error message we can give to direct people to the right API?
`return`
Not sure why the delegateService and service were using two streams [in the first place](https://github.com/flutter/flutter/pull/53809/files#diff-09557c5ab3307161425d441b6d004c20R35) but I trust you.
üéâ
Nothing in the tool at least. Originally hot reload was done from source, so the JSON-RPC devFS was used to send individual invalidated source files over to the device. Also assets were loaded over the network. The performance is fine for small text.

Anyway, filled https://github.com/flutter/flutter/issues/55912 to track

Once the tool switched to compilation to the binary format (kernel), the performance of this tanked so the HTTPWriter and HTTP api was introduced to remove the base64 bottleneck.

The entire `DevFSOperations` class should probably be refactored now that we only support write through HTTP.
Fixed
They were single subscription, and I need to intercept the private streamNotify responses the old vm service was using to update Isolates
Ooh. I didn't know `@visibleForTesting` could go here. We've been following the pattern of having a separate `test` named constructor, but maybe this is a better pattern?
Not for this PR. A better abstraction for creating service extensions would be nice. Like implementing/extending a base class, rather than  adding more code to a giant `setup` method.
Native crash, like a Dart VM crash? If so, we need to report that to the VM team.

Also please file an issue about how to recover the lost test coverage here.
Alphabetize imports.
I'm not 100% sure how well this works. I think this should be temporary until I can come up with a better refactor here: https://github.com/flutter/flutter/issues/55912

I like the named constructors because they seem more descriptive. 
Agreed
This is covered by https://github.com/flutter/flutter/issues/46180 , it just turns out more than one test is crashing :( 

I think fixing this test requires some more globals removal and refactoring of the resident runner. Then, the test should really just be a unit test of the stream reconnect logic.

There are some other issues that need to be covered as well:

https://github.com/flutter/flutter/issues/55864
Done
```suggestion
        }, skip: isBrowser); // https://github.com/flutter/flutter/issues/41389
```
```suggestion
        }, skip: isBrowser); // https://github.com/flutter/flutter/issues/41389
```
```suggestion
    }, skip: isBrowser); // https://github.com/flutter/flutter/issues/44572
```
```suggestion
  }, skip: isBrowser); // https://github.com/flutter/flutter/issues/32238
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
  }); // Reference needed
```
```suggestion
      }); // Reference needed
```
```suggestion
      }); // Reference needed
```
```suggestion
        }, skip: isBrowser); // https://github.com/flutter/flutter/issues/41389
```
```suggestion
        }, skip: isBrowser); // https://github.com/flutter/flutter/issues/41389
```
```suggestion
    }, skip: isBrowser); // https://github.com/flutter/flutter/issues/44572
```
```suggestion
  }, skip: isBrowser); // https://github.com/flutter/flutter/issues/32238
```
should be => are.
Maybe a little more prescriptive: The directory where the generated localization classes will be written. The app must import the [how to refer to the app_localizations.dart file?] from this directory.
... which will inserted at the top of each generated Dart file.
The directory that contains the project's arb files.
When printing file names, it's probably best to surround them with quotes, in case they contain spaces or special characters.
Ideally, we wouldn't create the output directory until all the input validity checks had succeeded, i.e. until we were about to start writing files.
I tried addressing this with my latest commits. PTAL
@dkwingsmt The associated issue here is closed, can this be resolved?
I removed this since the 'Deprecated' below will be culled later on during deprecation reaping. No need for a todo.
@HansMuller is this what the todo is implying here? Would this be appropriate to match spec?
Same here @HansMuller 
I moved the ignore to the deprecation notice so it can be removed with the deprecation symbol. When deprecations are removed, todos like these will probably be left behind.
@HansMuller where can I check to see if this is still the spec value? https://material.io/components/dialogs did not specify.
@HansMuller is this actionable? I haven't found an issue for it.
@HansMuller Is there a desired change here in the todo?
Issue was closed unimplemented.
What color should this be?
cc/ @chunhtai for these resolutions.
Maybe add a comment say this should never be reached
I made a PR that solves this https://github.com/flutter/flutter/pull/55805. Unfortunately it is a (minor) breaking change. (Is it urgent? If not I might put a low priority on writing the breaking change docs)
Awesome! Thanks for opening a PR! I wouldn't consider it high priority, I've just been auditing ToDos, so take your time. Thanks for resolving!
@xster is there a different curve this should be?
@jonahwilliams is there an issue to reference here? I don't think this is ready to be uncommented. 
```suggestion
    // This should never be reached.
    throw UnimplementedError();
```
```suggestion
    assert(debugCheckHasMaterialLocalizations(context));
```
```suggestion
    // TODO(jonahwilliams): Uncomment this check once tests are migrated, needs reference
```
```suggestion
        curve: Curves.linear, // TODO(ianh): Use a more appropriate curve.
```
I'm just going to leave this so this change can proceed.
I think you can kill this TODO. we have an issue to track this as a feature request.
```suggestion
```
```suggestion
```
This change will require an update in google3.
Is there already a test with multiple devices from `FuchsiaDevFinder.list()`?
Crap :( 
Updated API
Test added
nit: missing newline at EOF
Shouldn't we be checking the errorText as well? https://api.flutter.dev/flutter/material/InputDecoration/enabled.html

I tried to be lazy and just check one because they're the same widget under the hood.  I'll add a check for both though :)
Done.
This is the fix
The last incremental migration is to remove the custom isolate and vm type. That will remove the need for the shimming, which will remove the need for our own vm service type, which will remove the need for the noSuchMethod
if nulls are not common then we are performing 3 null tests per call. Nesting could reduce that to 2.

Another idea is setting the timestampMicros to 0 (or -1) on construction? (Though it hides the fact that some events didn't have a timestamp. At least with -1, that would be an invalid value given that the field is meant to be time since beginning of tracing).

Or doing a null == 0 test on the saved values and then just falling into the compareTo method?

Or having a fake getter for nonNullTimestampMicros (or "sortingMetric")?
What about a helper function:

```
int nullsFirstCompare(num a, num b) {
  if (a == null) {
    return b == null ? 0 : -1;
  }
  return b == null ? 1 : a.compareTo(b);
}
```
(Just discovered that dart doesn't consider "+1" to be a valid number...)
nested them :-)
If you don't reverse the timestamps, then this isn't verifying the sort, is it?
I would throw in an expect for the event names as well just for completeness. It may seem silly, but this doesn't technically test that the events themselves are reordered when sorting the timestamps...
It couldn't hurt to test the names as well as the timestamps. See comment on next test...
I just tried running this on my favorite benchmark and got a null exception here. Apparently not all events have timestamps and so you need to do something special to compare events with null timestamps (null should be sorted as less than everything else, maybe?)
It looks like all of the events in the timeline I was processing that had null timestamps were the "thread_name" events at the beginning of the log.
The general pattern for doc comments is to put a line break between the first sentence and the rest.
Flutter doesn't adhere to the 80 chars per line rule. So you can put this code on the same line as above.
Comments should be structured like a sentence. i.e.
```suggestion
        onPressed: () {/* Enable the button. */},
```
```suggestion
    await tester.pump(); // Start gesture.
```
```suggestion
        milliseconds: 1000)); // Wait for splash to be well under way.
```
Done.
Done.
```suggestion
  /// If null, default splash radius of [Material.defaultSplashRadius] is used.
```
The structure of this test does match most of the others in this file however, I think it would preferable to establish a new slightly simpler pattern. 

```dart
await tester.pumpWidget(
  MaterialApp(
    home: Material(
      child: Center(
        IconButton(
          icon: const Icon(Icons.android),
          splashRadius: splashRadius,
          onPressed: () { /* enable the button */ },
        ),
      ),
    ),
  ),
);
```
There are one or two tests that have already been set up like this. 
NICE
Done. Thanks for the pointer.
Looks like a compile error here:

```suggestion
            child: IconButton(
              icon: const Icon(Icons.android),
              splashRadius: splashRadius,
              onPressed: () { /* enable the button */ },
            ),
```
this first arg wasn't used
the return value was a mistake that should have been cleaned up in my previous PR.
nit: spacing

```suggestion

      expect(
```
nit: replace with template use {flutter.widgets.Focus.overrideFocusability}
Would it be more clear or too verbose to call this `overrideDescendantFocusability` instead?
I would also refer back to `Focus`
Would benefit from adding references to the `excludeFocus` member documentation so that a user can learn more about Focus exclusion.
Should this use the same name, i.e. `overrideFocusability`?
No, this text refers to "this node", and the other refers to "this widget", which are important distinctions for the audience reading them.
Yeah, I considered that, and it feels too verbose to me. I also considered `overrideCanRequestFocus` and `excludeFocus`, but they didn't really seem right either.  The name is a compromise, to be sure.
Done.
OK, done.
I considered that, but the difference is that there is no `canRequestFocus` on this API, so really all you can do is exclude focus.

Another option would be to change the semantics of `overrideFocusability` and rename it to be `excludeFocus` too, where it also means set `canRequestFocus` to false if it is set.  In fact... That sounds like a better API anyhow, since then you don't have to set two things to get it to exclude, and `overrideFocusability` is a no-op anyhow if `canRequestFocus` is true.  I'll see if I can make that work.
True. Sounds like a good idea!
If I understand correctly, this should only mention its descendants. The widget's focus node will still be focusable
Why only include this for certain subclasses? This seems odd.
This seems to contradict the sentence above. Does it make this node unfocusable or not?
nit: blank line after "See also:" and for consistency * instead of - in the enumeration.
For consistency with ExcludeSemantics, IgnorePointer, etc. should this argument be called excluding?
Oh, whoops, that was from before when the attribute was "overridesDescendants", and FocusScopeNodes always did that, so printing it was too verbose, since it was always true.  Now it doesn't make any sense for this to be different.

Removed the conditional.
Correct. Fixed.
You're not hallucinating, it _is_ contradictory!  Fixed.
Gosh, and I did a whole cleanup PR of those as penance a while ago.  You'd think I'd remember! Fixed!
Sure, I went back and forth on that too.

I ended up here because I thought it more descriptive of what happened, because I could use the doc template, and because `excluding` has the opposite sense from `descendantsAreFocusable`, but I'm fine with being consistent. Renamed, swapped the default to "excluding = true", and expanded out the docs, correcting the sense of the flag in the docs.
Could you revert the formatting changes in this file?
I would move `'-D$dartDefine',` to the next line
I think this can be simplified a bit to:

```contains(<String>['-Ddart.vm.profile=false', '-Ddart.vm.product=true'])```
I would make this method `static` and annotate it with `@visibleForTesting` from `package:meta/meta.dart`
Hmm I think this is going to match `[['-Ddart.vm.profile=true', '-Ddart.vm.product=false'],'--aot']` only

```
Expected: (contains ['-Ddart.vm.profile=true', '-Ddart.vm.product=false'])
  Actual: [
            '--aot',
            '--tfa',
            '--no-embed-sources',
            '-Ddart.vm.profile=true',
            '-Ddart.vm.product=false',
            '-Ddart.developer.causal_async_stacks=false'
          ]
```
Ahh, right. Matchers are hard :) 

```suggestion
Michael Lee <ckmichael8@gmail.com>

```
Prefer 2 space indents in this file
 I don't understand this one, what should I do? It should be 2 space indents already.
and the rest:

```suggestion
        FuchsiaKernelCompiler.getBuildInfoFlags(
```
this one is good
and the following lines

```suggestion
        FuchsiaKernelCompiler.getBuildInfoFlags(
```
all of these lines below should be indented 2 spaces, sorry I can't figure out how to do a multi-line suggestion so I left it on the first line. 
```suggestion
          buildInfo: BuildInfo.release,
          manifestPath: '',
        ),
        allOf(<Matcher>[
          contains('-Ddart.vm.profile=false'),
          contains('-Ddart.vm.product=true'),
        ]));
```
NVM I figured it out!
```suggestion
          buildInfo: const BuildInfo(
            BuildMode.debug,
            null,
            treeShakeIcons: true,
            dartDefines: <String>['abc=efg'],
          ),
          manifestPath: ''),
```
can you add a comment here?
Done
Extra line.
Does "common messages" mean anything as a comment?
I like I like the "Please let us know at" text better, I say "file" all the time but I don't think everyone uses that verb.
Does this need to be in the context?  We're trying to move as much out of the context and globals as possible for testability, and g3 doesn't need to override it.

Can we inject fileSystem, flutterProjectFactory, and client into CrashReporter and let the Flutter version create a `GitHubTemplateCreator`, and the g3 version just ignore any params it doesn't need?

Then there's no need for a nullable `GitHubTemplateCreator` injected into `CrashReporter`
Can you make these final and private?
Then this null check doesn't need to be here if this class creates the GitHubTemplateCreator.
I think this needs tests.
Can you make these private?
details.error.toString()
Oops.  Fixed.
All of the other messages in this file are preceded by "Messages used in X", so I was trying to clarify this is a message used in multiple components.
How about "Please report"?
I can make them final.  Private doesn't make sense; the point is for these fields to be extracted by whatever the `CrashDetails` object is passed to.
`gitHubTemplateCreator` is supplied as an construction argument, and it could be null. (The google3 subclass will not provide one. Granted, it also will override `informUser`, but in principle overridng `informUser` isn't required.)
I did not make them private since they might be needed by the derived class.  I either could make them `@protected` or make them private with the derived class duplicating the fields.
Is there a preference for using `.toString()`?  I generally prefer string interpolation since it guarantees a string even for null inputs.
Oops, I missed the other comment about creating the `GitHubTemplateCreator`.  Okay.
I've added a simple test that verifies that `CrashReporter.informUser` prints some key strings.  Did you have anything beyond that in mind?
If there isn't some reason in this PR that these need to be public, then following suit with this pattern in the rest of the tool, they should be private.
IIRC from my VM team days, interpolation will be a bit slower. This code is not performance critical, so the overriding concern here would be following a consistent style. Also, I think it is not possible to throw `null`, so `error` won't  ever be `null`. We'll be able to enforce that to this point with non-nullability in the future.
Okay, I'll make them private.
Okay, I'll change it to `.toString()`.
Good enough, thanks!
dart doc for public api
What is the motivation of this change? (I mean add AndroidViewController to the framework)
Also, please link an issue for the TODOs, this one and the below ones.
The Dart doc is in the constructor. The doc can go in either place.
I added a link to https://github.com/flutter/flutter/issues/55904. The other TODOs don't need an individual issue since they are all related to the same issue.
Is this performance critical? My personal preference would be to not require a correct ipv6 determination ahead of time.

```dart
String get url => '${Uri(scheme: 'http', host: _host, port: _port)}';
```

One slight difference in behavior, if `_port` is `80` you won't get the `:80` on this String. That's probably an improvement.
Oh, thats a lot nicer - thanks @natebosch 
Done
I know we used to have this check, could you remind me of the reason we added? Is there git console spam on no-op upgrades otherwise?
I think before, we never grabbed the revision that we wanted to upgrade to, so the way that we checked if an upgrade wasn't necessary was that we saved the version we were at, did an upgrade, and checked to see if we were on the same commit. if so, the upgrade was an essential no-op, and we didn't have to do the second half.

Since we're grabbing the desired upgrade target revision from the start, just exit early without messing with their repo.
That makes sense, thanks Chris!
`throwOnError` is true, so you'll get a `ProcessException` on an error and this condition won't ever be true. Do we have tests with git invocations mocked out and failing?
Good point, lemme look into it.
Created [this PR](https://github.com/flutter/flutter/pull/55759) to address.


=============== REACHED API LIMIT AT PR 1968 ===============
6890 comments were gathered
